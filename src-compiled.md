# Source Code Compilation

Generated on: Mon Dec 29 07:44:44 EST 2025

## agents/baseAgent.ts

```typescript
import { IAgent } from './interfaces/IAgent';
import { ITool } from './interfaces/ITool';
import { CommonResult } from '../types';

/**
 * Base class for all agents in the MCP plugin
 * Provides common functionality for agent implementation
 */
export abstract class BaseAgent implements IAgent {
  name: string;
  protected _description: string;
  version: string;
  protected tools: Map<string, ITool> = new Map();

  // Reference to agent manager
  protected agentManager?: {
    getAgent(agentName: string): IAgent | undefined;
  };
  
  /**
   * Create a new agent
   * @param name Name of the agent
   * @param description Description of the agent
   * @param version Version of the agent
   */
  constructor(name: string, description: string, version: string) {
    this.name = name;
    this._description = description;
    this.version = version;
  }

  /**
   * Get the agent description
   * Can be overridden by subclasses for dynamic descriptions
   */
  get description(): string {
    return this._description;
  }
  
  /**
   * Set the agent manager reference
   * @param manager Agent manager instance
   */
  setAgentManager(manager: { getAgent(agentName: string): IAgent | undefined }): void {
    this.agentManager = manager;
  }
  
  /**
   * Get all tools provided by this agent
   * @returns Array of tools
   */
  getTools(): ITool[] {
    return Array.from(this.tools.values());
  }

  /**
   * Get a specific tool by slug
   * @param toolSlug Slug of the tool to get
   * @returns Tool with the specified slug or undefined if not found
   */
  getTool(toolSlug: string): ITool | undefined {
    return this.tools.get(toolSlug);
  }

  /**
   * Register a tool with this agent
   * @param tool Tool to register
   */
  registerTool(tool: ITool): void {
    this.tools.set(tool.slug, tool);
  }

  /**
   * Unregister a tool from this agent
   * @param toolSlug Slug of the tool to unregister
   * @returns true if tool was removed, false if it didn't exist
   */
  unregisterTool(toolSlug: string): boolean {
    return this.tools.delete(toolSlug);
  }

  /**
   * Check if a tool is registered
   * @param toolSlug Slug of the tool to check
   */
  hasTool(toolSlug: string): boolean {
    return this.tools.has(toolSlug);
  }
  
  /**
   * Initialize the agent
   * Default implementation does nothing
   * @returns Promise that resolves when initialization is complete
   */
  async initialize(): Promise<void> {
    // Default implementation does nothing
  }
  
  /**
   * Execute a tool by slug
   * @param toolSlug Slug of the tool to execute
   * @param params Parameters to pass to the tool (tool-specific only, no context)
   * @returns Promise that resolves with the tool's result
   * @throws Error if tool not found
   */
  async executeTool(toolSlug: string, params: Record<string, unknown>): Promise<CommonResult> {
    const tool = this.tools.get(toolSlug);
    if (!tool) {
      // Build helpful error with suggestions
      const errorInfo = this.buildToolNotFoundError(toolSlug);
      throw new Error(errorInfo);
    }

    // Execute the tool with its specific params
    // Context/session validation happens at useTool level, not here
    const result = await tool.execute(params);

    return result;
  }
  
  
  /**
   * Clean up resources when the agent is unloaded
   * This is a base implementation that child classes can extend
   */
  onunload(): void {
    // Default implementation does nothing
  }

  /**
   * Build a helpful error message when a tool is not found
   * Checks if the tool exists on other agents and suggests the correct one
   */
  private buildToolNotFoundError(toolSlug: string): string {
    const lines: string[] = [];

    // Check if this tool exists on another agent
    if (this.agentManager) {
      const correctAgent = this.findToolInOtherAgents(toolSlug);
      if (correctAgent) {
        lines.push(`Tool "${toolSlug}" not found in "${this.name}".`);
        lines.push(`ðŸ’¡ Did you mean: ${correctAgent.agentName} with tool: ${correctAgent.toolName}?`);
        lines.push('');
        lines.push('Correct usage:');
        lines.push(`  Agent: ${correctAgent.agentName}`);
        lines.push(`  Arguments: { "tool": "${correctAgent.toolName}", ... }`);
        return lines.join('\n');
      }
    }

    // List available tools on this agent
    const availableTools = Array.from(this.tools.keys());
    lines.push(`Tool "${toolSlug}" not found in agent "${this.name}".`);
    lines.push('');
    lines.push(`Available tools for ${this.name}:`);
    availableTools.forEach(t => lines.push(`  - ${t}`));

    return lines.join('\n');
  }

  /**
   * Search other agents for a tool by slug
   * Returns the agent name and tool slug if found
   */
  private findToolInOtherAgents(toolSlug: string): { agentName: string; toolName: string } | null {
    if (!this.agentManager) return null;

    // Search known agent names for exact tool match
    const agentNames = ['storageManager', 'contentManager', 'searchManager', 'memoryManager', 'commandManager', 'promptManager'];

    for (const agentName of agentNames) {
      if (agentName === this.name) continue;

      const agent = this.agentManager.getAgent(agentName);
      if (agent) {
        // Exact match
        const tool = agent.getTool(toolSlug);
        if (tool) {
          return { agentName, toolName: tool.slug };
        }

        // Case-insensitive match
        for (const t of agent.getTools()) {
          if (t.slug.toLowerCase() === toolSlug.toLowerCase()) {
            return { agentName, toolName: t.slug };
          }
        }
      }
    }

    return null;
  }
}
```

## agents/baseTool.ts

```typescript
import { ITool } from './interfaces/ITool';
import { CommonParameters, CommonResult } from '../types';
import {
  getCommonParameterSchema,
  getCommonResultSchema,
  createResult,
  mergeWithCommonSchema
} from '../utils/schemaUtils';
import { parseWorkspaceContext } from '../utils/contextUtils';
import { getErrorMessage } from '../utils/errorUtils';
import { enhanceSchemaDocumentation } from '../utils/validationUtils';

// Import new validation utilities
import {
  ValidationResultHelper,
  ValidationError,
  ValidationResult,
  ToolInterface
} from '../utils/validation/ValidationResultHelper';
import {
  CommonValidators,
  ValidationRuleSet
} from '../utils/validation/CommonValidators';

/**
 * Base class for all tools in the MCP plugin
 * Provides common functionality for tool implementation
 */
export abstract class BaseTool<T extends CommonParameters = CommonParameters, R extends CommonResult = CommonResult> implements ITool<T, R> {
  slug: string;
  name: string;
  description: string;
  version: string;

  /** Parent workspace context for session tracking */
  protected parentContext?: CommonResult['workspaceContext'];

  /** Session ID for tracking related operations */
  protected sessionId?: string;

  /**
   * Create a new tool
   * @param slug Slug of the tool (used for identification)
   * @param name Name of the tool
   * @param description Description of the tool
   * @param version Version of the tool
   */
  constructor(slug: string, name: string, description: string, version: string) {
    this.slug = slug;
    this.name = name;
    this.description = description;
    this.version = version;
  }

  /**
   * Execute the tool with parameters
   * @param params Parameters for the tool
   * @returns Promise that resolves with the tool's result
   */
  abstract execute(params: T): Promise<R>;

  /**
   * Get the JSON schema for the tool's parameters
   * @returns JSON schema object
   */
  abstract getParameterSchema(): any;

  /**
   * Get common parameter schema elements for workspace context
   * This is now a proxy to the central utility for DRY implementation
   * @returns JSON schema for common parameters
   */
  protected getCommonParameterSchema(): any {
    return getCommonParameterSchema();
  }

  /**
   * Get the JSON schema for the tool's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    // Default implementation returns the common result schema
    return getCommonResultSchema();
  }

  /**
   * Helper method to merge tool-specific schema with common schema and enhance documentation
   * This ensures that every tool has workspace context parameters,
   * and provides clear documentation on which parameters are required vs. optional
   *
   * @param customSchema The tool-specific schema
   * @returns Merged and enhanced schema with common parameters and improved documentation
   */
  protected getMergedSchema(customSchema: any): any {
    // Get the merged schema with common parameters
    const mergedSchema = mergeWithCommonSchema(customSchema);

    // Ensure the schema has a type and properties
    mergedSchema.type = mergedSchema.type || 'object';
    mergedSchema.properties = mergedSchema.properties || {};

    // Make sure workspaceContext is defined as optional property
    // This is a safety check in case it's not included in the common schema for some reason
    if (!mergedSchema.properties.workspaceContext) {
      mergedSchema.properties.workspaceContext = {
        type: 'object',
        properties: {
          workspaceId: {
            type: 'string',
            description: 'Workspace identifier'
          },
          workspacePath: {
            type: 'array',
            items: { type: 'string' },
            description: 'Path from root workspace to specific phase/task'
          },
          sessionId: {
            type: 'string',
            description: 'Session identifier to track related tool calls (required)'
          }
        },
        description: 'Optional workspace context'
      };
    }

    // Enhance schema with detailed documentation on required vs. optional parameters
    // and type information, to improve user experience
    return enhanceSchemaDocumentation(mergedSchema);
  }

  /**
   * Prepare a standardized result object
   * With Two-Tool Architecture, tools receive only their params - no context validation needed here.
   * Context/session validation happens at useTool level.
   * @param success Whether the operation was successful
   * @param data Operation-specific data
   * @param error Error message if operation failed
   * @param _context Deprecated - ignored (context handled at useTool level)
   * @param _workspaceContext Deprecated - ignored (context handled at useTool level)
   * @returns Standardized result object
   */
  protected prepareResult(
    success: boolean,
    data?: unknown,
    error?: string,
    _context?: unknown,
    _workspaceContext?: unknown
  ): R {
    return createResult<R>(success, data, error);
  }

  /**
   * Set parent workspace context for session tracking
   * This allows session IDs to be propagated between tools
   * @param context Parent workspace context
   */
  setParentContext(context: CommonResult['workspaceContext']): void {
    this.parentContext = context;
  }

  /**
   * Get the inherited workspace context
   * This method handles workspace context inheritance, where a child operation
   * can inherit context from its parent if not explicitly specified.
   *
   * Order of precedence:
   * 1. Current params.workspaceContext if explicitly provided
   * 2. Parent context from setParentContext if available
   * 3. Context from default session context
   *
   * @param params Parameters that may include workspaceContext
   * @returns The effective workspace context to use, or null if none available
   */
  protected getInheritedWorkspaceContext(params: CommonParameters): CommonResult['workspaceContext'] | null {
    // 1. Use explicitly provided context if available
    if (params.workspaceContext) {
      // Use the utility function to safely parse context
      const fallbackId = this.parentContext?.workspaceId || 'default-workspace';
      return parseWorkspaceContext(params.workspaceContext, fallbackId);
    }

    // 2. Fall back to parent context
    if (this.parentContext?.workspaceId) {
      return this.parentContext;
    }

    // 3. No context available
    return null;
  }


  // ========================================
  // VALIDATION UTILITIES
  // ========================================

  /**
   * Helper for standardized error responses
   *
   * Creates consistent error results using ValidationResultHelper while maintaining
   * backward compatibility with existing result creation patterns.
   *
   * @param error Error string, Error object, or array of ValidationErrors
   * @param params Original parameters (for context extraction)
   * @param context Additional context to include in result
   * @returns Standardized error result
   */
  protected createErrorResult(
    error: string | Error | ValidationError[],
    params?: T,
    context?: any
  ): R {
    return ValidationResultHelper.createErrorResult(this as ToolInterface, error, params, context);
  }

  /**
   * Helper for standardized success responses
   *
   * Creates consistent success results using ValidationResultHelper with proper
   * context propagation and session tracking.
   *
   * @param data Result data to include
   * @param params Original parameters (for context extraction)
   * @param additionalData Additional properties to include in result
   * @returns Standardized success result
   */
  protected createSuccessResult(
    data: any,
    params?: T,
    additionalData?: any
  ): R {
    return ValidationResultHelper.createSuccessResult(this as ToolInterface, data, params, additionalData);
  }

  /**
   * Enhanced validation execution pipeline
   *
   * Validates multiple fields using CommonValidators and returns a comprehensive
   * validation result with all errors collected.
   *
   * @param params Parameters object to validate
   * @param validators Mapping of field names to validation functions
   * @returns Validation result with success status and error details
   */
  protected validateCustom<TParams>(
    params: TParams,
    validators: ValidationRuleSet<TParams>
  ): ValidationResult<TParams> {
    const errors = CommonValidators.validateFields(params, validators);
    return ValidationResultHelper.createValidationResult(params, errors);
  }

  /**
   * Validate session context using standardized patterns
   *
   * Validates CommonParameters context structure using CommonValidators
   * with appropriate options for the current tool.
   *
   * @param params CommonParameters to validate
   * @param options Validation options (optional)
   * @returns Array of validation errors
   */
  protected validateSessionContext(
    params: CommonParameters,
    options?: {
      requireSessionId?: boolean;
      requireWorkspace?: boolean;
      minContextLength?: number;
    }
  ): ValidationError[] {
    return CommonValidators.validateSessionContext(params, this as ToolInterface, options);
  }

  /**
   * Helper for quick validation with automatic error result creation
   *
   * Combines validation and error result creation into a single method
   * for simpler error handling in tool implementations.
   *
   * @param params Parameters to validate
   * @param validators Validation rule set
   * @returns Error result if validation fails, null if valid
   */
  protected quickValidate<TParams>(
    params: TParams,
    validators: ValidationRuleSet<TParams>
  ): R | null {
    const validation = this.validateCustom(params, validators);
    if (!validation.success) {
      return this.createErrorResult(validation.errors, params as unknown as T);
    }
    return null;
  }
}

```

## agents/commandManager/commandManager.ts

```typescript
import { App } from 'obsidian';
import { BaseAgent } from '../baseAgent';
import {
  ListCommandsTool,
  ExecuteCommandTool
} from './tools';
import { isAgentHidden } from '../../config/toolVisibility';

/**
 * CommandManager Agent for command palette operations
 */
export class CommandManagerAgent extends BaseAgent {
  /**
   * Obsidian app instance
   */
  private app: App;

  /**
   * Create a new CommandManagerAgent
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'commandManager',
      'Command palette operations for Obsidian',
      '1.0.0'
    );

    this.app = app;

    // Register tools only if agent is not hidden
    if (!isAgentHidden('commandManager')) {
      this.registerTool(new ListCommandsTool(app));
      this.registerTool(new ExecuteCommandTool(app, this));
    }
  }
  
  /**
   * Get a list of available commands
   * @param filter Optional filter to apply to command list
   * @returns Promise that resolves with the command list
   */
  async listCommands(filter?: string): Promise<{
    commands: Array<{
      id: string;
      name: string;
      icon?: string;
      hotkeys?: string[];
    }>;
    total: number;
  }> {
    // Get all commands from the app
    const commands = this.app.commands.listCommands();
    
    // Filter commands if filter is provided
    const filteredCommands = filter
      ? commands.filter(cmd => 
          cmd.name.toLowerCase().includes(filter.toLowerCase()) ||
          cmd.id.toLowerCase().includes(filter.toLowerCase())
        )
      : commands;
    
    // Map to the desired format
    const mappedCommands = filteredCommands.map(cmd => ({
      id: cmd.id,
      name: cmd.name,
      icon: cmd.icon,
      hotkeys: this.getCommandHotkeys(cmd.id)
    }));
    
    return {
      commands: mappedCommands,
      total: mappedCommands.length
    };
  }
  
  /**
   * Execute a command by ID
   * @param commandId ID of the command to execute
   * @returns Promise that resolves when the command is executed
   */
  async executeCommand(commandId: string): Promise<boolean> {
    try {
      // Check if the command exists
      const commands = this.app.commands.listCommands();
      const command = commands.find(cmd => cmd.id === commandId);
      
      if (!command) {
        throw new Error(`Command with ID ${commandId} not found`);
      }
      
      // Execute the command
      await this.app.commands.executeCommandById(commandId);
      
      return true;
    } catch (error) {
      console.error(`Error executing command ${commandId}:`, error);
      throw error;
    }
  }
  
  /**
   * Get hotkeys for a command
   * @param commandId ID of the command
   * @returns Array of hotkey strings or undefined if none
   */
  private getCommandHotkeys(commandId: string): string[] | undefined {
    try {
      // Access the Obsidian internal API to retrieve hotkeys
      // Using Record<string, unknown> pattern for internal API access
      const appInternal = this.app as unknown as Record<string, unknown>;
      const hotkeyManager = appInternal.hotkeyManager as Record<string, unknown> | undefined;
      if (!hotkeyManager) return undefined;

      // Get all hotkeys from the manager
      const getHotkeys = hotkeyManager.getHotkeys as ((id: string) => Array<{ modifiers: string[]; key: string }>) | undefined;
      if (!getHotkeys) return undefined;
      const hotkeys = getHotkeys(commandId) || [];

      // Format hotkey strings
      return hotkeys.map((hotkey) => {
        // Accessing internal Obsidian API properties
        const { modifiers, key } = hotkey;
        const modifierKeys = [];
        
        // Add modifiers in a standard order
        if (modifiers.includes('Mod')) modifierKeys.push('Ctrl/Cmd');
        if (modifiers.includes('Shift')) modifierKeys.push('Shift');
        if (modifiers.includes('Alt')) modifierKeys.push('Alt');
        if (modifiers.includes('Meta')) modifierKeys.push('Meta');
        
        // Join modifiers + key with + sign
        return [...modifierKeys, key].join('+');
      });
    } catch (error) {
      return undefined;
    }
  }
}
```

## agents/commandManager/tools/executeCommand.ts

```typescript
import { App } from 'obsidian';
import { BaseTool } from '../../baseTool';
import { ExecuteCommandParams, ExecuteCommandResult } from '../types';
import { CommandManagerAgent } from '../commandManager';
import { parseWorkspaceContext } from '../../../utils/contextUtils';
import { addRecommendations, Recommendation } from '../../../utils/recommendationUtils';
import { NudgeHelpers } from '../../../utils/nudgeHelpers';

/**
 * Tool for executing a command
 */
export class ExecuteCommandTool extends BaseTool<ExecuteCommandParams, ExecuteCommandResult> {
  private app: App;
  private agent: CommandManagerAgent;

  /**
   * Create a new ExecuteCommandTool
   * @param app Obsidian app instance
   * @param agent CommandManager agent instance
   */
  constructor(app: App, agent: CommandManagerAgent) {
    super(
      'executeCommand',
      'Execute Command',
      'Run an Obsidian command',
      '1.0.0'
    );

    this.app = app;
    this.agent = agent;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise that resolves when the command is executed
   */
  async execute(params: ExecuteCommandParams): Promise<ExecuteCommandResult> {
    try {
      const { commandId, workspaceContext } = params;

      if (!commandId) {
        return this.prepareResult(false, undefined, 'Command ID is required');
      }

      // Check if the command exists
      const commands = this.app.commands.listCommands();
      const command = commands.find(cmd => cmd.id === commandId);

      if (!command) {
        return this.prepareResult(false, undefined, `Command with ID ${commandId} not found`);
      }

      // Execute the command
      await this.app.commands.executeCommandById(commandId);

      // Prepare result with workspace context
      const response = this.prepareResult(
        true,
        {
          commandId
        }
      );

      // Generate nudges for command execution
      const nudges = this.generateCommandNudges();
      const responseWithNudges = addRecommendations(response, nudges);

      return responseWithNudges;
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return this.prepareResult(false, undefined, `Error executing command: ${errorMessage}`);
    }
  }

  /**
   * Get the JSON schema for the tool's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    // Create the tool-specific schema
    const toolSchema = {
      type: 'object',
      properties: {
        commandId: {
          type: 'string',
          description: 'ID of the command to execute'
        }
      },
      required: ['commandId']
    };

    // Merge with common schema (workspace context)
    return this.getMergedSchema(toolSchema);
  }

  /**
   * Get the JSON schema for the tool's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    // Use the base result schema from BaseTool, which includes common result properties
    const baseSchema = super.getResultSchema();

    // Add tool-specific data properties
    baseSchema.properties.data = {
      type: 'object',
      properties: {
        commandId: {
          type: 'string',
          description: 'ID of the executed command'
        }
      },
      required: ['commandId']
    };

    return baseSchema;
  }

  /**
   * Generate nudges for command execution
   */
  private generateCommandNudges(): Recommendation[] {
    const nudges: Recommendation[] = [];

    // Always suggest impact awareness after command execution
    nudges.push(NudgeHelpers.suggestImpactAwareness());

    return nudges;
  }
}

```

## agents/commandManager/tools/index.ts

```typescript
export { ListCommandsTool } from './listCommands';
export { ExecuteCommandTool } from './executeCommand';

```

## agents/commandManager/tools/listCommands.ts

```typescript
import { App } from 'obsidian';
import { BaseTool } from '../../baseTool';
import { ListCommandsParams, ListCommandsResult } from '../types';
import { parseWorkspaceContext } from '../../../utils/contextUtils';

/**
 * Tool for listing available commands
 */
export class ListCommandsTool extends BaseTool<ListCommandsParams, ListCommandsResult> {
  private app: App;

  /**
   * Create a new ListCommandsTool
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'listCommands',
      'List Commands',
      'List available Obsidian commands',
      '1.0.0'
    );

    this.app = app;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise that resolves with the list of commands
   */
  async execute(params: ListCommandsParams): Promise<ListCommandsResult> {
    try {
      const { filter, workspaceContext } = params;

      // Get all commands from the app
      const commands = this.app.commands.listCommands();

      // Filter commands if filter is provided
      const filteredCommands = filter
        ? commands.filter(cmd =>
            cmd.name.toLowerCase().includes(filter.toLowerCase()) ||
            cmd.id.toLowerCase().includes(filter.toLowerCase())
          )
        : commands;

      // Map to the desired format
      const mappedCommands = filteredCommands.map(cmd => ({
        id: cmd.id,
        name: cmd.name,
        icon: cmd.icon,
        hotkeys: this.getCommandHotkeys(cmd.id)
      }));

      // Prepare result with workspace context
      const response = this.prepareResult(true, {
          commands: mappedCommands,
          total: mappedCommands.length
        });

      return response;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return this.prepareResult(false, undefined, `Error listing commands: ${errorMessage}`);
    }
  }

  /**
   * Get hotkeys for a command
   * @param commandId ID of the command
   * @returns Array of hotkey strings or undefined if none
   */
  private getCommandHotkeys(_commandId: string): string[] | undefined {
    // This is a placeholder as Obsidian's public API doesn't expose hotkeys directly
    // In a real implementation, we'd need to access the internal hotkey registry
    return undefined;
  }

  /**
   * Get the JSON schema for the tool's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const toolSchema = {
      type: 'object',
      properties: {
        filter: {
          type: 'string',
          description: 'Optional filter to apply to command list'
        }
      }
    };

    return this.getMergedSchema(toolSchema);
  }

  /**
   * Get the JSON schema for the tool's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation succeeded'
        },
        error: {
          type: 'string',
          description: 'Error message if success is false'
        },
        data: {
          type: 'object',
          properties: {
            commands: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  id: {
                    type: 'string',
                    description: 'Command ID'
                  },
                  name: {
                    type: 'string',
                    description: 'Display name of the command'
                  },
                  icon: {
                    type: 'string',
                    description: 'Optional icon name'
                  },
                  hotkeys: {
                    type: 'array',
                    items: {
                      type: 'string'
                    },
                    description: 'List of hotkeys associated with the command'
                  }
                },
                required: ['id', 'name']
              },
              description: 'List of available commands'
            },
            total: {
              type: 'number',
              description: 'Total number of commands'
            }
          },
          required: ['commands', 'total']
        },
        workspaceContext: {
          type: 'object',
          properties: {
            workspaceId: {
              type: 'string',
              description: 'ID of the workspace'
            },
            workspacePath: {
              type: 'array',
              items: {
                type: 'string'
              },
              description: 'Path of the workspace'
            },
            activeWorkspace: {
              type: 'boolean',
              description: 'Whether this is the active workspace'
            }
          }
        },
      },
      required: ['success']
    };
  }
}

```

## agents/commandManager/types.ts

```typescript
import { CommonParameters, CommonResult } from '../../types';

/**
 * Params for listing available commands
 */
export interface ListCommandsParams extends CommonParameters {
  /**
   * Optional filter to apply to command list
   */
  filter?: string;
}

/**
 * Command information
 */
export interface CommandInfo {
  /**
   * Command ID
   */
  id: string;
  
  /**
   * Display name of the command
   */
  name: string;
  
  /**
   * Optional icon name
   */
  icon?: string;
  
  /**
   * List of hotkeys associated with the command
   */
  hotkeys?: string[];
}

/**
 * Result of listing available commands
 */
export interface ListCommandsResult extends CommonResult {
  data?: {
    /**
     * List of available commands
     */
    commands: CommandInfo[];
    
    /**
     * Total number of commands
     */
    total: number;
  };
}

/**
 * Params for executing a command
 */
export interface ExecuteCommandParams extends CommonParameters {
  /**
   * ID of the command to execute
   */
  commandId: string;
}

/**
 * Result of executing a command
 */
export interface ExecuteCommandResult extends CommonResult {
  data?: {
    /**
     * ID of the executed command
     */
    commandId: string;
  };
}
```

## agents/contentManager/contentManager.ts

```typescript
import { App } from 'obsidian';
import { BaseAgent } from '../baseAgent';
import {
  ReadTool,
  WriteTool,
  UpdateTool
} from './tools';
import NexusPlugin from '../../main';
import { WorkspaceService } from '../../services/WorkspaceService';
import { MemoryService } from '../memoryManager/services/MemoryService';

/**
 * Agent for content operations in the vault
 * Simplified from 8 tools to 3 tools following CRUA pattern
 *
 * Tools:
 * - read: Read content from files with explicit line ranges
 * - write: Create new files or overwrite existing files
 * - update: Insert, replace, delete, append, or prepend content
 */
export class ContentManagerAgent extends BaseAgent {
  protected app: App;
  protected plugin: NexusPlugin | null = null;

  private workspaceService: WorkspaceService | null = null;
  private memoryService: MemoryService | null = null;

  /**
   * Create a new ContentManagerAgent
   * @param app Obsidian app instance
   * @param plugin Nexus plugin instance
   * @param memoryService Optional injected memory service
   * @param workspaceService Optional injected workspace service
   */
  constructor(
    app: App,
    plugin?: NexusPlugin,
    memoryService?: MemoryService | null,
    workspaceService?: WorkspaceService | null
  ) {
    super(
      'contentManager',
      'Content operations for Obsidian notes',
      '1.0.0'
    );

    this.app = app;
    this.plugin = plugin || null;

    // Use injected services if provided, otherwise fall back to plugin services
    if (memoryService) {
      this.memoryService = memoryService;
    } else if (plugin?.services?.memoryService) {
      this.memoryService = plugin.services.memoryService;
    }

    if (workspaceService) {
      this.workspaceService = workspaceService;
    } else if (plugin?.services?.workspaceService) {
      this.workspaceService = plugin.services.workspaceService;
    }

    // Register simplified tools (3 tools replacing 8)
    this.registerTool(new ReadTool(app));
    this.registerTool(new WriteTool(app));
    this.registerTool(new UpdateTool(app));
  }
  
  
  /**
   * Gets the workspace service
   * @returns WorkspaceService instance or null
   */
  public getWorkspaceService(): WorkspaceService | null {
    return this.workspaceService;
  }
  
  /**
   * Gets the memory service
   * @returns MemoryService instance or null
   */
  public getMemoryService(): MemoryService | null {
    return this.memoryService;
  }
  
}

```

## agents/contentManager/tools/index.ts

```typescript
// ContentManager tools (3 tools)
export { ReadTool } from './read';
export { WriteTool } from './write';
export { UpdateTool } from './update';

```

## agents/contentManager/tools/read.ts

```typescript
import { App } from 'obsidian';
import { BaseTool } from '../../baseTool';
import { ReadParams, ReadResult } from '../types';
import { ContentOperations } from '../utils/ContentOperations';
import { createErrorMessage } from '../../../utils/errorUtils';
import { addRecommendations, Recommendation } from '../../../utils/recommendationUtils';
import { NudgeHelpers } from '../../../utils/nudgeHelpers';

/**
 * Location: src/agents/contentManager/tools/read.ts
 *
 * Simplified read tool for ContentManager.
 * Reads content from a file with explicit line range control.
 *
 * Key Design:
 * - startLine is REQUIRED (forces intentional positioning)
 * - endLine is optional (defaults to end of file)
 * - Encourages LLMs to think about where content is located
 *
 * Relationships:
 * - Uses ContentOperations utility for file operations
 * - Part of CRUA architecture (Read operation)
 */
export class ReadTool extends BaseTool<ReadParams, ReadResult> {
  private app: App;

  /**
   * Create a new ReadTool
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'read',
      'Read',
      'Read content from a file with line range',
      '1.0.0'
    );

    this.app = app;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise that resolves with the file content (always with line numbers)
   */
  async execute(params: ReadParams): Promise<ReadResult> {
    try {
      const { path, startLine, endLine } = params;

      // Read full content first
      const fullContent = await ContentOperations.readContent(this.app, path);
      const allLines = fullContent.split('\n');
      const totalLines = allLines.length;

      // Determine actual range
      const actualStartLine = startLine;
      const actualEndLine = endLine !== undefined ? Math.min(endLine, totalLines) : totalLines;

      // Extract requested lines (1-based to 0-based)
      const startIdx = Math.max(0, actualStartLine - 1);
      const endIdx = actualEndLine;
      const requestedLines = allLines.slice(startIdx, endIdx);

      // Always add line numbers to content
      const numberedLines = requestedLines.map((line, idx) => {
        const lineNum = actualStartLine + idx;
        return `${lineNum}: ${line}`;
      });
      const content = numberedLines.join('\n');

      const resultData = {
        content,
        path,
        startLine: actualStartLine,
        endLine: actualEndLine
      };

      const result = this.prepareResult(true, resultData);

      // Generate nudges based on content
      const nudges = this.generateReadNudges(resultData);
      const resultWithNudges = addRecommendations(result, nudges);

      return resultWithNudges;
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Error reading content: ', error));
    }
  }

  /**
   * Get the JSON schema for the tool's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): Record<string, unknown> {
    const toolSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to the file to read'
        },
        startLine: {
          type: 'number',
          description: 'Start line (1-based), REQUIRED - forces intentional positioning. Use 1 to read from beginning.'
        },
        endLine: {
          type: 'number',
          description: 'End line (1-based, inclusive). If omitted, reads to end of file.'
        }
      },
      required: ['path', 'startLine']
    };

    return this.getMergedSchema(toolSchema);
  }

  /**
   * Get the JSON schema for the tool's result
   * @returns JSON schema object
   */
  getResultSchema(): Record<string, unknown> {
    const baseSchema = super.getResultSchema();

    baseSchema.properties.data = {
      type: 'object',
      properties: {
        content: {
          type: 'string',
          description: 'Content with line numbers (format: "N: line content")'
        },
        path: {
          type: 'string',
          description: 'Path to the file'
        },
        startLine: {
          type: 'number',
          description: 'Starting line that was read'
        },
        endLine: {
          type: 'number',
          description: 'Ending line that was read (if applicable)'
        }
      },
      required: ['content', 'path', 'startLine']
    };

    return baseSchema;
  }

  /**
   * Generate nudges based on content reading results
   */
  private generateReadNudges(resultData: { content: string; path: string }): Recommendation[] {
    const nudges: Recommendation[] = [];

    // Check for large content (>7,000 characters)
    const largeContentNudge = NudgeHelpers.checkLargeContent(resultData.content.length);
    if (largeContentNudge) {
      nudges.push(largeContentNudge);
    }

    return nudges;
  }
}

```

## agents/contentManager/tools/update.ts

```typescript
import { App, TFile } from 'obsidian';
import { BaseTool } from '../../baseTool';
import { UpdateParams, UpdateResult } from '../types';
import { ContentOperations } from '../utils/ContentOperations';
import { createErrorMessage } from '../../../utils/errorUtils';

/**
 * Location: src/agents/contentManager/tools/update.ts
 *
 * Unified update tool for ContentManager.
 * Handles insert, replace, delete, append, and prepend operations.
 *
 * Behavior:
 * - startLine only â†’ INSERT at that line (pushes existing content down)
 * - startLine + endLine â†’ REPLACE that range
 * - content: "" with range â†’ DELETE that range
 * - startLine: -1 â†’ APPEND to end of file
 *
 * Key Design:
 * - Single tool replaces: appendContent, prependContent, replaceContent, replaceByLine, findReplaceContent, deleteContent
 * - Line-based operations are explicit and predictable
 * - Clear error messages guide recovery
 *
 * Relationships:
 * - Uses ContentOperations utility for file operations
 * - Part of CRUA architecture (Update operation)
 * - Follows write tool response stripping principle (returns { success: true } only)
 */
export class UpdateTool extends BaseTool<UpdateParams, UpdateResult> {
  private app: App;

  /**
   * Create a new UpdateTool
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'update',
      'Update',
      'Insert, replace, or delete content at specific line positions',
      '1.0.0'
    );

    this.app = app;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise that resolves with the update result
   */
  async execute(params: UpdateParams): Promise<UpdateResult> {
    try {
      const { path, content, startLine, endLine } = params;

      // Normalize path (remove leading slash)
      const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
      const file = this.app.vault.getAbstractFileByPath(normalizedPath);

      if (!file) {
        return this.prepareResult(false, undefined,
          `File not found: "${path}". Use searchContent to find files by name, or storageManager.list to explore folders.`
        );
      }

      if (!(file instanceof TFile)) {
        return this.prepareResult(false, undefined,
          `Path is a folder, not a file: "${path}". Use storageManager.list to see its contents.`
        );
      }

      const existingContent = await this.app.vault.read(file);
      const lines = existingContent.split('\n');
      const totalLines = lines.length;

      let newContent: string;

      // Special case: startLine === -1 means APPEND to end of file
      if (startLine === -1) {
        // Add newline before appending if file doesn't end with one
        const needsNewline = existingContent.length > 0 && !existingContent.endsWith('\n');
        newContent = existingContent + (needsNewline ? '\n' : '') + content;
        await this.app.vault.modify(file, newContent);
        return this.prepareResult(true);
      }

      // Validate line numbers
      if (startLine < 1) {
        return this.prepareResult(false, undefined,
          `Invalid startLine: ${startLine}. Line numbers are 1-based. Use -1 to append to end of file.`
        );
      }

      if (startLine > totalLines + 1) {
        return this.prepareResult(false, undefined,
          `Start line ${startLine} is beyond file length (${totalLines} lines). Use read to view the file first.`
        );
      }

      // Case 1: INSERT (startLine only, no endLine)
      if (endLine === undefined) {
        // Insert content at startLine, pushing existing content down
        const beforeLines = lines.slice(0, startLine - 1);
        const afterLines = lines.slice(startLine - 1);
        const insertLines = content.split('\n');

        newContent = [
          ...beforeLines,
          ...insertLines,
          ...afterLines
        ].join('\n');

        await this.app.vault.modify(file, newContent);
        return this.prepareResult(true);
      }

      // Validate endLine
      if (endLine < startLine) {
        return this.prepareResult(false, undefined,
          `End line ${endLine} cannot be less than start line ${startLine}.`
        );
      }

      if (endLine > totalLines) {
        return this.prepareResult(false, undefined,
          `End line ${endLine} is beyond file length (${totalLines} lines). Use read to view the file first.`
        );
      }

      // Case 2: REPLACE (startLine + endLine with content)
      // Case 3: DELETE (startLine + endLine with empty content)
      const beforeLines = lines.slice(0, startLine - 1);
      const afterLines = lines.slice(endLine);

      if (content === '') {
        // DELETE: Remove lines, don't insert anything
        newContent = [
          ...beforeLines,
          ...afterLines
        ].join('\n');
      } else {
        // REPLACE: Remove lines and insert new content
        const replacementLines = content.split('\n');
        newContent = [
          ...beforeLines,
          ...replacementLines,
          ...afterLines
        ].join('\n');
      }

      await this.app.vault.modify(file, newContent);
      return this.prepareResult(true);

    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Error updating file: ', error));
    }
  }

  /**
   * Get the JSON schema for the tool's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): Record<string, unknown> {
    const toolSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to the file to modify'
        },
        content: {
          type: 'string',
          description: 'Content to insert/replace (empty string to delete lines)'
        },
        startLine: {
          type: 'number',
          description: 'Start line (1-based). Use -1 to append to end of file. Use 1 to prepend to start.'
        },
        endLine: {
          type: 'number',
          description: 'End line (1-based, inclusive). Omit to INSERT at startLine. Provide to REPLACE range.'
        }
      },
      required: ['path', 'content', 'startLine']
    };

    return this.getMergedSchema(toolSchema);
  }

  /**
   * Get the JSON schema for the tool's result
   * @returns JSON schema object
   */
  getResultSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation succeeded'
        },
        error: {
          type: 'string',
          description: 'Error message if failed (includes recovery guidance)'
        }
      },
      required: ['success']
    };
  }
}

```

## agents/contentManager/tools/write.ts

```typescript
import { App, TFile } from 'obsidian';
import { BaseTool } from '../../baseTool';
import { WriteParams, WriteResult } from '../types';
import { ContentOperations } from '../utils/ContentOperations';
import { createErrorMessage } from '../../../utils/errorUtils';

/**
 * Location: src/agents/contentManager/tools/write.ts
 *
 * Simplified write tool for ContentManager.
 * Creates a new file or overwrites an existing file.
 *
 * Key Design:
 * - Default behavior is safe (no overwrite)
 * - Explicit overwrite flag required to replace existing files
 * - Clear error messages guide recovery
 *
 * Relationships:
 * - Uses ContentOperations utility for file operations
 * - Part of CRUA architecture (Create operation)
 * - Follows write tool response stripping principle (returns { success: true } only)
 */
export class WriteTool extends BaseTool<WriteParams, WriteResult> {
  private app: App;

  /**
   * Create a new WriteTool
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'write',
      'Write',
      'Create a new file or overwrite existing file',
      '1.0.0'
    );

    this.app = app;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise that resolves with the creation result
   */
  async execute(params: WriteParams): Promise<WriteResult> {
    try {
      const { content, overwrite = false } = params;
      let { path } = params;

      // Normalize empty/root paths - generate a filename if only directory is specified
      if (!path || path === '/' || path === '.') {
        const timestamp = Date.now();
        path = `untitled-${timestamp}.md`;
      } else if (path.endsWith('/') || path.endsWith('.')) {
        const dir = path.endsWith('.') ? '' : path.slice(0, -1);
        const timestamp = Date.now();
        path = dir ? `${dir}/untitled-${timestamp}.md` : `untitled-${timestamp}.md`;
      }

      if (content === undefined || content === null) {
        return this.prepareResult(false, undefined, 'Content is required');
      }

      // Normalize path (remove leading slash)
      const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
      const existingFile = this.app.vault.getAbstractFileByPath(normalizedPath);

      if (existingFile) {
        if (!overwrite) {
          return this.prepareResult(false, undefined,
            `File already exists: "${path}". Use read to view it, update to modify it, or write with overwrite: true to replace it completely.`
          );
        }

        // Overwrite existing file
        if (!(existingFile instanceof TFile)) {
          return this.prepareResult(false, undefined,
            `Path is a folder, not a file: "${path}". Use storageManager.list to see its contents.`
          );
        }

        await this.app.vault.modify(existingFile, content);
      } else {
        // Create new file
        await ContentOperations.createContent(this.app, path, content);
      }

      // Success - LLM already knows the path and content it passed
      return this.prepareResult(true);
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Error writing file: ', error));
    }
  }

  /**
   * Get the JSON schema for the tool's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): Record<string, unknown> {
    const toolSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to the file to create or overwrite'
        },
        content: {
          type: 'string',
          description: 'Content to write to the file'
        },
        overwrite: {
          type: 'boolean',
          description: 'Overwrite if file exists (default: false)',
          default: false
        }
      },
      required: ['path', 'content']
    };

    return this.getMergedSchema(toolSchema);
  }

  /**
   * Get the JSON schema for the tool's result
   * @returns JSON schema object
   */
  getResultSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation succeeded'
        },
        error: {
          type: 'string',
          description: 'Error message if failed (includes recovery guidance)'
        }
      },
      required: ['success']
    };
  }
}

```

## agents/contentManager/types.ts

```typescript
import { CommonParameters, CommonResult } from '../../types';

// ============================================================================
// NEW SIMPLIFIED TOOLS (3 tools replacing 8)
// ============================================================================

/**
 * Params for reading content from a file
 */
export interface ReadParams extends CommonParameters {
  /**
   * Path to the file to read
   */
  path: string;

  /**
   * Start line (1-based), REQUIRED - forces intentional positioning
   */
  startLine: number;

  /**
   * End line (1-based, inclusive). If omitted, reads to end of file.
   */
  endLine?: number;
}

/**
 * Result of reading content from a file
 */
export interface ReadResult extends CommonResult {
  data?: {
    /**
     * Content of the file
     */
    content: string;

    /**
     * Path to the file
     */
    path: string;

    /**
     * Starting line that was read
     */
    startLine: number;

    /**
     * Ending line that was read (if applicable)
     */
    endLine?: number;
  };
}

/**
 * Params for writing content to a file (create or overwrite)
 */
export interface WriteParams extends CommonParameters {
  /**
   * Path to the file to create or overwrite
   */
  path: string;

  /**
   * Content to write to the file
   */
  content: string;

  /**
   * Overwrite if file exists (default: false)
   */
  overwrite?: boolean;
}

/**
 * Result of writing content to a file
 */
export interface WriteResult extends CommonResult {
  // No data returned - LLM already knows the path and content it passed
}

/**
 * Params for updating content in a file (insert, replace, delete, append)
 */
export interface UpdateParams extends CommonParameters {
  /**
   * Path to the file to modify
   */
  path: string;

  /**
   * Content to insert/replace (empty string to delete lines)
   */
  content: string;

  /**
   * Start line (1-based). Use -1 to append to end of file.
   */
  startLine: number;

  /**
   * End line (1-based, inclusive). Omit to INSERT at startLine. Provide to REPLACE range.
   */
  endLine?: number;
}

/**
 * Result of updating content in a file
 */
export interface UpdateResult extends CommonResult {
  // No data returned - LLM already knows the path, content, and lines it passed
}

// ============================================================================
// LEGACY TOOLS (deprecated, kept for backward compatibility)
// ============================================================================

/**
 * Params for reading content from a file
 */
export interface ReadContentParams extends CommonParameters {
  /**
   * Path to the file to read
   */
  filePath: string;

  /**
   * Optional number of lines to read
   */
  limit?: number;

  /**
   * Optional line number to start reading from (1-based)
   */
  offset?: number;

  /**
   * Whether to include line numbers in the output
   */
  includeLineNumbers?: boolean;
}

/**
 * Result of reading content from a file
 */
export interface ReadContentResult extends CommonResult {
  data?: {
    /**
     * Content of the file
     */
    content: string;

    /**
     * Path to the file
     */
    filePath: string;

    /**
     * Whether line numbers are included in the content
     */
    lineNumbersIncluded?: boolean;

    /**
     * Starting line if offset was specified
     */
    startLine?: number;

    /**
     * Ending line if limit was specified
     */
    endLine?: number;
  };
}

/**
 * Params for creating a new file with content
 */
export interface CreateContentParams extends CommonParameters {
  /**
   * Path to the file to create
   */
  filePath: string;
  
  /**
   * Content to write to the file
   */
  content: string;
}

/**
 * Result of creating a file
 */
export interface CreateContentResult extends CommonResult {
  data?: {
    /**
     * Path to the created file
     */
    filePath: string;
    
    /**
     * Creation timestamp
     */
    created: number;
  };
}

/**
 * Params for appending content to a file
 */
export interface AppendContentParams extends CommonParameters {
  /**
   * Path to the file to append to
   */
  filePath: string;
  
  /**
   * Content to append to the file
   */
  content: string;
}

/**
 * Result of appending content to a file
 */
export interface AppendContentResult extends CommonResult {
  data?: {
    /**
     * Path to the file
     */
    filePath: string;
    
    /**
     * Length of the content appended
     */
    appendedLength: number;
    
    /**
     * Total length of the file after appending
     */
    totalLength: number;
  };
}

/**
 * Params for prepending content to a file
 */
export interface PrependContentParams extends CommonParameters {
  /**
   * Path to the file to prepend to
   */
  filePath: string;
  
  /**
   * Content to prepend to the file
   */
  content: string;
}

/**
 * Result of prepending content to a file
 */
export interface PrependContentResult extends CommonResult {
  data?: {
    /**
     * Path to the file
     */
    filePath: string;
    
    /**
     * Length of the content prepended
     */
    prependedLength: number;
    
    /**
     * Total length of the file after prepending
     */
    totalLength: number;
  };
}

/**
 * Params for replacing content in a file
 */
export interface ReplaceContentParams extends CommonParameters {
  /**
   * Path to the file to modify
   */
  filePath: string;
  
  /**
   * Content to replace
   */
  oldContent: string;
  
  /**
   * Content to replace with
   */
  newContent: string;
  
  /**
   * Threshold for fuzzy matching (0.0 to 1.0, where 1.0 is exact match)
   * @default 0.95
   */
  similarityThreshold?: number;
}

/**
 * Result of replacing content in a file
 */
export interface ReplaceContentResult extends CommonResult {
  data?: {
    /**
     * Path to the file
     */
    filePath: string;
    
    /**
     * Number of replacements made
     */
    replacements: number;
  };
}

/**
 * Params for replacing content by line number
 */
export interface ReplaceByLineParams extends CommonParameters {
  /**
   * Path to the file to modify
   */
  filePath: string;
  
  /**
   * Start line number (1-based)
   */
  startLine: number;
  
  /**
   * End line number (1-based, inclusive)
   */
  endLine: number;
  
  /**
   * Content to replace with
   */
  newContent: string;
}

/**
 * Result of replacing content by line number
 */
export interface ReplaceByLineResult extends CommonResult {
  data?: {
    /**
     * Path to the file
     */
    filePath: string;
    
    /**
     * Number of lines replaced
     */
    linesReplaced: number;
  };
}

/**
 * Params for deleting content from a file
 */
export interface DeleteContentParams extends CommonParameters {
  /**
   * Path to the file to modify
   */
  filePath: string;
  
  /**
   * Content to delete
   */
  content: string;
  
  /**
   * Threshold for fuzzy matching (0.0 to 1.0, where 1.0 is exact match)
   * @default 0.95
   */
  similarityThreshold?: number;
}

/**
 * Result of deleting content from a file
 */
export interface DeleteContentResult extends CommonResult {
  data?: {
    /**
     * Path to the file
     */
    filePath: string;
    
    /**
     * Number of deletions made
     */
    deletions: number;
  };
}

/**
 * Params for find and replace operations in a file
 */
export interface FindReplaceContentParams extends CommonParameters {
  /**
   * Path to the file to modify
   */
  filePath: string;
  
  /**
   * Text to find
   */
  findText: string;
  
  /**
   * Text to replace with
   */
  replaceText: string;
  
  /**
   * Whether to replace all occurrences or just the first one
   * @default false
   */
  replaceAll?: boolean;
  
  /**
   * Whether the search should be case sensitive
   * @default true
   */
  caseSensitive?: boolean;
  
  /**
   * Whether to use whole word matching
   * @default false
   */
  wholeWord?: boolean;
}

/**
 * Result of find and replace operations in a file
 */
export interface FindReplaceContentResult extends CommonResult {
  data?: {
    /**
     * Path to the file
     */
    filePath: string;
    
    /**
     * Number of replacements made
     */
    replacements: number;
    
    /**
     * Text that was searched for
     */
    findText: string;
    
    /**
     * Text that was used as replacement
     */
    replaceText: string;
  };
}

/**
 * Content operation type for batch operations
 */
export type ContentOperation = 
  | { type: 'read', params: Omit<ReadContentParams, keyof CommonParameters> }
  | { type: 'create', params: Omit<CreateContentParams, keyof CommonParameters> }
  | { type: 'append', params: Omit<AppendContentParams, keyof CommonParameters> }
  | { type: 'prepend', params: Omit<PrependContentParams, keyof CommonParameters> }
  | { type: 'replace', params: Omit<ReplaceContentParams, keyof CommonParameters> }
  | { type: 'replaceByLine', params: Omit<ReplaceByLineParams, keyof CommonParameters> }
  | { type: 'delete', params: Omit<DeleteContentParams, keyof CommonParameters> }
  | { type: 'findReplace', params: Omit<FindReplaceContentParams, keyof CommonParameters> };

/**
 * Params for batch content operations
 */
export interface BatchContentParams extends CommonParameters {
  /**
   * Array of operations to perform
   */
  operations: ContentOperation[];
}

/**
 * Result of a batch operation
 */
export interface BatchContentResult extends CommonResult {
  data?: {
    /**
     * Array of operation results
     */
    results: Array<{
      /**
       * Whether the operation succeeded
       */
      success: boolean;
      
      /**
       * Error message if success is false
       */
      error?: string;
      
      /**
       * Operation-specific result data
       */
      data?: any;
      
      /**
       * Type of operation
       */
      type: ContentOperation['type'];
      
      /**
       * File path for the operation
       */
      filePath: string;
    }>;
  };
}
```

## agents/contentManager/utils/ContentOperations.ts

```typescript
import { App, TFile } from 'obsidian';
import { diff_match_patch } from 'diff-match-patch';

/**
 * Utility class for content operations
 */
export class ContentOperations {
  /**
   * Normalize file path by removing any leading slash
   * @param filePath Path to normalize
   * @returns Normalized path
   */
  private static normalizePath(filePath: string): string {
    // Remove leading slash if present
    return filePath.startsWith('/') ? filePath.slice(1) : filePath;
  }

  /**
   * Read the content of a note
   * @param app Obsidian app instance
   * @param filePath Path to the note
   * @returns Promise that resolves with the note content
   */
  static async readContent(app: App, filePath: string): Promise<string> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (!file) {
        throw new Error(`File not found: "${filePath}". Use searchContent to find files by name, or storageManager.list to explore folders.`);
      }
      
      if (!(file instanceof TFile)) {
        throw new Error(`Path is a folder, not a file: "${filePath}". Use storageManager.list to see its contents.`);
      }
      
      return await app.vault.read(file);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error reading file: ${errorMessage}`);
    }
  }
  
  /**
   * Read the content of a note with line numbers
   * @param app Obsidian app instance
   * @param filePath Path to the note
   * @returns Promise that resolves with the note content including line numbers
   */
  static async readContentWithLineNumbers(app: App, filePath: string): Promise<string> {
    try {
      // Normalize path is handled by readContent internally
      const content = await this.readContent(app, filePath);
      const lines = content.split('\n');
      
      return lines.map((line, index) => `${index + 1}: ${line}`).join('\n');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error reading file with line numbers: ${errorMessage}`);
    }
  }
  
  /**
   * Read specific lines from a note
   * @param app Obsidian app instance
   * @param filePath Path to the note
   * @param startLine Start line (1-based)
   * @param endLine End line (1-based, inclusive)
   * @param includeLineNumbers Whether to include line numbers in output
   * @returns Promise that resolves with the specified lines
   */
  static async readLines(
    app: App, 
    filePath: string, 
    startLine: number, 
    endLine: number,
    includeLineNumbers = false
  ): Promise<string[]> {
    try {
      // Normalize path is handled by readContent internally
      const content = await this.readContent(app, filePath);
      const lines = content.split('\n');
      
      // Adjust for 1-based line numbers
      startLine = Math.max(1, startLine);
      endLine = Math.min(lines.length, endLine);
      
      if (startLine > endLine) {
        throw new Error('Start line cannot be greater than end line');
      }
      
      const selectedLines = lines.slice(startLine - 1, endLine);
      
      if (includeLineNumbers) {
        return selectedLines.map((line, index) => `${startLine + index}: ${line}`);
      }
      
      return selectedLines;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error reading lines: ${errorMessage}`);
    }
  }
  
  /**
   * Create a new file with content
   * @param app Obsidian app instance
   * @param filePath Path to the new file
   * @param content Content for the new file
   * @returns Promise that resolves with the created file
   */
  static async createContent(app: App, filePath: string, content: string): Promise<TFile> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (file) {
        throw new Error(`File already exists: "${filePath}". Use readContent to view it, or appendContent/prependContent to add to it.`);
      }
      
      // Ensure parent folders exist
      const folderPath = normalizedPath.substring(0, normalizedPath.lastIndexOf('/'));
      if (folderPath) {
        // Normalize the folder path as well
        await app.vault.createFolder(folderPath).catch(() => {
          // Folder might already exist, ignore error
        });
      }
      
      return await app.vault.create(normalizedPath, content);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error creating file: ${errorMessage}`);
    }
  }
  
  /**
   * Append content to a file
   * @param app Obsidian app instance
   * @param filePath Path to the file
   * @param content Content to append
   * @returns Promise that resolves when the content is appended
   */
  static async appendContent(app: App, filePath: string, content: string): Promise<{
    appendedLength: number;
    totalLength: number;
  }> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (!file) {
        throw new Error(`File not found: "${filePath}". Use searchContent to find files by name, or storageManager.list to explore folders.`);
      }
      
      if (!(file instanceof TFile)) {
        throw new Error(`Path is a folder, not a file: "${filePath}". Use storageManager.list to see its contents.`);
      }
      
      const existingContent = await app.vault.read(file);
      const newContent = existingContent + content;
      
      await app.vault.modify(file, newContent);
      
      return {
        appendedLength: content.length,
        totalLength: newContent.length
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error appending to file: ${errorMessage}`);
    }
  }
  
  /**
   * Prepend content to a file
   * @param app Obsidian app instance
   * @param filePath Path to the file
   * @param content Content to prepend
   * @returns Promise that resolves when the content is prepended
   */
  static async prependContent(app: App, filePath: string, content: string): Promise<{
    prependedLength: number;
    totalLength: number;
  }> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (!file) {
        throw new Error(`File not found: "${filePath}". Use searchContent to find files by name, or storageManager.list to explore folders.`);
      }
      
      if (!(file instanceof TFile)) {
        throw new Error(`Path is a folder, not a file: "${filePath}". Use storageManager.list to see its contents.`);
      }
      
      const existingContent = await app.vault.read(file);
      const newContent = content + existingContent;
      
      await app.vault.modify(file, newContent);
      
      return {
        prependedLength: content.length,
        totalLength: newContent.length
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error prepending to file: ${errorMessage}`);
    }
  }
  
  /**
   * Replace content in a file using fuzzy matching
   * @param app Obsidian app instance
   * @param filePath Path to the file
   * @param oldContent Content to replace
   * @param newContent Content to replace with
   * @param similarityThreshold Threshold for fuzzy matching (0.0 to 1.0, where 1.0 is exact match)
   * @returns Promise that resolves with the number of replacements made
   */
  static async replaceContent(
    app: App,
    filePath: string,
    oldContent: string,
    newContent: string,
    similarityThreshold = 0.95
  ): Promise<number> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (!file) {
        throw new Error(`File not found: "${filePath}". Use searchContent to find files by name, or storageManager.list to explore folders.`);
      }
      
      if (!(file instanceof TFile)) {
        throw new Error(`Path is a folder, not a file: "${filePath}". Use storageManager.list to see its contents.`);
      }
      
      const existingContent = await app.vault.read(file);
      
      // Try exact match first
      const regex = new RegExp(this.escapeRegExp(oldContent), 'g');
      const exactMatches = (existingContent.match(regex) || []).length;
      
      if (exactMatches > 0) {
        // Perform exact replacement if found
        const modifiedContent = existingContent.replace(regex, newContent);
        await app.vault.modify(file, modifiedContent);
        return exactMatches;
      }
      
      // If no exact match, try fuzzy matching
      const dmp = new diff_match_patch();
      
      // Configure the matcher
      dmp.Match_Threshold = similarityThreshold;
      dmp.Match_Distance = 1000; // Maximum distance to search
      
      // Find the best match position
      const matchPosition = dmp.match_main(existingContent, oldContent, 0);
      
      if (matchPosition === -1) {
        // No match found even with fuzzy matching - provide recovery guidance
        throw new Error(`Content to replace not found in "${filePath}" (tried fuzzy matching at ${similarityThreshold * 100}% threshold). Use readContent to view the exact file contents first, then copy the EXACT text you want to replace.`);
      }
      
      // Extract the actual matched text for informational purposes
      const matchedLength = oldContent.length;
      const actualMatchedText = existingContent.substring(matchPosition, matchPosition + matchedLength);
      
      
      // Create a clean replacement by slicing the original content
      const beforeMatch = existingContent.substring(0, matchPosition);
      const afterMatch = existingContent.substring(matchPosition + matchedLength);
      const modifiedContent = beforeMatch + newContent + afterMatch;
      
      // Modify the file
      await app.vault.modify(file, modifiedContent);
      
      return 1; // One fuzzy replacement made
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error replacing content: ${errorMessage}`);
    }
  }
  
  /**
   * Replace specific lines in a file
   * @param app Obsidian app instance
   * @param filePath Path to the file
   * @param startLine Start line (1-based)
   * @param endLine End line (1-based, inclusive)
   * @param newContent Content to replace with
   * @returns Promise that resolves with the number of lines replaced
   */
  static async replaceByLine(
    app: App,
    filePath: string,
    startLine: number,
    endLine: number,
    newContent: string
  ): Promise<number> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (!file) {
        throw new Error(`File not found: "${filePath}". Use searchContent to find files by name, or storageManager.list to explore folders.`);
      }
      
      if (!(file instanceof TFile)) {
        throw new Error(`Path is a folder, not a file: "${filePath}". Use storageManager.list to see its contents.`);
      }
      
      const existingContent = await app.vault.read(file);
      const lines = existingContent.split('\n');
      
      // Adjust for 1-based line numbers
      startLine = Math.max(1, startLine);
      endLine = Math.min(lines.length, endLine);
      
      if (startLine > endLine) {
        throw new Error('Start line cannot be greater than end line');
      }
      
      const linesReplaced = endLine - startLine + 1;
      
      // Replace lines
      const beforeLines = lines.slice(0, startLine - 1);
      const afterLines = lines.slice(endLine);
      
      const newLines = newContent.split('\n');
      
      const modifiedContent = [
        ...beforeLines,
        ...newLines,
        ...afterLines
      ].join('\n');
      
      await app.vault.modify(file, modifiedContent);
      
      return linesReplaced;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error replacing lines: ${errorMessage}`);
    }
  }
  
  /**
   * Delete content from a file with fuzzy matching support
   * @param app Obsidian app instance
   * @param filePath Path to the file
   * @param content Content to delete
   * @param similarityThreshold Threshold for fuzzy matching (0.0 to 1.0, where 1.0 is exact match)
   * @returns Promise that resolves with the number of deletions made
   */
  static async deleteContent(
    app: App,
    filePath: string,
    content: string,
    similarityThreshold = 0.95
  ): Promise<number> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (!file) {
        throw new Error(`File not found: "${filePath}". Use searchContent to find files by name, or storageManager.list to explore folders.`);
      }
      
      if (!(file instanceof TFile)) {
        throw new Error(`Path is a folder, not a file: "${filePath}". Use storageManager.list to see its contents.`);
      }
      
      const existingContent = await app.vault.read(file);
      
      // Try exact match first
      const regex = new RegExp(this.escapeRegExp(content), 'g');
      const exactMatches = (existingContent.match(regex) || []).length;
      
      if (exactMatches > 0) {
        // Perform exact deletion if found
        const modifiedContent = existingContent.replace(regex, '');
        await app.vault.modify(file, modifiedContent);
        return exactMatches;
      }
      
      // If no exact match, try fuzzy matching
      const dmp = new diff_match_patch();
      
      // Configure the matcher
      dmp.Match_Threshold = similarityThreshold;
      dmp.Match_Distance = 1000; // Maximum distance to search
      
      // Find the best match position
      const matchPosition = dmp.match_main(existingContent, content, 0);
      
      if (matchPosition === -1) {
        // No match found even with fuzzy matching
        throw new Error(`Content to delete not found in file, even with fuzzy matching at ${similarityThreshold * 100}% threshold`);
      }
      
      // Extract the actual matched text for informational purposes
      const matchedLength = content.length;
      const actualMatchedText = existingContent.substring(matchPosition, matchPosition + matchedLength);
      
      
      // Create a clean deletion by slicing the original content
      const beforeMatch = existingContent.substring(0, matchPosition);
      const afterMatch = existingContent.substring(matchPosition + matchedLength);
      const modifiedContent = beforeMatch + afterMatch;
      
      // Modify the file
      await app.vault.modify(file, modifiedContent);
      
      return 1; // One fuzzy deletion made
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error deleting content: ${errorMessage}`);
    }
  }
  
  /**
   * Find and replace text in a file
   * @param app Obsidian app instance
   * @param filePath Path to the file
   * @param findText Text to find
   * @param replaceText Text to replace with
   * @param replaceAll Whether to replace all occurrences or just the first one
   * @param caseSensitive Whether the search should be case sensitive
   * @param wholeWord Whether to use whole word matching
   * @returns Promise that resolves with the number of replacements made
   */
  static async findReplaceContent(
    app: App,
    filePath: string,
    findText: string,
    replaceText: string,
    replaceAll = false,
    caseSensitive = true,
    wholeWord = false
  ): Promise<number> {
    try {
      // Normalize path to remove any leading slash
      const normalizedPath = this.normalizePath(filePath);
      const file = app.vault.getAbstractFileByPath(normalizedPath);
      
      if (!file) {
        throw new Error(`File not found: "${filePath}". Use searchContent to find files by name, or storageManager.list to explore folders.`);
      }
      
      if (!(file instanceof TFile)) {
        throw new Error(`Path is a folder, not a file: "${filePath}". Use storageManager.list to see its contents.`);
      }
      
      const existingContent = await app.vault.read(file);
      
      // Build regex pattern
      let pattern = this.escapeRegExp(findText);
      
      // Add word boundaries if wholeWord is true
      if (wholeWord) {
        pattern = `\\b${pattern}\\b`;
      }
      
      // Create regex with appropriate flags
      const flags = (caseSensitive ? '' : 'i') + (replaceAll ? 'g' : '');
      const regex = new RegExp(pattern, flags);
      
      // Count matches before replacement
      const matches = existingContent.match(regex);
      const matchCount = matches ? matches.length : 0;
      
      if (matchCount === 0) {
        // No matches found
        return 0;
      }
      
      // Perform replacement
      const modifiedContent = existingContent.replace(regex, replaceText);
      await app.vault.modify(file, modifiedContent);
      
      return matchCount;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Error in find and replace: ${errorMessage}`);
    }
  }

  /**
   * Escape special characters in a string for use in a regular expression
   * @param string String to escape
   * @returns Escaped string
   */
  private static escapeRegExp(string: string): string {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
}
```

## agents/index.ts

```typescript
// Core agents in the new agent structure
export * from './contentManager/contentManager';
export * from './commandManager/commandManager';
export * from './storageManager/storageManager';
export * from './searchManager/searchManager';
export * from './memoryManager/memoryManager';
export * from './promptManager/promptManager';
export * from './toolManager/toolManager';
// Chat agent removed - using native chatbot UI instead
```

## agents/interfaces/IAgent.ts

```typescript
// Import ITool from separate file
import { ITool } from './ITool';

/**
 * Interface for agents in the MCP plugin
 * Each agent is responsible for a specific domain and provides a set of tools
 */
export interface IAgent {
  /**
   * Name of the agent
   */
  name: string;

  /**
   * Description of the agent
   */
  description: string;

  /**
   * Version of the agent
   */
  version: string;

  /**
   * Get all tools provided by this agent
   * @returns Array of tools
   */
  getTools(): ITool[];

  /**
   * Get a specific tool by slug
   * @param toolSlug Slug of the tool to get
   * @returns Tool with the specified slug or undefined if not found
   */
  getTool(toolSlug: string): ITool | undefined;

  /**
   * Initialize the agent
   * @returns Promise that resolves when initialization is complete
   */
  initialize(): Promise<void>;

  /**
   * Execute a tool with parameters
   * @param toolSlug Slug of the tool to execute
   * @param params Parameters to pass to the tool
   * @returns Promise that resolves with the tool's result
   */
  executeTool(toolSlug: string, params: any): Promise<any>;

  /**
   * Set the agent manager reference
   * @param agentManager Agent manager instance
   */
  setAgentManager(agentManager: any): void;

}
```

## agents/interfaces/ITool.ts

```typescript
/**
 * Interface for tools in the MCP plugin
 * Each tool provides a specific functionality within an agent's domain
 */
export interface ITool<T = any, R = any> {
  /**
   * Slug of the tool (used for identification)
   */
  slug: string;

  /**
   * Name of the tool
   */
  name: string;

  /**
   * Description of the tool
   */
  description: string;

  /**
   * Version of the tool
   */
  version: string;

  /**
   * Execute the tool with parameters
   * @param params Parameters for the tool
   * @returns Promise that resolves with the tool's result
   */
  execute(params: T): Promise<R>;

  /**
   * Get the JSON schema for the tool's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any;

  /**
   * Get the JSON schema for the tool's result
   * @returns JSON schema object
   */
  getResultSchema(): any;
}

```

## agents/memoryManager/memoryManager.ts

```typescript
import { App } from 'obsidian';
import { BaseAgent } from '../baseAgent';
import { MemoryService } from "./services/MemoryService";
import { WorkspaceService } from "../../services/WorkspaceService";
import { sanitizeVaultName } from '../../utils/vaultUtils';
import { getNexusPlugin } from '../../utils/pluginLocator';
import { NexusPluginWithServices } from './tools/utils/pluginTypes';

// Import consolidated tools
import { CreateStateTool } from './tools/states/createState';
import { ListStatesTool } from './tools/states/listStates';
import { LoadStateTool } from './tools/states/loadState';
import { CreateWorkspaceTool } from './tools/workspaces/createWorkspace';
import { ListWorkspacesTool } from './tools/workspaces/listWorkspaces';
import { LoadWorkspaceTool } from './tools/workspaces/loadWorkspace';
import { UpdateWorkspaceTool } from './tools/workspaces/updateWorkspace';
import { ArchiveWorkspaceTool } from './tools/workspaces/archiveWorkspace';

/**
 * Agent for managing workspace memory and states
 *
 * CONSOLIDATED ARCHITECTURE:
 * - Sessions are now implicit (sessionId comes from context, no CRUD needed)
 * - 3 state tools: create/list/load (states are immutable - no update/archive)
 * - 5 workspace tools: create/list/load/update/archive
 * - 3 services: ValidationService/ContextBuilder/MemoryTraceService
 */
export class MemoryManagerAgent extends BaseAgent {
  /**
   * Memory service instance
   */
  private readonly memoryService: MemoryService;

  /**
   * Workspace service instance
   */
  private readonly workspaceService: WorkspaceService;
  
  /**
   * App instance
   */
  private app: App;

  /**
   * Vault name for multi-vault support
   */
  private vaultName: string;

  /**
   * Flag to prevent infinite recursion in description getter
   */
  private isGettingDescription = false;

  /**
   * Create a new MemoryManagerAgent with consolidated modes
   * @param app Obsidian app instance
   * @param plugin Plugin instance for accessing shared services
   * @param memoryService Injected memory service
   * @param workspaceService Injected workspace service
   */
  constructor(
    app: App,
    public plugin: any,
    memoryService: MemoryService,
    workspaceService: WorkspaceService
  ) {
    super(
      'memoryManager',
      'Manages workspaces and states for contextual recall',
      '1.3.0'
    );

    this.app = app;
    this.vaultName = sanitizeVaultName(app.vault.getName());

    // Store injected services
    this.memoryService = memoryService;
    this.workspaceService = workspaceService;

    // Register state tools (3 tools: create, list, load)
    this.registerTool(new CreateStateTool(this));
    this.registerTool(new ListStatesTool(this));
    this.registerTool(new LoadStateTool(this));

    // Register workspace tools (5 tools: create, list, load, update, archive)
    this.registerTool(new CreateWorkspaceTool(this));
    this.registerTool(new ListWorkspacesTool(this));
    this.registerTool(new LoadWorkspaceTool(this));
    this.registerTool(new UpdateWorkspaceTool(this));
    this.registerTool(new ArchiveWorkspaceTool(this));
  }

  /**
   * Dynamic description that includes current workspace information
   */
  get description(): string {
    const baseDescription = 'Manages workspaces and states for contextual recall';
    
    // Prevent infinite recursion
    if (this.isGettingDescription) {
      return `[${this.vaultName}] ${baseDescription}`;
    }
    
    this.isGettingDescription = true;
    try {
      const workspaceContext = this.getWorkspacesSummary();
      return `[${this.vaultName}] ${baseDescription}\n\n${workspaceContext}`;
    } finally {
      this.isGettingDescription = false;
    }
  }
  
  /**
   * Initialize the agent
   */
  async initialize(): Promise<void> {
    await super.initialize();
    // No additional initialization needed
  }
  
  /**
   * Get the memory service instance - now uses injected service
   */
  getMemoryService(): MemoryService | null {
    return this.memoryService;
  }
  
  /**
   * Get the workspace service instance - now uses injected service
   */
  getWorkspaceService(): WorkspaceService | null {
    return this.workspaceService;
  }
  
  /**
   * Get the memory service instance asynchronously - now uses injected service
   */
  async getMemoryServiceAsync(): Promise<MemoryService | null> {
    return this.memoryService;
  }
  
  /**
   * Get the workspace service instance asynchronously - now uses injected service
   */
  async getWorkspaceServiceAsync(): Promise<WorkspaceService | null> {
    return this.workspaceService;
  }
  
  /**
   * Get the Obsidian app instance
   */
  getApp() {
    return this.app;
  }

  /**
   * Get the CacheManager service instance
   */
  getCacheManager() {
    const plugin = getNexusPlugin<NexusPluginWithServices>(this.app);
    return plugin?.getServiceIfReady('cacheManager') || null;
  }

  /**
   * Get a summary of available workspaces
   * @returns Formatted string with workspace information
   * @private
   */
  private getWorkspacesSummary(): string {
    try {
      // Check if workspace service is available using ServiceContainer
      const workspaceService = this.getWorkspaceService();
      if (!workspaceService) {
        return `ðŸ—ï¸ Workspaces: Service not available (initializing...)`;
      }

      // Service is available - return success message
      return `ðŸ—ï¸ Workspaces: Available (use listWorkspaces tool to see details)`;
      
    } catch (error) {
      return `ðŸ—ï¸ Workspaces: Error loading workspace information (${error})`;
    }
  }
}

```

## agents/memoryManager/services/index.ts

```typescript
export { MemoryService } from './MemoryService';
export { WorkspaceService } from '../../../services/WorkspaceService';
export { ValidationService } from './ValidationService';
```

## agents/memoryManager/services/MemoryService.ts

```typescript
// Location: src/agents/memoryManager/services/MemoryService.ts
// Agent-specific memory management service that delegates to WorkspaceService or IStorageAdapter
// Used by: MemoryManager agent tools for memory operations
// Dependencies: WorkspaceService (legacy) or IStorageAdapter (new) for all data access

import { Plugin } from 'obsidian';
import { WorkspaceService } from '../../../services/WorkspaceService';
import { IStorageAdapter } from '../../../database/interfaces/IStorageAdapter';
import {
  WorkspaceMemoryTrace,
  WorkspaceSession,
  WorkspaceState
} from '../../../database/workspace-types';
import { MemoryTraceData, SessionMetadata } from '../../../types/storage/HybridStorageTypes';
import { PaginatedResult, PaginationParams, calculatePaginationMetadata } from '../../../types/pagination/PaginationTypes';
import { normalizeLegacyTraceMetadata } from '../../../services/memory/LegacyTraceMetadataNormalizer';

/**
 * MemoryService provides agent-specific logic for memory management
 * Data access is delegated to either:
 * - IStorageAdapter (new hybrid JSONL+SQLite backend with pagination)
 * - WorkspaceService (legacy JSON file backend)
 */
export class MemoryService {
  constructor(
    private plugin: Plugin,
    private workspaceService: WorkspaceService,
    private storageAdapter?: IStorageAdapter
  ) {}

  /**
   * Get memory traces from a workspace/session
   * @param workspaceId - Workspace ID
   * @param sessionId - Optional session ID to filter by
   * @param options - Optional pagination parameters
   * @returns Always returns PaginatedResult for consistent API
   */
  async getMemoryTraces(
    workspaceId: string,
    sessionId?: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<WorkspaceMemoryTrace>> {
    // Use new storage adapter if available
    if (this.storageAdapter) {
      const result = await this.storageAdapter.getTraces(workspaceId, sessionId, options);

      // Convert MemoryTraceData to WorkspaceMemoryTrace format
      const convertedItems = result.items.map(trace => this.convertToLegacyTrace(trace));

      return {
        ...result,
        items: convertedItems
      };
    }

    // Legacy path: use WorkspaceService
    let allTraces: WorkspaceMemoryTrace[] = [];

    if (sessionId) {
      // Get traces from specific session
      const traces = await this.workspaceService.getMemoryTraces(workspaceId, sessionId);
      allTraces = traces.map(trace => ({
        ...trace,
        workspaceId,
        sessionId
      }));
    } else {
      // Get all traces from all sessions in workspace
      const workspace = await this.workspaceService.getWorkspace(workspaceId);

      if (workspace) {
        for (const [sid, session] of Object.entries(workspace.sessions)) {
          const sessionTraces = Object.values(session.memoryTraces).map(trace => ({
            ...trace,
            workspaceId,
            sessionId: sid
          }));
          allTraces.push(...sessionTraces);
        }
      }
    }

    // Wrap in PaginatedResult for consistent return type
    return this.wrapInPaginatedResult(allTraces, options);
  }

  /**
   * Helper to wrap an array in a PaginatedResult
   */
  private wrapInPaginatedResult<T>(items: T[], options?: PaginationParams): PaginatedResult<T> {
    const page = options?.page ?? 0;
    const pageSize = options?.pageSize ?? (items.length || 1); // Default to all items
    const totalItems = items.length;

    // Apply pagination if options provided
    const start = page * pageSize;
    const end = start + pageSize;
    const paginatedItems = options ? items.slice(start, end) : items;

    return {
      items: paginatedItems,
      ...calculatePaginationMetadata(page, pageSize, totalItems)
    };
  }

  /**
   * Helper to convert MemoryTraceData to WorkspaceMemoryTrace format
   */
  private convertToLegacyTrace(trace: MemoryTraceData): WorkspaceMemoryTrace {
    return {
      id: trace.id,
      workspaceId: trace.workspaceId,
      sessionId: trace.sessionId,
      timestamp: trace.timestamp,
      type: trace.type || 'generic',
      content: trace.content,
      metadata: trace.metadata
    };
  }

  /**
   * Helper to convert WorkspaceMemoryTrace to MemoryTraceData format
   */
  private convertFromLegacyTrace(trace: WorkspaceMemoryTrace): MemoryTraceData {
    return {
      id: trace.id,
      workspaceId: trace.workspaceId,
      sessionId: trace.sessionId || '',
      timestamp: trace.timestamp,
      type: trace.type,
      content: trace.content,
      metadata: trace.metadata
    };
  }

  /**
   * Record activity trace in a session
   */
  async recordActivityTrace(trace: Omit<WorkspaceMemoryTrace, 'id'>): Promise<string> {
    const workspaceId = trace.workspaceId;
    let sessionId = trace.sessionId || 'default-session';

    // Use new storage adapter if available
    if (this.storageAdapter) {
      try {
        const traceId = await this.storageAdapter.addTrace(workspaceId, sessionId, {
          timestamp: trace.timestamp || Date.now(),
          type: trace.type || 'generic',
          content: trace.content || '',
          metadata: normalizeLegacyTraceMetadata({
            workspaceId,
            sessionId,
            traceType: trace.type,
            metadata: trace.metadata
          })
        });
        return traceId;
      } catch (error) {
        // If session doesn't exist, try to create it first
        if ((error as Error).message?.includes('session')) {
          await this.storageAdapter.createSession(workspaceId, {
            name: 'Default Session',
            description: 'Auto-created session',
            startTime: Date.now(),
            isActive: true
          });
          // Retry adding trace
          return await this.storageAdapter.addTrace(workspaceId, sessionId, {
            timestamp: trace.timestamp || Date.now(),
            type: trace.type || 'generic',
            content: trace.content || '',
            metadata: normalizeLegacyTraceMetadata({
              workspaceId,
              sessionId,
              traceType: trace.type,
              metadata: trace.metadata
            })
          });
        }
        throw error;
      }
    }

    // Legacy path: use WorkspaceService
    // Ensure workspace exists
    const workspace = await this.workspaceService.getWorkspace(workspaceId);

    if (!workspace) {
      throw new Error(`Workspace ${workspaceId} not found`);
    }

    // Create session if it doesn't exist
    if (!workspace.sessions[sessionId]) {
      await this.workspaceService.addSession(workspaceId, {
        id: sessionId,
        name: 'Default Session',
        startTime: Date.now(),
        isActive: true,
        memoryTraces: {},
        states: {}
      });
    }

    // Add trace to session
    const createdTrace = await this.workspaceService.addMemoryTrace(workspaceId, sessionId, {
      timestamp: trace.timestamp || Date.now(),
      type: trace.type || 'generic',
      content: trace.content || '',
      metadata: normalizeLegacyTraceMetadata({
        workspaceId,
        sessionId,
        traceType: trace.type,
        metadata: trace.metadata
      })
    });

    return createdTrace.id;
  }

  /**
   * Create memory trace
   */
  async createMemoryTrace(trace: Omit<WorkspaceMemoryTrace, 'id'>): Promise<WorkspaceMemoryTrace> {
    const traceId = await this.recordActivityTrace(trace);
    const workspaceId = trace.workspaceId;
    const sessionId = trace.sessionId || 'default-session';

    // Retrieve the created trace
    const traces = await this.workspaceService.getMemoryTraces(workspaceId, sessionId);
    const createdTrace = traces.find(t => t.id === traceId);

    if (!createdTrace) {
      throw new Error('Failed to retrieve created memory trace');
    }

    return {
      ...createdTrace,
      workspaceId,
      sessionId
    };
  }

  /**
   * Get sessions for a workspace
   * @param workspaceId - Workspace ID
   * @param options - Optional pagination parameters
   * @returns Always returns PaginatedResult for consistent API
   */
  async getSessions(
    workspaceId: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<WorkspaceSession>> {
    // Use new storage adapter if available
    if (this.storageAdapter) {
      const result = await this.storageAdapter.getSessions(workspaceId, options);

      // Convert SessionMetadata to WorkspaceSession format
      const convertedItems = result.items.map(session => this.convertSessionMetadataToWorkspaceSession(session));

      return {
        ...result,
        items: convertedItems
      };
    }

    // Legacy path: use WorkspaceService
    const workspace = await this.workspaceService.getWorkspace(workspaceId);

    if (!workspace) {
      return this.wrapInPaginatedResult([], options);
    }

    const sessions = Object.values(workspace.sessions).map(session => ({
      ...session,
      workspaceId
    }));

    // Wrap in PaginatedResult for consistent return type
    return this.wrapInPaginatedResult(sessions, options);
  }

  /**
   * Helper to convert SessionMetadata to WorkspaceSession format
   */
  private convertSessionMetadataToWorkspaceSession(metadata: SessionMetadata): WorkspaceSession {
    return {
      id: metadata.id,
      workspaceId: metadata.workspaceId,
      name: metadata.name,
      description: metadata.description
    };
  }

  /**
   * Create session in workspace
   */
  async createSession(session: Omit<WorkspaceSession, 'id'> & {
    id?: string;
    workspaceId: string;
    startTime?: number;
    endTime?: number;
    isActive?: boolean;
  }): Promise<WorkspaceSession> {
    const workspaceId = session.workspaceId;
    const sessionId = session.id; // Extract ID if provided

    const createdSession = await this.workspaceService.addSession(workspaceId, {
      id: sessionId, // Pass the ID through!
      name: session.name,
      description: session.description,
      startTime: session.startTime || Date.now(),
      endTime: session.endTime,
      isActive: session.isActive ?? true,
      memoryTraces: {},
      states: {}
    });

    return {
      ...createdSession,
      workspaceId
    };
  }

  /**
   * Update session
   */
  async updateSession(workspaceId: string, sessionId: string, updates: Partial<WorkspaceSession>): Promise<void> {
    await this.workspaceService.updateSession(workspaceId, sessionId, updates);
  }

  /**
   * Get session by ID
   */
  async getSession(workspaceId: string, sessionId: string): Promise<WorkspaceSession | null> {
    const session = await this.workspaceService.getSession(workspaceId, sessionId);

    if (!session) {
      return null;
    }

    return {
      ...session,
      workspaceId
    };
  }

  /**
   * Get session by name or ID (unified lookup)
   * Tries ID lookup first, then falls back to name lookup
   */
  async getSessionByNameOrId(workspaceId: string, identifier: string): Promise<WorkspaceSession | null> {
    const session = await this.workspaceService.getSessionByNameOrId(workspaceId, identifier);

    if (!session) {
      return null;
    }

    return {
      ...session,
      workspaceId
    };
  }

  /**
   * Delete session
   */
  async deleteSession(workspaceId: string, sessionId: string): Promise<void> {
    await this.workspaceService.deleteSession(workspaceId, sessionId);
  }

  /**
   * Save state to session
   */
  async saveState(
    workspaceId: string,
    sessionId: string,
    stateData: WorkspaceState,
    name?: string
  ): Promise<string> {
    const state = await this.workspaceService.addState(workspaceId, sessionId, {
      id: stateData.id,  // Pass the ID to preserve it
      name: name || stateData.name || 'Unnamed State',
      created: stateData.created || Date.now(),
      state: stateData
    });

    return state.id;
  }

  /**
   * Get state from session by ID
   */
  async getState(
    workspaceId: string,
    sessionId: string,
    stateId: string
  ): Promise<WorkspaceState | null> {
    const stateData = await this.workspaceService.getState(workspaceId, sessionId, stateId);

    if (!stateData) {
      return null;
    }

    return stateData.state;
  }

  /**
   * Get state by name or ID (unified lookup)
   * Tries ID lookup first, then falls back to name lookup
   */
  async getStateByNameOrId(
    workspaceId: string,
    sessionId: string,
    identifier: string
  ): Promise<WorkspaceState | null> {
    const stateData = await this.workspaceService.getStateByNameOrId(workspaceId, sessionId, identifier);

    if (!stateData) {
      return null;
    }

    return stateData.state;
  }

  /**
   * State item type for getStates return
   */
  private static readonly StateItem = {} as {
    id: string;
    name: string;
    created: number;
    state: WorkspaceState;
  };

  /**
   * Get all states for a session (or all sessions in workspace if sessionId not provided)
   * @param workspaceId - Workspace ID
   * @param sessionId - Optional session ID to filter by
   * @param options - Optional pagination parameters
   * @returns Always returns PaginatedResult for consistent API
   */
  async getStates(
    workspaceId: string,
    sessionId?: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<{
    id: string;
    name: string;
    created: number;
    state: WorkspaceState;
  }>> {
    type StateItem = { id: string; name: string; created: number; state: WorkspaceState };

    // Use new storage adapter if available
    if (this.storageAdapter) {
      const result = await this.storageAdapter.getStates(workspaceId, sessionId, options);

      // Convert StateMetadata to legacy format
      const convertedItems: StateItem[] = result.items.map(stateMeta => ({
        id: stateMeta.id,
        name: stateMeta.name,
        created: stateMeta.created,
        state: {} as WorkspaceState // Metadata doesn't include full content
      }));

      return {
        ...result,
        items: convertedItems
      };
    }

    // Legacy path: use WorkspaceService
    const workspace = await this.workspaceService.getWorkspace(workspaceId);
    let allStates: StateItem[] = [];

    if (workspace) {
      // If sessionId provided, get states for that session only
      if (sessionId) {
        if (workspace.sessions[sessionId]) {
          allStates = Object.values(workspace.sessions[sessionId].states);
        }
      } else {
        // Get all states from all sessions in workspace
        for (const session of Object.values(workspace.sessions)) {
          allStates.push(...Object.values(session.states));
        }
      }
    }

    // Wrap in PaginatedResult for consistent return type
    return this.wrapInPaginatedResult(allStates, options);
  }

  /**
   * Update state
   */
  async updateState(
    workspaceId: string,
    sessionId: string,
    stateId: string,
    updates: Partial<{
      name: string;
      state: WorkspaceState;
    }>
  ): Promise<void> {
    const workspace = await this.workspaceService.getWorkspace(workspaceId);

    if (!workspace || !workspace.sessions[sessionId] || !workspace.sessions[sessionId].states[stateId]) {
      throw new Error('State not found');
    }

    // Update the state
    const state = workspace.sessions[sessionId].states[stateId];
    workspace.sessions[sessionId].states[stateId] = {
      ...state,
      ...updates
    };

    // Save workspace
    await this.workspaceService.updateWorkspace(workspaceId, workspace);
  }

  /**
   * Delete state
   */
  async deleteState(
    workspaceId: string,
    sessionId: string,
    stateId: string
  ): Promise<void> {
    const workspace = await this.workspaceService.getWorkspace(workspaceId);

    if (!workspace || !workspace.sessions[sessionId]) {
      throw new Error('Session not found');
    }

    // Delete the state
    delete workspace.sessions[sessionId].states[stateId];

    // Save workspace
    await this.workspaceService.updateWorkspace(workspaceId, workspace);
  }

}

```

## agents/memoryManager/services/ServiceAccessor.ts

```typescript
/**
 * Location: /src/agents/memoryManager/services/ServiceAccessor.ts
 *
 * Purpose: Core service access logic with retry and error handling
 * Extracted from ValidationService.ts to separate concerns
 *
 * Used by: ValidationService for service discovery and access
 * Dependencies: App (Obsidian)
 */

import { App, Plugin } from 'obsidian';
import { getErrorMessage } from '../../../utils/errorUtils';
import { getAllPluginIds } from '../../../constants/branding';
import { getNexusPlugin } from '../../../utils/pluginLocator';

export interface ServiceStatus {
  available: boolean;
  initialized: boolean;
  lastError?: string;
  lastCheck: number;
  retryCount: number;
}

export interface ServiceAccessResult<T> {
  success: boolean;
  service: T | null;
  error?: string;
  status: ServiceStatus;
  diagnostics?: {
    pluginFound: boolean;
    serviceContainerAvailable: boolean;
    serviceFound: boolean;
    methodUsed: string;
    duration: number;
  };
}

export interface ServiceIntegrationConfig {
  maxRetries: number;
  retryDelayMs: number;
  timeoutMs: number;
  enableHealthCheck: boolean;
  fallbackBehavior: 'fail' | 'warn' | 'silent';
  logLevel: 'debug' | 'info' | 'warn' | 'error';
}

export interface NexusPluginBridge extends Plugin {
  services?: Record<string, any>;
  serviceContainer?: {
    getIfReady<T>(serviceName: string): T | null;
  };
  getService?<T>(serviceName: string): Promise<T>;
}

/**
 * Handles service access with robust error handling and retry logic
 */
export class ServiceAccessor {
  private serviceStatuses: Map<string, ServiceStatus> = new Map();

  constructor(
    private app: App,
    private config: ServiceIntegrationConfig
  ) {}

  /**
   * Get service with comprehensive error handling
   */
  async getService<T>(serviceName: string, displayName: string): Promise<ServiceAccessResult<T>> {
    const startTime = Date.now();
    const status = this.getServiceStatus(serviceName);

    // If service was recently checked and failed, return cached failure
    if (!status.available && (Date.now() - status.lastCheck) < this.config.retryDelayMs) {
      this.log('debug', `[ServiceAccessor] Using cached failure for ${displayName}`);
      return this.createResult<T>(false, null, status.lastError || 'Service unavailable', status, {
        pluginFound: false,
        serviceContainerAvailable: false,
        serviceFound: false,
        methodUsed: 'cached',
        duration: Date.now() - startTime
      });
    }

    let attempts = 0;
    let lastError = '';

    while (attempts <= this.config.maxRetries) {
      try {
        attempts++;
        this.log('debug', `[ServiceAccessor] Attempting to get ${displayName} (attempt ${attempts}/${this.config.maxRetries + 1})`);

        const plugin = getNexusPlugin<NexusPluginBridge>(this.app);
        if (!plugin) {
          const knownIds = getAllPluginIds().join(`' or '`);
          lastError = `Plugin '${knownIds}' not found`;
          this.log('error', `[ServiceAccessor] ${lastError}`);

          if (attempts <= this.config.maxRetries) {
            await this.delay(this.config.retryDelayMs);
            continue;
          }
          break;
        }

        const diagnostics = {
          pluginFound: true,
          serviceContainerAvailable: false,
          serviceFound: false,
          methodUsed: '',
          duration: 0
        };

        // Try ServiceContainer first (preferred method)
        if (plugin.serviceContainer) {
          this.log('debug', `[ServiceAccessor] Trying ServiceContainer for ${displayName}`);
          diagnostics.serviceContainerAvailable = true;
          diagnostics.methodUsed = 'serviceContainer';

          const service = plugin.serviceContainer.getIfReady<T>(serviceName);
          if (service) {
            this.log('debug', `[ServiceAccessor] Successfully got ${displayName} via ServiceContainer`);
            diagnostics.serviceFound = true;
            diagnostics.duration = Date.now() - startTime;

            const successStatus = this.updateServiceStatus(serviceName, true, undefined);
            return this.createResult<T>(true, service, undefined, successStatus, diagnostics);
          }
        }

        // Try async getService method
        if (plugin.getService) {
          this.log('debug', `[ServiceAccessor] Trying async getService for ${displayName}`);
          diagnostics.methodUsed = diagnostics.methodUsed ? `${diagnostics.methodUsed}+async` : 'async';

          try {
            const service = await this.withTimeout(plugin.getService<T>(serviceName), this.config.timeoutMs);
            if (service) {
              this.log('debug', `[ServiceAccessor] Successfully got ${displayName} via async method`);
              diagnostics.serviceFound = true;
              diagnostics.duration = Date.now() - startTime;

              const successStatus = this.updateServiceStatus(serviceName, true, undefined);
              return this.createResult<T>(true, service, undefined, successStatus, diagnostics);
            }
          } catch (asyncError) {
            this.log('warn', `[ServiceAccessor] Async service access failed for ${displayName}:`, asyncError);
            lastError = getErrorMessage(asyncError);
          }
        }

        // Try direct services access (fallback)
        if (plugin.services && plugin.services[serviceName]) {
          this.log('debug', `[ServiceAccessor] Trying direct services access for ${displayName}`);
          diagnostics.methodUsed = diagnostics.methodUsed ? `${diagnostics.methodUsed}+direct` : 'direct';

          const service = plugin.services[serviceName] as T;
          if (service) {
            this.log('debug', `[ServiceAccessor] Successfully got ${displayName} via direct access`);
            diagnostics.serviceFound = true;
            diagnostics.duration = Date.now() - startTime;

            const successStatus = this.updateServiceStatus(serviceName, true, undefined);
            return this.createResult<T>(true, service, undefined, successStatus, diagnostics);
          }
        }

        lastError = `${displayName} not available through any access method`;
        this.log('warn', `[ServiceAccessor] ${lastError} (attempt ${attempts})`);

        if (attempts <= this.config.maxRetries) {
          await this.delay(this.config.retryDelayMs);
        }

      } catch (error) {
        lastError = getErrorMessage(error);
        this.log('error', `[ServiceAccessor] Error accessing ${displayName} (attempt ${attempts}):`, error);

        if (attempts <= this.config.maxRetries) {
          await this.delay(this.config.retryDelayMs);
        }
      }
    }

    // All attempts failed
    const failureStatus = this.updateServiceStatus(serviceName, false, lastError);
    const diagnostics = {
      pluginFound: false,
      serviceContainerAvailable: false,
      serviceFound: false,
      methodUsed: 'failed',
      duration: Date.now() - startTime
    };

    this.handleServiceFailure(displayName, lastError, attempts);
    return this.createResult<T>(false, null, lastError, failureStatus, diagnostics);
  }

  /**
   * Get service synchronously for immediate availability checks
   */
  getServiceSync<T>(serviceName: string, displayName: string): ServiceAccessResult<T> {
    const startTime = Date.now();

    try {
      const plugin = getNexusPlugin<NexusPluginBridge>(this.app);
      if (!plugin) {
        const knownIds = getAllPluginIds().join(`' or '`);
        const error = `Plugin '${knownIds}' not found`;
        const status = this.updateServiceStatus(serviceName, false, error);
        return this.createResult<T>(false, null, error, status, {
          pluginFound: false,
          serviceContainerAvailable: false,
          serviceFound: false,
          methodUsed: 'sync',
          duration: Date.now() - startTime
        });
      }

      const diagnostics = {
        pluginFound: true,
        serviceContainerAvailable: !!plugin.serviceContainer,
        serviceFound: false,
        methodUsed: 'sync',
        duration: 0
      };

      // Try ServiceContainer first
      if (plugin.serviceContainer) {
        const service = plugin.serviceContainer.getIfReady<T>(serviceName);
        if (service) {
          diagnostics.serviceFound = true;
          diagnostics.duration = Date.now() - startTime;
          const status = this.updateServiceStatus(serviceName, true, undefined);
          return this.createResult<T>(true, service, undefined, status, diagnostics);
        }
      }

      // Try direct access
      if (plugin.services && plugin.services[serviceName]) {
        const service = plugin.services[serviceName] as T;
        if (service) {
          diagnostics.serviceFound = true;
          diagnostics.methodUsed = 'direct';
          diagnostics.duration = Date.now() - startTime;
          const status = this.updateServiceStatus(serviceName, true, undefined);
          return this.createResult<T>(true, service, undefined, status, diagnostics);
        }
      }

      const error = `${displayName} not available synchronously`;
      const status = this.updateServiceStatus(serviceName, false, error);
      return this.createResult<T>(false, null, error, status, diagnostics);

    } catch (error) {
      const errorMessage = getErrorMessage(error);
      const status = this.updateServiceStatus(serviceName, false, errorMessage);
      return this.createResult<T>(false, null, errorMessage, status, {
        pluginFound: false,
        serviceContainerAvailable: false,
        serviceFound: false,
        methodUsed: 'sync-failed',
        duration: Date.now() - startTime
      });
    }
  }

  /**
   * Get or create service status tracking
   */
  private getServiceStatus(serviceName: string): ServiceStatus {
    if (!this.serviceStatuses.has(serviceName)) {
      this.serviceStatuses.set(serviceName, {
        available: false,
        initialized: false,
        lastCheck: 0,
        retryCount: 0
      });
    }
    return this.serviceStatuses.get(serviceName)!;
  }

  /**
   * Update service status tracking
   */
  private updateServiceStatus(serviceName: string, available: boolean, error?: string): ServiceStatus {
    const status = this.getServiceStatus(serviceName);

    status.available = available;
    status.initialized = available;
    status.lastError = error;
    status.lastCheck = Date.now();

    if (available) {
      status.retryCount = 0;
    } else {
      status.retryCount++;
    }

    this.serviceStatuses.set(serviceName, status);
    return status;
  }

  /**
   * Create standardized service access result
   */
  private createResult<T>(
    success: boolean,
    service: T | null,
    error?: string,
    status?: ServiceStatus,
    diagnostics?: any
  ): ServiceAccessResult<T> {
    return {
      success,
      service,
      error,
      status: status || {
        available: success,
        initialized: success,
        lastError: error,
        lastCheck: Date.now(),
        retryCount: 0
      },
      diagnostics
    };
  }

  /**
   * Handle service failure with appropriate logging
   */
  private handleServiceFailure(serviceName: string, error: string, attempts: number): void {
    const message = `${serviceName} unavailable after ${attempts} attempts: ${error}`;

    switch (this.config.fallbackBehavior) {
      case 'fail':
        this.log('error', `[ServiceAccessor] CRITICAL: ${message}`);
        break;
      case 'warn':
        this.log('warn', `[ServiceAccessor] WARNING: ${message} - operations will be limited`);
        break;
      case 'silent':
        this.log('debug', `[ServiceAccessor] ${message}`);
        break;
    }
  }

  /**
   * Timeout wrapper for promises
   */
  private withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
    return Promise.race([
      promise,
      new Promise<T>((_, reject) =>
        setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs)
      )
    ]);
  }

  /**
   * Delay utility for retry logic
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Configurable logging
   */
  private log(level: 'debug' | 'info' | 'warn' | 'error', message: string, ...args: any[]): void {
    const levels = { debug: 0, info: 1, warn: 2, error: 3 };
    const configLevel = levels[this.config.logLevel];
    const messageLevel = levels[level];

    if (messageLevel >= configLevel) {
      console[level](message, ...args);
    }
  }

  /**
   * Reset service status (for testing or manual intervention)
   */
  resetServiceStatus(serviceName?: string): void {
    if (serviceName) {
      this.serviceStatuses.delete(serviceName);
    } else {
      this.serviceStatuses.clear();
    }
  }

  /**
   * Get comprehensive service diagnostics
   */
  getDiagnostics(): Record<string, ServiceStatus> {
    const diagnostics: Record<string, ServiceStatus> = {};

    for (const [serviceName, status] of this.serviceStatuses.entries()) {
      diagnostics[serviceName] = { ...status };
    }

    return diagnostics;
  }
}

```

## agents/memoryManager/services/ValidationService.ts

```typescript
/**
 * Location: /src/agents/memoryManager/services/ValidationService.ts
 * Purpose: Consolidated validation service with delegated validators
 * Refactored to use extracted validators following SOLID principles
 *
 * Used by: All memory manager modes for service access and validation
 */

import { App } from 'obsidian';
import { MemoryService } from "./MemoryService";
import { WorkspaceService } from "../../../services/WorkspaceService";
import { StateValidator } from '../validators/StateValidator';
import { ValidationError } from '../validators/ValidationTypes';
import {
  ServiceAccessor,
  ServiceAccessResult,
  ServiceIntegrationConfig,
  ServiceStatus
} from './ServiceAccessor';

/**
 * Consolidated validation service for memory manager operations
 */
export class ValidationService {
  private static readonly DEFAULT_CONFIG: ServiceIntegrationConfig = {
    maxRetries: 3,
    retryDelayMs: 500,
    timeoutMs: 5000,
    enableHealthCheck: true,
    fallbackBehavior: 'warn',
    logLevel: 'warn'
  };

  private serviceAccessor: ServiceAccessor;

  constructor(app: App, config: Partial<ServiceIntegrationConfig> = {}) {
    const fullConfig = { ...ValidationService.DEFAULT_CONFIG, ...config };
    this.serviceAccessor = new ServiceAccessor(app, fullConfig);
  }

  /**
   * Get memory service with robust error handling and retry logic
   */
  async getMemoryService(): Promise<ServiceAccessResult<MemoryService>> {
    return this.serviceAccessor.getService<MemoryService>('memoryService', 'MemoryService');
  }

  /**
   * Get workspace service with robust error handling and retry logic
   */
  async getWorkspaceService(): Promise<ServiceAccessResult<WorkspaceService>> {
    return this.serviceAccessor.getService<WorkspaceService>('workspaceService', 'WorkspaceService');
  }

  /**
   * Get memory service synchronously (for immediate availability checks)
   */
  getMemoryServiceSync(): ServiceAccessResult<MemoryService> {
    return this.serviceAccessor.getServiceSync<MemoryService>('memoryService', 'MemoryService');
  }

  /**
   * Get workspace service synchronously (for immediate availability checks)
   */
  getWorkspaceServiceSync(): ServiceAccessResult<WorkspaceService> {
    return this.serviceAccessor.getServiceSync<WorkspaceService>('workspaceService', 'WorkspaceService');
  }

  /**
   * Validate state creation parameters
   */
  validateStateCreationParams(params: any): ValidationError[] {
    return StateValidator.validateCreationParams(params);
  }

  /**
   * Reset service status (for testing or manual intervention)
   */
  resetServiceStatus(serviceName?: string): void {
    this.serviceAccessor.resetServiceStatus(serviceName);
  }

  /**
   * Get comprehensive service diagnostics
   */
  getDiagnostics(): Record<string, ServiceStatus> {
    return this.serviceAccessor.getDiagnostics();
  }
}

/**
 * Default service integration instance factory
 * Creates a standard service integration with recommended settings
 */
export function createServiceIntegration(app: App, config?: Partial<ServiceIntegrationConfig>): ValidationService {
  return new ValidationService(app, {
    maxRetries: 2,
    retryDelayMs: 300,
    timeoutMs: 3000,
    enableHealthCheck: true,
    fallbackBehavior: 'warn',
    logLevel: 'warn',
    ...config
  });
}

// Re-export types for backward compatibility
export type {
  ServiceStatus,
  ServiceAccessResult,
  ServiceIntegrationConfig,
  ValidationError
};

```

## agents/memoryManager/services/WorkspaceContextBuilder.ts

```typescript
/**
 * Location: /src/agents/memoryManager/services/WorkspaceContextBuilder.ts
 * Purpose: Builds context information for workspaces
 *
 * This service handles building various context components for workspaces
 * including contextual briefings, workflows, key files, and preferences.
 *
 * Used by: LoadWorkspaceMode for building workspace context
 * Integrates with: MemoryService for recent activity data
 *
 * Responsibilities:
 * - Build contextual briefings with recent activity
 * - Extract and format workflow information
 * - Extract key files from workspace context
 * - Build preferences summary
 */

import { ProjectWorkspace } from '../../../database/types/workspace/WorkspaceTypes';

/** Trace item shape for context building */
interface TraceItem {
  timestamp?: number;
  content?: string;
  metadata?: {
    request?: {
      normalizedParams?: { context?: { memory?: string; sessionMemory?: string } };
      originalParams?: { context?: { memory?: string; sessionMemory?: string } };
    };
  };
}

/**
 * Interface for memory service methods used by this builder
 * Returns PaginatedResult with items array
 */
interface IMemoryServiceForContext {
  getMemoryTraces(workspaceId: string): Promise<{ items: TraceItem[]; total: number }>;
}

/**
 * Context briefing structure
 */
export interface ContextBriefing {
  name: string;
  description?: string;
  purpose?: string;
  rootFolder: string;
  recentActivity: string[];
}

/**
 * Service for building workspace context information
 * Implements Single Responsibility Principle - only handles context building
 */
export class WorkspaceContextBuilder {
  /**
   * Build a contextual briefing for the workspace
   * @param workspace The workspace
   * @param memoryService The memory service instance
   * @param limit Maximum number of recent activity items
   * @returns Context briefing object
   */
  async buildContextBriefing(
    workspace: ProjectWorkspace,
    memoryService: IMemoryServiceForContext | null,
    limit: number
  ): Promise<ContextBriefing> {
    let recentActivity: string[] = [];

    if (memoryService) {
      try {
        recentActivity = await this.getRecentActivity(workspace.id, memoryService, limit);
      } catch (error) {
        console.error('[WorkspaceContextBuilder] getRecentActivity failed:', error);
        recentActivity = [`Recent activity error: ${error instanceof Error ? error.message : String(error)}`];
      }
    } else {
      recentActivity = ['No recent activity'];
    }

    const finalActivity = recentActivity.length > 0 ? recentActivity : ['No recent activity'];

    return {
      name: workspace.name,
      description: workspace.description || undefined,
      purpose: workspace.context?.purpose || undefined,
      rootFolder: workspace.rootFolder,
      recentActivity: finalActivity
    };
  }

  /**
   * Build workflows array - one string per workflow
   * @param workspace The workspace
   * @returns Array of formatted workflow strings
   */
  buildWorkflows(workspace: ProjectWorkspace): string[] {
    if (!workspace.context?.workflows || workspace.context.workflows.length === 0) {
      return [];
    }

    return workspace.context.workflows.map(workflow => {
      return `**${workflow.name}** (${workflow.when}):\n${workflow.steps}`;
    });
  }

  /**
   * Extract key files into a flat structure
   * @param workspace The workspace
   * @returns Record of file names to file paths
   */
  extractKeyFiles(workspace: ProjectWorkspace): Record<string, string> {
    const keyFiles: Record<string, string> = {};

    if (workspace.context?.keyFiles) {
      // New format: simple array of file paths
      if (Array.isArray(workspace.context.keyFiles)) {
        workspace.context.keyFiles.forEach((filePath, index) => {
          // Extract filename without extension as key
          const fileName = filePath.split('/').pop()?.replace(/\.[^/.]+$/, '') || `file_${index}`;
          keyFiles[fileName] = filePath;
        });
      }
      // Legacy format: array of categorized files (for backward compatibility)
      else if (typeof workspace.context.keyFiles === 'object' && 'length' in workspace.context.keyFiles) {
        const legacyKeyFiles = workspace.context.keyFiles as Array<{ files?: Record<string, string> }>;
        legacyKeyFiles.forEach((category) => {
          if (category.files) {
            Object.entries(category.files).forEach(([name, path]) => {
              keyFiles[name] = path;
            });
          }
        });
      }
    }

    return keyFiles;
  }

  /**
   * Build preferences summary
   * @param workspace The workspace
   * @returns Preferences summary string
   */
  buildPreferences(workspace: ProjectWorkspace): string {
    // Preferences is now a string, not an array
    if (workspace.context?.preferences && workspace.context.preferences.trim()) {
      return workspace.context.preferences;
    }

    // Legacy support for userPreferences (if still exists)
    if (workspace.preferences?.userPreferences && Array.isArray(workspace.preferences.userPreferences)) {
      return workspace.preferences.userPreferences.join('. ') + '.';
    }

    return 'No preferences set';
  }

  /**
   * Get recent activity from memory traces
   * Extracts memory (new format) or sessionMemory (legacy) from trace metadata
   * @param workspaceId The workspace ID
   * @param memoryService The memory service instance
   * @param limit Maximum number of activity items
   * @returns Array of recent activity strings
   */
  private async getRecentActivity(
    workspaceId: string,
    memoryService: IMemoryServiceForContext,
    limit: number
  ): Promise<string[]> {
    try {
      // Get all traces from workspace (across all sessions)
      const tracesResult = await memoryService.getMemoryTraces(workspaceId);
      const traces = tracesResult.items || [];

      if (traces.length === 0) {
        return ['No recent activity'];
      }

      // Sort by timestamp descending (newest first)
      traces.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));

      // Extract memory (new format) or sessionMemory (legacy) from trace metadata
      const activities: string[] = [];
      for (let i = 0; i < Math.min(limit, traces.length); i++) {
        const trace = traces[i];

        // Try new format first (memory), then fall back to legacy (sessionMemory)
        const memoryValue =
          trace.metadata?.request?.normalizedParams?.context?.memory ||
          trace.metadata?.request?.originalParams?.context?.memory ||
          trace.metadata?.request?.normalizedParams?.context?.sessionMemory ||
          trace.metadata?.request?.originalParams?.context?.sessionMemory;

        if (memoryValue && memoryValue.trim()) {
          activities.push(memoryValue);
        } else {
          // Fallback to trace content if no memory field
          activities.push(trace.content || 'Unknown activity');
        }
      }

      return activities.length > 0 ? activities : ['No recent activity'];
    } catch (error) {
      return ['Recent activity unavailable'];
    }
  }
}

```

## agents/memoryManager/services/WorkspaceDataFetcher.ts

```typescript
/**
 * Location: /src/agents/memoryManager/services/WorkspaceDataFetcher.ts
 * Purpose: Fetches sessions and states data for workspaces with pagination
 *
 * This service handles fetching and filtering workspace-related data
 * including sessions and states from the memory service.
 *
 * Used by: LoadWorkspaceMode for retrieving workspace sessions and states
 * Integrates with: MemoryService for data access
 *
 * Responsibilities:
 * - Fetch workspace sessions with defensive validation and pagination
 * - Fetch workspace states with defensive validation and pagination
 * - Filter data to ensure workspace isolation
 */

import { PaginatedResult, PaginationParams, createEmptyPaginatedResult } from '../../../types/pagination/PaginationTypes';

/**
 * Session summary returned from fetch operations
 */
export interface SessionSummary {
  id: string;
  name: string;
  description?: string;
  created: number;
  workspaceId?: string;
}

/**
 * State summary returned from fetch operations
 */
export interface StateSummary {
  id: string;
  name: string;
  description?: string;
  sessionId: string;
  created: number;
  tags?: string[];
  workspaceId?: string;
}

/**
 * Service for fetching workspace sessions and states
 * Implements Single Responsibility Principle - only handles data fetching
 */
export class WorkspaceDataFetcher {
  /**
   * Fetch sessions for a workspace with defensive filtering and pagination
   * @param workspaceId The workspace ID
   * @param memoryService The memory service instance
   * @param options Optional pagination parameters
   * @returns Paginated result of session summaries
   */
  async fetchWorkspaceSessions(
    workspaceId: string,
    memoryService: any,
    options?: PaginationParams
  ): Promise<PaginatedResult<SessionSummary>> {
    try {
      if (!memoryService) {
        return createEmptyPaginatedResult<SessionSummary>(0, options?.pageSize ?? 10);
      }

      // Validate workspace ID
      if (!workspaceId || workspaceId === 'unknown') {
        return createEmptyPaginatedResult<SessionSummary>(0, options?.pageSize ?? 10);
      }

      // getSessions returns PaginatedResult<WorkspaceSession>
      const sessionsResult = await memoryService.getSessions(workspaceId);
      const sessions = sessionsResult.items || [];

      // Defensive validation: ensure all sessions belong to workspace
      const validSessions = sessions.filter((session: any) =>
        session.workspaceId === workspaceId
      );

      if (validSessions.length !== sessions.length) {
        console.error(
          `[WorkspaceDataFetcher] Database filtering failed! Retrieved ${sessions.length} sessions, ` +
          `only ${validSessions.length} belong to workspace ${workspaceId}`
        );
      }

      // Map to session summaries
      const sessionSummaries = validSessions.map((session: any) => ({
        id: session.id,
        name: session.name,
        description: session.description,
        created: session.startTime,
        workspaceId: session.workspaceId // Include for validation
      }));

      // Apply manual pagination since getSessions doesn't support it yet
      const page = options?.page ?? 0;
      const pageSize = options?.pageSize ?? sessionSummaries.length;
      const start = page * pageSize;
      const end = start + pageSize;
      const paginatedItems = sessionSummaries.slice(start, end);
      const totalPages = Math.ceil(sessionSummaries.length / pageSize);

      return {
        items: paginatedItems,
        page,
        pageSize,
        totalItems: sessionSummaries.length,
        totalPages,
        hasNextPage: page < totalPages - 1,
        hasPreviousPage: page > 0
      };

    } catch (error) {
      console.error('[WorkspaceDataFetcher] Failed to fetch workspace sessions:', error);
      return createEmptyPaginatedResult<SessionSummary>(0, options?.pageSize ?? 10);
    }
  }

  /**
   * Fetch states for a workspace with defensive filtering and pagination
   * @param workspaceId The workspace ID
   * @param memoryService The memory service instance
   * @param options Optional pagination parameters
   * @returns Paginated result of state summaries
   */
  async fetchWorkspaceStates(
    workspaceId: string,
    memoryService: any,
    options?: PaginationParams
  ): Promise<PaginatedResult<StateSummary>> {
    try {
      if (!memoryService) {
        return createEmptyPaginatedResult<StateSummary>(0, options?.pageSize ?? 10);
      }

      // Validate workspace ID
      if (!workspaceId || workspaceId === 'unknown') {
        return createEmptyPaginatedResult<StateSummary>(0, options?.pageSize ?? 10);
      }

      // getStates returns PaginatedResult - pass pagination options
      const statesResult = await memoryService.getStates(workspaceId, undefined, options);

      // Extract items from paginated result
      const states = statesResult.items;

      // Defensive validation: ensure all states belong to workspace
      const validStates = states.filter((state: any) =>
        state.state?.workspaceId === workspaceId || state.workspaceId === workspaceId
      );

      if (validStates.length !== states.length) {
        console.error(
          `[WorkspaceDataFetcher] Filtered ${states.length - validStates.length} ` +
          `cross-workspace states`
        );
      }

      // Map to state summaries
      const stateSummaries = validStates.map((state: any) => ({
        id: state.id,
        name: state.name,
        description: state.description || state.state?.description,
        sessionId: state.sessionId || state.state?.sessionId,
        created: state.created || state.timestamp,
        tags: state.state?.metadata?.tags || [],
        workspaceId: state.state?.workspaceId || state.workspaceId // Include for validation
      }));

      // Return with pagination metadata from the original result
      return {
        items: stateSummaries,
        page: statesResult.page,
        pageSize: statesResult.pageSize,
        totalItems: statesResult.totalItems,
        totalPages: statesResult.totalPages,
        hasNextPage: statesResult.hasNextPage,
        hasPreviousPage: statesResult.hasPreviousPage
      };

    } catch (error) {
      console.error('[WorkspaceDataFetcher] Failed to fetch workspace states:', error);
      return createEmptyPaginatedResult<StateSummary>(0, options?.pageSize ?? 10);
    }
  }
}

```

## agents/memoryManager/services/WorkspaceFileCollector.ts

```typescript
/**
 * Location: /src/agents/memoryManager/services/WorkspaceFileCollector.ts
 * Purpose: Collects and organizes workspace files
 *
 * This service handles building workspace file structures and collecting
 * recently modified files from the cache.
 *
 * Used by: LoadWorkspaceMode for file structure and recent files
 * Integrates with: Obsidian Vault API and CacheManager
 *
 * Responsibilities:
 * - Build workspace path structure with all files
 * - Collect all files recursively from folders
 * - Get recently modified files in workspace
 */

import { App, TFolder, TAbstractFile, TFile } from 'obsidian';

/**
 * Interface for workspace data
 */
interface IWorkspaceData {
  rootFolder: string;
}

/**
 * Interface for cache manager
 */
interface ICacheManager {
  getRecentFiles(limit: number, folder: string): Array<{ path: string; modified: number }> | null;
}

/**
 * Workspace path structure with files list
 */
export interface WorkspacePath {
  folder: string;
  files: string[];
}

/**
 * Result of workspace path building
 */
export interface WorkspacePathResult {
  path: WorkspacePath;
  failed: boolean;
}

/**
 * Recent file information
 */
export interface RecentFileInfo {
  path: string;
  modified: number;
}

/**
 * Service for collecting and organizing workspace files
 * Implements Single Responsibility Principle - only handles file operations
 */
export class WorkspaceFileCollector {
  /**
   * Build workspace path with folder path and flat files list
   * @param rootFolder The workspace root folder path
   * @param app The Obsidian app instance
   * @returns Workspace path result with files list
   */
  async buildWorkspacePath(
    rootFolder: string,
    app: App
  ): Promise<WorkspacePathResult> {
    try {
      const folder = app.vault.getAbstractFileByPath(rootFolder);

      if (!folder || !(folder instanceof TFolder)) {
        return { path: { folder: rootFolder, files: [] }, failed: true };
      }

      // Collect all files recursively with relative paths
      const files = this.collectAllFiles(folder, rootFolder);

      return {
        path: {
          folder: rootFolder,
          files: files
        },
        failed: false
      };

    } catch (error) {
      return { path: { folder: rootFolder, files: [] }, failed: true };
    }
  }

  /**
   * Collect all files recursively as flat list with relative paths
   * @param folder The folder to collect from
   * @param basePath The base path for relative path calculation
   * @returns Array of relative file paths
   */
  collectAllFiles(folder: TFolder, basePath: string): string[] {
    const files: string[] = [];

    if (!folder.children) {
      return files;
    }

    for (const child of folder.children) {
      if (child instanceof TFolder) {
        // It's a folder - recurse into it
        const subFiles = this.collectAllFiles(child, basePath);
        files.push(...subFiles);
      } else {
        // It's a file - add with relative path from base
        const relativePath = child.path.replace(basePath + '/', '');
        files.push(relativePath);
      }
    }

    return files.sort();
  }

  /**
   * Get recently modified files in workspace folder
   * @param workspace The workspace object
   * @param cacheManager The cache manager instance
   * @returns Array of recent file info
   */
  async getRecentFilesInWorkspace(
    workspace: IWorkspaceData,
    cacheManager: ICacheManager | null
  ): Promise<RecentFileInfo[]> {
    try {
      if (!cacheManager) {
        return [];
      }

      const recentFiles = cacheManager.getRecentFiles(5, workspace.rootFolder);

      if (!recentFiles || recentFiles.length === 0) {
        return [];
      }

      // Map IndexedFile[] to simple {path, modified} objects
      return recentFiles.map((file) => ({
        path: file.path,
        modified: file.modified
      }));

    } catch (error) {
      return [];
    }
  }
}

```

## agents/memoryManager/services/WorkspacePromptResolver.ts

```typescript
/**
 * Location: /src/agents/memoryManager/services/WorkspacePromptResolver.ts
 * Purpose: Resolves custom prompt information from workspaces
 *
 * This service handles looking up custom prompt data associated with workspaces,
 * supporting both ID-based and unified name/ID lookup with backward
 * compatibility for legacy workspace structures.
 *
 * Used by: LoadWorkspaceMode for resolving workspace prompts
 * Integrates with: CustomPromptStorageService via AgentManager
 *
 * Responsibilities:
 * - Resolve workspace prompt from dedicatedAgent or legacy agents array
 * - Fetch prompt data by ID (for when ID is known)
 * - Fetch prompt data by name or ID (unified lookup)
 */

import type { App } from 'obsidian';
import { ProjectWorkspace, WorkspaceContext } from '../../../database/types/workspace/WorkspaceTypes';
import { getNexusPlugin } from '../../../utils/pluginLocator';
import type { AgentManager } from '../../../services/AgentManager';
import type { PromptManagerAgent } from '../../promptManager/promptManager';
import type { CustomPromptStorageService } from '../../promptManager/services/CustomPromptStorageService';

/**
 * Prompt information returned from resolution operations
 */
export interface WorkspacePromptInfo {
  id: string;
  name: string;
  systemPrompt: string;
}

/**
 * Legacy workspace context structure for backward compatibility
 * Extends the current WorkspaceContext with deprecated fields
 */
interface LegacyWorkspaceContext extends WorkspaceContext {
  agents?: Array<{
    name: string;
    [key: string]: unknown;
  }>;
}

/**
 * Plugin interface with agentManager property
 */
interface NexusPluginWithAgentManager {
  agentManager: AgentManager;
}

/**
 * PromptManager agent interface with storage service
 */
interface PromptManagerWithStorage {
  storageService: CustomPromptStorageService;
}

/**
 * Service for resolving workspace prompts (custom prompts associated with workspaces)
 * Implements Single Responsibility Principle - only handles prompt resolution
 */
export class WorkspacePromptResolver {
  /**
   * Fetch workspace prompt data if available
   * Handles both new dedicatedAgent structure and legacy agents array
   * @param workspace The workspace to fetch prompt from
   * @param app The Obsidian app instance
   * @returns Prompt info or null if not available
   */
  async fetchWorkspacePrompt(
    workspace: ProjectWorkspace,
    app: App
  ): Promise<WorkspacePromptInfo | null> {
    try {
      // Check if workspace has a dedicated prompt (stored as dedicatedAgent for backward compat)
      if (!workspace.context?.dedicatedAgent) {
        // Fall back to legacy agents array for backward compatibility
        const legacyContext = workspace.context as LegacyWorkspaceContext | undefined;
        const legacyAgents = legacyContext?.agents;
        if (legacyAgents && Array.isArray(legacyAgents) && legacyAgents.length > 0) {
          const legacyPromptRef = legacyAgents[0];
          if (legacyPromptRef && legacyPromptRef.name) {
            return await this.fetchPromptByNameOrId(legacyPromptRef.name, app);
          }
        }
        return null;
      }

      // Use the dedicated prompt structure - use unified lookup
      const { agentId } = workspace.context.dedicatedAgent;
      return await this.fetchPromptByNameOrId(agentId, app);

    } catch (error) {
      return null;
    }
  }

  /**
   * Fetch prompt by name or ID (unified lookup)
   * Tries ID first (more specific), then falls back to name
   * @param identifier The prompt name or ID
   * @param app The Obsidian app instance
   * @returns Prompt info or null if not found
   */
  async fetchPromptByNameOrId(
    identifier: string,
    app: App
  ): Promise<WorkspacePromptInfo | null> {
    try {
      // Get CustomPromptStorageService through plugin's agentManager
      const plugin = getNexusPlugin(app);
      if (!plugin || !this.hasAgentManager(plugin)) {
        return null;
      }

      const promptManagerAgent = plugin.agentManager.getAgent('promptManager');
      if (!this.isPromptManagerAgent(promptManagerAgent)) {
        return null;
      }

      // Use unified lookup that tries ID first, then name
      const prompt = promptManagerAgent.storageService.getPromptByNameOrId(identifier);
      if (!prompt) {
        return null;
      }

      return {
        id: prompt.id,
        name: prompt.name,
        systemPrompt: prompt.prompt
      };

    } catch (error) {
      return null;
    }
  }

  /**
   * Type guard to check if plugin has agentManager property
   */
  private hasAgentManager(plugin: unknown): plugin is NexusPluginWithAgentManager {
    return typeof plugin === 'object' && plugin !== null && 'agentManager' in plugin;
  }

  /**
   * Type guard to check if agent is PromptManagerAgent with storageService
   */
  private isPromptManagerAgent(agent: unknown): agent is PromptManagerWithStorage {
    return typeof agent === 'object' && agent !== null && 'storageService' in agent;
  }
}

```

## agents/memoryManager/services/WorkspaceService.ts.backup

```text
import { Plugin } from 'obsidian';
import { ProjectWorkspace, ItemStatus } from '../../../database/workspace-types';
import { v4 as uuidv4 } from 'uuid';

export const GLOBAL_WORKSPACE_ID = 'global-workspace';

/**
 * WorkspaceService using direct Obsidian data storage
 */
export class WorkspaceService {
  private plugin: Plugin;
  private readonly STORAGE_KEY = 'workspaces';

  constructor(plugin: Plugin) {
    this.plugin = plugin;
  }

  /**
   * Get all workspaces
   */
  async getAllWorkspaces(): Promise<ProjectWorkspace[]> {
    const data = await this.plugin.loadData();
    return data?.[this.STORAGE_KEY] || [];
  }

  /**
   * Get workspace by ID
   */
  async getWorkspace(id: string): Promise<ProjectWorkspace | undefined> {
    const workspaces = await this.getAllWorkspaces();
    return workspaces.find(w => w.id === id);
  }

  /**
   * Create a new workspace
   */
  async createWorkspace(workspaceData: Omit<ProjectWorkspace, 'id'> | string, description?: string): Promise<ProjectWorkspace> {
    let newWorkspace: ProjectWorkspace;

    if (typeof workspaceData === 'string') {
      // Legacy interface - create from name and description
      newWorkspace = {
        id: uuidv4(),
        name: workspaceData,
        description: description || '',
        rootFolder: '/',
        created: Date.now(),
        lastAccessed: Date.now(),
        activityHistory: [],
        checkpoints: [],
        completionStatus: {},
        associatedNotes: []
      };
    } else {
      // New interface - create from workspace object
      newWorkspace = {
        id: uuidv4(),
        ...workspaceData
      };
    }

    const workspaces = await this.getAllWorkspaces();
    workspaces.push(newWorkspace);
    await this.saveWorkspaces(workspaces);

    return newWorkspace;
  }

  /**
   * Update workspace
   */
  async updateWorkspace(id: string, updates: Partial<ProjectWorkspace>): Promise<void> {
    const workspaces = await this.getAllWorkspaces();
    const index = workspaces.findIndex(w => w.id === id);

    if (index === -1) {
      throw new Error(`Workspace ${id} not found`);
    }

    workspaces[index] = { ...workspaces[index], ...updates, lastAccessed: Date.now() };
    await this.saveWorkspaces(workspaces);
  }

  /**
   * Delete workspace
   */
  async deleteWorkspace(id: string): Promise<void> {
    const workspaces = await this.getAllWorkspaces();
    const filtered = workspaces.filter(w => w.id !== id);
    await this.saveWorkspaces(filtered);
  }

  /**
   * Get all workspaces (alias for getAllWorkspaces for backward compatibility)
   */
  async getWorkspaces(): Promise<ProjectWorkspace[]> {
    return this.getAllWorkspaces();
  }

  /**
   * Add activity to workspace
   */
  async addActivity(workspaceId: string, activity: any): Promise<void> {
    const workspace = await this.getWorkspace(workspaceId);
    if (workspace) {
      if (!workspace.activityHistory) {
        workspace.activityHistory = [];
      }
      workspace.activityHistory.push(activity);
      await this.updateWorkspace(workspaceId, workspace);
    }
  }

  /**
   * Save workspaces to storage
   */
  private async saveWorkspaces(workspaces: ProjectWorkspace[]): Promise<void> {
    const data = await this.plugin.loadData() || {};
    data[this.STORAGE_KEY] = workspaces;
    await this.plugin.saveData(data);
  }
}
```

## agents/memoryManager/tools/index.ts

```typescript
// State tools (3 tools: create, list, load)
export { CreateStateTool } from './states/createState';
export { ListStatesTool } from './states/listStates';
export { LoadStateTool } from './states/loadState';

// Workspace tools (5 tools: create, list, load, update, archive)
export * from './workspaces';

```

## agents/memoryManager/tools/states/createState.ts

```typescript
/**
 * Location: /src/agents/memoryManager/modes/states/CreateStateMode.ts
 * Purpose: Consolidated state creation mode combining all create functionality from original state files
 * 
 * This file consolidates:
 * - Original createStateMode.ts functionality
 * - StateCreator service logic
 * - Parameter validation logic
 * - Context building and tracing logic
 * 
 * Used by: MemoryManager agent for state creation operations
 */

import { App } from 'obsidian';
import { BaseTool } from '../../../baseTool';
import { MemoryManagerAgent } from '../../memoryManager'
import { CreateStateParams, StateResult } from '../../types';
import { createErrorMessage } from '../../../../utils/errorUtils';
import { extractContextFromParams } from '../../../../utils/contextUtils';
import { MemoryService } from "../../services/MemoryService";
import { WorkspaceService, GLOBAL_WORKSPACE_ID } from '../../../../services/WorkspaceService';
import { createServiceIntegration, ValidationError } from '../../services/ValidationService';
import { SchemaBuilder, SchemaType } from '../../../../utils/schemas/SchemaBuilder';

/**
 * Consolidated CreateStateMode - combines all state creation functionality
 */
export class CreateStateTool extends BaseTool<CreateStateParams, StateResult> {
    private app: App;
    private serviceIntegration: ReturnType<typeof createServiceIntegration>;
    private schemaBuilder: SchemaBuilder;

    constructor(private agent: MemoryManagerAgent) {
        super(
            'createState',
            'Create State',
            'Create a state with restoration context for later resumption',
            '2.0.0'
        );

        this.app = agent.getApp();
        this.serviceIntegration = createServiceIntegration(this.app, {
            logLevel: 'warn',
            maxRetries: 3,
            fallbackBehavior: 'warn'
        });
        this.schemaBuilder = new SchemaBuilder();
    }

    /**
     * Execute state creation with consolidated logic
     */
    async execute(params: CreateStateParams): Promise<StateResult> {
        const startTime = Date.now();
        
        try {
            // Phase 1: Get services and validate
            const servicesResult = await this.getServices();
            if (!servicesResult.success) {
                return this.prepareResult(false, undefined, servicesResult.error);
            }

            const { memoryService, workspaceService } = servicesResult;
            
            // Ensure services are available
            if (!memoryService || !workspaceService) {
                return this.prepareResult(false, undefined, 'Required services not available');
            }

            // Phase 2: Validate parameters (consolidated validation logic)
            const validationErrors = this.validateParameters(params);
            if (validationErrors.length > 0) {
                const errorMessages = validationErrors.map(e => `${e.field}: ${e.requirement}`).join('\n');
                return this.prepareResult(
                    false,
                    undefined,
                    `Missing required parameters:\n${errorMessages}`,
                    extractContextFromParams(params)
                );
            }

            // Phase 3: Resolve workspace context (consolidated workspace resolution)
            const workspaceResult = await this.resolveWorkspaceContext(params, workspaceService);
            if (!workspaceResult.success) {
                return this.prepareResult(false, undefined, workspaceResult.error, extractContextFromParams(params));
            }

            // Phase 3.5: Check state name uniqueness (states are workspace-scoped using '_workspace' as sessionId)
            const existingStates = await memoryService.getStates(workspaceResult.data.workspaceId, '_workspace');
            const nameExists = existingStates.items.some(state => state.name === params.name);
            if (nameExists) {
                return this.prepareResult(
                    false,
                    undefined,
                    `State "${params.name}" already exists. States are immutable - use a unique name like "${params.name}-v2" or "${params.name}-${new Date().toISOString().split('T')[0]}".`,
                    extractContextFromParams(params)
                );
            }

            // Phase 4: Build state context (consolidated from StateCreator logic)
            const contextResult = await this.buildStateContext(params, workspaceResult.data, workspaceService);

            // Phase 5: Create and persist state (consolidated persistence logic)
            const persistResult = await this.createAndPersistState(params, workspaceResult.data, contextResult, memoryService);
            if (!persistResult.success) {
                return this.prepareResult(false, undefined, persistResult.error, extractContextFromParams(params));
            }
            
            // Ensure stateId is available
            if (!persistResult.stateId) {
                return this.prepareResult(false, undefined, 'State creation failed - no state ID returned', extractContextFromParams(params));
            }

            // Extract workspaceId for verification (use '_workspace' as sessionId)
            const workspaceId = workspaceResult.data.workspaceId;

            // Phase 6: Verify persistence (data integrity check)
            const verificationResult = await this.verifyStatePersistence(workspaceId, '_workspace', persistResult.stateId, memoryService);
            if (!verificationResult.success) {
                // Rollback if verification fails
                await this.rollbackState(workspaceId, '_workspace', persistResult.stateId, memoryService);
                return this.prepareResult(false, undefined, `State verification failed: ${verificationResult.error}`, extractContextFromParams(params));
            }

            // Phase 7: Prepare final result
            return this.prepareFinalResult(
                persistResult.stateId,
                persistResult.savedState,
                contextResult,
                workspaceResult.data,
                startTime,
                params
            );

        } catch (error) {
            const errorMsg = createErrorMessage('Error creating state: ', error);
            return this.prepareResult(
                false, 
                {
                    error: errorMsg,
                    parameterHints: 'ðŸ’¡ Check that all required parameters are correctly formatted:\n- name: string\n- conversationContext: string (what was happening)\n- activeTask: string (what you were working on)\n- activeFiles: array of file paths\n- nextSteps: array of action items',
                    suggestions: [
                        'Verify all required fields are provided',
                        'Ensure activeFiles is an array: ["file1.md", "file2.md"]',
                        'Ensure nextSteps is an array: ["Step 1", "Step 2", "Step 3"]',
                        'Check that workspace context is available',
                        'Verify memory service is initialized'
                    ],
                    providedParams: params
                }, 
                errorMsg,
                extractContextFromParams(params)
            );
        }
    }

    /**
     * Get required services with validation
     */
    private async getServices(): Promise<{success: boolean; error?: string; memoryService?: MemoryService; workspaceService?: WorkspaceService}> {
        const [memoryResult, workspaceResult] = await Promise.all([
            this.serviceIntegration.getMemoryService(),
            this.serviceIntegration.getWorkspaceService()
        ]);

        if (!memoryResult.success || !memoryResult.service) {
            return { success: false, error: `Memory service not available: ${memoryResult.error}` };
        }

        if (!workspaceResult.success || !workspaceResult.service) {
            return { success: false, error: `Workspace service not available: ${workspaceResult.error}` };
        }

        return { 
            success: true, 
            memoryService: memoryResult.service, 
            workspaceService: workspaceResult.service 
        };
    }

    /**
     * Validate state creation parameters (consolidated validation logic)
     */
    private validateParameters(params: CreateStateParams): ValidationError[] {
        const errors: ValidationError[] = [];

        // Required fields validation
        if (!params.name || typeof params.name !== 'string' || params.name.trim() === '') {
            errors.push({
                field: 'name',
                value: params.name,
                requirement: 'Name is required and must be a non-empty string'
            });
        }

        if (!params.conversationContext || typeof params.conversationContext !== 'string' || params.conversationContext.trim() === '') {
            errors.push({
                field: 'conversationContext',
                value: params.conversationContext,
                requirement: 'Conversation context is required and must be a non-empty string'
            });
        }

        if (!params.activeTask || typeof params.activeTask !== 'string' || params.activeTask.trim() === '') {
            errors.push({
                field: 'activeTask',
                value: params.activeTask,
                requirement: 'Active task is required and must be a non-empty string'
            });
        }

        if (!Array.isArray(params.activeFiles)) {
            errors.push({
                field: 'activeFiles',
                value: params.activeFiles,
                requirement: 'Active files is required and must be an array'
            });
        }

        if (!Array.isArray(params.nextSteps)) {
            errors.push({
                field: 'nextSteps',
                value: params.nextSteps,
                requirement: 'Next steps is required and must be an array'
            });
        }

        return errors;
    }

    /**
     * Resolve workspace context (consolidated workspace resolution)
     */
    private async resolveWorkspaceContext(params: CreateStateParams, workspaceService: WorkspaceService): Promise<{success: boolean; error?: string; data?: any}> {
        try {
            // Get workspace from inherited context or use global workspace
            const inheritedContext = this.getInheritedWorkspaceContext(params);
            let workspaceId: string;
            
            if (inheritedContext?.workspaceId) {
                workspaceId = inheritedContext.workspaceId;
            } else {
                workspaceId = GLOBAL_WORKSPACE_ID;
            }

            // Get the workspace to capture its current context
            const workspace = await workspaceService.getWorkspace(workspaceId);
            if (!workspace) {
                return { success: false, error: `Workspace not found: ${workspaceId}` };
            }

            return { success: true, data: { workspaceId, workspace } };

        } catch (error) {
            return { success: false, error: createErrorMessage('Error resolving workspace: ', error) };
        }
    }

    /**
     * Build state context (consolidated from StateCreator logic)
     */
    private async buildStateContext(params: CreateStateParams, workspaceData: any, workspaceService: WorkspaceService): Promise<any> {
        const { workspace } = workspaceData;

        // Extract or create workspace context
        let currentWorkspaceContext;
        if (workspace.context) {
            currentWorkspaceContext = workspace.context;
        } else {
            // Create basic context for legacy workspace
            currentWorkspaceContext = {
                purpose: workspace.description || `Work in ${workspace.name}`,
                workflows: [],
                keyFiles: [],
                preferences: ''
            };
        }

        // Build the state context from LLM input (no reasoning field)
        const context = {
            workspaceContext: currentWorkspaceContext,
            conversationContext: params.conversationContext,
            activeTask: params.activeTask,
            activeFiles: params.activeFiles,
            nextSteps: params.nextSteps
        };

        return {
            context,
            workspaceContext: currentWorkspaceContext
        };
    }

    /**
     * Create and persist state (consolidated persistence logic)
     */
    private async createAndPersistState(
        params: CreateStateParams,
        workspaceData: any,
        contextResult: any,
        memoryService: MemoryService
    ): Promise<{success: boolean; error?: string; stateId?: string; savedState?: any}> {
        try {
            const { workspaceId, workspace } = workspaceData;
            const { context } = contextResult;
            const now = Date.now();

            // Build WorkspaceState for storage following the architecture design
            // This matches the WorkspaceState interface which extends State
            // Use '_workspace' as sessionId for workspace-scoped states
            const workspaceState = {
                // Core State fields (required)
                id: `state_${now}_${Math.random().toString(36).substring(2, 11)}`,
                name: params.name,
                workspaceId: workspaceId,
                created: now,
                context: context,  // The inner StateContext with activeTask, activeFiles, etc.

                // Additional WorkspaceState fields
                sessionId: '_workspace',  // All states are workspace-scoped
                timestamp: now,
                state: {
                    workspace,
                    recentTraces: [], // Could be populated from current session
                    contextFiles: params.activeFiles || [],
                    metadata: {
                        createdBy: 'CreateStateMode',
                        version: '2.0.0',
                        creationMethod: 'manual',
                        tags: params.tags || []
                    }
                }
            };

            // Persist to MemoryService - use '_workspace' as sessionId
            const stateId = await memoryService.saveState(
                workspaceId,
                '_workspace',
                workspaceState,  // Pass the full object
                workspaceState.name
            );

            return { success: true, stateId, savedState: workspaceState };

        } catch (error) {
            return { success: false, error: createErrorMessage('Error persisting state: ', error) };
        }
    }

    /**
     * Verify that a state was properly persisted
     */
    private async verifyStatePersistence(workspaceId: string, sessionId: string, stateId: string, memoryService: MemoryService): Promise<{success: boolean; error?: string}> {
        try {
            // getState returns WorkspaceState which has a context property
            const retrieved = await memoryService.getState(workspaceId, sessionId, stateId);
            if (!retrieved) {
                return { success: false, error: 'State not found after creation' };
            }

            // Verify essential context fields
            if (!retrieved.context || !retrieved.context.activeTask) {
                return { success: false, error: 'State data incomplete after persistence - missing context.activeTask' };
            }

            if (!retrieved.workspaceId || !retrieved.name) {
                return { success: false, error: 'Critical state fields missing after persistence - missing workspaceId or name' };
            }

            return { success: true };
        } catch (error) {
            return { success: false, error: createErrorMessage('Verification failed: ', error) };
        }
    }

    /**
     * Rollback a state creation if verification fails
     */
    private async rollbackState(workspaceId: string, sessionId: string, stateId: string, memoryService: MemoryService): Promise<void> {
        try {
            await memoryService.deleteState(workspaceId, sessionId, stateId);
            // State rolled back silently - error will be reported through main flow
        } catch (error) {
            // Rollback failure is not critical - verification failure is the primary issue
            // Don't log or throw here to avoid noise
        }
    }

    /**
     * Prepare final result - simplified to just return success
     */
    private prepareFinalResult(
        stateId: string,
        savedState: any,
        contextResult: any,
        workspaceData: any,
        startTime: number,
        params: CreateStateParams
    ): StateResult {
        // Success - LLM already knows the state details it passed
        return this.prepareResult(true);
    }

    /**
     * Schema methods using consolidated logic
     */
    getParameterSchema(): any {
        const toolSchema = {
            type: 'object',
            title: 'Create State',
            description: 'Save current work context for later resumption. States are immutable snapshots.',
            properties: {
                name: {
                    type: 'string',
                    description: 'Short descriptive title for this save point'
                },
                conversationContext: {
                    type: 'string',
                    description: 'Detailed markdown summary enabling seamless resumption. Structure with headings:\n\n## Original Request\nWhat the user asked for and their goal\n\n## Key Decisions Made\n- Decision and reasoning\n- Decision and reasoning\n\n## Important Context\nBackground info, constraints, or discoveries from the conversation\n\n## Current Status\nWhat is complete, what is in progress, any blockers'
                },
                activeTask: {
                    type: 'string',
                    description: 'The specific task in progress when saving'
                },
                activeFiles: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'File paths being edited or referenced'
                },
                nextSteps: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Specific action items to resume work, in priority order'
                },
                tags: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Optional tags for categorization'
                }
            },
            required: ['name', 'conversationContext', 'activeTask', 'activeFiles', 'nextSteps'],
            additionalProperties: false
        };
        
        return this.getMergedSchema(toolSchema);
    }

    getResultSchema(): any {
        return this.schemaBuilder.buildResultSchema(SchemaType.State, {
            mode: 'createState'
        });
    }
}
```

## agents/memoryManager/tools/states/listStates.ts

```typescript
/**
 * ListStatesMode - Lists states with filtering and sorting capabilities
 * Following the same pattern as ListWorkspacesMode for consistency
 */

import { BaseTool } from '../../../baseTool';
import { MemoryManagerAgent } from '../../memoryManager'
import { ListStatesParams, StateResult } from '../../types';
import { createErrorMessage } from '../../../../utils/errorUtils';
import { extractContextFromParams } from '../../../../utils/contextUtils';
import { MemoryService } from "../../services/MemoryService";
import { WorkspaceService, GLOBAL_WORKSPACE_ID } from '../../../../services/WorkspaceService';

/**
 * Mode for listing states with filtering and sorting
 */
export class ListStatesTool extends BaseTool<ListStatesParams, StateResult> {
  private agent: MemoryManagerAgent;

  constructor(agent: MemoryManagerAgent) {
    super(
      'listStates',
      'List States',
      'List states with optional filtering and sorting',
      '2.0.0'
    );
    this.agent = agent;
  }

  async execute(params: ListStatesParams): Promise<StateResult> {
    try {
      // Get services from agent
      const memoryService = await this.agent.getMemoryServiceAsync();
      const workspaceService = await this.agent.getWorkspaceServiceAsync();

      if (!memoryService) {
        return this.prepareResult(false, undefined, 'Memory service not available');
      }

      // Get workspace ID from context
      let workspaceId: string | undefined;
      const inheritedContext = this.getInheritedWorkspaceContext(params);
      if (inheritedContext?.workspaceId) {
        workspaceId = inheritedContext.workspaceId;
      }

      // Prepare pagination options for DB-level pagination
      // Use pageSize if provided, otherwise fall back to limit for backward compatibility
      const pageSize = params.pageSize || params.limit;
      const paginationOptions = {
        page: params.page ?? 0,
        pageSize: pageSize
      };

      // Get states with true DB-level pagination (use '_workspace' as sessionId)
      const statesResult = await memoryService.getStates(
        workspaceId || GLOBAL_WORKSPACE_ID,
        '_workspace',
        paginationOptions
      );

      // Extract items from PaginatedResult
      let processedStates = statesResult.items;

      // Filter out archived states by default (unless includeArchived is true)
      if (!params.includeArchived) {
        processedStates = processedStates.filter(state => {
          const stateData = state.state as unknown as Record<string, unknown> | undefined;
          const nestedState = stateData?.state as Record<string, unknown> | undefined;
          const metadata = nestedState?.metadata as Record<string, unknown> | undefined;
          return !metadata?.isArchived;
        });
      }

      // Filter by tags if provided (tags aren't in DB, so must filter in-memory)
      // Note: This happens AFTER pagination, so may return fewer results than pageSize
      if (params.tags && params.tags.length > 0) {
        processedStates = processedStates.filter(state => {
          const stateData = state.state as unknown as Record<string, unknown> | undefined;
          const nestedState = stateData?.state as Record<string, unknown> | undefined;
          const metadata = nestedState?.metadata as Record<string, unknown> | undefined;
          const stateTags = (metadata?.tags as string[]) || [];
          return params.tags!.some(tag => stateTags.includes(tag));
        });
      }

      // Sort states (in-memory sorting for now - TODO: move to DB level)
      const sortedStates = this.sortStates(processedStates, params.order || 'desc');

      // Simplify state data to just name and description
      const simplifiedStates = sortedStates.map(state => ({
        name: state.name,
        description: state.description || state.state?.context?.activeTask || 'No description'
      }));

      return this.prepareResult(true, simplifiedStates);

    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Error listing states: ', error));
    }
  }

  /**
   * Sort states by creation date
   */
  private sortStates(states: any[], order: 'asc' | 'desc'): any[] {
    return states.sort((a, b) => {
      const timeA = a.timestamp || a.created || 0;
      const timeB = b.timestamp || b.created || 0;
      return order === 'asc' ? timeA - timeB : timeB - timeA;
    });
  }

  /**
   * Enhance states with workspace names and context
   */
  private async enhanceStatesWithContext(states: any[], workspaceService: WorkspaceService, includeContext?: boolean): Promise<any[]> {
    const workspaceCache = new Map<string, string>();
    
    return await Promise.all(states.map(async (state) => {
      let workspaceName = 'Unknown Workspace';
      
      if (!workspaceCache.has(state.workspaceId)) {
        try {
          const workspace = await workspaceService.getWorkspace(state.workspaceId);
          workspaceName = workspace?.name || 'Unknown Workspace';
          workspaceCache.set(state.workspaceId, workspaceName);
        } catch {
          workspaceCache.set(state.workspaceId, 'Unknown Workspace');
        }
      } else {
        workspaceName = workspaceCache.get(state.workspaceId)!;
      }

      const enhanced: any = {
        ...state,
        workspaceName,
        created: state.created || state.timestamp
      };

      if (includeContext && state.state?.context) {
        enhanced.context = {
          files: state.state.context.activeFiles || [],
          traceCount: 0, // Could be enhanced to count related traces
          tags: state.state?.state?.metadata?.tags || [],
          summary: state.state.context.activeTask || 'No active task recorded'
        };
      }

      return enhanced;
    }));
  }


  /**
   * Get workspace context from inherited parameters
   */
  protected getInheritedWorkspaceContext(params: ListStatesParams): any {
    return extractContextFromParams(params);
  }

  getParameterSchema(): any {
    const toolSchema = {
      type: 'object',
      properties: {
        includeArchived: {
          type: 'boolean',
          description: 'Include archived states (default: false)'
        },
        tags: {
          type: 'array',
          items: { type: 'string' },
          description: 'Filter by tags'
        },
        page: {
          type: 'number',
          description: 'Page number for pagination (0-indexed, default: 0)',
          minimum: 0
        },
        pageSize: {
          type: 'number',
          description: 'Number of items per page (default: all items if not specified)',
          minimum: 1
        },
        order: {
          type: 'string',
          enum: ['asc', 'desc'],
          description: 'Sort order by creation date (default: desc)'
        }
      },
      additionalProperties: false
    };

    return this.getMergedSchema(toolSchema);
  }

  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation was successful'
        },
        data: {
          type: 'object',
          description: 'State data with pagination'
        },
        error: {
          type: 'string',
          description: 'Error message if operation failed'
        }
      },
      required: ['success'],
      additionalProperties: false
    };
  }
}
```

## agents/memoryManager/tools/states/loadState.ts

```typescript
/**
 * Location: /src/agents/memoryManager/modes/states/LoadStateMode.ts
 * Purpose: Consolidated state loading mode combining all load functionality from original state files
 * 
 * This file consolidates:
 * - Original loadStateMode.ts functionality
 * - StateRetriever and restoration logic
 * - FileCollector and TraceProcessor logic
 * - SessionManager and WorkspaceContextBuilder logic
 * - RestorationSummaryGenerator and RestorationTracer logic
 * 
 * Used by: MemoryManager agent for state loading and restoration operations
 */

import { App } from 'obsidian';
import { BaseTool } from '../../../baseTool';
import { MemoryManagerAgent } from '../../memoryManager'
import { LoadStateParams, StateResult } from '../../types';
import { createErrorMessage } from '../../../../utils/errorUtils';
import { extractContextFromParams } from '../../../../utils/contextUtils';
import { MemoryService } from "../../services/MemoryService";
import { WorkspaceService, GLOBAL_WORKSPACE_ID } from '../../../../services/WorkspaceService';
import { createServiceIntegration } from '../../services/ValidationService';
import { SchemaBuilder, SchemaType } from '../../../../utils/schemas/SchemaBuilder';

/**
 * Consolidated LoadStateMode - combines all state loading functionality
 */
export class LoadStateTool extends BaseTool<LoadStateParams, StateResult> {
    private app: App;
    private serviceIntegration: ReturnType<typeof createServiceIntegration>;
    private schemaBuilder: SchemaBuilder;

    constructor(private agent: MemoryManagerAgent) {
        super(
            'loadState',
            'Load State',
            'Load a saved state and optionally create a continuation session with restored context',
            '2.0.0'
        );

        this.app = agent.getApp();
        this.serviceIntegration = createServiceIntegration(this.app, {
            logLevel: 'warn',
            maxRetries: 2,
            fallbackBehavior: 'warn'
        });
        this.schemaBuilder = new SchemaBuilder();
    }

    /**
     * Execute state loading with consolidated logic
     */
    async execute(params: LoadStateParams): Promise<StateResult> {
        try {
            // Phase 1: Get services and validate
            const servicesResult = await this.getServices();
            if (!servicesResult.success) {
                return this.prepareResult(false, undefined, servicesResult.error);
            }

            const { memoryService, workspaceService } = servicesResult;

            // Phase 2: Extract workspaceId and load state data
            if (!memoryService) {
                return this.prepareResult(false, undefined, 'Memory service not available', extractContextFromParams(params));
            }

            // Extract workspaceId from params (use '_workspace' as sessionId for workspace-scoped states)
            const parsedContext = params.workspaceContext ?
                (typeof params.workspaceContext === 'string' ? JSON.parse(params.workspaceContext) : params.workspaceContext) : null;
            const workspaceId = parsedContext?.workspaceId || GLOBAL_WORKSPACE_ID;

            // Use name (required) or fall back to deprecated stateId for backward compatibility
            const stateName = params.name ?? params.stateId;
            if (!stateName) {
                return this.prepareResult(false, undefined, 'State name is required. Use listStates to see available states.', extractContextFromParams(params));
            }
            const stateResult = await this.loadStateData(workspaceId, '_workspace', stateName, memoryService);
            if (!stateResult.success) {
                return this.prepareResult(false, undefined, stateResult.error, extractContextFromParams(params));
            }

            // Phase 3: Process and restore context (consolidated from FileCollector and TraceProcessor logic)
            if (!workspaceService) {
                return this.prepareResult(false, undefined, 'Workspace service not available', extractContextFromParams(params));
            }
            const contextResult = await this.processAndRestoreContext(stateResult.data, workspaceService, memoryService);

            // Phase 4: Prepare simplified result (no session continuation, just return state data)
            return this.prepareFinalResult(
                stateResult.data,
                contextResult
            );

        } catch (error) {
            return this.prepareResult(false, undefined, createErrorMessage('Error loading state: ', error));
        }
    }

    /**
     * Get required services with validation
     */
    private async getServices(): Promise<{success: boolean; error?: string; memoryService?: MemoryService; workspaceService?: WorkspaceService}> {
        const [memoryResult, workspaceResult] = await Promise.all([
            this.serviceIntegration.getMemoryService(),
            this.serviceIntegration.getWorkspaceService()
        ]);

        if (!memoryResult.success || !memoryResult.service) {
            return { success: false, error: `Memory service not available: ${memoryResult.error}` };
        }

        if (!workspaceResult.success || !workspaceResult.service) {
            return { success: false, error: `Workspace service not available: ${workspaceResult.error}` };
        }

        return { 
            success: true, 
            memoryService: memoryResult.service, 
            workspaceService: workspaceResult.service 
        };
    }

    /**
     * Load state data (consolidated from StateRetriever logic)
     * Looks up state by name
     */
    private async loadStateData(workspaceId: string, sessionId: string, stateName: string, memoryService: MemoryService): Promise<{success: boolean; error?: string; data?: any}> {
        try {
            // Get state from memory service by name
            const loadedState = await memoryService.getStateByNameOrId(workspaceId, sessionId, stateName);
            if (!loadedState) {
                return { success: false, error: `State "${stateName}" not found. Use listStates to see available states.` };
            }

            // Get related traces if available using the actual state's session ID
            let relatedTraces: any[] = [];
            try {
                const effectiveSessionId = loadedState.sessionId || sessionId;
                if (effectiveSessionId && effectiveSessionId !== 'current') {
                    const tracesResult = await memoryService.getMemoryTraces(workspaceId, effectiveSessionId);
                    relatedTraces = tracesResult.items;
                }
            } catch {
                // Ignore errors getting traces - not critical for state loading
            }

            return {
                success: true,
                data: {
                    loadedState,
                    relatedTraces: relatedTraces || []
                }
            };

        } catch (error) {
            return { success: false, error: createErrorMessage('Error loading state data: ', error) };
        }
    }

    /**
     * Process and restore context (consolidated from FileCollector and TraceProcessor logic)
     */
    private async processAndRestoreContext(stateData: any, workspaceService: WorkspaceService, memoryService: MemoryService): Promise<any> {
        try {
            const { loadedState, relatedTraces } = stateData;

            // Get workspace for context
            let workspace: any;
            try {
                workspace = await workspaceService.getWorkspace(loadedState.workspaceId);
            } catch {
                workspace = { name: 'Unknown Workspace' };
            }

            // Extract state context details (using new naming: context instead of snapshot)
            const stateContext = loadedState.context || {};

            // Build context summary (consolidated from FileCollector logic)
            const summary = this.buildContextSummary(loadedState, workspace, stateContext);

            // Process active files (consolidated file collection logic)
            const activeFiles = stateContext.activeFiles || [];
            const associatedNotes = this.processActiveFiles(activeFiles);

            // Process memory traces (consolidated from TraceProcessor logic)
            const processedTraces = this.processMemoryTraces(relatedTraces);

            return {
                summary,
                associatedNotes,
                stateCreatedAt: new Date(loadedState.created).toISOString(),
                originalSessionId: loadedState.sessionId,
                workspace,
                restoredContext: {
                    conversationContext: stateContext.conversationContext,
                    activeTask: stateContext.activeTask,
                    activeFiles,
                    nextSteps: stateContext.nextSteps || [],
                    reasoning: stateContext.reasoning,
                    workspaceContext: stateContext.workspaceContext
                },
                traces: processedTraces
            };

        } catch (error) {
            return {
                summary: `State "${stateData.loadedState.name}" loaded successfully`,
                associatedNotes: [],
                stateCreatedAt: new Date().toISOString(),
                originalSessionId: stateData.loadedState.sessionId,
                workspace: { name: 'Unknown Workspace' },
                restoredContext: {
                    conversationContext: 'Context restoration incomplete',
                    activeTask: 'Resume from saved state',
                    activeFiles: [],
                    nextSteps: [],
                    reasoning: 'State loaded with limited context'
                },
                traces: []
            };
        }
    }

    /**
     * Prepare final result - simplified to return just the structured state data
     */
    private prepareFinalResult(stateData: any, contextResult: any): StateResult {
        const loadedState = stateData.loadedState;
        const stateContext = loadedState.context || {};

        const resultData = {
            name: loadedState.name,
            conversationContext: stateContext.conversationContext,
            activeTask: stateContext.activeTask,
            activeFiles: stateContext.activeFiles || [],
            nextSteps: stateContext.nextSteps || [],
            description: loadedState.description,
            tags: loadedState.state?.metadata?.tags || []
        };

        return this.prepareResult(
            true,
            resultData,
            undefined,
            undefined
        );
    }

    /**
     * Helper methods (consolidated from various services)
     */
    private buildContextSummary(loadedState: any, workspace: any, stateContext: any): string {
        const parts: string[] = [];

        parts.push(`Loaded state: "${loadedState.name}"`);
        parts.push(`Workspace: ${workspace.name}`);

        if (stateContext.activeTask) {
            parts.push(`Active task: ${stateContext.activeTask}`);
        }

        if (stateContext.conversationContext) {
            const contextPreview = stateContext.conversationContext.length > 100
                ? stateContext.conversationContext.substring(0, 100) + '...'
                : stateContext.conversationContext;
            parts.push(`Context: ${contextPreview}`);
        }

        if (stateContext.activeFiles && stateContext.activeFiles.length > 0) {
            parts.push(`${stateContext.activeFiles.length} active file${stateContext.activeFiles.length === 1 ? '' : 's'}`);
        }

        if (stateContext.nextSteps && stateContext.nextSteps.length > 0) {
            parts.push(`${stateContext.nextSteps.length} next step${stateContext.nextSteps.length === 1 ? '' : 's'} defined`);
        }

        const stateAge = Date.now() - loadedState.created;
        const daysAgo = Math.floor(stateAge / (1000 * 60 * 60 * 24));
        if (daysAgo > 0) {
            parts.push(`Created ${daysAgo} day${daysAgo === 1 ? '' : 's'} ago`);
        } else {
            const hoursAgo = Math.floor(stateAge / (1000 * 60 * 60));
            if (hoursAgo > 0) {
                parts.push(`Created ${hoursAgo} hour${hoursAgo === 1 ? '' : 's'} ago`);
            } else {
                parts.push('Created recently');
            }
        }

        return parts.join('. ');
    }

    private processActiveFiles(activeFiles: string[]): string[] {
        // Filter and validate active files
        return activeFiles
            .filter(file => file && typeof file === 'string')
            .slice(0, 20); // Limit to 20 files for performance
    }

    private processMemoryTraces(traces: any[]): any[] {
        // Process and format traces for display
        return traces
            .slice(0, 5) // Limit to 5 most recent traces
            .map(trace => ({
                timestamp: trace.timestamp,
                content: trace.content.substring(0, 150) + (trace.content.length > 150 ? '...' : ''),
                type: trace.type,
                importance: trace.importance
            }));
    }

    /**
     * Schema methods using consolidated logic
     */
    getParameterSchema(): any {
        const toolSchema = {
            type: 'object',
            properties: {
                name: {
                    type: 'string',
                    description: 'Name of the state to load (REQUIRED). Use listStates to see available states.'
                }
            },
            required: ['name'],
            additionalProperties: false
        };

        return this.getMergedSchema(toolSchema);
    }

    getResultSchema(): any {
        return this.schemaBuilder.buildResultSchema(SchemaType.State, {
            mode: 'loadState'
        });
    }
}
```

## agents/memoryManager/tools/utils/pluginTypes.ts

```typescript
import { Plugin } from 'obsidian';
import { WorkspaceService } from '../../../../services/WorkspaceService';
import { MemoryService } from "../../services/MemoryService";

/**
 * Custom interface for the Nexus plugin with services
 */
export interface NexusPluginWithServices extends Plugin {
  services: {
    workspaceService: WorkspaceService;
    memoryService: MemoryService;
    [key: string]: unknown;
  };
  getService<T>(serviceName: string): Promise<T | null>;
  getServiceIfReady<T>(serviceName: string): T | null;
}

```

## agents/memoryManager/tools/workspaces/archiveWorkspace.ts

```typescript
/**
 * Location: /src/agents/memoryManager/tools/workspaces/ArchiveWorkspace.ts
 * Purpose: Archive a workspace (soft delete) by setting isArchived flag
 *
 * Used by: MemoryManager agent for workspace archival operations
 */

import { App } from 'obsidian';
import { BaseTool } from '../../../baseTool';
import { MemoryManagerAgent } from '../../memoryManager';
import { createServiceIntegration } from '../../services/ValidationService';
import { createErrorMessage } from '../../../../utils/errorUtils';
import { CommonResult, CommonParameters } from '../../../../types/mcp/AgentTypes';

// Define parameter and result types for workspace archival
export interface ArchiveWorkspaceParameters extends CommonParameters {
    name: string;  // Workspace name to archive/restore
    restore?: boolean;  // If true, restores from archive instead of archiving
}

export interface ArchiveWorkspaceResult extends CommonResult {
    success: boolean;
    error?: string;
}

/**
 * ArchiveWorkspace - Soft delete a workspace by setting isArchived flag
 */
export class ArchiveWorkspaceTool extends BaseTool<ArchiveWorkspaceParameters, ArchiveWorkspaceResult> {
    private app: App;
    private serviceIntegration: ReturnType<typeof createServiceIntegration>;

    constructor(private agent: MemoryManagerAgent) {
        super(
            'archiveWorkspace',
            'Archive Workspace',
            'Archive a workspace (soft delete). Workspace will be hidden from lists but can be restored.',
            '1.0.0'
        );

        this.app = agent.getApp();
        this.serviceIntegration = createServiceIntegration(this.app, {
            logLevel: 'warn',
            maxRetries: 2,
            fallbackBehavior: 'warn'
        });
    }

    async execute(params: ArchiveWorkspaceParameters): Promise<ArchiveWorkspaceResult> {
        try {
            // Get workspace service
            const serviceResult = await this.serviceIntegration.getWorkspaceService();
            if (!serviceResult.success || !serviceResult.service) {
                return this.prepareResult(false, undefined, `Workspace service not available: ${serviceResult.error}`);
            }

            const workspaceService = serviceResult.service;

            // Validate workspace exists
            const existingWorkspace = await workspaceService.getWorkspaceByNameOrId(params.name);
            if (!existingWorkspace) {
                return this.prepareResult(false, undefined, `Workspace "${params.name}" not found. Use listWorkspaces to see available workspaces.`);
            }

            const isRestore = params.restore === true;

            // Check current state
            if (isRestore && !existingWorkspace.isArchived) {
                return this.prepareResult(false, undefined, `Workspace "${params.name}" is not archived.`);
            }
            if (!isRestore && existingWorkspace.isArchived) {
                return this.prepareResult(false, undefined, `Workspace "${params.name}" is already archived.`);
            }

            // Create a copy and toggle isArchived flag
            const workspaceCopy = JSON.parse(JSON.stringify(existingWorkspace));
            workspaceCopy.isArchived = !isRestore;
            workspaceCopy.lastAccessed = Date.now();

            // Perform the update
            await workspaceService.updateWorkspace(existingWorkspace.id, workspaceCopy);

            // Success - LLM already knows what it passed
            return this.prepareResult(true);

        } catch (error) {
            return this.prepareResult(false, undefined, createErrorMessage('Error archiving workspace: ', error));
        }
    }

    getParameterSchema(): Record<string, unknown> {
        const toolSchema = {
            type: 'object',
            properties: {
                name: {
                    type: 'string',
                    description: 'Name of the workspace to archive or restore (REQUIRED)'
                },
                restore: {
                    type: 'boolean',
                    description: 'If true, restores the workspace from archive. If false/omitted, archives the workspace.'
                }
            },
            required: ['name']
        };

        return this.getMergedSchema(toolSchema);
    }

    getResultSchema(): Record<string, unknown> {
        return {
            type: 'object',
            properties: {
                success: { type: 'boolean', description: 'Whether the operation succeeded' },
                error: { type: 'string', description: 'Error message if failed (includes recovery guidance)' }
            },
            required: ['success']
        };
    }
}

```

## agents/memoryManager/tools/workspaces/createWorkspace.ts

```typescript
/**
 * Location: /src/agents/memoryManager/modes/workspaces/CreateWorkspaceMode.ts
 * Purpose: Consolidated workspace creation tool
 *
 * This file consolidates the original createWorkspaceMode.ts functionality
 *
 * Used by: MemoryManager agent for workspace creation operations
 */

import { App } from 'obsidian';
import { BaseTool } from '../../../baseTool';
import { MemoryManagerAgent } from '../../memoryManager'
import { createServiceIntegration } from '../../services/ValidationService';

// Import types from existing workspace mode
import { 
    CreateWorkspaceParameters, 
    CreateWorkspaceResult
} from '../../../../database/types/workspace/ParameterTypes';
import { ProjectWorkspace, WorkspaceContext } from '../../../../database/types/workspace/WorkspaceTypes';
import { WorkspaceService } from '../../../../services/WorkspaceService';
import { createErrorMessage } from '../../../../utils/errorUtils';

/**
 * Consolidated CreateWorkspaceMode - simplified from original
 */
export class CreateWorkspaceTool extends BaseTool<CreateWorkspaceParameters, CreateWorkspaceResult> {
    private app: App;
    private serviceIntegration: ReturnType<typeof createServiceIntegration>;
    
    constructor(private agent: MemoryManagerAgent) {
        super(
            'createWorkspace',
            'Create Workspace',
            'Create a new workspace with structured context data',
            '2.0.0'
        );

        this.app = agent.getApp();
        this.serviceIntegration = createServiceIntegration(this.app, {
            logLevel: 'warn',
            maxRetries: 2,
            fallbackBehavior: 'warn'
        });
    }
    
    async execute(params: CreateWorkspaceParameters): Promise<CreateWorkspaceResult> {
        try {
            // Get workspace service
            const serviceResult = await this.serviceIntegration.getWorkspaceService();
            if (!serviceResult.success || !serviceResult.service) {
                return this.prepareResult(false, undefined, `Workspace service not available: ${serviceResult.error}`);
            }
            
            const workspaceService = serviceResult.service;
            
            // Validate required fields
            if (!params.name) {
                return this.prepareResult(false, undefined, 'Name is required. Provide a descriptive workspace name.');
            }
            if (!params.description) {
                return this.prepareResult(false, undefined, 'Description is required. Provide a brief description of what this workspace is for.');
            }
            if (!params.rootFolder) {
                return this.prepareResult(false, undefined, 'Root folder is required. Specify the vault folder path for this workspace.');
            }
            if (!params.purpose) {
                return this.prepareResult(false, undefined, 'Purpose is required. Describe what this workspace is used for.');
            }
            
            // Ensure root folder exists
            try {
                const folder = this.app.vault.getAbstractFileByPath(params.rootFolder);
                if (!folder) {
                    await this.app.vault.createFolder(params.rootFolder);
                }
            } catch (folderError) {
                // Ignore folder creation errors
            }
            
            // Handle dedicated agent setup
            let dedicatedAgent: { agentId: string; agentName: string } | undefined = undefined;
            if (params.dedicatedAgentId) {
                try {
                    // Get the agent name from CustomPromptStorageService
                    const plugin = this.app.plugins.getPlugin('claudesidian-mcp') as unknown as Record<string, unknown> | null;
                    const agentManager = plugin?.agentManager as Record<string, unknown> | undefined;
                    if (agentManager?.getAgent) {
                        const getAgent = agentManager.getAgent as (name: string) => Record<string, unknown> | undefined;
                        const agentManagerAgent = getAgent('agentManager');
                        const storageService = agentManagerAgent?.storageService as Record<string, unknown> | undefined;
                        if (storageService?.getPromptById) {
                            const getPromptById = storageService.getPromptById as (id: string) => { id: string; name: string } | undefined;
                            const agent = getPromptById(params.dedicatedAgentId);
                            if (agent) {
                                dedicatedAgent = {
                                    agentId: agent.id,
                                    agentName: agent.name
                                };
                            }
                        }
                    }
                } catch (error) {
                    // Ignore agent name retrieval errors
                }
            }

            // Combine provided key files with auto-detected ones
            const providedKeyFiles = params.keyFiles || [];
            const autoDetectedKeyFiles = await this.detectSimpleKeyFiles(params.rootFolder);
            const allKeyFiles = [...new Set([...providedKeyFiles, ...autoDetectedKeyFiles])]; // Remove duplicates

            // Build workspace context
            const context: WorkspaceContext = {
                purpose: params.purpose,
                workflows: params.workflows,
                keyFiles: allKeyFiles,
                preferences: params.preferences || '',
                ...(dedicatedAgent && { dedicatedAgent })
            };
            
            // Create workspace data
            const now = Date.now();
            const workspaceData: Omit<ProjectWorkspace, 'id'> = {
                name: params.name,
                context: context,
                rootFolder: params.rootFolder,
                created: now,
                lastAccessed: now,
                description: params.description,
                relatedFolders: params.relatedFolders || [],
                relatedFiles: params.relatedFiles || [],
                associatedNotes: [],
                keyFileInstructions: params.keyFileInstructions,
                activityHistory: [{
                    timestamp: now,
                    action: 'create',
                    toolName: 'CreateWorkspaceMode',
                    context: `Created workspace: ${params.purpose}`
                }],
                preferences: undefined, // Legacy field - preferences now stored in context
                projectPlan: undefined,
                checkpoints: [],
                completionStatus: {}
            };
            
            // Check if workspace with same name already exists
            try {
                const existing = await workspaceService.getWorkspaceByNameOrId(params.name);
                if (existing) {
                    return this.prepareResult(false, undefined, `Workspace "${params.name}" already exists. Use listWorkspaces to see existing workspaces.`);
                }
            } catch (error) {
                // Ignore lookup errors
            }

            // Save workspace
            await workspaceService.createWorkspace(workspaceData);

            // Success - LLM already knows the workspace details it passed
            return this.prepareResult(true);

        } catch (error) {
            return this.prepareResult(false, undefined, createErrorMessage('Error creating workspace: ', error));
        }
    }
    
    /**
     * Auto-detect key files in workspace folder (simple array format)
     */
    private async detectSimpleKeyFiles(rootFolder: string): Promise<string[]> {
        try {
            const detectedFiles: string[] = [];

            const folder = this.app.vault.getAbstractFileByPath(rootFolder);
            if (folder && 'children' in folder && Array.isArray(folder.children)) {
                for (const child of folder.children as Array<{ path: string; name: string; cachedData?: { frontmatter?: { key?: boolean } } }>) {
                    if (child.path.endsWith('.md')) {
                        const fileName = child.name.toLowerCase();

                        // Auto-detect common key files
                        if (['index.md', 'readme.md', 'summary.md', 'moc.md', 'overview.md'].includes(fileName)) {
                            detectedFiles.push(child.path);
                        }

                        try {
                            // Check for frontmatter key: true
                            if ('cachedData' in child && child.cachedData?.frontmatter?.key === true) {
                                detectedFiles.push(child.path);
                            }
                        } catch (error) {
                            // Ignore frontmatter parsing errors
                        }
                    }
                }
            }

            return detectedFiles;

        } catch (error) {
            return [];
        }
    }

    getParameterSchema(): any {
        const toolSchema = {
            type: 'object',
            title: 'Create Workspace',
            description: 'Create a new workspace with structured workflows and context.',
            properties: {
                name: {
                    type: 'string',
                    description: 'Workspace name'
                },
                description: {
                    type: 'string',
                    description: 'Brief description of the workspace purpose'
                },
                rootFolder: {
                    type: 'string',
                    description: 'Root folder path for this workspace'
                },
                purpose: {
                    type: 'string',
                    description: 'Overall purpose and goals for this workspace'
                },
                workflows: {
                    type: 'array',
                    description: 'Workflows for different situations. Each workflow has name, when (trigger), and steps (newline-separated string).',
                    items: {
                        type: 'object',
                        properties: {
                            name: {
                                type: 'string',
                                description: 'Workflow name'
                            },
                            when: {
                                type: 'string',
                                description: 'When to use this workflow'
                            },
                            steps: {
                                type: 'string',
                                description: 'Steps separated by newline characters (\\n)'
                            }
                        },
                        required: ['name', 'when', 'steps']
                    },
                    minItems: 1
                },
                keyFiles: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Key file paths for quick reference'
                },
                preferences: {
                    type: 'string',
                    description: 'User preferences or workspace settings'
                },
                dedicatedAgentId: {
                    type: 'string',
                    description: 'ID of dedicated prompt for this workspace'
                },
                relatedFolders: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Related folder paths'
                },
                relatedFiles: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Related file paths'
                },
                keyFileInstructions: {
                    type: 'string',
                    description: 'Instructions for working with key files'
                }
            },
            required: ['name', 'description', 'rootFolder', 'purpose'],
            errorHelp: {
                missingName: 'The "name" parameter is required. Provide a descriptive workspace name.',
                missingDescription: 'The "description" parameter is required. Provide a brief description.',
                missingRootFolder: 'The "rootFolder" parameter is required. Specify the folder path for this workspace.',
                missingPurpose: 'The "purpose" parameter is required. Describe what this workspace is for.',
                workflowStepsFormat: 'CRITICAL: workflow "steps" should be a SINGLE STRING with steps separated by newline characters (\\n). Example: "Step 1\\nStep 2\\nStep 3"'
            }
        };
        
        return this.getMergedSchema(toolSchema);
    }
    
    getResultSchema(): any {
        return {
            type: 'object',
            properties: {
                success: { type: 'boolean' },
                data: {
                    type: 'object',
                    properties: {
                        workspaceId: { type: 'string' },
                        workspace: { type: 'object' },
                        validationPrompt: { type: 'string' }
                    }
                }
            }
        };
    }
}
```

## agents/memoryManager/tools/workspaces/index.ts

```typescript
export * from './createWorkspace';
export * from './listWorkspaces';
export * from './loadWorkspace';
export * from './updateWorkspace';
export * from './archiveWorkspace';

```

## agents/memoryManager/tools/workspaces/listWorkspaces.ts

```typescript
/**
 * Location: src/agents/memoryManager/modes/workspaces/ListWorkspacesMode.ts
 * 
 * Purpose: Implements the listWorkspaces mode for the consolidated MemoryManager
 * This mode lists available workspaces with filtering and sorting options.
 * 
 * Used by: MemoryManagerAgent for workspace listing operations
 * Integrates with: WorkspaceService for accessing workspace data
 */

import { BaseTool } from '../../../baseTool';
import { 
  ListWorkspacesParameters, 
  ListWorkspacesResult
} from '../../../../database/workspace-types';
import { WorkspaceService } from '../../../../services/WorkspaceService';
import { parseWorkspaceContext } from '../../../../utils/contextUtils';

/**
 * Mode to list available workspaces with filtering and sorting
 */
export class ListWorkspacesTool extends BaseTool<ListWorkspacesParameters, ListWorkspacesResult> {
  private agent: any;
  
  /**
   * Create a new ListWorkspacesMode for the consolidated MemoryManager
   * @param agent The MemoryManagerAgent instance
   */
  constructor(agent: any) {
    super(
      'listWorkspaces',
      'List Workspaces',
      'List available workspaces with filters and sorting',
      '1.0.0'
    );
    this.agent = agent;
  }
  
  /**
   * Execute the mode to list workspaces
   * @param params Mode parameters
   * @returns Promise resolving to the result
   */
  async execute(params: ListWorkspacesParameters): Promise<ListWorkspacesResult> {
    try {
      // Get workspace service from agent
      const workspaceService = await this.agent.getWorkspaceServiceAsync();
      if (!workspaceService) {
        return {
          success: false,
          error: 'WorkspaceService not available',
          data: { workspaces: [] }
        };
      }
      
      // Get workspaces with optional filtering and sorting
      const queryParams: {
        sortBy?: 'name' | 'created' | 'lastAccessed',
        sortOrder?: 'asc' | 'desc',
        limit?: number
      } = {
        sortBy: params.sortBy as 'name' | 'created' | 'lastAccessed' | undefined,
        sortOrder: params.order as 'asc' | 'desc' | undefined,
        limit: params.limit
      };

      let workspaces;
      try {
        workspaces = await workspaceService.getWorkspaces(queryParams);
      } catch (queryError) {
        return {
          success: false,
          error: `Failed to query workspaces: ${queryError instanceof Error ? queryError.message : String(queryError)}`,
          data: { workspaces: [] }
        };
      }

      // Filter out archived workspaces unless explicitly requested
      const includeArchived = params.includeArchived ?? false;
      let filteredWorkspaces = workspaces;
      if (!includeArchived) {
        filteredWorkspaces = workspaces.filter((ws: any) => !ws.isArchived);
      }

      // Lean format: just name and description
      const leanWorkspaces = filteredWorkspaces.map((ws: any) => ({
        name: ws.name,
        description: ws.description || ''
      }));

      return {
        success: true,
        data: leanWorkspaces
      };
      
    } catch (error: any) {
      return {
        success: false,
        error: `Unexpected error: ${error.message || String(error)}`,
        data: { workspaces: [] }
      };
    }
  }
  
  /**
   * Get the parameter schema
   */
  getParameterSchema(): any {
    const toolSchema = {
      type: 'object',
      properties: {
        includeArchived: {
          type: 'boolean',
          description: 'Include archived workspaces (default: false)'
        },
        sortBy: {
          type: 'string',
          enum: ['name', 'created', 'lastAccessed'],
          description: 'Field to sort workspaces by'
        },
        order: {
          type: 'string',
          enum: ['asc', 'desc'],
          description: 'Sort order (ascending or descending)'
        },
        limit: {
          type: 'number',
          description: 'Maximum number of workspaces to return'
        }
      }
    };

    // Merge with common schema (adds sessionId, workspaceContext)
    return this.getMergedSchema(toolSchema);
  }
  
  /**
   * Get the result schema
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation was successful'
        },
        error: {
          type: 'string',
          description: 'Error message if operation failed'
        },
        data: {
          type: 'array',
          description: 'Array of workspaces with name and description',
          items: {
            type: 'object',
            properties: {
              name: {
                type: 'string',
                description: 'Workspace name'
              },
              description: {
                type: 'string',
                description: 'Workspace description'
              }
            },
            required: ['name', 'description']
          }
        }
      },
      required: ['success']
    };
  }
}
```

## agents/memoryManager/tools/workspaces/loadWorkspace.ts

```typescript
/**
 * Location: /src/agents/memoryManager/modes/workspaces/LoadWorkspaceMode.ts
 * Purpose: Consolidated workspace loading mode for MemoryManager
 *
 * This file handles loading a workspace by ID and restoring workspace context
 * and state for the user session. It automatically collects all files in the
 * workspace directory recursively and provides comprehensive workspace information.
 *
 * Used by: MemoryManager agent for workspace loading operations
 * Integrates with: WorkspaceService for accessing workspace data
 * Refactored: Now uses dedicated services for data fetching, agent resolution,
 *             context building, and file collection following SOLID principles
 */

import { BaseTool } from '../../../baseTool';
import {
  LoadWorkspaceParameters,
  LoadWorkspaceResult
} from '../../../../database/types/workspace/ParameterTypes';
import { ProjectWorkspace } from '../../../../database/types/workspace/WorkspaceTypes';
import { parseWorkspaceContext } from '../../../../utils/contextUtils';
import { createErrorMessage } from '../../../../utils/errorUtils';
import { PaginationParams } from '../../../../types/pagination/PaginationTypes';

// Import refactored services
import { WorkspaceDataFetcher } from '../../services/WorkspaceDataFetcher';
import { WorkspacePromptResolver } from '../../services/WorkspacePromptResolver';
import { WorkspaceContextBuilder } from '../../services/WorkspaceContextBuilder';
import { WorkspaceFileCollector } from '../../services/WorkspaceFileCollector';

/**
 * Mode to load and restore a workspace by ID
 * Automatically collects all files in the workspace directory and provides complete workspace information
 *
 * Follows SOLID principles with service composition:
 * - WorkspaceDataFetcher: Handles session and state data retrieval
 * - WorkspacePromptResolver: Resolves workspace prompts (custom prompts)
 * - WorkspaceContextBuilder: Builds context briefings and workflows
 * - WorkspaceFileCollector: Collects and organizes workspace files
 */
export class LoadWorkspaceTool extends BaseTool<LoadWorkspaceParameters, LoadWorkspaceResult> {
  private agent: any;

  // Composed services following Dependency Inversion Principle
  private dataFetcher: WorkspaceDataFetcher;
  private promptResolver: WorkspacePromptResolver;
  private contextBuilder: WorkspaceContextBuilder;
  private fileCollector: WorkspaceFileCollector;

  /**
   * Create a new LoadWorkspaceMode for the consolidated MemoryManager
   * @param agent The MemoryManagerAgent instance
   */
  constructor(agent: any) {
    super(
      'loadWorkspace',
      'Load Workspace',
      'Load a workspace by ID and restore context and state',
      '2.0.0'
    );
    this.agent = agent;

    // Initialize composed services
    this.dataFetcher = new WorkspaceDataFetcher();
    this.promptResolver = new WorkspacePromptResolver();
    this.contextBuilder = new WorkspaceContextBuilder();
    this.fileCollector = new WorkspaceFileCollector();
  }

  /**
   * Execute the mode to load a workspace
   * @param params Mode parameters
   * @returns Promise resolving to the result
   */
  async execute(params: LoadWorkspaceParameters): Promise<LoadWorkspaceResult> {
    const startTime = Date.now();

    try {
      // Get workspace service from agent
      const workspaceService = await this.agent.getWorkspaceServiceAsync();
      if (!workspaceService) {
        console.error('[LoadWorkspaceMode] WorkspaceService not available');
        return this.createErrorResult('WorkspaceService not available', params);
      }

      // Get the workspace by ID or name (unified lookup)
      let workspace: ProjectWorkspace | undefined;
      try {
        workspace = await workspaceService.getWorkspaceByNameOrId(params.id);
      } catch (queryError) {
        console.error('[LoadWorkspaceMode] Failed to load workspace:', queryError);
        return this.createErrorResult(
          `Failed to load workspace: ${queryError instanceof Error ? queryError.message : String(queryError)}`,
          params
        );
      }

      if (!workspace) {
        console.error('[LoadWorkspaceMode] Workspace not found:', params.id);
        return this.createErrorResult(`Workspace '${params.id}' not found (searched by both name and ID)`, params);
      }

      // Update last accessed timestamp (use actual workspace ID, not the identifier)
      try {
        await workspaceService.updateLastAccessed(workspace.id);
      } catch (updateError) {
        // Continue - this is not critical
      }

      // Get limit from params (default to 3)
      const limit = params.limit ?? 3;

      // Get memory service for data operations
      const memoryService = this.agent.getMemoryService();

      // Build context using services
      const context = await this.contextBuilder.buildContextBriefing(
        workspace,
        memoryService,
        limit
      );

      const workflows = this.contextBuilder.buildWorkflows(workspace);
      const keyFiles = this.contextBuilder.extractKeyFiles(workspace);
      const preferences = this.contextBuilder.buildPreferences(workspace);

      // Pagination options for database queries (page 0, pageSize = limit)
      const paginationOptions: PaginationParams = {
        page: 0,
        pageSize: limit
      };

      // Fetch sessions and states using data fetcher with pagination
      const sessionsResult = await this.dataFetcher.fetchWorkspaceSessions(
        workspace.id,
        memoryService,
        paginationOptions
      );
      const limitedSessions = sessionsResult.items;

      const statesResult = await this.dataFetcher.fetchWorkspaceStates(
        workspace.id,
        memoryService,
        paginationOptions
      );
      const limitedStates = statesResult.items;

      // Fetch prompt data using prompt resolver
      const app = this.agent.getApp();
      const workspacePrompt = await this.promptResolver.fetchWorkspacePrompt(workspace, app);

      // Collect files using file collector
      const cacheManager = this.agent.getCacheManager();
      const recentFiles = await this.fileCollector.getRecentFilesInWorkspace(workspace, cacheManager);

      // Build workspace structure using file collector
      const workspacePathResult = await this.fileCollector.buildWorkspacePath(
        workspace.rootFolder,
        app
      );
      const workspaceStructure = workspacePathResult.path?.files || [];
      const workspaceContext = {
        workspaceId: workspace.id,
        workspacePath: workspaceStructure  // Use string[] not WorkspacePath object
      };

      const result = {
        success: true,
        data: {
          context: context,
          workflows: workflows,
          workspaceStructure: workspaceStructure,
          recentFiles: recentFiles,
          keyFiles: keyFiles,
          preferences: preferences,
          sessions: limitedSessions,
          states: limitedStates,
          ...(workspacePrompt && { prompt: workspacePrompt })
        },
        pagination: {
          sessions: {
            page: sessionsResult.page,
            pageSize: sessionsResult.pageSize,
            totalItems: sessionsResult.totalItems,
            totalPages: sessionsResult.totalPages,
            hasNextPage: sessionsResult.hasNextPage,
            hasPreviousPage: sessionsResult.hasPreviousPage
          },
          states: {
            page: statesResult.page,
            pageSize: statesResult.pageSize,
            totalItems: statesResult.totalItems,
            totalPages: statesResult.totalPages,
            hasNextPage: statesResult.hasNextPage,
            hasPreviousPage: statesResult.hasPreviousPage
          }
        },
        workspaceContext: workspaceContext
      };

      // Add navigation fallback message if workspace path building failed
      if (workspacePathResult.failed) {
        result.data.context.recentActivity.push(
          "Note: Workspace directory navigation unavailable. Use vaultManager listDirectoryMode to explore the workspace folder structure."
        );
      }

      return result;

    } catch (error: any) {
      console.error(`[LoadWorkspaceMode] Unexpected error after ${Date.now() - startTime}ms:`, {
        message: error.message,
        stack: error.stack,
        params: params
      });

      return this.createErrorResult(
        createErrorMessage('Unexpected error loading workspace: ', error),
        params
      );
    }
  }

  /**
   * Create an error result with default data structure
   * Follows DRY principle by consolidating error result creation
   */
  protected createErrorResult(errorMessage: string, params: LoadWorkspaceParameters): LoadWorkspaceResult {
    return {
      success: false,
      error: errorMessage,
      data: {
        context: {
          name: 'Unknown',
          rootFolder: '',
          recentActivity: [errorMessage]
        },
        workflows: [],
        workspaceStructure: [],
        recentFiles: [],
        keyFiles: {},
        preferences: '',
        sessions: [],
        states: [],
      },
      workspaceContext: typeof params.workspaceContext === 'string'
        ? parseWorkspaceContext(params.workspaceContext) || undefined
        : params.workspaceContext
    };
  }

  /**
   * Get the parameter schema
   */
  getParameterSchema(): any {
    const toolSchema = {
      type: 'object',
      properties: {
        id: {
          type: 'string',
          description: 'Workspace ID or name to load (REQUIRED). Accepts either the unique workspace ID or the workspace name.'
        },
        limit: {
          type: 'number',
          description: 'Optional limit for sessions, states, and recentActivity returned (default: 3)',
          default: 3,
          minimum: 1,
          maximum: 20
        }
      },
      required: ['id']
    };

    // Merge with common schema (adds sessionId, workspaceContext)
    return this.getMergedSchema(toolSchema);
  }

  /**
   * Get the result schema
   */
  getResultSchema(): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the operation was successful'
        },
        error: {
          type: 'string',
          description: 'Error message if operation failed'
        },
        data: {
          type: 'object',
          properties: {
            context: {
              type: 'string',
              description: 'Formatted contextual briefing about the workspace'
            },
            workflows: {
              type: 'array',
              items: { type: 'string' },
              description: 'Workflow strings'
            },
            workspaceStructure: {
              type: 'array',
              items: { type: 'string' },
              description: 'File structure paths'
            },
            recentFiles: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  path: {
                    type: 'string',
                    description: 'File path relative to workspace root'
                  },
                  modified: {
                    type: 'number',
                    description: 'Last modified timestamp'
                  }
                },
                required: ['path', 'modified']
              },
              description: 'Most recently modified files in workspace (up to 5)'
            },
            keyFiles: {
              type: 'object',
              additionalProperties: {
                type: 'string'
              },
              description: 'Key files as name-path pairs'
            },
            preferences: {
              type: 'string',
              description: 'Formatted user preferences'
            },
            sessions: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  id: {
                    type: 'string',
                    description: 'Session ID'
                  },
                  name: {
                    type: 'string',
                    description: 'Session name'
                  },
                  description: {
                    type: 'string',
                    description: 'Session description'
                  },
                  created: {
                    type: 'number',
                    description: 'Session creation timestamp'
                  }
                },
                required: ['id', 'name', 'created']
              },
              description: 'Sessions in this workspace (paginated)'
            },
            states: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  id: {
                    type: 'string',
                    description: 'State ID'
                  },
                  name: {
                    type: 'string',
                    description: 'State name'
                  },
                  description: {
                    type: 'string',
                    description: 'State description'
                  },
                  sessionId: {
                    type: 'string',
                    description: 'Session ID this state belongs to'
                  },
                  created: {
                    type: 'number',
                    description: 'State creation timestamp'
                  },
                  tags: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'State tags'
                  }
                },
                required: ['id', 'name', 'sessionId', 'created']
              },
              description: 'States in this workspace (paginated)'
            },
            prompt: {
              type: 'object',
              properties: {
                id: {
                  type: 'string',
                  description: 'Prompt ID'
                },
                name: {
                  type: 'string',
                  description: 'Prompt name'
                },
                systemPrompt: {
                  type: 'string',
                  description: 'Custom prompt content'
                }
              },
              required: ['id', 'name', 'systemPrompt'],
              description: 'Associated workspace prompt (if available)'
            }
          }
        },
        pagination: {
          type: 'object',
          properties: {
            sessions: {
              type: 'object',
              properties: {
                page: { type: 'number', description: 'Current page (0-indexed)' },
                pageSize: { type: 'number', description: 'Items per page' },
                totalItems: { type: 'number', description: 'Total sessions in workspace' },
                totalPages: { type: 'number', description: 'Total pages available' },
                hasNextPage: { type: 'boolean', description: 'Whether more sessions exist' },
                hasPreviousPage: { type: 'boolean', description: 'Whether previous page exists' }
              },
              description: 'Pagination metadata for sessions'
            },
            states: {
              type: 'object',
              properties: {
                page: { type: 'number', description: 'Current page (0-indexed)' },
                pageSize: { type: 'number', description: 'Items per page' },
                totalItems: { type: 'number', description: 'Total states in workspace' },
                totalPages: { type: 'number', description: 'Total pages available' },
                hasNextPage: { type: 'boolean', description: 'Whether more states exist' },
                hasPreviousPage: { type: 'boolean', description: 'Whether previous page exists' }
              },
              description: 'Pagination metadata for states'
            }
          },
          description: 'Pagination metadata for sessions and states'
        },
        workspaceContext: {
          type: 'object',
          properties: {
            workspaceId: {
              type: 'string',
              description: 'Current workspace ID'
            },
            workspacePath: {
              type: 'array',
              items: { type: 'string' },
              description: 'Full path from root workspace'
            }
          }
        }
      },
      required: ['success']
    };
  }
}

```

## agents/memoryManager/tools/workspaces/updateWorkspace.ts

```typescript
/**
 * Location: /src/agents/memoryManager/modes/workspaces/UpdateWorkspaceMode.ts
 * Purpose: Update existing workspace properties and context
 *
 * Supports partial updates - pass only the fields you want to change.
 * Context fields can be updated individually without replacing the entire context.
 *
 * Used by: MemoryManager agent for workspace modification operations
 */

import { App } from 'obsidian';
import { BaseTool } from '../../../baseTool';
import { MemoryManagerAgent } from '../../memoryManager';
import { createServiceIntegration } from '../../services/ValidationService';
import { createErrorMessage } from '../../../../utils/errorUtils';
import { CommonResult, CommonParameters } from '../../../../types/mcp/AgentTypes';

// Define parameter and result types for workspace updates
export interface UpdateWorkspaceParameters extends CommonParameters {
    workspaceId: string;
    // Top-level fields (all optional)
    name?: string;
    description?: string;
    rootFolder?: string;
    // Context fields (all optional) - merged individually
    purpose?: string;
    workflows?: Array<{ name: string; when: string; steps: string }>;
    keyFiles?: string[];
    preferences?: string;
}

export interface UpdateWorkspaceResult extends CommonResult {
    success: boolean;
    error?: string;
}

/**
 * UpdateWorkspaceMode - Modify existing workspace properties
 * Pass only the fields you want to update; others remain unchanged.
 */
export class UpdateWorkspaceTool extends BaseTool<UpdateWorkspaceParameters, UpdateWorkspaceResult> {
    private app: App;
    private serviceIntegration: ReturnType<typeof createServiceIntegration>;

    constructor(private agent: MemoryManagerAgent) {
        super(
            'updateWorkspace',
            'Update Workspace',
            'Update workspace properties. Pass only fields to change - others remain unchanged.',
            '2.0.0'
        );

        this.app = agent.getApp();
        this.serviceIntegration = createServiceIntegration(this.app, {
            logLevel: 'warn',
            maxRetries: 2,
            fallbackBehavior: 'warn'
        });
    }

    async execute(params: UpdateWorkspaceParameters): Promise<UpdateWorkspaceResult> {
        try {
            // Get workspace service
            const serviceResult = await this.serviceIntegration.getWorkspaceService();
            if (!serviceResult.success || !serviceResult.service) {
                return this.prepareResult(false, undefined, `Workspace service not available: ${serviceResult.error}`);
            }

            const workspaceService = serviceResult.service;

            // Validate workspace exists using unified lookup (ID or name)
            const existingWorkspace = await workspaceService.getWorkspaceByNameOrId(params.workspaceId);
            if (!existingWorkspace) {
                return this.prepareResult(false, undefined, `Workspace "${params.workspaceId}" not found. Use listWorkspaces to see available workspaces.`);
            }

            // Check that at least one field is being updated
            const hasTopLevelUpdates = params.name !== undefined ||
                                       params.description !== undefined ||
                                       params.rootFolder !== undefined;
            const hasContextUpdates = params.purpose !== undefined ||
                                      params.workflows !== undefined ||
                                      params.keyFiles !== undefined ||
                                      params.preferences !== undefined;

            if (!hasTopLevelUpdates && !hasContextUpdates) {
                return this.prepareResult(false, undefined, 'No updates provided. Pass at least one field to update (name, description, rootFolder, purpose, workflows, keyFiles, or preferences).');
            }

            // Create a deep copy for updating
            const workspaceCopy = JSON.parse(JSON.stringify(existingWorkspace));
            const now = Date.now();

            // Apply top-level updates
            if (params.name !== undefined) {
                workspaceCopy.name = params.name;
            }
            if (params.description !== undefined) {
                workspaceCopy.description = params.description;
            }
            if (params.rootFolder !== undefined) {
                // Ensure folder exists
                try {
                    const folder = this.app.vault.getAbstractFileByPath(params.rootFolder);
                    if (!folder) {
                        await this.app.vault.createFolder(params.rootFolder);
                    }
                } catch (folderError) {
                    // Ignore folder creation errors
                }
                workspaceCopy.rootFolder = params.rootFolder;
            }

            // Initialize context if it doesn't exist
            if (!workspaceCopy.context) {
                workspaceCopy.context = {};
            }

            // Apply context-level updates (merged individually)
            if (params.purpose !== undefined) {
                workspaceCopy.context.purpose = params.purpose;
            }
            if (params.workflows !== undefined) {
                workspaceCopy.context.workflows = params.workflows;
            }
            if (params.keyFiles !== undefined) {
                workspaceCopy.context.keyFiles = params.keyFiles;
            }
            if (params.preferences !== undefined) {
                workspaceCopy.context.preferences = params.preferences;
            }

            // Update timestamp
            workspaceCopy.lastAccessed = now;

            // Perform the update
            await workspaceService.updateWorkspace(existingWorkspace.id, workspaceCopy);

            // Success - LLM already knows what it passed
            return this.prepareResult(true);

        } catch (error) {
            return this.prepareResult(false, undefined, createErrorMessage('Error updating workspace: ', error));
        }
    }

    getParameterSchema(): Record<string, unknown> {
        const toolSchema = {
            type: 'object',
            properties: {
                workspaceId: {
                    type: 'string',
                    description: 'ID or name of the workspace to update (REQUIRED)'
                },
                // Top-level optional fields
                name: {
                    type: 'string',
                    description: 'New workspace name (optional)'
                },
                description: {
                    type: 'string',
                    description: 'New workspace description (optional)'
                },
                rootFolder: {
                    type: 'string',
                    description: 'New root folder path (optional, will create if needed)'
                },
                // Context optional fields
                purpose: {
                    type: 'string',
                    description: 'New workspace purpose (optional, updates context.purpose)'
                },
                workflows: {
                    type: 'array',
                    description: 'New workflows array (optional, replaces context.workflows)',
                    items: {
                        type: 'object',
                        properties: {
                            name: { type: 'string' },
                            when: { type: 'string' },
                            steps: { type: 'string' }
                        },
                        required: ['name', 'when', 'steps']
                    }
                },
                keyFiles: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'New key files array (optional, replaces context.keyFiles)'
                },
                preferences: {
                    type: 'string',
                    description: 'New preferences text (optional, updates context.preferences)'
                }
            },
            required: ['workspaceId']
        };

        return this.getMergedSchema(toolSchema);
    }

    getResultSchema(): Record<string, unknown> {
        return {
            type: 'object',
            properties: {
                success: { type: 'boolean', description: 'Whether the operation succeeded' },
                error: { type: 'string', description: 'Error message if failed (includes recovery guidance)' }
            },
            required: ['success']
        };
    }
}

```

## agents/memoryManager/types.ts

```typescript
import { CommonResult, CommonParameters } from '../../types';
import { WorkspaceContext } from '../../utils/contextUtils';

/**
 * Base parameters for memory management operations
 */
export interface MemoryParams extends CommonParameters {
  /**
   * Optional context depth for memory operations
   * - minimal: Just basic information
   * - standard: Regular level of detail (default)
   * - comprehensive: Maximum detail and context
   */
  contextDepth?: 'minimal' | 'standard' | 'comprehensive';
}

/**
 * Base result for memory management operations
 */
export interface MemoryResult extends CommonResult {
  /**
   * Optional contextual information about the memory operation
   */
  memoryContext?: {
    /**
     * When the operation occurred
     */
    timestamp: number;
    
    /**
     * Tags associated with this memory operation
     */
    tags?: string[];
  };
}

/**
 * State-related parameter and result types
 *
 * Note: Sessions are now implicit (sessionId comes from context).
 * Session tools (createSession, listSessions, loadSession, updateSession) have been removed.
 */

// Params for creating a state
export interface CreateStateParams extends MemoryParams {
  /**
   * State name (unique per workspace)
   */
  name: string;

  /**
   * Conversation context for this state (REQUIRED)
   */
  conversationContext: string;

  /**
   * Currently active task (REQUIRED)
   */
  activeTask: string;

  /**
   * List of active files (REQUIRED)
   */
  activeFiles: string[];

  /**
   * Next steps for the workflow (REQUIRED)
   */
  nextSteps: string[];

  /**
   * Tags to associate with this state (optional)
   */
  tags?: string[];
}

// Params for listing states
export interface ListStatesParams extends MemoryParams {
  /**
   * Whether to include state context information
   */
  includeContext?: boolean;

  /**
   * Maximum number of states to return (deprecated, use pageSize instead)
   */
  limit?: number;

  /**
   * Filter states by target session ID
   */
  targetSessionId?: string;

  /**
   * Sort order for states (default: desc - newest first)
   */
  order?: 'asc' | 'desc';

  /**
   * Filter states by tags
   */
  tags?: string[];

  /**
   * Page number for pagination (0-indexed)
   */
  page?: number;

  /**
   * Number of items per page for pagination
   */
  pageSize?: number;

  /**
   * Whether to include archived states in the results (default: false)
   */
  includeArchived?: boolean;
}

// Params for loading a state
export interface LoadStateParams extends MemoryParams {
  /**
   * Name of the state to load (required)
   */
  name: string;

  /**
   * @deprecated Use `name` instead. Kept for backward compatibility.
   */
  stateId?: string;
}

// Result for state operations
export interface StateResult extends MemoryResult {
  data?: {
    /**
     * State ID
     */
    stateId?: string;
    
    /**
     * State name
     */
    name?: string;
    
    /**
     * State description
     */
    description?: string;
    
    /**
     * Workspace ID
     */
    workspaceId?: string;
    
    /**
     * Session ID
     */
    sessionId?: string;
    
    /**
     * Creation timestamp
     */
    created?: number;
    
    /**
     * New session ID when loading a state
     */
    newSessionId?: string;
    
    /**
     * List of states (for listing operations)
     */
    states?: Array<{
      id: string;
      name: string;
      workspaceId: string;
      sessionId: string;
      timestamp: number;
      description?: string;
      context?: {
        files: string[];
        traceCount: number;
        tags: string[];
        summary?: string;
      };
    }>;
    
    /**
     * Total number of states matching criteria before limit applied
     */
    total?: number;
    
    /**
     * Context information for the restored state
     */
    restoredContext?: {
      summary: string;
      associatedNotes: string[];
      stateCreatedAt: string;
      originalSessionId: string;
      continuationHistory?: Array<{
        timestamp: number;
        description: string;
      }>;
    };
  };
}
```

## agents/memoryManager/utils/ServiceIntegration.ts

```typescript
/**
 * Location: /src/agents/memoryManager/utils/ServiceIntegration.ts
 * Purpose: Robust service integration patterns for memory manager operations
 * 
 * This utility provides standardized service access patterns with:
 * - Consistent error handling and logging
 * - Service availability validation
 * - Graceful fallback mechanisms
 * - Retry logic and timeout handling
 * - Health monitoring and diagnostics
 * 
 * Used by: All workspace and state management modes for reliable service access
 */

import { App } from 'obsidian';
import { MemoryService } from "../services/MemoryService";
import { WorkspaceService } from '../../../services/WorkspaceService';
import { getErrorMessage } from '../../../utils/errorUtils';
import { getAllPluginIds } from '../../../constants/branding';
import { getNexusPlugin } from '../../../utils/pluginLocator';
import type { NexusPluginBridge } from '../services/ServiceAccessor';

/**
 * Service availability status
 */
export interface ServiceStatus {
  available: boolean;
  initialized: boolean;
  lastError?: string;
  lastCheck: number;
  retryCount: number;
}

/**
 * Service integration configuration
 */
export interface ServiceIntegrationConfig {
  maxRetries: number;
  retryDelayMs: number;
  timeoutMs: number;
  enableHealthCheck: boolean;
  fallbackBehavior: 'fail' | 'warn' | 'silent';
  logLevel: 'debug' | 'info' | 'warn' | 'error';
}

/**
 * Service access result with detailed error information
 */
export interface ServiceAccessResult<T> {
  success: boolean;
  service: T | null;
  error?: string;
  status: ServiceStatus;
  diagnostics?: {
    pluginFound: boolean;
    serviceContainerAvailable: boolean;
    serviceFound: boolean;
    methodUsed: string;
    duration: number;
  };
}

/**
 * Robust service integration utility for memory manager operations
 */
export class ServiceIntegration {
  private static readonly DEFAULT_CONFIG: ServiceIntegrationConfig = {
    maxRetries: 3,
    retryDelayMs: 500,
    timeoutMs: 5000,
    enableHealthCheck: true,
    fallbackBehavior: 'warn',
    logLevel: 'warn'
  };

  private app: App;
  private config: ServiceIntegrationConfig;
  private serviceStatuses: Map<string, ServiceStatus> = new Map();

  constructor(app: App, config: Partial<ServiceIntegrationConfig> = {}) {
    this.app = app;
    this.config = { ...ServiceIntegration.DEFAULT_CONFIG, ...config };
  }

  /**
   * Get memory service with robust error handling and retry logic
   */
  async getMemoryService(): Promise<ServiceAccessResult<MemoryService>> {
    return this.getService<MemoryService>('memoryService', 'MemoryService');
  }

  /**
   * Get workspace service with robust error handling and retry logic
   */
  async getWorkspaceService(): Promise<ServiceAccessResult<WorkspaceService>> {
    return this.getService<WorkspaceService>('workspaceService', 'WorkspaceService');
  }

  /**
   * Get memory service synchronously (for immediate availability checks)
   */
  getMemoryServiceSync(): ServiceAccessResult<MemoryService> {
    return this.getServiceSync<MemoryService>('memoryService', 'MemoryService');
  }

  /**
   * Get workspace service synchronously (for immediate availability checks)
   */
  getWorkspaceServiceSync(): ServiceAccessResult<WorkspaceService> {
    return this.getServiceSync<WorkspaceService>('workspaceService', 'WorkspaceService');
  }

  /**
   * Core service access method with comprehensive error handling
   */
  private async getService<T>(serviceName: string, displayName: string): Promise<ServiceAccessResult<T>> {
    const startTime = Date.now();
    const status = this.getServiceStatus(serviceName);
    
    // If service was recently checked and failed, return cached failure
    if (!status.available && (Date.now() - status.lastCheck) < this.config.retryDelayMs) {
      this.log('debug', `[ServiceIntegration] Using cached failure for ${displayName}`);
      return this.createResult<T>(false, null, status.lastError || 'Service unavailable', status, {
        pluginFound: false,
        serviceContainerAvailable: false,
        serviceFound: false,
        methodUsed: 'cached',
        duration: Date.now() - startTime
      });
    }

    let attempts = 0;
    let lastError = '';

    while (attempts <= this.config.maxRetries) {
      try {
        attempts++;
        this.log('debug', `[ServiceIntegration] Attempting to get ${displayName} (attempt ${attempts}/${this.config.maxRetries + 1})`);

        const plugin = getNexusPlugin<NexusPluginBridge>(this.app);
        if (!plugin) {
          const knownIds = getAllPluginIds().join(`' or '`);
          lastError = `Plugin '${knownIds}' not found`;
          this.log('error', `[ServiceIntegration] ${lastError}`);
          
          if (attempts <= this.config.maxRetries) {
            await this.delay(this.config.retryDelayMs);
            continue;
          }
          break;
        }

        const diagnostics = {
          pluginFound: true,
          serviceContainerAvailable: false,
          serviceFound: false,
          methodUsed: '',
          duration: 0
        };

        // Try ServiceContainer first (preferred method)
        if (plugin.serviceContainer) {
          this.log('debug', `[ServiceIntegration] Trying ServiceContainer for ${displayName}`);
          diagnostics.serviceContainerAvailable = true;
          diagnostics.methodUsed = 'serviceContainer';

          const service = plugin.serviceContainer.getIfReady<T>(serviceName);
          if (service) {
            this.log('debug', `[ServiceIntegration] Successfully got ${displayName} via ServiceContainer`);
            diagnostics.serviceFound = true;
            diagnostics.duration = Date.now() - startTime;
            
            const successStatus = this.updateServiceStatus(serviceName, true, undefined);
            return this.createResult<T>(true, service, undefined, successStatus, diagnostics);
          }
        }

        // Try async getService method
        if (plugin.getService) {
          this.log('debug', `[ServiceIntegration] Trying async getService for ${displayName}`);
          diagnostics.methodUsed = diagnostics.methodUsed ? `${diagnostics.methodUsed}+async` : 'async';

          try {
            const service = await this.withTimeout(plugin.getService<T>(serviceName), this.config.timeoutMs);
            if (service) {
              this.log('debug', `[ServiceIntegration] Successfully got ${displayName} via async method`);
              diagnostics.serviceFound = true;
              diagnostics.duration = Date.now() - startTime;
              
              const successStatus = this.updateServiceStatus(serviceName, true, undefined);
              return this.createResult<T>(true, service, undefined, successStatus, diagnostics);
            }
          } catch (asyncError) {
            this.log('warn', `[ServiceIntegration] Async service access failed for ${displayName}:`, asyncError);
            lastError = getErrorMessage(asyncError);
          }
        }

        // Try direct services access (fallback)
        if (plugin.services && plugin.services[serviceName as keyof typeof plugin.services]) {
          this.log('debug', `[ServiceIntegration] Trying direct services access for ${displayName}`);
          diagnostics.methodUsed = diagnostics.methodUsed ? `${diagnostics.methodUsed}+direct` : 'direct';

          const service = plugin.services[serviceName as keyof typeof plugin.services] as T;
          if (service) {
            this.log('debug', `[ServiceIntegration] Successfully got ${displayName} via direct access`);
            diagnostics.serviceFound = true;
            diagnostics.duration = Date.now() - startTime;
            
            const successStatus = this.updateServiceStatus(serviceName, true, undefined);
            return this.createResult<T>(true, service, undefined, successStatus, diagnostics);
          }
        }

        lastError = `${displayName} not available through any access method`;
        this.log('warn', `[ServiceIntegration] ${lastError} (attempt ${attempts})`);

        if (attempts <= this.config.maxRetries) {
          await this.delay(this.config.retryDelayMs);
        }

      } catch (error) {
        lastError = getErrorMessage(error);
        this.log('error', `[ServiceIntegration] Error accessing ${displayName} (attempt ${attempts}):`, error);
        
        if (attempts <= this.config.maxRetries) {
          await this.delay(this.config.retryDelayMs);
        }
      }
    }

    // All attempts failed
    const failureStatus = this.updateServiceStatus(serviceName, false, lastError);
    const diagnostics = {
      pluginFound: false,
      serviceContainerAvailable: false,
      serviceFound: false,
      methodUsed: 'failed',
      duration: Date.now() - startTime
    };

    this.handleServiceFailure(displayName, lastError, attempts);
    return this.createResult<T>(false, null, lastError, failureStatus, diagnostics);
  }

  /**
   * Synchronous service access for immediate availability checks
   */
  private getServiceSync<T>(serviceName: string, displayName: string): ServiceAccessResult<T> {
    const startTime = Date.now();
    
    try {
      const plugin = getNexusPlugin<NexusPluginBridge>(this.app);
      if (!plugin) {
        const knownIds = getAllPluginIds().join(`' or '`);
        const error = `Plugin '${knownIds}' not found`;
        const status = this.updateServiceStatus(serviceName, false, error);
        return this.createResult<T>(false, null, error, status, {
          pluginFound: false,
          serviceContainerAvailable: false,
          serviceFound: false,
          methodUsed: 'sync',
          duration: Date.now() - startTime
        });
      }

      const diagnostics = {
        pluginFound: true,
        serviceContainerAvailable: !!plugin.serviceContainer,
        serviceFound: false,
        methodUsed: 'sync',
        duration: 0
      };

      // Try ServiceContainer first
      if (plugin.serviceContainer) {
        const service = plugin.serviceContainer.getIfReady<T>(serviceName);
        if (service) {
          diagnostics.serviceFound = true;
          diagnostics.duration = Date.now() - startTime;
          const status = this.updateServiceStatus(serviceName, true, undefined);
          return this.createResult<T>(true, service, undefined, status, diagnostics);
        }
      }

      // Try direct access
      if (plugin.services && plugin.services[serviceName as keyof typeof plugin.services]) {
        const service = plugin.services[serviceName as keyof typeof plugin.services] as T;
        if (service) {
          diagnostics.serviceFound = true;
          diagnostics.methodUsed = 'direct';
          diagnostics.duration = Date.now() - startTime;
          const status = this.updateServiceStatus(serviceName, true, undefined);
          return this.createResult<T>(true, service, undefined, status, diagnostics);
        }
      }

      const error = `${displayName} not available synchronously`;
      const status = this.updateServiceStatus(serviceName, false, error);
      return this.createResult<T>(false, null, error, status, diagnostics);

    } catch (error) {
      const errorMessage = getErrorMessage(error);
      const status = this.updateServiceStatus(serviceName, false, errorMessage);
      return this.createResult<T>(false, null, errorMessage, status, {
        pluginFound: false,
        serviceContainerAvailable: false,
        serviceFound: false,
        methodUsed: 'sync-failed',
        duration: Date.now() - startTime
      });
    }
  }

  /**
   * Get or create service status tracking
   */
  private getServiceStatus(serviceName: string): ServiceStatus {
    if (!this.serviceStatuses.has(serviceName)) {
      this.serviceStatuses.set(serviceName, {
        available: false,
        initialized: false,
        lastCheck: 0,
        retryCount: 0
      });
    }
    return this.serviceStatuses.get(serviceName)!;
  }

  /**
   * Update service status tracking
   */
  private updateServiceStatus(serviceName: string, available: boolean, error?: string): ServiceStatus {
    const status = this.getServiceStatus(serviceName);
    
    status.available = available;
    status.initialized = available;
    status.lastError = error;
    status.lastCheck = Date.now();
    
    if (available) {
      status.retryCount = 0;
    } else {
      status.retryCount++;
    }

    this.serviceStatuses.set(serviceName, status);
    return status;
  }

  /**
   * Create standardized service access result
   */
  private createResult<T>(
    success: boolean,
    service: T | null,
    error?: string,
    status?: ServiceStatus,
    diagnostics?: any
  ): ServiceAccessResult<T> {
    return {
      success,
      service,
      error,
      status: status || {
        available: success,
        initialized: success,
        lastError: error,
        lastCheck: Date.now(),
        retryCount: 0
      },
      diagnostics
    };
  }

  /**
   * Handle service failure with appropriate logging and fallback behavior
   */
  private handleServiceFailure(serviceName: string, error: string, attempts: number): void {
    const message = `${serviceName} unavailable after ${attempts} attempts: ${error}`;
    
    switch (this.config.fallbackBehavior) {
      case 'fail':
        this.log('error', `[ServiceIntegration] CRITICAL: ${message}`);
        break;
      case 'warn':
        this.log('warn', `[ServiceIntegration] WARNING: ${message} - operations will be limited`);
        break;
      case 'silent':
        this.log('debug', `[ServiceIntegration] ${message}`);
        break;
    }
  }

  /**
   * Timeout wrapper for promises
   */
  private withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
    return Promise.race([
      promise,
      new Promise<T>((_, reject) => 
        setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs)
      )
    ]);
  }

  /**
   * Delay utility for retry logic
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Configurable logging
   */
  private log(level: 'debug' | 'info' | 'warn' | 'error', message: string, ...args: any[]): void {
    const levels = { debug: 0, info: 1, warn: 2, error: 3 };
    const configLevel = levels[this.config.logLevel];
    const messageLevel = levels[level];
    
    if (messageLevel >= configLevel) {
      console[level](message, ...args);
    }
  }

  /**
   * Reset service status (for testing or manual intervention)
   */
  resetServiceStatus(serviceName?: string): void {
    if (serviceName) {
      this.serviceStatuses.delete(serviceName);
    } else {
      this.serviceStatuses.clear();
    }
  }

  /**
   * Get comprehensive service diagnostics
   */
  getDiagnostics(): Record<string, ServiceStatus> {
    const diagnostics: Record<string, ServiceStatus> = {};
    
    for (const [serviceName, status] of this.serviceStatuses.entries()) {
      diagnostics[serviceName] = { ...status };
    }
    
    return diagnostics;
  }
}

/**
 * Default service integration instance factory
 * Creates a standard service integration with recommended settings
 */
export function createServiceIntegration(app: App, config?: Partial<ServiceIntegrationConfig>): ServiceIntegration {
  return new ServiceIntegration(app, {
    maxRetries: 2,
    retryDelayMs: 300,
    timeoutMs: 3000,
    enableHealthCheck: true,
    fallbackBehavior: 'warn',
    logLevel: 'warn',
    ...config
  });
}

```

## agents/memoryManager/validators/StateValidator.ts

```typescript
/**
 * Location: /src/agents/memoryManager/validators/StateValidator.ts
 *
 * Purpose: Validates state creation and update parameters
 * Extracted from ValidationService.ts to follow Single Responsibility Principle
 *
 * Used by: State-related modes for parameter validation
 * Dependencies: None
 */

import { ValidationError } from './ValidationTypes';

/**
 * Validator for state operations
 */
export class StateValidator {
  /**
   * Validate state creation parameters
   */
  static validateCreationParams(params: any): ValidationError[] {
    const errors: ValidationError[] = [];

    if (!params.name) {
      errors.push({
        field: 'name',
        value: params.name,
        requirement: 'State name is required and must be a descriptive, non-empty string'
      });
    }

    if (!params.conversationContext) {
      errors.push({
        field: 'conversationContext',
        value: params.conversationContext,
        requirement: 'Conversation context is required. Provide a summary of what was happening when you decided to save this state'
      });
    }

    if (!params.activeTask) {
      errors.push({
        field: 'activeTask',
        value: params.activeTask,
        requirement: 'Active task description is required. Be specific about the current task you were working on'
      });
    }

    if (!params.activeFiles || !Array.isArray(params.activeFiles) || params.activeFiles.length === 0) {
      errors.push({
        field: 'activeFiles',
        value: params.activeFiles,
        requirement: 'Active files list is required. Specify which files were being edited or referenced'
      });
    }

    if (!params.nextSteps || !Array.isArray(params.nextSteps) || params.nextSteps.length === 0) {
      errors.push({
        field: 'nextSteps',
        value: params.nextSteps,
        requirement: 'Next steps are required. Provide specific actionable steps for when you resume'
      });
    }

    if (!params.reasoning) {
      errors.push({
        field: 'reasoning',
        value: params.reasoning,
        requirement: 'Reasoning for saving state is required. Explain why you are saving the state at this point'
      });
    }

    return errors;
  }
}

```

## agents/memoryManager/validators/ValidationTypes.ts

```typescript
/**
 * Location: /src/agents/memoryManager/validators/ValidationTypes.ts
 *
 * Purpose: Shared validation types and interfaces
 * Extracted from ValidationService.ts for reusability
 *
 * Used by: All validators
 * Dependencies: None
 */

/**
 * Validation error structure
 */
export interface ValidationError {
  field: string;
  value: any;
  requirement: string;
}

```

## agents/promptManager/promptManager.ts

```typescript
import { BaseAgent } from '../baseAgent';
import {
  ListPromptsTool,
  GetPromptTool,
  CreatePromptTool,
  UpdatePromptTool,
  ArchivePromptTool,
  ListModelsTool,
  ExecutePromptsTool,
  GenerateImageTool,
  SubagentTool,
} from './tools';
import type { SubagentExecutor } from '../../services/chat/SubagentExecutor';
import type { SubagentToolContext } from './tools/subagent';
import { CustomPromptStorageService } from './services/CustomPromptStorageService';
import { Settings } from '../../settings';
import { sanitizeVaultName } from '../../utils/vaultUtils';
import { LLMProviderManager } from '../../services/llm/providers/ProviderManager';
import { AgentManager } from '../../services/AgentManager';
import { UsageTracker } from '../../services/UsageTracker';
import { Vault, EventRef } from 'obsidian';
import { LLMSettingsNotifier } from '../../services/llm/LLMSettingsNotifier';
import { LLMProviderSettings } from '../../types';

/**
 * PromptManager Agent for custom prompt operations
 */
export class PromptManagerAgent extends BaseAgent {
  /**
   * Custom prompt storage service
   */
  private storageService: CustomPromptStorageService;

  /**
   * Vault name for multi-vault support
   */
  private vaultName: string;

  /**
   * Flag to prevent infinite recursion in description getter
   */
  private isGettingDescription = false;

  /**
   * LLM Provider Manager for model operations
   */
  private readonly providerManager: LLMProviderManager;

  /**
   * Agent Manager for inter-agent communication
   */
  private readonly parentAgentManager: AgentManager;

  /**
   * Usage Tracker for LLM cost tracking
   */
  private readonly usageTracker: UsageTracker;

  /**
   * Vault instance for image generation
   */
  private readonly vault: Vault;

  /**
   * EventRef for settings change listener (Obsidian Events API)
   */
  private settingsEventRef: EventRef | null = null;

  /**
   * Subagent tool - stored for later executor wiring
   */
  private subagentTool: SubagentTool;

  /**
   * Create a new PromptManagerAgent with dependency injection
   * @param settings Settings instance for prompt storage
   * @param providerManager LLM Provider Manager for model operations
   * @param parentAgentManager Agent Manager for inter-agent communication
   * @param usageTracker Usage Tracker for LLM cost tracking
   * @param vault Vault instance for image generation
   */
  constructor(
    settings: Settings,
    providerManager: LLMProviderManager,
    parentAgentManager: AgentManager,
    usageTracker: UsageTracker,
    vault: Vault
  ) {
    super(
      'promptManager',
      'Manage custom prompts for personalized AI interactions',
      '1.0.0'
    );

    // Store injected dependencies
    this.providerManager = providerManager;
    this.parentAgentManager = parentAgentManager;
    this.usageTracker = usageTracker;
    this.vault = vault;

    this.storageService = new CustomPromptStorageService(settings);
    this.vaultName = sanitizeVaultName(vault.getName());

    // Register prompt management tools
    this.registerTool(new ListPromptsTool(this.storageService));
    this.registerTool(new GetPromptTool(this.storageService));
    this.registerTool(new CreatePromptTool(this.storageService));
    this.registerTool(new UpdatePromptTool(this.storageService));
    this.registerTool(new ArchivePromptTool(this.storageService));

    // Register LLM tools with dependencies already available
    this.registerTool(new ListModelsTool(this.providerManager));

    // Register unified prompt execution tool (handles single and batch)
    this.registerTool(new ExecutePromptsTool(
      undefined, // plugin - not needed in constructor injection pattern
      this.providerManager.getLLMService(), // Get LLM service from provider manager
      this.providerManager,
      this.parentAgentManager,
      this.storageService
    ));

    // Register image generation tool only if Google or OpenRouter API keys are configured
    const llmProviders = settings.settings.llmProviders;
    const hasGoogleKey = llmProviders?.providers?.google?.apiKey && llmProviders?.providers?.google?.enabled;
    const hasOpenRouterKey = llmProviders?.providers?.openrouter?.apiKey && llmProviders?.providers?.openrouter?.enabled;

    if (hasGoogleKey || hasOpenRouterKey) {
      this.registerTool(new GenerateImageTool({
        vault: this.vault,
        llmSettings: llmProviders
      }));
    }

    // Register subagent tool (internal chat only - executor wired up separately)
    // Supports both spawn and cancel actions via action parameter
    this.subagentTool = new SubagentTool();
    this.registerTool(this.subagentTool);

    // Subscribe to settings changes to dynamically register/unregister tools (Obsidian Events API)
    this.settingsEventRef = LLMSettingsNotifier.onSettingsChanged((newSettings) => {
      this.handleSettingsChange(newSettings);
    });
  }

  /**
   * Handle LLM provider settings changes
   * Dynamically registers/unregisters GenerateImageTool based on API key availability
   */
  private handleSettingsChange(settings: LLMProviderSettings): void {
    const hasGoogleKey = settings.providers?.google?.apiKey && settings.providers?.google?.enabled;
    const hasOpenRouterKey = settings.providers?.openrouter?.apiKey && settings.providers?.openrouter?.enabled;
    const shouldHaveGenerateImage = hasGoogleKey || hasOpenRouterKey;
    const hasGenerateImage = this.hasTool('generateImage');

    if (shouldHaveGenerateImage && !hasGenerateImage) {
      // Register the tool - API key now available
      this.registerTool(new GenerateImageTool({
        vault: this.vault,
        llmSettings: settings
      }));
    } else if (!shouldHaveGenerateImage && hasGenerateImage) {
      // Unregister the tool - API key removed
      this.unregisterTool('generateImage');
    } else if (shouldHaveGenerateImage && hasGenerateImage) {
      // Update the existing tool with new settings
      this.unregisterTool('generateImage');
      this.registerTool(new GenerateImageTool({
        vault: this.vault,
        llmSettings: settings
      }));
    }
  }

  /**
   * Clean up resources when the agent is unloaded
   */
  onunload(): void {
    // Unsubscribe from settings changes (Obsidian Events API)
    if (this.settingsEventRef) {
      LLMSettingsNotifier.unsubscribe(this.settingsEventRef);
      this.settingsEventRef = null;
    }
  }

  /**
   * Dynamic description that includes information about custom prompts
   */
  get description(): string {
    const baseDescription = 'Manage custom prompts for personalized AI interactions';

    // Prevent infinite recursion
    if (this.isGettingDescription) {
      return `[${this.vaultName}] ${baseDescription}`;
    }

    this.isGettingDescription = true;
    try {
      const customPromptsContext = this.getPromptsSummary();
      return `[${this.vaultName}] ${baseDescription}\n\n${customPromptsContext}`;
    } finally {
      this.isGettingDescription = false;
    }
  }
  
  /**
   * Get the storage service for direct access if needed
   * @returns CustomPromptStorageService instance
   */
  getStorageService(): CustomPromptStorageService {
    return this.storageService;
  }

  /**
   * Get the LLM Provider Manager
   * @returns LLM Provider Manager instance
   */
  getProviderManager(): LLMProviderManager {
    return this.providerManager;
  }

  /**
   * Get the Usage Tracker
   * @returns Usage Tracker instance
   */
  getUsageTracker(): UsageTracker {
    return this.usageTracker;
  }

  /**
   * Get the parent Agent Manager
   * @returns Agent Manager instance
   */
  getParentAgentManager(): AgentManager {
    return this.parentAgentManager;
  }

  /**
   * Get the Vault instance
   * @returns Vault instance
   */
  getVault(): Vault {
    return this.vault;
  }

  /**
   * Wire up the SubagentExecutor to the subagent tool
   * Called after the executor is created (typically in ChatView or ChatService)
   * @param executor The SubagentExecutor instance
   * @param contextProvider Function that provides execution context
   */
  setSubagentExecutor(
    executor: SubagentExecutor,
    contextProvider: () => SubagentToolContext
  ): void {
    this.subagentTool.setSubagentExecutor(executor);
    this.subagentTool.setContextProvider(contextProvider);
  }

  /**
   * Get the SubagentTool instance for external access
   * @returns SubagentTool instance
   */
  getSubagentTool(): SubagentTool {
    return this.subagentTool;
  }

  /**
   * Get a summary of all available custom prompts
   * @returns Formatted string with custom prompt information
   * @private
   */
  private getPromptsSummary(): string {
    try {
      // Check if storage service is available
      if (!this.storageService) {
        return `Custom Prompts: Storage service not available`;
      }

      // Check if custom prompts feature is enabled
      if (!this.storageService.isEnabled()) {
        return `Custom Prompts: Custom prompts feature is disabled`;
      }

      // Get all custom prompts
      const customPrompts = this.storageService.getAllPrompts();

      if (!customPrompts || customPrompts.length === 0) {
        return `Custom Prompts: No custom prompts created yet`;
      }

      const enabledCount = customPrompts.filter(prompt => prompt.isEnabled).length;
      const promptSummary = [`Custom Prompts (${customPrompts.length} total, ${enabledCount} enabled):`];

      for (const prompt of customPrompts) {
        const status = prompt.isEnabled ? 'âœ…' : 'âŒ';
        const description = prompt.description || 'No description provided';
        promptSummary.push(`   ${status} ${prompt.name}: ${description}`);
      }

      return promptSummary.join('\n');
    } catch (error) {
      return `Custom Prompts: Error loading custom prompts (${error})`;
    }
  }
}
```

## agents/promptManager/services/CustomPromptStorageService.ts

```typescript
import { CustomPrompt, CustomPromptsSettings, DEFAULT_CUSTOM_PROMPTS_SETTINGS } from '../../../types';
import { Settings } from '../../../settings';

/**
 * Service for managing custom prompt storage and persistence
 * Handles CRUD operations for custom prompts within plugin settings
 */
export class CustomPromptStorageService {
    private settings: Settings;

    constructor(settings: Settings) {
        this.settings = settings;
    }

    /**
     * Get all custom prompts
     * @returns Array of all custom prompts
     */
    getAllPrompts(): CustomPrompt[] {
        this.ensureCustomPromptsSettings();
        return this.settings.settings.customPrompts?.prompts || [];
    }

    /**
     * Get enabled custom prompts only
     * @returns Array of enabled custom prompts
     */
    getEnabledPrompts(): CustomPrompt[] {
        return this.getAllPrompts().filter(prompt => prompt.isEnabled);
    }

    /**
     * Get a specific prompt by name or ID (unified lookup)
     * Tries ID lookup first (more specific), then falls back to name lookup
     * @param identifier Prompt name or ID
     * @returns Custom prompt or undefined if not found
     */
    getPromptByNameOrId(identifier: string): CustomPrompt | undefined {
        const prompts = this.getAllPrompts();
        // Try ID lookup first (more specific)
        const byId = prompts.find(prompt => prompt.id === identifier);
        if (byId) {
            return byId;
        }
        // Fall back to name lookup
        return prompts.find(prompt => prompt.name === identifier);
    }

    /**
     * Find prompt by name (internal use for duplicate checking)
     */
    private findByName(name: string): CustomPrompt | undefined {
        return this.getAllPrompts().find(prompt => prompt.name === name);
    }

    /**
     * Create a new custom prompt
     * @param prompt Prompt data (without id - will be generated)
     * @returns Created prompt with generated ID
     * @throws Error if prompt name already exists
     */
    async createPrompt(promptData: Omit<CustomPrompt, 'id'>): Promise<CustomPrompt> {
        this.ensureCustomPromptsSettings();
        
        // Check for duplicate names
        if (this.findByName(promptData.name)) {
            throw new Error(`A prompt with the name "${promptData.name}" already exists`);
        }

        // Generate unique ID
        const id = this.generateId();
        
        // Create the new prompt
        const newPrompt: CustomPrompt = {
            id,
            ...promptData
        };

        // Add to prompts array
        this.settings.settings.customPrompts!.prompts.push(newPrompt);
        
        // Save settings
        await this.settings.saveSettings();
        
        return newPrompt;
    }

    /**
     * Update an existing custom prompt
     * @param id Prompt ID
     * @param updates Partial prompt data to update
     * @returns Updated prompt
     * @throws Error if prompt not found or name conflict
     */
    async updatePrompt(id: string, updates: Partial<Omit<CustomPrompt, 'id'>>): Promise<CustomPrompt> {
        this.ensureCustomPromptsSettings();
        
        const prompts = this.settings.settings.customPrompts!.prompts;
        const index = prompts.findIndex(prompt => prompt.id === id);
        
        if (index === -1) {
            throw new Error(`Prompt with ID "${id}" not found`);
        }

        // Check for name conflicts if name is being updated
        if (updates.name && updates.name !== prompts[index].name) {
            const existingPrompt = this.findByName(updates.name);
            if (existingPrompt && existingPrompt.id !== id) {
                throw new Error(`A prompt with the name "${updates.name}" already exists`);
            }
        }

        // Update the prompt
        prompts[index] = {
            ...prompts[index],
            ...updates
        };

        // Save settings
        await this.settings.saveSettings();
        
        return prompts[index];
    }

    /**
     * Delete a custom prompt
     * @param id Prompt ID
     * @returns True if deleted, false if not found
     */
    async deletePrompt(id: string): Promise<boolean> {
        this.ensureCustomPromptsSettings();
        
        const prompts = this.settings.settings.customPrompts!.prompts;
        const index = prompts.findIndex(prompt => prompt.id === id);
        
        if (index === -1) {
            return false;
        }

        // Remove the prompt
        prompts.splice(index, 1);
        
        // Save settings
        await this.settings.saveSettings();
        
        return true;
    }

    /**
     * Toggle enabled state of a prompt
     * @param id Prompt ID
     * @returns Updated prompt
     * @throws Error if prompt not found
     */
    async togglePrompt(id: string): Promise<CustomPrompt> {
        const prompt = this.getPromptByNameOrId(id);
        if (!prompt) {
            throw new Error(`Prompt "${id}" not found (searched by both name and ID)`);
        }

        return await this.updatePrompt(prompt.id, { isEnabled: !prompt.isEnabled });
    }

    /**
     * Check if custom prompts are enabled globally
     * @returns True if enabled
     */
    isEnabled(): boolean {
        this.ensureCustomPromptsSettings();
        return this.settings.settings.customPrompts?.enabled || false;
    }

    /**
     * Enable or disable custom prompts globally
     * @param enabled Whether to enable custom prompts
     */
    async setEnabled(enabled: boolean): Promise<void> {
        this.ensureCustomPromptsSettings();
        this.settings.settings.customPrompts!.enabled = enabled;
        await this.settings.saveSettings();
    }

    /**
     * Ensure custom prompts settings exist with defaults
     */
    private ensureCustomPromptsSettings(): void {
        if (!this.settings.settings.customPrompts) {
            this.settings.settings.customPrompts = { ...DEFAULT_CUSTOM_PROMPTS_SETTINGS };
        }
    }

    /**
     * Generate a unique ID for a prompt
     * @returns Unique string ID
     */
    private generateId(): string {
        return `prompt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }
}
```

## agents/promptManager/services/index.ts

```typescript
/**
 * Agent Manager Services Exports
 */

export { CustomPromptStorageService } from './CustomPromptStorageService';
```

## agents/promptManager/tools/archivePrompt.ts

```typescript
import { BaseTool } from '../../baseTool';
import { ArchivePromptParams, ArchivePromptResult } from '../types';
import { CustomPromptStorageService } from '../services/CustomPromptStorageService';

/**
 * Tool for archiving a custom prompt
 *
 * Location: src/agents/promptManager/tools/archivePrompt.ts
 *
 * Functionality: Sets isEnabled flag to false on a prompt, making it disappear from
 * active listings while preserving its configuration for potential restoration.
 *
 * Relationships:
 * - Uses CustomPromptStorageService to update prompt enabled status
 * - Prompt can be restored via updatePrompt tool with isEnabled: true
 * - Integrates with listPrompts tool which filters archived prompts by default
 */
export class ArchivePromptTool extends BaseTool<ArchivePromptParams, ArchivePromptResult> {
  private storageService: CustomPromptStorageService;

  /**
   * Create a new ArchivePromptTool
   * @param storageService Custom prompt storage service
   */
  constructor(storageService: CustomPromptStorageService) {
    super(
      'archivePrompt',
      'Archive Prompt',
      'Archive a custom prompt by disabling it (preserves configuration for restoration)',
      '1.0.0'
    );

    this.storageService = storageService;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise that resolves with archive result
   */
  async execute(params: ArchivePromptParams): Promise<ArchivePromptResult> {
    try {
      const { name } = params;

      // Validate required name
      if (!name?.trim()) {
        return this.prepareResult(false, undefined, 'Prompt name is required');
      }

      // Check if prompt exists (unified lookup by ID or name)
      const existingPrompt = this.storageService.getPromptByNameOrId(name.trim());
      if (!existingPrompt) {
        return this.prepareResult(false, undefined, `Prompt "${name}" not found. Use listPrompts to see available prompts.`);
      }

      // Archive the prompt by setting isEnabled to false
      await this.storageService.updatePrompt(existingPrompt.id, { isEnabled: false });

      // Success - LLM already knows what it archived
      return this.prepareResult(true);
    } catch (error) {
      return this.prepareResult(false, undefined, `Failed to archive prompt: ${error}`);
    }
  }

  /**
   * Get the JSON schema for the tool's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const toolSchema = {
      type: 'object',
      properties: {
        name: {
          type: 'string',
          description: 'Name or ID of the prompt to archive. Prompt will be disabled but configuration preserved for restoration via updatePrompt.',
          minLength: 1
        }
      },
      required: ['name']
    };

    return this.getMergedSchema(toolSchema);
  }

  getResultSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean', description: 'Whether the operation succeeded' },
        error: { type: 'string', description: 'Error message if failed (includes recovery guidance)' }
      },
      required: ['success']
    };
  }
}

```

## agents/promptManager/tools/createPrompt.ts

```typescript
import { BaseTool } from '../../baseTool';
import { CreatePromptParams, CreatePromptResult } from '../types';
import { CustomPromptStorageService } from '../services/CustomPromptStorageService';

/**
 * Tool for creating a new custom prompt
 */
export class CreatePromptTool extends BaseTool<CreatePromptParams, CreatePromptResult> {
  private storageService: CustomPromptStorageService;

  /**
   * Create a new CreatePromptTool
   * @param storageService Custom prompt storage service
   */
  constructor(storageService: CustomPromptStorageService) {
    super(
      'createPrompt',
      'Create Prompt',
      'Create a new custom prompt',
      '1.0.0'
    );

    this.storageService = storageService;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise that resolves with the created prompt
   */
  async execute(params: CreatePromptParams): Promise<CreatePromptResult> {
    try {
      const { name, description, prompt, isEnabled = true } = params;

      // Validate required fields
      if (!name?.trim()) {
        return this.prepareResult(false, undefined, 'Name is required');
      }

      if (!description?.trim()) {
        return this.prepareResult(false, undefined, 'Description is required');
      }

      if (!prompt?.trim()) {
        return this.prepareResult(false, undefined, 'Prompt text is required');
      }

      // Create the prompt
      await this.storageService.createPrompt({
        name: name.trim(),
        description: description.trim(),
        prompt: prompt.trim(),
        isEnabled
      });

      // Success - LLM already knows what it passed
      return this.prepareResult(true);
    } catch (error) {
      return this.prepareResult(false, undefined, `Failed to create prompt: ${error}`);
    }
  }

  /**
   * Get the JSON schema for the tool's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const toolSchema = {
      type: 'object',
      properties: {
        name: {
          type: 'string',
          description: 'Name of the prompt (must be unique)',
          minLength: 1,
          maxLength: 100
        },
        description: {
          type: 'string',
          description: 'Description of what this prompt does',
          minLength: 1,
          maxLength: 500
        },
        prompt: {
          type: 'string',
          description: 'The actual prompt text/persona',
          minLength: 1
        },
        isEnabled: {
          type: 'boolean',
          description: 'Whether the prompt is enabled',
          default: true
        }
      },
      required: ['name', 'description', 'prompt']
    };

    return this.getMergedSchema(toolSchema);
  }

  getResultSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean', description: 'Whether the operation succeeded' },
        error: { type: 'string', description: 'Error message if failed (includes recovery guidance)' }
      },
      required: ['success']
    };
  }
}

```

## agents/promptManager/tools/executePrompts/executePrompts.ts

```typescript
import { Plugin } from 'obsidian';
import { BaseTool } from '../../../baseTool';
import { getErrorMessage } from '../../../../utils/errorUtils';
import { createResult } from '../../../../utils/schemaUtils';
import { LLMProviderManager } from '../../../../services/llm/providers/ProviderManager';
import { LLMService } from '../../../../services/llm/core/LLMService';
import { AgentManager } from '../../../../services/AgentManager';
import { CustomPromptStorageService } from '../../services/CustomPromptStorageService';
import { UsageTracker } from '../../../../services/UsageTracker';

// Import refactored services and types
import {
  BatchExecutePromptParams,
  BatchExecutePromptResult,
  PromptConfig,
  ExecutionContext
} from './types';
import {
  BudgetValidator,
  ContextBuilder,
  PromptExecutor,
  RequestExecutor,
  SequenceManager,
  ResultProcessor,
  ActionExecutor
} from './services';
import { PromptParser } from './utils';
import { addRecommendations, Recommendation } from '../../../../utils/recommendationUtils';
import { NudgeHelpers } from '../../../../utils/nudgeHelpers';

/**
 * ExecutePromptsTool - Execute one or more LLM prompts
 * For single prompt: pass one item in prompts array
 * For multiple: supports sequencing, parallel groups, and result forwarding
 *
 * Responsibilities:
 * - Orchestrate prompt execution workflow
 * - Coordinate specialized services
 * - Handle high-level error management
 */
export class ExecutePromptsTool extends BaseTool<BatchExecutePromptParams, BatchExecutePromptResult> {
  // Core services (injected)
  private llmService: LLMService | null = null;
  private providerManager: LLMProviderManager | null = null;
  private agentManager: AgentManager | null = null;
  private promptStorage: CustomPromptStorageService | null = null;
  private usageTracker: UsageTracker | null = null;

  // Specialized services (composition)
  private budgetValidator!: BudgetValidator;
  private contextBuilder!: ContextBuilder;
  private promptExecutor!: PromptExecutor;
  private requestExecutor!: RequestExecutor;
  private sequenceManager!: SequenceManager;
  private resultProcessor!: ResultProcessor;
  private actionExecutor!: ActionExecutor;
  
  // Utilities
  private promptParser!: PromptParser;

  constructor(
    plugin?: Plugin,
    llmService?: LLMService,
    providerManager?: LLMProviderManager,
    agentManager?: AgentManager,
    promptStorage?: CustomPromptStorageService
  ) {
    super(
      'executePrompts',
      'Execute LLM Prompts',
      'Execute one or more LLM prompts. For single: pass one item. For multiple: supports sequencing (sequence: 0,1,2), parallel groups, and result forwarding (includePreviousResults: true).',
      '1.0.0'
    );
    
    // Store injected dependencies
    this.llmService = llmService || null;
    this.providerManager = providerManager || null;
    this.agentManager = agentManager || null;
    this.promptStorage = promptStorage || null;

    // Initialize specialized services
    this.initializeServices();
  }

  /**
   * Wait for dependencies to be initialized
   * @param timeoutMs Maximum time to wait in milliseconds
   * @private
   */
  private async waitForDependencies(timeoutMs: number): Promise<void> {
    const startTime = Date.now();
    const checkInterval = 100; // Check every 100ms
    
    while (Date.now() - startTime < timeoutMs) {
      if (this.llmService && this.providerManager && this.promptStorage) {
        return;
      }
      
      // Wait for the next check
      await new Promise(resolve => setTimeout(resolve, checkInterval));
    }
  }

  /**
   * Initialize all specialized services following dependency injection patterns
   */
  private initializeServices(): void {
    // Initialize utilities
    this.promptParser = new PromptParser();

    // Initialize core services
    this.budgetValidator = new BudgetValidator(this.usageTracker || undefined);
    this.contextBuilder = new ContextBuilder();
    this.actionExecutor = new ActionExecutor(this.agentManager || undefined);

    // PromptExecutor requires LLM service, so we'll initialize it in execute() if needed
    // Same for SequenceManager and ResultProcessor
    this.resultProcessor = new ResultProcessor();
  }

  /**
   * Ensure request executor is initialized with all dependencies
   */
  private ensureRequestExecutor(): void {
    if (!this.promptExecutor && this.llmService) {
      this.promptExecutor = new PromptExecutor(
        this.llmService,
        this.budgetValidator,
        this.contextBuilder,
        this.promptStorage || undefined
      );
    }

    if (!this.requestExecutor && this.promptExecutor && this.actionExecutor) {
      this.requestExecutor = new RequestExecutor(
        this.promptExecutor,
        this.actionExecutor
      );

      this.sequenceManager = new SequenceManager(
        this.requestExecutor,
        this.contextBuilder
      );
    }
  }

  /**
   * Execute multiple LLM prompts with orchestrated workflow
   */
  async execute(params: BatchExecutePromptParams): Promise<BatchExecutePromptResult> {
    try {
      // Try to wait for dependencies if not available
      if (!this.llmService || !this.providerManager || !this.promptStorage) {
        await this.waitForDependencies(3000);
      }
      
      // Validate dependencies
      if (!this.llmService) {
        return createResult<BatchExecutePromptResult>(
          false, undefined, 'LLM Service not initialized'
        );
      }

      if (!this.providerManager) {
        return createResult<BatchExecutePromptResult>(
          false, undefined, 'LLM Provider Manager not initialized. Please ensure you have configured at least one LLM provider with valid API keys.'
        );
      }

      if (!this.promptStorage) {
        return createResult<BatchExecutePromptResult>(
          false, undefined, 'Prompt storage service not initialized'
        );
      }

      // Ensure specialized services are ready
      this.ensureRequestExecutor();
      if (!this.requestExecutor || !this.sequenceManager) {
        return createResult<BatchExecutePromptResult>(
          false, undefined, 'Failed to initialize execution services'
        );
      }

      // Validate parameters using utility
      const validation = this.promptParser.validateParameters(params);
      if (!validation.valid) {
        return createResult<BatchExecutePromptResult>(
          false, undefined, `Parameter validation failed: ${validation.errors.join(', ')}`
        );
      }

      const startTime = performance.now();
      
      // Normalize prompt configurations
      const normalizedPrompts = this.promptParser.normalizePromptConfigs(params.prompts);

      // Initialize execution context with default values
      const executionContext = this.contextBuilder.initializeExecutionContext(
        'default',
        ''
      );

      // Execute prompts with sequence and parallel group support
      const results = await this.sequenceManager.executePromptsWithSequencing(
        normalizedPrompts,
        executionContext
      );
      
      // Process actions for results that have them
      await this.processResultActions(results, normalizedPrompts, params);
      
      const totalExecutionTime = performance.now() - startTime;
      
      // Process and format final results
      const processedResults = this.resultProcessor.processResults(
        results,
        params.mergeResponses || false,
        totalExecutionTime,
        params.prompts.length
      );
      
      const result = createResult<BatchExecutePromptResult>(
        processedResults.success,
        processedResults,
        processedResults.error
      );

      // Dynamic nudges based on operation count
      const nudges: Recommendation[] = [NudgeHelpers.suggestCaptureProgress()];
      const batchNudge = NudgeHelpers.checkBatchAgentOpportunity(processedResults.results?.length || 0);
      if (batchNudge) nudges.push(batchNudge);

      return addRecommendations(result, nudges);

    } catch (error) {
      console.error('Batch LLM prompt execution failed:', error);
      return createResult<BatchExecutePromptResult>(
        false,
        undefined,
        `Batch execution failed: ${getErrorMessage(error)}`
      );
    }
  }

  /**
   * Process content actions for results that specify them
   */
  private async processResultActions(
    results: any[],
    promptConfigs: PromptConfig[],
    params: BatchExecutePromptParams
  ): Promise<void> {
    for (let i = 0; i < results.length; i++) {
      const result = results[i];
      const promptConfig = promptConfigs.find(p => p.id === result.id) || promptConfigs[i];
      
      // Only process actions for text results
      if (promptConfig?.type === 'text' && 'action' in promptConfig && promptConfig.action && 
          result.success && result.type === 'text' && result.response) {
        try {
          const actionResult = await this.actionExecutor.executeContentAction(
            promptConfig.action,
            result.response,
            'default',
            ''
          );

          result.actionPerformed = {
            type: promptConfig.action.type,
            targetPath: promptConfig.action.targetPath,
            success: actionResult.success,
            error: actionResult.error
          };
        } catch (actionError) {
          result.actionPerformed = {
            type: promptConfig.action.type,
            targetPath: promptConfig.action.targetPath,
            success: false,
            error: actionError instanceof Error ? actionError.message : 'Unknown action error'
          };
        }
      }
    }
  }

  /**
   * Set the LLM service instance
   */
  setLLMService(llmService: LLMService): void {
    this.llmService = llmService;
  }

  /**
   * Set the usage tracker for LLM cost tracking
   */
  setUsageTracker(usageTracker: UsageTracker): void {
    this.usageTracker = usageTracker;
    this.budgetValidator = new BudgetValidator(usageTracker);
  }

  /**
   * Set the provider manager instance
   */
  setProviderManager(providerManager: LLMProviderManager): void {
    this.providerManager = providerManager;
    
    // Get LLM service from provider manager if we don't have one
    if (!this.llmService && providerManager) {
      this.llmService = providerManager.getLLMService();
    }
  }

  /**
   * Set the agent manager for action execution
   */
  setAgentManager(agentManager: AgentManager): void {
    this.agentManager = agentManager;
    this.actionExecutor = new ActionExecutor(agentManager);
  }

  /**
   * Set the prompt storage for custom agent support
   */
  setPromptStorage(promptStorage: CustomPromptStorageService): void {
    this.promptStorage = promptStorage;
  }

  /**
   * Get parameter schema for MCP tool definition
   */
  getParameterSchema(): any {
    // Get default from data.json settings
    const defaultModel = this.providerManager?.getSettings()?.defaultModel;
    
    const toolSchema = {
      properties: {
        prompts: {
          type: 'array',
          description: 'Array of text and/or image generation requests to execute in batch',
          minItems: 1,
          maxItems: 100,
          items: {
            type: 'object',
            properties: {
              type: {
                type: 'string',
                enum: ['text', 'image'],
                description: 'Type of request: "text" for LLM prompts, "image" for AI image generation'
              },
              id: {
                type: 'string',
                description: 'Optional unique identifier for this request'
              },
              prompt: {
                type: 'string',
                description: 'Text prompt (for LLM) or image description (for image generation)',
                minLength: 1,
                maxLength: 32000
              },
              sequence: {
                type: 'integer',
                minimum: 0,
                description: 'Execution sequence (0, 1, 2, etc.). Requests in same sequence run in parallel'
              },
              parallelGroup: {
                type: 'string',
                description: 'Parallel group identifier within sequence. Different groups run sequentially'
              },
              includePreviousResults: {
                type: 'boolean',
                description: 'Include results from previous sequences as context'
              },
              contextFromSteps: {
                type: 'array',
                items: { type: 'string' },
                description: 'Specific request IDs to include as context'
              },
              // Text-specific properties
              provider: {
                type: 'string',
                description: `LLM provider (defaults to: ${defaultModel?.provider || 'not configured'}). For images, use "google". Use listModels to see available providers.`,
                default: defaultModel?.provider
              },
              model: {
                type: 'string',
                description: `Model name (defaults to: ${defaultModel?.model || 'not configured'}). Use listModels to see available models.`,
                default: defaultModel?.model
              },
              contextFiles: {
                type: 'array',
                items: { type: 'string' },
                description: 'File paths to include as context (text requests only)'
              },
              workspace: {
                type: 'string',
                description: 'Workspace name for context gathering (text requests only)'
              },
              action: {
                type: 'object',
                description: 'Content action to perform with LLM response (text requests only)',
                properties: {
                  type: {
                    type: 'string',
                    enum: ['create', 'append', 'prepend', 'replace', 'findReplace']
                  },
                  targetPath: { type: 'string' },
                  findText: { type: 'string' },
                  replaceAll: { type: 'boolean' },
                  caseSensitive: { type: 'boolean' },
                  wholeWord: { type: 'boolean' }
                },
                required: ['type', 'targetPath']
              },
              customPrompt: {
                type: 'string',
                description: 'Custom prompt name or ID to use (text requests only). Use listPrompts to see available prompts.'
              },
              // Image-specific properties
              savePath: {
                type: 'string',
                description: 'Vault-relative path to save generated image (image requests only)',
                pattern: '^[^/].*\\.(png|jpg|jpeg|webp)$'
              },
              aspectRatio: {
                type: 'string',
                description: 'Image aspect ratio (image requests only)',
                enum: ['1:1', '3:4', '4:3', '9:16', '16:9'],
                default: '1:1'
              }
            },
            required: ['type', 'prompt', 'provider', 'model'],
            allOf: [
              {
                if: { properties: { type: { const: 'image' } } },
                then: {
                  required: ['savePath'],
                  properties: {
                    provider: { const: 'google' }
                  }
                }
              }
            ]
          }
        },
        mergeResponses: {
          type: 'boolean',
          description: 'Whether to merge all responses into a single result',
          default: false
        }
      },
      required: ['prompts']
    };
    
    return this.getMergedSchema(toolSchema);
  }

  /**
   * Get result schema for MCP tool definition (lean format)
   * Type inferred from fields: response/savedTo = text, imagePath = image
   */
  getResultSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean' },
        results: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              success: { type: 'boolean' },
              response: { type: 'string', description: 'Text response (omitted if saved)' },
              savedTo: { type: 'string', description: 'Path where text was saved' },
              imagePath: { type: 'string', description: 'Path where image was saved' },
              error: { type: 'string' }
            },
            required: ['success']
          }
        },
        merged: { type: 'string', description: 'Combined response (if mergeResponses: true)' },
        error: { type: 'string' }
      },
      required: ['success']
    };
  }
}
```

## agents/promptManager/tools/executePrompts/index.ts

```typescript
// Re-export all components for easy importing
export * from './types';
export * from './services';
export * from './utils';
export { ExecutePromptsTool } from './executePrompts';

```

## agents/promptManager/tools/executePrompts/services/ActionExecutor.ts

```typescript
import { AgentManager } from '../../../../../services/AgentManager';
import { ContentAction, ImagePromptConfig } from '../types';
import { CommonResult } from '../../../../../types';

/**
 * Type guard to verify a value conforms to CommonResult interface
 * This allows safe narrowing from unknown returns of executeAgentTool
 */
function isCommonResult(value: unknown): value is CommonResult {
  return (
    typeof value === 'object' &&
    value !== null &&
    'success' in value &&
    typeof (value as CommonResult).success === 'boolean'
  );
}

/**
 * Service responsible for executing content actions with LLM responses
 * Follows SRP by focusing only on action execution logic
 */
export class ActionExecutor {
  constructor(private agentManager?: AgentManager) {}

  /**
   * Execute a ContentManager action with the LLM response
   */
  async executeContentAction(
    action: ContentAction,
    content: string,
    sessionId?: string,
    context?: string
  ): Promise<{ success: boolean; error?: string }> {
    if (!this.agentManager) {
      return { success: false, error: 'Agent manager not available' };
    }

    try {
      const actionParams: Record<string, unknown> = {
        sessionId: sessionId || '',
        context: context || '',
        content
      };

      switch (action.type) {
        case 'create':
          return await this.executeCreateAction(actionParams, action);
        case 'append':
          return await this.executeAppendAction(actionParams, action);
        case 'prepend':
          return await this.executePrependAction(actionParams, action);
        case 'replace':
          return await this.executeReplaceAction(actionParams, action);
        case 'findReplace':
          return await this.executeFindReplaceAction(actionParams, action);
        default:
          return { success: false, error: `Unknown action type: ${action.type}` };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error executing action'
      };
    }
  }

  /**
   * Execute create content action
   */
  private async executeCreateAction(
    actionParams: Record<string, unknown>,
    action: ContentAction
  ): Promise<{ success: boolean; error?: string }> {
    actionParams.filePath = action.targetPath;
    const createResult = await this.agentManager!.executeAgentTool('contentManager', 'createContent', actionParams);
    if (!isCommonResult(createResult)) {
      return { success: false, error: 'Invalid response from createContent tool' };
    }
    return { success: createResult.success, error: createResult.error };
  }

  /**
   * Execute append content action
   */
  private async executeAppendAction(
    actionParams: Record<string, unknown>,
    action: ContentAction
  ): Promise<{ success: boolean; error?: string }> {
    actionParams.filePath = action.targetPath;
    const appendResult = await this.agentManager!.executeAgentTool('contentManager', 'appendContent', actionParams);
    if (!isCommonResult(appendResult)) {
      return { success: false, error: 'Invalid response from appendContent tool' };
    }
    return { success: appendResult.success, error: appendResult.error };
  }

  /**
   * Execute prepend content action
   */
  private async executePrependAction(
    actionParams: Record<string, unknown>,
    action: ContentAction
  ): Promise<{ success: boolean; error?: string }> {
    actionParams.filePath = action.targetPath;
    const prependResult = await this.agentManager!.executeAgentTool('contentManager', 'prependContent', actionParams);
    if (!isCommonResult(prependResult)) {
      return { success: false, error: 'Invalid response from prependContent tool' };
    }
    return { success: prependResult.success, error: prependResult.error };
  }

  /**
   * Execute replace content action
   */
  private async executeReplaceAction(
    actionParams: Record<string, unknown>,
    action: ContentAction
  ): Promise<{ success: boolean; error?: string }> {
    actionParams.filePath = action.targetPath;
    let replaceResult: unknown;

    if (action.position !== undefined) {
      actionParams.line = action.position;
      replaceResult = await this.agentManager!.executeAgentTool('contentManager', 'replaceByLine', actionParams);
    } else {
      replaceResult = await this.agentManager!.executeAgentTool('contentManager', 'replaceContent', actionParams);
    }

    if (!isCommonResult(replaceResult)) {
      return { success: false, error: 'Invalid response from replace tool' };
    }
    return { success: replaceResult.success, error: replaceResult.error };
  }

  /**
   * Execute find and replace content action
   */
  private async executeFindReplaceAction(
    actionParams: Record<string, unknown>,
    action: ContentAction
  ): Promise<{ success: boolean; error?: string }> {
    if (!action.findText) {
      return { success: false, error: 'findText is required for findReplace action' };
    }

    actionParams.filePath = action.targetPath;
    actionParams.findText = action.findText;
    actionParams.replaceText = actionParams.content; // LLM response becomes the replacement text
    actionParams.replaceAll = action.replaceAll ?? false;
    actionParams.caseSensitive = action.caseSensitive ?? true;
    actionParams.wholeWord = action.wholeWord ?? false;

    const findReplaceResult = await this.agentManager!.executeAgentTool('contentManager', 'findReplaceContent', actionParams);
    if (!isCommonResult(findReplaceResult)) {
      return { success: false, error: 'Invalid response from findReplaceContent tool' };
    }
    return { success: findReplaceResult.success, error: findReplaceResult.error };
  }

  /**
   * Validate action configuration
   */
  validateAction(action: ContentAction): { valid: boolean; error?: string } {
    if (!action.type) {
      return { valid: false, error: 'Action type is required' };
    }

    if (!action.targetPath) {
      return { valid: false, error: 'Target path is required' };
    }

    if (action.type === 'findReplace' && !action.findText) {
      return { valid: false, error: 'findText is required for findReplace action' };
    }

    if (action.type === 'replace' && action.position !== undefined && action.position < 0) {
      return { valid: false, error: 'Position must be non-negative for replace action' };
    }

    return { valid: true };
  }

  /**
   * Execute image generation action
   */
  async executeImageGenerationAction(
    imageConfig: ImagePromptConfig,
    sessionId?: string,
    context?: string
  ): Promise<{ success: boolean; error?: string; imagePath?: string }> {
    if (!this.agentManager) {
      return { success: false, error: 'Agent manager not available' };
    }

    try {
      const imageParams: Record<string, unknown> = {
        prompt: imageConfig.prompt,
        provider: imageConfig.provider,
        model: imageConfig.model,
        aspectRatio: imageConfig.aspectRatio,
        savePath: imageConfig.savePath,
        sessionId: sessionId || '',
        context: context || ''
      };

      const imageResult = await this.agentManager.executeAgentTool('promptManager', 'generateImage', imageParams);

      if (!isCommonResult(imageResult)) {
        return { success: false, error: 'Invalid response from generateImage tool' };
      }

      const data = imageResult.data as { imagePath?: string } | undefined;
      if (imageResult.success && data?.imagePath) {
        return {
          success: true,
          imagePath: data.imagePath
        };
      } else {
        return {
          success: false,
          error: imageResult.error || 'Image generation failed without specific error'
        };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error executing image generation'
      };
    }
  }

  /**
   * Get supported action types
   */
  getSupportedActionTypes(): string[] {
    return ['create', 'append', 'prepend', 'replace', 'findReplace'];
  }

  /**
   * Get supported request types
   */
  getSupportedRequestTypes(): string[] {
    return ['text', 'image'];
  }
}
```

## agents/promptManager/tools/executePrompts/services/BudgetValidator.ts

```typescript
import { UsageTracker } from '../../../../../services/UsageTracker';

/**
 * Service responsible for validating budget constraints before prompt execution
 * Follows SRP by focusing only on budget-related validation
 */
export class BudgetValidator {
  constructor(private usageTracker?: UsageTracker) {}

  /**
   * Check if the monthly budget has been exceeded
   * @throws Error if budget is exceeded
   */
  async validateBudget(): Promise<void> {
    if (!this.usageTracker) {
      return; // No budget tracking configured
    }

    const budgetStatus = await this.usageTracker.getBudgetStatusAsync();
    if (budgetStatus.budgetExceeded) {
      throw new Error(
        `Monthly LLM budget of $${budgetStatus.monthlyBudget.toFixed(2)} has been exceeded. ` +
        `Current spending: $${budgetStatus.currentSpending.toFixed(2)}. ` +
        `Please reset or increase your budget in settings.`
      );
    }
  }

  /**
   * Track usage after successful execution
   * @param provider LLM provider used
   * @param cost Total cost of the execution
   */
  async trackUsage(provider: string, cost: number): Promise<void> {
    if (!this.usageTracker) {
      return; // No usage tracking configured
    }

    try {
      await this.usageTracker.trackUsage(provider.toLowerCase(), cost);
    } catch (error) {
      console.error('Failed to track LLM usage:', error);
      // Don't fail the request if usage tracking fails
    }
  }

  /**
   * Get current budget status for reporting
   */
  async getBudgetStatus() {
    if (!this.usageTracker) {
      return null;
    }

    return await this.usageTracker.getBudgetStatusAsync();
  }
}
```

## agents/promptManager/tools/executePrompts/services/ContextBuilder.ts

```typescript
import { ExecutionContext, InternalExecutionResult, PromptConfig } from '../types';

/**
 * Service responsible for building context from previous execution results
 * Follows SRP by focusing only on context building logic
 */
export class ContextBuilder {

  /**
   * Build context string from previous sequence and group results with precise ID-based selection
   */
  buildPreviousResultsContext(
    previousResults: Map<number, InternalExecutionResult[]> | { [sequence: number]: InternalExecutionResult[] },
    currentSequence: number,
    currentSequenceGroupResults?: { [groupKey: string]: InternalExecutionResult[] },
    currentParallelGroup?: string,
    contextFromSteps?: string[],
    allResults?: InternalExecutionResult[]
  ): string {
    const contextParts: string[] = [];
    
    // If specific step IDs are requested, use those exclusively
    if (contextFromSteps && contextFromSteps.length > 0 && allResults) {
      contextParts.push('--- Selected Step Results ---');
      
      for (const stepId of contextFromSteps) {
        const result = allResults.find(r => r.id === stepId);
        if (result && result.success) {
          const groupLabel = result.parallelGroup ? ` (${result.parallelGroup})` : '';
          const sequenceLabel = result.sequence !== undefined ? ` [seq:${result.sequence}]` : '';
          
          if (result.type === 'text' && result.response) {
            contextParts.push(`${stepId}${groupLabel}${sequenceLabel}: ${result.response}`);
          } else if (result.type === 'image' && result.imagePath) {
            contextParts.push(`${stepId}${groupLabel}${sequenceLabel}: [Image generated: ${result.imagePath}]`);
          }
        } else if (!result) {
          contextParts.push(`${stepId}: [Step not found or not yet executed]`);
        } else if (!result.success) {
          contextParts.push(`${stepId}: [Step failed: ${result.error || 'Unknown error'}]`);
        }
      }
      
      return contextParts.join('\n');
    }
    
    // Otherwise, use the default behavior: include all previous sequences and groups
    
    // Include results from all previous sequences
    for (let seq = 0; seq < currentSequence; seq++) {
      const sequenceResults = previousResults instanceof Map ? previousResults.get(seq) : previousResults[seq];
      if (sequenceResults && sequenceResults.length > 0) {
        contextParts.push(`--- Sequence ${seq} Results ---`);
        sequenceResults.forEach((result, index) => {
          if (result.success) {
            const label = result.id ? `${result.id}` : `Step ${index + 1}`;
            const groupLabel = result.parallelGroup ? ` (${result.parallelGroup})` : '';
            
            if (result.type === 'text' && result.response) {
              contextParts.push(`${label}${groupLabel}: ${result.response}`);
            } else if (result.type === 'image' && result.imagePath) {
              contextParts.push(`${label}${groupLabel}: [Image generated: ${result.imagePath}]`);
            }
          }
        });
        contextParts.push('');
      }
    }
    
    // Include results from previous parallel groups in the current sequence
    if (currentSequenceGroupResults && currentParallelGroup) {
      for (const [groupKey, groupResults] of Object.entries(currentSequenceGroupResults)) {
        // Only include groups that come before the current group alphabetically
        if (groupKey !== 'default' && currentParallelGroup !== 'default' && groupKey >= currentParallelGroup) {
          continue;
        }
        if (groupKey === currentParallelGroup) {
          continue; // Don't include current group
        }
        
        if (groupResults && groupResults.length > 0) {
          contextParts.push(`--- Sequence ${currentSequence}, Group ${groupKey} Results ---`);
          groupResults.forEach((result, index) => {
            if (result.success) {
              const label = result.id ? `${result.id}` : `Step ${index + 1}`;
              
              if (result.type === 'text' && result.response) {
                contextParts.push(`${label}: ${result.response}`);
              } else if (result.type === 'image' && result.imagePath) {
                contextParts.push(`${label}: [Image generated: ${result.imagePath}]`);
              }
            }
          });
          contextParts.push('');
        }
      }
    }
    
    return contextParts.join('\n');
  }

  /**
   * Build enhanced user prompt with context from previous results
   */
  buildUserPromptWithContext(
    originalPrompt: string,
    promptConfig: PromptConfig,
    executionContext: ExecutionContext
  ): string {
    let userPrompt = originalPrompt;
    
    // Add previous results as context if requested
    if (promptConfig.includePreviousResults) {
      const previousContext = this.buildPreviousResultsContext(
        executionContext.previousResults,
        promptConfig.sequence || 0,
        undefined, // currentSequenceGroupResults - would need to be passed in
        promptConfig.parallelGroup,
        promptConfig.contextFromSteps,
        executionContext.allResults
      );
      
      if (previousContext) {
        userPrompt = `Previous step results:\n${previousContext}\n\nCurrent prompt: ${originalPrompt}`;
      }
    }
    
    return userPrompt;
  }

  /**
   * Initialize execution context for batch processing
   */
  initializeExecutionContext(sessionId?: string, context?: any): ExecutionContext {
    return {
      sessionId,
      context,
      previousResults: new Map(),
      allResults: []
    };
  }

  /**
   * Update execution context with new results
   */
  updateExecutionContext(
    executionContext: ExecutionContext,
    sequence: number,
    results: InternalExecutionResult[]
  ): void {
    // Store results by sequence
    const currentSequenceResults = executionContext.previousResults.get(sequence) || [];
    currentSequenceResults.push(...results);
    executionContext.previousResults.set(sequence, currentSequenceResults);

    // Add to all results
    executionContext.allResults.push(...results);
  }
}
```

## agents/promptManager/tools/executePrompts/services/index.ts

```typescript
// Re-export all services for easy importing
export * from './ActionExecutor';
export * from './BudgetValidator';
export * from './ContextBuilder';
export * from './PromptExecutor';
export * from './RequestExecutor';
export * from './ResultProcessor';
export * from './SequenceManager';
```

## agents/promptManager/tools/executePrompts/services/PromptExecutor.ts

```typescript
import { LLMService } from '../../../../../services/llm/core/LLMService';
import { CustomPromptStorageService } from '../../../services/CustomPromptStorageService';
import { BudgetValidator } from './BudgetValidator';
import { ContextBuilder } from './ContextBuilder';
import {
  PromptConfig,
  TextPromptConfig,
  InternalExecutionResult,
  PromptExecutionParams,
  ExecutionContext
} from '../types';
import { getErrorMessage } from '../../../../../utils/errorUtils';

/**
 * Service responsible for executing individual LLM prompts
 * Follows SRP by focusing only on prompt execution logic
 */
export class PromptExecutor {
  constructor(
    private llmService: LLMService,
    private budgetValidator: BudgetValidator,
    private contextBuilder: ContextBuilder,
    private promptStorage?: CustomPromptStorageService
  ) {}

  /**
   * Execute a single prompt with all necessary context and validation
   */
  async executePrompt(
    promptConfig: PromptConfig,
    executionContext: ExecutionContext,
    currentSequence: number,
    index: number = 0
  ): Promise<InternalExecutionResult> {
    try {
      // Add delay between concurrent requests to avoid overwhelming APIs
      if (index > 0) {
        await new Promise(resolve => setTimeout(resolve, index * 100));
      }
      
      const startTime = performance.now();
      
      // Only handle text prompts - images are handled by RequestExecutor
      if (promptConfig.type !== 'text') {
        const executionTime = performance.now() - startTime;
        return {
          type: 'text',
          id: promptConfig.id,
          prompt: promptConfig.prompt,
          success: false,
          error: 'PromptExecutor only handles text prompts',
          executionTime,
          sequence: currentSequence,
          parallelGroup: promptConfig.parallelGroup
        };
      }

      const textConfig = promptConfig as TextPromptConfig;

      // Validate and determine provider and model
      const { provider, model, validationError } = await this.validateAndSelectProviderModel(textConfig);
      if (validationError) {
        const executionTime = performance.now() - startTime;
        return {
          type: 'text',
          id: textConfig.id,
          prompt: textConfig.prompt,
          success: false,
          error: validationError,
          provider: textConfig.provider,
          model: textConfig.model,
          promptName: textConfig.customPrompt || 'default',
          executionTime,
          sequence: currentSequence,
          parallelGroup: textConfig.parallelGroup
        };
      }

      // Resolve custom prompt if specified
      const { systemPrompt, promptUsed } = await this.resolveCustomPrompt(textConfig.customPrompt);
      
      // Build user prompt with context from previous results
      const userPrompt = this.contextBuilder.buildUserPromptWithContext(
        textConfig.prompt,
        textConfig,
        executionContext
      );
      
      // Build execution parameters with validated provider and model
      const executeParams: PromptExecutionParams = {
        systemPrompt,
        userPrompt,
        filepaths: textConfig.contextFiles,
        provider,
        model,
        workspace: textConfig.workspace,
        sessionId: executionContext.sessionId
      };
      
      // Check budget before executing
      await this.budgetValidator.validateBudget();
      
      // Execute the prompt
      const response = await this.llmService.executePrompt(executeParams);
      
      // Track usage
      if (response.cost && response.provider) {
        await this.budgetValidator.trackUsage(
          response.provider.toLowerCase(),
          response.cost.totalCost || 0
        );
      }
      
      const executionTime = performance.now() - startTime;
      
      return {
        type: 'text',
        id: textConfig.id,
        prompt: textConfig.prompt,
        success: true,
        response: response.response,
        provider: response.provider,
        model: response.model,
        promptName: promptUsed,
        usage: response.usage,
        cost: response.cost,
        executionTime,
        filesIncluded: response.filesIncluded,
        sequence: currentSequence,
        parallelGroup: textConfig.parallelGroup
      };
      
    } catch (error) {
      return {
        type: 'text',
        id: promptConfig.id,
        prompt: promptConfig.prompt,
        success: false,
        error: getErrorMessage(error),
        provider: promptConfig.provider,
        model: promptConfig.model,
        promptName: promptConfig.type === 'text' ? (promptConfig as TextPromptConfig).customPrompt || 'default' : 'default',
        executionTime: 0,
        sequence: currentSequence,
        parallelGroup: promptConfig.parallelGroup
      };
    }
  }

  /**
   * Execute multiple prompts concurrently
   */
  async executeConcurrentPrompts(
    prompts: PromptConfig[],
    executionContext: ExecutionContext,
    currentSequence: number
  ): Promise<InternalExecutionResult[]> {
    const batchPromises = prompts.map((promptConfig, index) => 
      this.executePrompt(promptConfig, executionContext, currentSequence, index)
    );
    
    return await Promise.all(batchPromises);
  }

  /**
   * Validate and select provider and model for execution
   */
  private async validateAndSelectProviderModel(textConfig: TextPromptConfig): Promise<{
    provider?: string;
    model?: string;
    validationError?: string;
  }> {
    try {
      // Get available providers
      const availableProviders = this.llmService.getAvailableProviders();
      
      if (availableProviders.length === 0) {
        return {
          validationError: 'No LLM providers available. Please configure at least one provider with valid API keys in settings.'
        };
      }

      // Determine provider
      let selectedProvider = textConfig.provider;

      // If no provider specified, use the agent model (handles local provider fallback)
      if (!selectedProvider) {
        const agentModel = this.llmService.getAgentModel();
        selectedProvider = agentModel.provider;
        
        // If default provider isn't available, use first available provider
        if (!availableProviders.includes(selectedProvider)) {
          selectedProvider = availableProviders[0];
        }
      }
      
      // Validate that selected provider is available
      if (!availableProviders.includes(selectedProvider)) {
        return {
          validationError: `Provider '${selectedProvider}' is not available. Available providers: ${availableProviders.join(', ')}. Please check your API key configuration.`
        };
      }

      // Get available models for the provider
      const availableModels = await this.llmService.getAvailableModels();
      const providerModels = availableModels.filter(m => m.provider === selectedProvider);
      
      if (providerModels.length === 0) {
        return {
          validationError: `No models available for provider '${selectedProvider}'.`
        };
      }

      // Determine model
      let selectedModel = textConfig.model;

      // If no model specified, use agent model or first available for provider
      if (!selectedModel) {
        const agentModel = this.llmService.getAgentModel();

        // If agent model's provider matches, use agent model's model
        if (agentModel.provider === selectedProvider && agentModel.model) {
          selectedModel = agentModel.model;
        } else {
          // Use first available model for the provider
          selectedModel = providerModels[0].id;
        }
      }
      
      // Validate that selected model exists for the provider
      const modelExists = providerModels.some(m => m.id === selectedModel);
      if (!modelExists) {
        const availableModelNames = providerModels.map(m => m.id);
        return {
          validationError: `Model '${selectedModel}' is not available for provider '${selectedProvider}'. Available models: ${availableModelNames.join(', ')}`
        };
      }

      return {
        provider: selectedProvider,
        model: selectedModel
      };
      
    } catch (error) {
      return {
        validationError: `Failed to validate provider/model: ${getErrorMessage(error)}`
      };
    }
  }

  /**
   * Resolve custom prompt configuration
   */
  private async resolveCustomPrompt(promptIdentifier?: string): Promise<{ systemPrompt: string; promptUsed: string }> {
    let systemPrompt = '';
    let promptUsed = 'default';

    if (promptIdentifier && this.promptStorage) {
      try {
        // Use unified lookup (tries ID first, then name)
        const customPrompt = await this.promptStorage.getPromptByNameOrId(promptIdentifier);
        if (customPrompt && customPrompt.isEnabled) {
          systemPrompt = customPrompt.prompt;
          promptUsed = customPrompt.name;
        }
      } catch (error) {
      }
    }

    return { systemPrompt, promptUsed };
  }
}
```

## agents/promptManager/tools/executePrompts/services/RequestExecutor.ts

```typescript
import {
  PromptConfig,
  TextPromptConfig,
  ImagePromptConfig,
  InternalExecutionResult
} from '../types';
import { PromptExecutor } from './PromptExecutor';
import { ActionExecutor } from './ActionExecutor';

/**
 * Service responsible for executing different types of requests (text and image)
 * Coordinates between PromptExecutor and ActionExecutor for unified handling
 */
export class RequestExecutor {
  constructor(
    private promptExecutor: PromptExecutor,
    private actionExecutor: ActionExecutor
  ) {}

  /**
   * Execute a single request (text or image)
   */
  async executeRequest(
    config: PromptConfig,
    context: unknown,
    sessionId?: string
  ): Promise<InternalExecutionResult> {
    const startTime = performance.now();

    try {
      if (config.type === 'text') {
        return await this.executeTextRequest(config as TextPromptConfig, context, sessionId, startTime);
      } else if (config.type === 'image') {
        return await this.executeImageRequest(config as ImagePromptConfig, context, sessionId, startTime);
      } else {
        const executionTime = performance.now() - startTime;
        const unknownConfig = config as TextPromptConfig | ImagePromptConfig;
        return {
          type: 'text',
          id: unknownConfig.id,
          prompt: unknownConfig.prompt,
          success: false,
          error: `Unknown request type: ${unknownConfig.type}`,
          executionTime,
          sequence: unknownConfig.sequence,
          parallelGroup: unknownConfig.parallelGroup
        };
      }
    } catch (error) {
      const executionTime = performance.now() - startTime;
      return {
        type: 'text',
        id: config.id,
        prompt: config.prompt,
        success: false,
        error: error instanceof Error ? error.message : 'Unknown execution error',
        executionTime,
        sequence: config.sequence,
        parallelGroup: config.parallelGroup
      };
    }
  }

  /**
   * Execute a text prompt request
   */
  private async executeTextRequest(
    config: TextPromptConfig,
    context: unknown,
    _sessionId?: string,
    startTime?: number
  ): Promise<InternalExecutionResult> {
    const actualStartTime = startTime || performance.now();

    try {
      // Execute the text prompt using the existing PromptExecutor
      const result = await this.promptExecutor.executePrompt(
        config,
        context as import('../types').ExecutionContext,
        config.sequence || 0
      );

      const executionTime = performance.now() - actualStartTime;
      return { ...result, executionTime };
    } catch (error) {
      const executionTime = performance.now() - actualStartTime;
      return {
        type: 'text',
        id: config.id,
        prompt: config.prompt,
        success: false,
        error: error instanceof Error ? error.message : 'Unknown text execution error',
        executionTime,
        sequence: config.sequence,
        parallelGroup: config.parallelGroup
      };
    }
  }

  /**
   * Execute an image generation request
   */
  private async executeImageRequest(
    config: ImagePromptConfig,
    context: unknown,
    sessionId?: string,
    startTime?: number
  ): Promise<InternalExecutionResult> {
    const actualStartTime = startTime || performance.now();

    try {
      // Execute image generation using ActionExecutor
      const result = await this.actionExecutor.executeImageGenerationAction(
        config,
        sessionId,
        typeof context === 'string' ? context : JSON.stringify(context)
      );

      const executionTime = performance.now() - actualStartTime;

      return {
        type: 'image',
        id: config.id,
        prompt: config.prompt,
        success: result.success,
        imagePath: result.imagePath,
        error: result.error,
        provider: config.provider,
        model: config.model || 'imagen-4',
        executionTime,
        sequence: config.sequence,
        parallelGroup: config.parallelGroup
      };
    } catch (error) {
      const executionTime = performance.now() - actualStartTime;
      return {
        type: 'image',
        id: config.id,
        prompt: config.prompt,
        success: false,
        error: error instanceof Error ? error.message : 'Unknown image execution error',
        provider: config.provider,
        model: config.model || 'imagen-4',
        executionTime,
        sequence: config.sequence,
        parallelGroup: config.parallelGroup
      };
    }
  }

  /**
   * Execute multiple requests in parallel
   */
  async executeRequestsInParallel(
    configs: PromptConfig[],
    context: unknown,
    sessionId?: string
  ): Promise<InternalExecutionResult[]> {
    const promises = configs.map(config =>
      this.executeRequest(config, context, sessionId)
    );

    return await Promise.all(promises);
  }

  /**
   * Validate a request configuration
   */
  validateRequest(config: PromptConfig): { valid: boolean; error?: string } {
    if (!config.type) {
      return { valid: false, error: 'Request type is required' };
    }

    if (!config.prompt || config.prompt.trim().length === 0) {
      return { valid: false, error: 'Prompt is required' };
    }

    if (config.type === 'image') {
      const imageConfig = config as ImagePromptConfig;
      
      if (!imageConfig.savePath || imageConfig.savePath.trim().length === 0) {
        return { valid: false, error: 'Save path is required for image generation' };
      }

      if (imageConfig.savePath.includes('..') || imageConfig.savePath.startsWith('/')) {
        return { valid: false, error: 'Save path must be relative to vault root' };
      }

      if (imageConfig.provider !== 'google') {
        return { valid: false, error: 'Only Google provider is currently supported for image generation' };
      }
    }

    return { valid: true };
  }
}
```

## agents/promptManager/tools/executePrompts/services/ResultProcessor.ts

```typescript
import {
  PromptExecutionResult,
  InternalExecutionResult,
  BatchExecutePromptResult,
  ExecutionStats,
  MergedResponse
} from '../types';

/**
 * Service responsible for processing and formatting execution results
 * Strips internal details to return lean, context-efficient results
 */
export class ResultProcessor {

  /**
   * Process results into final batch execution result (lean format)
   */
  processResults(
    results: InternalExecutionResult[],
    mergeResponses: boolean,
    _totalExecutionTime: number,
    _totalPrompts: number
  ): BatchExecutePromptResult {
    const successful = results.filter(r => r.success);

    if (mergeResponses) {
      const merged = this.mergePromptResults(successful);
      return {
        success: true,
        merged: merged.combinedResponse
      };
    } else {
      // Strip to lean format
      const leanResults = results.map(r => this.toLeanResult(r));
      return {
        success: true,
        results: leanResults
      };
    }
  }

  /**
   * Convert internal result to lean public result
   * Type inferred from fields: response/savedTo = text, imagePath = image
   */
  private toLeanResult(result: InternalExecutionResult): PromptExecutionResult {
    const lean: PromptExecutionResult = { success: result.success };

    if (result.type === 'image') {
      if (result.imagePath) lean.imagePath = result.imagePath;
    } else {
      // Only include response if no action saved it to a file
      if (result.response && !result.actionPerformed?.success) {
        lean.response = result.response;
      }
      // Include savedTo path if action was performed
      if (result.actionPerformed?.success && result.actionPerformed.targetPath) {
        lean.savedTo = result.actionPerformed.targetPath;
      }
    }

    if (!result.success && result.error) lean.error = result.error;
    return lean;
  }

  /**
   * Create error result for batch execution failures
   */
  createErrorResult(error: string): BatchExecutePromptResult {
    return {
      success: false,
      error
    };
  }

  /**
   * Merge multiple prompt results into a single unified response
   */
  private mergePromptResults(results: InternalExecutionResult[]): MergedResponse {
    const responses: string[] = [];
    const providersUsed = new Set<string>();

    results.forEach((result) => {
      if (result.success) {
        let content = '';
        if (result.type === 'text' && result.response) {
          content = result.response;
        } else if (result.type === 'image' && result.imagePath) {
          content = `[Image: ${result.imagePath}]`;
        }
        if (content) {
          responses.push(content);
          if (result.provider) providersUsed.add(result.provider);
        }
      }
    });

    return {
      totalPrompts: results.length,
      successfulPrompts: results.filter(r => r.success).length,
      combinedResponse: responses.join('\n\n'),
      providersUsed: Array.from(providersUsed)
    };
  }
}
```

## agents/promptManager/tools/executePrompts/services/SequenceManager.ts

```typescript
import { RequestExecutor } from './RequestExecutor';
import { ContextBuilder } from './ContextBuilder';
import {
  PromptConfig,
  InternalExecutionResult,
  ExecutionContext
} from '../types';

/**
 * Service responsible for managing request execution sequences and parallel groups
 * Handles both text and image requests through RequestExecutor
 * Follows SRP by focusing only on execution orchestration logic
 */
export class SequenceManager {
  constructor(
    private requestExecutor: RequestExecutor,
    private contextBuilder: ContextBuilder
  ) {}

  /**
   * Execute prompts with sequence and parallel group support
   * - Sequences execute in numerical order (0, 1, 2, etc.)
   * - Within each sequence, parallel groups execute sequentially
   * - Prompts within the same parallel group execute concurrently
   */
  async executePromptsWithSequencing(
    prompts: PromptConfig[],
    executionContext: ExecutionContext
  ): Promise<InternalExecutionResult[]> {
    const results: InternalExecutionResult[] = [];
    
    // Group prompts by sequence number (default to 0 if not specified)
    const sequenceGroups = this.groupPromptsBySequence(prompts);
    
    // Sort sequences to execute in order
    const sortedSequences = Array.from(sequenceGroups.keys()).sort((a, b) => a - b);
    
    // Execute each sequence in order
    for (const sequence of sortedSequences) {
      const sequencePrompts = sequenceGroups.get(sequence)!;
      
      // Execute prompts within this sequence with parallel group support
      const sequenceResults = await this.executeSequenceWithParallelGroups(
        sequencePrompts,
        executionContext,
        sequence
      );
      
      results.push(...sequenceResults);
      
      // Update execution context with results from this sequence
      this.contextBuilder.updateExecutionContext(executionContext, sequence, sequenceResults);
    }
    
    return results;
  }

  /**
   * Execute a sequence with parallel group support
   * Groups prompts by parallelGroup and executes groups sequentially, prompts within groups concurrently
   */
  private async executeSequenceWithParallelGroups(
    prompts: PromptConfig[],
    executionContext: ExecutionContext,
    _currentSequence: number
  ): Promise<InternalExecutionResult[]> {
    const results: InternalExecutionResult[] = [];
    
    // Group prompts by parallelGroup within this sequence
    const parallelGroups = this.groupPromptsByParallelGroup(prompts);
    
    // Sort groups to ensure consistent execution order (default group first, then alphabetically)
    const sortedGroups = this.sortParallelGroups(Array.from(parallelGroups.keys()));
    
    // Execute each parallel group sequentially
    for (const groupKey of sortedGroups) {
      const groupPrompts = parallelGroups.get(groupKey)!;
      
      // Execute all requests in this group concurrently (text and image)
      const groupExecutionResults = await this.requestExecutor.executeRequestsInParallel(
        groupPrompts,
        executionContext,
        executionContext.sessionId
      );
      
      results.push(...groupExecutionResults);
      
      // Update context with results from this group
      executionContext.allResults.push(...groupExecutionResults);
    }
    
    return results;
  }

  /**
   * Group prompts by sequence number
   */
  private groupPromptsBySequence(prompts: PromptConfig[]): Map<number, PromptConfig[]> {
    const sequenceGroups = new Map<number, PromptConfig[]>();
    
    for (const prompt of prompts) {
      const sequence = prompt.sequence || 0;
      if (!sequenceGroups.has(sequence)) {
        sequenceGroups.set(sequence, []);
      }
      sequenceGroups.get(sequence)!.push(prompt);
    }
    
    return sequenceGroups;
  }

  /**
   * Group prompts by parallel group within a sequence
   */
  private groupPromptsByParallelGroup(prompts: PromptConfig[]): Map<string, PromptConfig[]> {
    const parallelGroups = new Map<string, PromptConfig[]>();
    
    for (const prompt of prompts) {
      const groupKey = prompt.parallelGroup || 'default';
      if (!parallelGroups.has(groupKey)) {
        parallelGroups.set(groupKey, []);
      }
      parallelGroups.get(groupKey)!.push(prompt);
    }
    
    return parallelGroups;
  }

  /**
   * Sort parallel groups to ensure consistent execution order
   * Default group executes first, then alphabetically
   */
  private sortParallelGroups(groupKeys: string[]): string[] {
    return groupKeys.sort((a, b) => {
      if (a === 'default' && b !== 'default') return -1;
      if (a !== 'default' && b === 'default') return 1;
      return a.localeCompare(b);
    });
  }

  /**
   * Get execution statistics from results (internal use only)
   */
  getExecutionStatistics(results: InternalExecutionResult[]) {
    const successful = results.filter(r => r.success);
    const failed = results.filter(r => !r.success);
    const totalExecutionTime = results.reduce((sum, r) => sum + (r.executionTime || 0), 0);

    return {
      totalPrompts: results.length,
      successfulPrompts: successful.length,
      failedPrompts: failed.length,
      totalExecutionTimeMS: totalExecutionTime,
      avgExecutionTimeMS: results.length > 0 ? totalExecutionTime / results.length : 0
    };
  }
}
```

## agents/promptManager/tools/executePrompts/types/executeTypes.ts

```typescript
import { CommonParameters } from '../../../../../types';
import { AspectRatio } from '../../../../../services/llm/types/ImageTypes';

/**
 * Parameters for batch LLM prompt execution
 * Now supports mixed text and image generation requests
 */
export interface BatchExecutePromptParams extends CommonParameters {
  /** Array of requests to execute - can be text prompts or image generation requests */
  prompts: Array<BatchRequest>;
  /** Whether to merge all responses into a single result */
  mergeResponses?: boolean;
}

/**
 * Base interface for batch requests
 */
export interface BaseBatchRequest {
  /** Custom identifier for this request */
  id?: string;
  /** Sequence number for ordered execution (sequences execute in numerical order: 0, 1, 2, etc.) */
  sequence?: number;
  /** Parallel group within sequence - requests with same parallelGroup run together */
  parallelGroup?: string;
  /** Whether to include previous step results as context */
  includePreviousResults?: boolean;
  /** Specific IDs of previous steps to include as context */
  contextFromSteps?: string[];
}

/**
 * Text prompt request for LLM generation
 */
export interface TextPromptRequest extends BaseBatchRequest {
  /** Request type identifier */
  type: 'text';
  /** The prompt text to send to the LLM */
  prompt: string;
  /** Optional provider to use (defaults to settings default) */
  provider?: string;
  /** Optional model to use (defaults to settings default) */
  model?: string;
  /** Optional context files to include */
  contextFiles?: string[];
  /** Optional workspace for context */
  workspace?: string;
  /** Optional action to perform with the LLM response */
  action?: ContentAction;
  /** Optional custom prompt to use (by name or ID) */
  customPrompt?: string;
}

/**
 * Image generation request
 */
export interface ImageGenerationRequest extends BaseBatchRequest {
  /** Request type identifier */
  type: 'image';
  /** The prompt text describing the image to generate */
  prompt: string;
  /** Image generation provider (google for Imagen, openai disabled for now) */
  provider: 'google'; // Only Google supported currently due to OpenAI speed issues
  /** Optional model to use (imagen-4, imagen-4-ultra) */
  model?: 'imagen-4' | 'imagen-4-ultra';
  /** Image aspect ratio */
  aspectRatio?: AspectRatio;
  /** Vault-relative path where the image should be saved */
  savePath: string;
}

/**
 * Union type for all batch request types
 */
export type BatchRequest = TextPromptRequest | ImageGenerationRequest;

/**
 * Individual request configuration for execution (unified for text and image)
 */
export type PromptConfig = TextPromptConfig | ImagePromptConfig;

/**
 * Text prompt configuration for execution
 */
export interface TextPromptConfig {
  type: 'text';
  prompt: string;
  provider?: string;
  model?: string;
  contextFiles?: string[];
  workspace?: string;
  id?: string;
  sequence?: number;
  parallelGroup?: string;
  includePreviousResults?: boolean;
  contextFromSteps?: string[];
  action?: ContentAction;
  customPrompt?: string;
}

/**
 * Image generation configuration for execution
 */
export interface ImagePromptConfig {
  type: 'image';
  prompt: string;
  provider: 'google';
  model?: 'imagen-4' | 'imagen-4-ultra';
  aspectRatio?: AspectRatio;
  savePath: string;
  id?: string;
  sequence?: number;
  parallelGroup?: string;
  includePreviousResults?: boolean;
  contextFromSteps?: string[];
}

/**
 * Content action configuration
 */
export interface ContentAction {
  type: 'create' | 'append' | 'prepend' | 'replace' | 'findReplace';
  targetPath: string;
  position?: number;
  findText?: string;
  replaceAll?: boolean;
  caseSensitive?: boolean;
  wholeWord?: boolean;
}

/**
 * Execution context for prompt processing (uses internal results during execution)
 */
export interface ExecutionContext {
  sessionId?: string;
  context?: unknown;
  previousResults: Map<number, InternalExecutionResult[]>;
  allResults: InternalExecutionResult[];
}

/**
 * Parameters for individual prompt execution
 */
export interface PromptExecutionParams {
  systemPrompt: string;
  userPrompt: string;
  filepaths?: string[];
  provider?: string;
  model?: string;
  workspace?: string;
  sessionId?: string;
}

/**
 * Result from individual request execution (lean)
 * Infer type from fields: response/savedTo = text, imagePath = image
 */
export interface PromptExecutionResult {
  success: boolean;
  /** Text response - omitted if action saved content to note */
  response?: string;
  /** Path where content was saved (text with action) */
  savedTo?: string;
  /** Path where image was saved */
  imagePath?: string;
  /** Only included on failure */
  error?: string;
}

/**
 * Internal result with full details (used during execution, stripped before return)
 */
export interface InternalExecutionResult {
  type: 'text' | 'image';
  id?: string;
  prompt: string;
  success: boolean;
  response?: string;
  imagePath?: string;
  provider?: string;
  model?: string;
  /** Name of the custom prompt used (if any) */
  promptName?: string;
  error?: string;
  executionTime?: number;
  sequence?: number;
  parallelGroup?: string;
  usage?: {
    promptTokens?: number;
    completionTokens?: number;
    totalTokens?: number;
    imagesGenerated?: number;
    resolution?: string;
  };
  cost?: {
    inputCost: number;
    outputCost: number;
    totalCost: number;
    currency: string;
  };
  filesIncluded?: string[];
  actionPerformed?: {
    type: string;
    targetPath: string;
    success: boolean;
    error?: string;
  };
}
```

## agents/promptManager/tools/executePrompts/types/executionResult.ts

```typescript
import { PromptExecutionResult } from './executeTypes';

/**
 * Result from batch LLM prompt execution (lean for context efficiency)
 */
export interface BatchExecutePromptResult {
  success: boolean;
  /** Individual prompt results - minimal data */
  results?: PromptExecutionResult[];
  /** Combined response when mergeResponses is true */
  merged?: string;
  /** Only included on failure */
  error?: string;
}

/**
 * Internal execution statistics (not returned to caller)
 */
export interface ExecutionStats {
  totalExecutionTimeMS: number;
  promptsExecuted: number;
  promptsFailed: number;
  avgExecutionTimeMS: number;
  tokensUsed?: number;
}

/**
 * Internal merged response data (not returned to caller)
 */
export interface MergedResponse {
  totalPrompts: number;
  successfulPrompts: number;
  combinedResponse: string;
  providersUsed: string[];
}
```

## agents/promptManager/tools/executePrompts/types/index.ts

```typescript
// Re-export all types for easy importing
export * from './executeTypes';
export * from './executionResult';

```

## agents/promptManager/tools/executePrompts/utils/index.ts

```typescript
// Re-export all utilities for easy importing
export * from './promptParser';

```

## agents/promptManager/tools/executePrompts/utils/promptParser.ts

```typescript
import { PromptConfig, BatchExecutePromptParams, BatchRequest, TextPromptRequest, ImageGenerationRequest } from '../types';

/**
 * Utility for parsing and validating prompt configurations
 * Follows SRP by focusing only on prompt parsing logic
 */
export class PromptParser {

  /**
   * Validate batch execution parameters
   */
  validateParameters(params: BatchExecutePromptParams): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!params.prompts || params.prompts.length === 0) {
      errors.push('At least one prompt is required');
    }

    if (params.prompts && params.prompts.length > 100) {
      errors.push('Maximum of 100 prompts allowed per batch');
    }

    // Validate individual prompts
    if (params.prompts) {
      params.prompts.forEach((prompt, index) => {
        const promptErrors = this.validatePromptConfig(prompt, index);
        errors.push(...promptErrors);
      });
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  /**
   * Validate individual request configuration (text or image)
   */
  validatePromptConfig(requestConfig: any, index: number): string[] {
    const errors: string[] = [];
    const prefix = `Request ${index + 1}`;
    const requestType = requestConfig.type || 'text'; // Default to text for backward compatibility

    if (!requestConfig.prompt || typeof requestConfig.prompt !== 'string') {
      errors.push(`${prefix}: prompt text is required and must be a string`);
    }

    if (requestConfig.prompt && requestConfig.prompt.length > 32000) {
      errors.push(`${prefix}: prompt text cannot exceed 32,000 characters`);
    }

    // Type-specific validation
    if (requestType === 'image') {
      const imageConfig = requestConfig as ImageGenerationRequest;
      
      if (!imageConfig.savePath || typeof imageConfig.savePath !== 'string') {
        errors.push(`${prefix}: savePath is required for image generation`);
      }

      if (imageConfig.savePath && (imageConfig.savePath.includes('..') || imageConfig.savePath.startsWith('/'))) {
        errors.push(`${prefix}: savePath must be relative to vault root`);
      }

      if (!imageConfig.provider || imageConfig.provider !== 'google') {
        errors.push(`${prefix}: only 'google' provider is currently supported for image generation`);
      }

      if (imageConfig.model && !['imagen-4', 'imagen-4-ultra'].includes(imageConfig.model)) {
        errors.push(`${prefix}: invalid model for image generation. Supported: imagen-4, imagen-4-ultra`);
      }

    }

    if (requestConfig.sequence !== undefined && (typeof requestConfig.sequence !== 'number' || requestConfig.sequence < 0)) {
      errors.push(`${prefix}: sequence must be a non-negative number`);
    }

    if (requestConfig.contextFiles && !Array.isArray(requestConfig.contextFiles)) {
      errors.push(`${prefix}: contextFiles must be an array`);
    }

    if (requestConfig.contextFromSteps && !Array.isArray(requestConfig.contextFromSteps)) {
      errors.push(`${prefix}: contextFromSteps must be an array`);
    }

    // Only validate actions for text requests (images don't have actions)
    if (requestType === 'text' && requestConfig.action) {
      const actionErrors = this.validateActionConfig(requestConfig.action, prefix);
      errors.push(...actionErrors);
    }

    return errors;
  }

  /**
   * Validate action configuration
   */
  validateActionConfig(action: any, prefix: string): string[] {
    const errors: string[] = [];

    if (!action.type) {
      errors.push(`${prefix}: action.type is required`);
    }

    if (!action.targetPath) {
      errors.push(`${prefix}: action.targetPath is required`);
    }

    const validActionTypes = ['create', 'append', 'prepend', 'replace', 'findReplace'];
    if (action.type && !validActionTypes.includes(action.type)) {
      errors.push(`${prefix}: action.type must be one of: ${validActionTypes.join(', ')}`);
    }

    if (action.type === 'findReplace' && !action.findText) {
      errors.push(`${prefix}: action.findText is required for findReplace action`);
    }

    if (action.position !== undefined && (typeof action.position !== 'number' || action.position < 0)) {
      errors.push(`${prefix}: action.position must be a non-negative number`);
    }

    return errors;
  }

  /**
   * Normalize request configurations (text and image)
   */
  normalizePromptConfigs(requests: any[]): PromptConfig[] {
    return requests.map((request, index) => {
      const requestType = request.type || 'text'; // Default to text for backward compatibility
      const baseConfig = {
        id: request.id || `request_${index + 1}`,
        sequence: request.sequence || 0,
        parallelGroup: request.parallelGroup || 'default',
        includePreviousResults: request.includePreviousResults || false,
        contextFromSteps: request.contextFromSteps || [],
        prompt: request.prompt
      };

      if (requestType === 'image') {
        return {
          type: 'image',
          ...baseConfig,
          provider: request.provider || 'google',
          model: request.model || 'imagen-4',
          aspectRatio: request.aspectRatio,
          size: request.size,
          quality: request.quality,
          safety: request.safety,
          savePath: request.savePath,
          format: request.format,
          background: request.background
        } as PromptConfig;
      } else {
        return {
          type: 'text',
          ...baseConfig,
          provider: request.provider,
          model: request.model,
          contextFiles: request.contextFiles || [],
          workspace: request.workspace,
          action: request.action,
          agent: request.agent
        } as PromptConfig;
      }
    });
  }

  /**
   * Extract unique sequences from prompts
   */
  extractSequences(prompts: PromptConfig[]): number[] {
    const sequences = new Set(prompts.map(p => p.sequence || 0));
    return Array.from(sequences).sort((a, b) => a - b);
  }

  /**
   * Extract unique parallel groups from prompts
   */
  extractParallelGroups(prompts: PromptConfig[]): string[] {
    const groups = new Set(prompts.map(p => p.parallelGroup || 'default'));
    return Array.from(groups).sort();
  }

  /**
   * Get execution plan summary
   */
  getExecutionPlan(prompts: PromptConfig[]): {
    totalPrompts: number;
    sequences: number[];
    parallelGroups: string[];
    estimatedDuration: string;
  } {
    const sequences = this.extractSequences(prompts);
    const parallelGroups = this.extractParallelGroups(prompts);
    
    // Rough estimation based on typical LLM response times
    const avgPromptTime = 5; // seconds
    const maxConcurrency = Math.max(...parallelGroups.map(group => 
      prompts.filter(p => (p.parallelGroup || 'default') === group).length
    ));
    
    const estimatedSeconds = sequences.length * avgPromptTime * Math.ceil(prompts.length / maxConcurrency);
    const estimatedDuration = this.formatDuration(estimatedSeconds);

    return {
      totalPrompts: prompts.length,
      sequences,
      parallelGroups,
      estimatedDuration
    };
  }

  /**
   * Format duration in human-readable format
   */
  private formatDuration(seconds: number): string {
    if (seconds < 60) {
      return `${seconds}s`;
    } else if (seconds < 3600) {
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      return remainingSeconds > 0 ? `${minutes}m ${remainingSeconds}s` : `${minutes}m`;
    } else {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      return minutes > 0 ? `${hours}h ${minutes}m` : `${hours}h`;
    }
  }
}
```

## agents/promptManager/tools/generateImage.ts

```typescript
/**
 * Generate Image Tool - Image generation workflow for AgentManager
 * Integrates with ImageGenerationService and follows AgentManager patterns
 */

import { BaseTool } from '../../baseTool';
import { CommonResult, CommonParameters } from '../../../types';
import { createResult } from '../../../utils/schemaUtils';
import { ImageGenerationService } from '../../../services/llm/ImageGenerationService';
import { 
  ImageGenerationParams,
  ImageGenerationResult,
  AspectRatio
} from '../../../services/llm/types/ImageTypes';
import { SchemaBuilder, SchemaType } from '../../../utils/schemas/SchemaBuilder';
import { Vault } from 'obsidian';
import { LLMProviderSettings } from '../../../types/llm/ProviderTypes';

export interface GenerateImageParams extends CommonParameters {
  prompt: string;
  provider?: 'google' | 'openrouter'; // Defaults to 'google' if available
  model?: 'gemini-2.5-flash-image' | 'gemini-3-pro-image-preview' | 'flux-2-pro' | 'flux-2-flex'; // Defaults to 'gemini-2.5-flash-image'
  aspectRatio?: AspectRatio;
  numberOfImages?: number;
  imageSize?: '1K' | '2K' | '4K';
  referenceImages?: string[]; // Vault-relative paths to reference images
  savePath: string;
}

export interface GenerateImageModeResult extends CommonResult {
  data?: {
    imagePath: string;
  };
}

/**
 * Image Generation Tool for AgentManager
 * Handles AI image generation requests through Google provider
 */
export class GenerateImageTool extends BaseTool<GenerateImageParams, GenerateImageModeResult> {
  private imageService: ImageGenerationService | null = null;
  private schemaBuilder: SchemaBuilder;
  private vault: Vault | null = null;
  private llmSettings: LLMProviderSettings | null = null;

  constructor(dependencies?: { vault?: Vault; llmSettings?: LLMProviderSettings }) {
    super(
      'generateImage',
      'Generate Image',
      'Generate images using Google Nano Banana models (direct or via OpenRouter). Supports reference images for style/composition guidance.',
      '2.1.0'
    );

    this.schemaBuilder = new SchemaBuilder(null);

    // Use injected dependencies if provided
    if (dependencies) {
      if (dependencies.vault) {
        this.vault = dependencies.vault;
      }
      if (dependencies.llmSettings) {
        this.llmSettings = dependencies.llmSettings;
      }

      // Initialize service if both dependencies are available
      if (this.vault && this.llmSettings) {
        this.initializeImageService();
      }
    }
  }

  /**
   * Set the vault instance for image generation service
   */
  setVault(vault: Vault): void {
    this.vault = vault;
    this.initializeImageService();
  }

  /**
   * Set LLM provider settings
   */
  setLLMSettings(llmSettings: LLMProviderSettings): void {
    this.llmSettings = llmSettings;
    this.initializeImageService();
  }

  /**
   * Initialize image service when both vault and settings are available
   */
  private initializeImageService(): void {
    if (this.vault && this.llmSettings) {
      this.imageService = new ImageGenerationService(this.vault, this.llmSettings);
    }
  }

  /**
   * Execute image generation
   */
  async execute(params: GenerateImageParams): Promise<GenerateImageModeResult> {
    try {
      // Validate service availability
      if (!this.imageService) {
        return createResult<GenerateImageModeResult>(
          false,
          undefined,
          'Image generation service not initialized. Vault instance required.'
        );
      }

      // Check if any providers are available
      if (!this.imageService.hasAvailableProviders()) {
        return createResult<GenerateImageModeResult>(
          false,
          undefined,
          'No image generation providers available. Please configure Google API key in plugin settings.'
        );
      }

      // Apply defaults: google provider and gemini-2.5-flash-image model
      const provider = params.provider || 'google';
      const model = params.model || 'gemini-2.5-flash-image';

      // Validate parameters
      const validation = await this.imageService.validateParams({
        prompt: params.prompt,
        provider,
        model,
        aspectRatio: params.aspectRatio,
        numberOfImages: params.numberOfImages,
        imageSize: params.imageSize,
        referenceImages: params.referenceImages,
        savePath: params.savePath,
        sessionId: 'default',
        context: ''
      });

      if (!validation.isValid) {
        return createResult<GenerateImageModeResult>(
          false,
          undefined,
          `Parameter validation failed: ${validation.errors.join(', ')}`
        );
      }

      // Generate the image
      const result = await this.imageService.generateImage({
        prompt: params.prompt,
        provider,
        model,
        aspectRatio: params.aspectRatio,
        numberOfImages: params.numberOfImages,
        imageSize: params.imageSize,
        referenceImages: params.referenceImages,
        savePath: params.savePath,
        sessionId: 'default',
        context: ''
      });

      if (!result.success) {
        return createResult<GenerateImageModeResult>(
          false,
          undefined,
          result.error || 'Image generation failed'
        );
      }

      // Return lean result - just the path
      return createResult<GenerateImageModeResult>(
        true,
        result.data ? { imagePath: result.data.imagePath } : undefined
      );

    } catch (error) {
      return createResult<GenerateImageModeResult>(
        false,
        undefined,
        `Image generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  /**
   * Get parameter schema for MCP
   */
  getParameterSchema(): any {
    const toolSchema = {
      type: 'object',
      properties: {
        prompt: {
          type: 'string',
          description: 'Text prompt describing the image to generate',
          minLength: 1,
          maxLength: 32000
        },
        provider: {
          type: 'string',
          enum: ['google', 'openrouter'],
          default: 'google',
          description: 'AI provider (default: google)'
        },
        model: {
          type: 'string',
          enum: ['gemini-2.5-flash-image', 'gemini-3-pro-image-preview', 'flux-2-pro', 'flux-2-flex'],
          default: 'gemini-2.5-flash-image',
          description: 'Model (default: gemini-2.5-flash-image). FLUX models only via OpenRouter.'
        },
        aspectRatio: {
          type: 'string',
          enum: ['1:1', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '9:16', '16:9', '21:9'],
          description: 'Aspect ratio for the generated image'
        },
        numberOfImages: {
          type: 'number',
          minimum: 1,
          maximum: 4,
          description: 'Number of images to generate (1-4)'
        },
        imageSize: {
          type: 'string',
          enum: ['1K', '2K', '4K'],
          description: 'Image resolution. 4K only available for gemini-3-pro-image-preview'
        },
        referenceImages: {
          type: 'array',
          items: { type: 'string' },
          maxItems: 14,
          description: 'Reference images for style/composition. Max 3 for 2.5-flash, max 14 for 3-pro'
        },
        savePath: {
          type: 'string',
          description: 'Vault-relative path for the image. Extension may change based on API response format.',
          pattern: '^[^/].*\\.(png|jpg|jpeg|webp)$'
        }
      },
      required: ['prompt', 'savePath']
    };

    return this.getMergedSchema(toolSchema);
  }

  /**
   * Get result schema for MCP (lean format)
   */
  getResultSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean' },
        data: {
          type: 'object',
          properties: {
            imagePath: { type: 'string', description: 'Path where image was saved' }
          }
        },
        error: { type: 'string' }
      },
      required: ['success']
    };
  }
}
```

## agents/promptManager/tools/getPrompt.ts

```typescript
import { BaseTool } from '../../baseTool';
import { GetPromptParams, GetPromptResult } from '../types';
import { CustomPromptStorageService } from '../services/CustomPromptStorageService';
import { getCommonResultSchema, createResult } from '../../../utils/schemaUtils';

/**
 * Tool for getting a specific custom prompt for persona adoption
 */
export class GetPromptTool extends BaseTool<GetPromptParams, GetPromptResult> {
  private storageService: CustomPromptStorageService;

  /**
   * Create a new GetPromptTool
   * @param storageService Custom prompt storage service
   */
  constructor(storageService: CustomPromptStorageService) {
    super(
      'getPrompt',
      'Get Prompt',
      'Get a custom prompt for persona adoption - does NOT execute tasks automatically',
      '1.0.0'
    );

    this.storageService = storageService;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise that resolves with the prompt data
   */
  async execute(params: GetPromptParams): Promise<GetPromptResult> {
    try {
      const { id, name } = params;

      // Must provide either id or name
      if (!id && !name) {
        return createResult<GetPromptResult>(false, null, 'Either id or name must be provided');
      }

      // Get prompt by id or name
      let prompt = null;
      if (id) {
        // Use unified lookup (tries ID first, then name)
        prompt = this.storageService.getPromptByNameOrId(id);
      } else if (name) {
        prompt = this.storageService.getPromptByNameOrId(name);
      }

      if (!prompt) {
        const identifier = id ? `ID "${id}"` : `name "${name}"`;
        return createResult<GetPromptResult>(false, null, `Prompt with ${identifier} not found. Use listPrompts to see available prompts.`);
      }

      // Create message with persona instruction and warning (prompt content is already in the prompt field)
      const message = `PROMPT PERSONA RETRIEVED: "${prompt.name}"

IMPORTANT EXECUTION BOUNDARY:
- This is PERSONA ADOPTION only - no tasks will be executed
- Do NOT automatically use executePrompts unless explicitly requested
- Do NOT run actions, create files, or modify content
- You may adopt this persona for conversation
- Ask permission before switching to execution mode

To execute tasks: User must explicitly request promptManager_executePrompts`;

      const resultWithMessage = {
        ...prompt,
        message: message
      };

      return createResult<GetPromptResult>(true, resultWithMessage, undefined);
    } catch (error) {
      return createResult<GetPromptResult>(false, null, `Failed to get prompt: ${error}`);
    }
  }

  /**
   * Get the JSON schema for the tool's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const toolSchema = {
      type: 'object',
      properties: {
        id: {
          type: 'string',
          description: 'Unique ID or name of the prompt to retrieve for persona adoption (will try ID first, then name)'
        },
        name: {
          type: 'string',
          description: 'Name of the prompt to retrieve for persona adoption'
        }
      },
      required: [],
      anyOf: [
        { required: ['id'] },
        { required: ['name'] }
      ]
    };

    return this.getMergedSchema(toolSchema);
  }

  /**
   * Get the JSON schema for the tool's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    const commonSchema = getCommonResultSchema();

    // Override the data property to define the specific structure for this tool
    return {
      ...commonSchema,
      properties: {
        ...commonSchema.properties,
        data: {
          oneOf: [
            { type: 'null' },
            {
              type: 'object',
              properties: {
                id: { type: 'string' },
                name: { type: 'string' },
                description: { type: 'string' },
                prompt: { type: 'string' },
                isEnabled: { type: 'boolean' },
                message: { type: 'string', description: 'Complete persona instructions and warning about execute mode usage' }
              },
              required: ['id', 'name', 'description', 'prompt', 'isEnabled', 'message']
            }
          ]
        }
      }
    };
  }
}

```

## agents/promptManager/tools/index.ts

```typescript
// Export all PromptManager tools
export { ListPromptsTool } from './listPrompts';
export { GetPromptTool } from './getPrompt';
export { CreatePromptTool } from './createPrompt';
export { UpdatePromptTool } from './updatePrompt';
export { ArchivePromptTool } from './archivePrompt';
export { ListModelsTool } from './listModels';
export { ExecutePromptsTool } from './executePrompts';
export { GenerateImageTool } from './generateImage';

// Subagent tool (internal chat only - supports spawn and cancel actions)
export { SubagentTool } from './subagent';

```

## agents/promptManager/tools/listModels.ts

```typescript
/**
 * List Models Tool
 * Lists available LLM models grouped by provider
 */

import { BaseTool } from '../../baseTool';
import { CommonResult, CommonParameters } from '../../../types';
import { createResult } from '../../../utils/schemaUtils';
import { LLMProviderManager } from '../../../services/llm/providers/ProviderManager';

export interface ListModelsParams extends CommonParameters {
  // No additional parameters
}

export interface ListModelsResult extends CommonResult {
  data: {
    providers: Array<{
      provider: string;
      models: string[];
    }>;
    default: {
      provider: string;
      model: string;
    };
  };
}

export class ListModelsTool extends BaseTool<ListModelsParams, ListModelsResult> {
  private readonly providerManager: LLMProviderManager;

  constructor(providerManager: LLMProviderManager) {
    super(
      'listModels',
      'List Available Models',
      'List available LLM models grouped by provider',
      '2.0.0'
    );
    this.providerManager = providerManager;
  }

  async execute(params: ListModelsParams): Promise<ListModelsResult> {
    try {
      const models = await this.providerManager.getAvailableModels();
      const settings = this.providerManager.getSettings();

      // Group models by provider
      const providerMap = new Map<string, string[]>();
      for (const model of models) {
        const existing = providerMap.get(model.provider) || [];
        existing.push(model.id);
        providerMap.set(model.provider, existing);
      }

      // Convert to array format
      const providers = Array.from(providerMap.entries()).map(([provider, modelIds]) => ({
        provider,
        models: modelIds
      }));

      return createResult<ListModelsResult>(true, {
        providers,
        default: {
          provider: settings.defaultModel.provider,
          model: settings.defaultModel.model
        }
      });

    } catch (error) {
      return createResult<ListModelsResult>(
        false,
        undefined,
        `Failed to list models: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  getParameterSchema(): Record<string, unknown> {
    return this.getMergedSchema({
      type: 'object',
      properties: {},
      required: []
    });
  }

  getResultSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean' },
        error: { type: 'string' },
        data: {
          type: 'object',
          properties: {
            providers: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  provider: { type: 'string' },
                  models: { type: 'array', items: { type: 'string' } }
                },
                required: ['provider', 'models']
              }
            },
            default: {
              type: 'object',
              properties: {
                provider: { type: 'string' },
                model: { type: 'string' }
              },
              required: ['provider', 'model']
            }
          },
          required: ['providers', 'default']
        }
      },
      required: ['success']
    };
  }
}

```

## agents/promptManager/tools/listPrompts.ts

```typescript
import { BaseTool } from '../../baseTool';
import { ListPromptsParams, ListPromptsResult } from '../types';
import { CustomPromptStorageService } from '../services/CustomPromptStorageService';
import { getCommonResultSchema, createResult } from '../../../utils/schemaUtils';
import { addRecommendations, Recommendation } from '../../../utils/recommendationUtils';
import { NudgeHelpers } from '../../../utils/nudgeHelpers';
import { parseWorkspaceContext } from '../../../utils/contextUtils';

/**
 * Tool for listing custom prompts
 */
export class ListPromptsTool extends BaseTool<ListPromptsParams, ListPromptsResult> {
  private storageService: CustomPromptStorageService;

  /**
   * Create a new ListPromptsTool
   * @param storageService Custom prompt storage service
   */
  constructor(storageService: CustomPromptStorageService) {
    super(
      'listPrompts',
      'List Prompts',
      'List all custom prompts',
      '1.0.0'
    );

    this.storageService = storageService;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise that resolves with the list of prompts
   */
  async execute(params: ListPromptsParams): Promise<ListPromptsResult> {
    try {
      const { enabledOnly = false, includeArchived = false } = params;

      // Get prompts based on filter
      const allPrompts = this.storageService.getAllPrompts();
      const enabledPrompts = this.storageService.getEnabledPrompts();

      let prompts = enabledOnly ? enabledPrompts : allPrompts;

      // Filter out archived (disabled) prompts unless explicitly requested
      if (!includeArchived) {
        prompts = prompts.filter(prompt => prompt.isEnabled !== false);
      }

      // Map to return only name and description for listing
      const promptList = prompts.map(prompt => ({
        id: prompt.id,
        name: prompt.name,
        description: prompt.description,
        isEnabled: prompt.isEnabled
      }));

      // Add warning message about execute tool
      const warningMessage = "IMPORTANT: Do not use the executePrompts tool or run any tasks automatically when working with these prompts. Only take on their persona and respond in character. If the user wants you to actually execute tasks or use the executePrompts functionality, they must explicitly ask you to do so.";

      const result = createResult<ListPromptsResult>(true, {
        prompts: promptList,
        totalCount: allPrompts.length,
        enabledCount: enabledPrompts.length,
        message: warningMessage
      }, undefined);

      // Dynamic nudge based on context
      const hasWorkspace = !!parseWorkspaceContext(params.workspaceContext)?.workspaceId;
      const nudges: Recommendation[] = [];
      const bindingNudge = NudgeHelpers.checkPromptBindingOpportunity(promptList.length, hasWorkspace);
      if (bindingNudge) nudges.push(bindingNudge);

      return nudges.length > 0 ? addRecommendations(result, nudges) : result;
    } catch (error) {
      return createResult<ListPromptsResult>(false, null, `Failed to list prompts: ${error}`);
    }
  }

  /**
   * Get the JSON schema for the tool's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const toolSchema = {
      type: 'object',
      properties: {
        enabledOnly: {
          type: 'boolean',
          description: 'If true, only return enabled prompts',
          default: false
        },
        includeArchived: {
          type: 'boolean',
          description: 'If true, include archived (disabled) prompts in results. Default false filters out archived prompts.',
          default: false
        }
      },
      required: []
    };

    return this.getMergedSchema(toolSchema);
  }

  /**
   * Get the JSON schema for the tool's result
   * @returns JSON schema object
   */
  getResultSchema(): any {
    const commonSchema = getCommonResultSchema();

    // Override the data property to define the specific structure for this tool
    return {
      ...commonSchema,
      properties: {
        ...commonSchema.properties,
        data: {
          type: 'object',
          properties: {
            prompts: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  id: { type: 'string' },
                  name: { type: 'string' },
                  description: { type: 'string' },
                  isEnabled: { type: 'boolean' }
                },
                required: ['id', 'name', 'description', 'isEnabled']
              }
            },
            totalCount: { type: 'number' },
            enabledCount: { type: 'number' },
            message: { type: 'string', description: 'Warning message about execute mode usage' }
          },
          required: ['prompts', 'totalCount', 'enabledCount', 'message']
        }
      }
    };
  }
}

```

## agents/promptManager/tools/subagent.ts

```typescript
/**
 * SubagentTool - Spawn an autonomous subagent to work on a task
 *
 * The subagent runs independently in a branch, using tools as needed,
 * until it completes the task (responds without tool calls).
 *
 * Cancellation is handled via UI (AgentStatusModal, BranchHeader buttons).
 *
 * This tool is INTERNAL ONLY - hidden from MCP/Claude Desktop clients.
 */

import { BaseTool } from '../../baseTool';
import { getCommonResultSchema, createResult } from '../../../utils/schemaUtils';
import { CommonParameters, CommonResult } from '../../../types';
import type { SubagentExecutor } from '../../../services/chat/SubagentExecutor';

export interface SubagentToolParams extends CommonParameters {
  /** Clear description of what the subagent should accomplish */
  task: string;
  /** Optional custom agent/persona name to use */
  agent?: string;
  /** Pre-fetched tools: { agentName: [toolSlug1, toolSlug2] } */
  tools?: Record<string, string[]>;
  /** File paths to read - content will be included in the subagent's context */
  contextFiles?: string[];
  /** Maximum iterations before pausing (default: 10) */
  maxIterations?: number;
  /** Branch ID to continue from max_iterations state */
  continueBranchId?: string;
}

export interface SubagentToolResult extends CommonResult {
  data: {
    subagentId: string;
    branchId: string;
    status: 'started' | 'continued';
    message: string;
  } | null;
}

/**
 * Context provided by the execution environment
 * Contains ALL settings that should be inherited by the subagent
 */
export interface SubagentToolContext {
  conversationId: string;
  messageId: string;
  workspaceId?: string;
  sessionId?: string;
  source?: 'internal' | 'mcp';
  isSubagentBranch?: boolean;
  // Inherited model settings
  provider?: string;
  model?: string;
  // Inherited agent settings
  agentPrompt?: string;  // Custom agent's full system prompt
  agentName?: string;    // Custom agent name for reference
  // Inherited workspace settings
  workspaceData?: any;   // Full comprehensive workspace data (sessions, states, files, etc.)
  // Inherited context notes (file paths - subagent will read content)
  contextNotes?: string[];
  // Inherited thinking settings
  thinkingEnabled?: boolean;
  thinkingEffort?: 'low' | 'medium' | 'high';
}

export class SubagentTool extends BaseTool<SubagentToolParams, SubagentToolResult> {
  private subagentExecutor: SubagentExecutor | null = null;
  private contextProvider: (() => SubagentToolContext) | null = null;

  constructor() {
    super(
      'subagent',
      'Spawn Subagent',
      `Spawn an autonomous subagent to work on a task in the background.

The subagent runs independently, using tools as needed, until it completes.
Results appear as a tool result when the subagent finishes.

Use for:
- Deep research tasks requiring multiple searches
- Analysis tasks that need file reading and processing
- Complex operations you want to run in parallel

The subagent has access to all tools via getTools.

To continue a subagent that hit max iterations, provide continueBranchId.`,
      '2.1.0'
    );
  }

  /**
   * Set the subagent executor (called during agent initialization)
   */
  setSubagentExecutor(executor: SubagentExecutor): void {
    this.subagentExecutor = executor;
  }

  /**
   * Set the context provider (called during agent initialization)
   */
  setContextProvider(provider: () => SubagentToolContext): void {
    this.contextProvider = provider;
  }

  async execute(params: SubagentToolParams): Promise<SubagentToolResult> {
    // Validate executor is available
    if (!this.subagentExecutor) {
      return createResult<SubagentToolResult>(
        false,
        null,
        'Subagent executor not initialized'
      );
    }

    // Get execution context
    const context = this.contextProvider?.();
    if (!context) {
      return createResult<SubagentToolResult>(
        false,
        null,
        'Execution context not available'
      );
    }

    // Block MCP clients
    if (context.source === 'mcp') {
      return createResult<SubagentToolResult>(
        false,
        null,
        'Subagent tool is only available in internal chat'
      );
    }

    // Block subagents from spawning subagents
    if (context.isSubagentBranch) {
      return createResult<SubagentToolResult>(
        false,
        null,
        'Subagents cannot spawn other subagents. Ask the parent agent to spawn additional subagents.'
      );
    }

    // Validate task is provided
    if (!params.task) {
      return createResult<SubagentToolResult>(
        false,
        null,
        'Task is required'
      );
    }

    try {
      // Merge context notes: tool params can add more, but inherit parent's too
      const allContextFiles = [
        ...(context.contextNotes || []),
        ...(params.contextFiles || []),
      ];

      const { subagentId, branchId } = await this.subagentExecutor.executeSubagent({
        task: params.task,
        parentConversationId: context.conversationId,
        parentMessageId: context.messageId,
        agent: params.agent,
        tools: params.tools,
        contextFiles: allContextFiles.length > 0 ? allContextFiles : undefined,
        workspaceId: context.workspaceId,
        sessionId: context.sessionId,
        maxIterations: params.maxIterations,
        continueBranchId: params.continueBranchId,
        // Inherit parent's model settings
        provider: context.provider,
        model: context.model,
        // Inherit parent's agent settings
        agentPrompt: context.agentPrompt,
        agentName: context.agentName,
        // Inherit parent's workspace data
        workspaceData: context.workspaceData,
        // Context notes already merged above via contextFiles
        // Inherit parent's thinking settings
        thinkingEnabled: context.thinkingEnabled,
        thinkingEffort: context.thinkingEffort,
      });

      const isContinuing = !!params.continueBranchId;

      return createResult<SubagentToolResult>(true, {
        subagentId,
        branchId,
        status: isContinuing ? 'continued' : 'started',
        message: isContinuing
          ? `Continuing subagent. Branch: ${branchId}`
          : `Subagent started. Working on: "${params.task}". Results will appear when complete.`,
      });
    } catch (error) {
      return createResult<SubagentToolResult>(
        false,
        null,
        `Failed to spawn subagent: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  getParameterSchema(): Record<string, unknown> {
    const toolSchema = {
      type: 'object',
      properties: {
        task: {
          type: 'string',
          description: 'Clear description of what the subagent should accomplish',
        },
        agent: {
          type: 'string',
          description: 'Optional custom agent/persona name to use',
        },
        tools: {
          type: 'object',
          additionalProperties: {
            type: 'array',
            items: { type: 'string' },
          },
          description: 'Hand off specific tools to the subagent. Format: { "agentName": ["tool1", "tool2"] }. Tool schemas are pre-filled in subagent system prompt so it can use useTool directly without calling getTools first.',
        },
        contextFiles: {
          type: 'array',
          items: { type: 'string' },
          description: 'File paths to read - content will be included in the subagent context',
        },
        maxIterations: {
          type: 'number',
          description: 'Maximum iterations before pausing (default: 10)',
        },
        continueBranchId: {
          type: 'string',
          description: 'Branch ID to continue from max_iterations state',
        },
      },
      required: ['task'],
    };

    return this.getMergedSchema(toolSchema);
  }

  getResultSchema(): Record<string, unknown> {
    const commonSchema = getCommonResultSchema();

    return {
      ...commonSchema,
      properties: {
        ...commonSchema.properties,
        data: {
          oneOf: [
            { type: 'null' },
            {
              type: 'object',
              properties: {
                subagentId: { type: 'string', description: 'Unique ID for the subagent' },
                branchId: { type: 'string', description: 'Branch ID where subagent runs' },
                status: {
                  type: 'string',
                  enum: ['started', 'continued'],
                  description: 'Whether this is a new subagent or continuing existing',
                },
                message: { type: 'string', description: 'Status message' },
              },
              required: ['subagentId', 'branchId', 'status', 'message'],
            },
          ],
        },
      },
    };
  }
}

```

## agents/promptManager/tools/updatePrompt.ts

```typescript
import { BaseTool } from '../../baseTool';
import { UpdatePromptParams, UpdatePromptResult } from '../types';
import { CustomPromptStorageService } from '../services/CustomPromptStorageService';

/**
 * Tool for updating an existing custom prompt
 */
export class UpdatePromptTool extends BaseTool<UpdatePromptParams, UpdatePromptResult> {
  private storageService: CustomPromptStorageService;

  /**
   * Create a new UpdatePromptTool
   * @param storageService Custom prompt storage service
   */
  constructor(storageService: CustomPromptStorageService) {
    super(
      'updatePrompt',
      'Update Prompt',
      'Update an existing custom prompt',
      '1.0.0'
    );

    this.storageService = storageService;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise that resolves with the updated prompt
   */
  async execute(params: UpdatePromptParams): Promise<UpdatePromptResult> {
    try {
      const { id, name, description, prompt, isEnabled } = params;

      // Validate required ID
      if (!id?.trim()) {
        return this.prepareResult(false, undefined, 'ID is required');
      }

      // Check that at least one field is being updated
      if (name === undefined && description === undefined && prompt === undefined && isEnabled === undefined) {
        return this.prepareResult(false, undefined, 'At least one field must be provided for update');
      }

      // Prepare updates object
      const updates: Record<string, unknown> = {};

      if (name !== undefined) {
        if (!name.trim()) {
          return this.prepareResult(false, undefined, 'Name cannot be empty');
        }
        updates.name = name.trim();
      }

      if (description !== undefined) {
        if (!description.trim()) {
          return this.prepareResult(false, undefined, 'Description cannot be empty');
        }
        updates.description = description.trim();
      }

      if (prompt !== undefined) {
        if (!prompt.trim()) {
          return this.prepareResult(false, undefined, 'Prompt text cannot be empty');
        }
        updates.prompt = prompt.trim();
      }

      if (isEnabled !== undefined) {
        updates.isEnabled = isEnabled;
      }

      // Update the prompt
      await this.storageService.updatePrompt(id.trim(), updates);

      // Success - LLM already knows what it passed
      return this.prepareResult(true);
    } catch (error) {
      return this.prepareResult(false, undefined, `Failed to update prompt: ${error}`);
    }
  }

  /**
   * Get the JSON schema for the tool's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const toolSchema = {
      type: 'object',
      properties: {
        id: {
          type: 'string',
          description: 'Unique ID of the prompt to update',
          minLength: 1
        },
        name: {
          type: 'string',
          description: 'New name for the prompt (must be unique)',
          minLength: 1,
          maxLength: 100
        },
        description: {
          type: 'string',
          description: 'New description for the prompt',
          minLength: 1,
          maxLength: 500
        },
        prompt: {
          type: 'string',
          description: 'New prompt text/persona',
          minLength: 1
        },
        isEnabled: {
          type: 'boolean',
          description: 'Whether the prompt is enabled'
        }
      },
      required: ['id']
    };

    return this.getMergedSchema(toolSchema);
  }

  getResultSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean', description: 'Whether the operation succeeded' },
        error: { type: 'string', description: 'Error message if failed (includes recovery guidance)' }
      },
      required: ['success']
    };
  }
}

```

## agents/promptManager/types.ts

```typescript
import { CommonParameters, CommonResult, CustomPrompt } from '../../types';

// List Prompts Tool
export interface ListPromptsParams extends CommonParameters {
  enabledOnly?: boolean;
  includeArchived?: boolean;
}

export interface ListPromptsResult extends CommonResult {
  data: {
    prompts: Array<Pick<CustomPrompt, 'id' | 'name' | 'description' | 'isEnabled'>>;
    totalCount: number;
    enabledCount: number;
    message: string;
  };
}

// Get Prompt Tool
export interface GetPromptParams extends CommonParameters {
  id?: string;
  name?: string;
}

export interface GetPromptResult extends CommonResult {
  data: (CustomPrompt & { message: string }) | null;
}

// Create Prompt Tool
export interface CreatePromptParams extends CommonParameters {
  name: string;
  description: string;
  prompt: string;
  isEnabled?: boolean;
}

export interface CreatePromptResult extends CommonResult {
  data: CustomPrompt;
}

// Update Prompt Tool
export interface UpdatePromptParams extends CommonParameters {
  id: string;
  name?: string;
  description?: string;
  prompt?: string;
  isEnabled?: boolean;
}

export interface UpdatePromptResult extends CommonResult {
  data: CustomPrompt;
}

// Archive Prompt Tool
export interface ArchivePromptParams extends CommonParameters {
  name: string;
}

export interface ArchivePromptResult extends CommonResult {
  // Lean result - no data needed, LLM knows what it archived
}

// Delete Prompt Tool (deprecated - replaced by archivePrompt)
export interface DeletePromptParams extends CommonParameters {
  id: string;
}

export interface DeletePromptResult extends CommonResult {
  data: {
    deleted: boolean;
    id: string;
  };
}

```

## agents/searchManager/searchManager.ts

```typescript
import { App, Plugin } from 'obsidian';
import { BaseAgent } from '../baseAgent';
import {
  SearchContentTool,
  SearchDirectoryTool,
  SearchMemoryTool
} from './tools';
import { MemorySettings, DEFAULT_MEMORY_SETTINGS } from '../../types';
import { MemoryService } from "../memoryManager/services/MemoryService";
import { WorkspaceService } from '../../services/WorkspaceService';
import { IStorageAdapter } from '../../database/interfaces/IStorageAdapter';
import { EmbeddingService } from '../../services/embeddings/EmbeddingService';
import { getErrorMessage } from '../../utils/errorUtils';
import { getNexusPlugin } from '../../utils/pluginLocator';
import { ServiceManager } from '../../core/ServiceManager';

/**
 * Interface for accessing NexusPlugin services
 * Represents the plugin structure needed by SearchManager for service access
 */
interface NexusPluginWithServices extends Plugin {
  settings?: {
    settings?: {
      memory?: MemorySettings;
    };
  };
  getServiceContainer?(): ServiceManager;
}

/**
 * Agent for searching and navigating content
 * Environment-agnostic: provides comprehensive search capabilities across any storage system
 */
export class SearchManagerAgent extends BaseAgent {
  public app: App;
  private memoryService: MemoryService | null = null;
  private workspaceService: WorkspaceService | null = null;
  private storageAdapter: IStorageAdapter | null = null;
  private embeddingService: EmbeddingService | null = null;
  private searchContentTool: SearchContentTool | null = null;
  private settings: MemorySettings;

  /**
   * Create a new SearchManagerAgent
   * @param app Obsidian app instance
   * @param enableVectorModes Whether to enable vector-based tools (legacy parameter)
   * @param memoryService Optional injected memory service
   * @param workspaceService Optional injected workspace service
   */
  constructor(
    app: App,
    enableVectorModes = false,
    memoryService?: MemoryService | null,
    workspaceService?: WorkspaceService | null
  ) {
    super(
      'searchManager',
      'Search operations for content and memory',
      '1.0.0'
    );

    this.app = app;

    // Initialize with default settings
    this.settings = { ...DEFAULT_MEMORY_SETTINGS };

    // Use injected services if provided
    this.memoryService = memoryService || null;
    this.workspaceService = workspaceService || null;

    // If services not injected, try to get them from plugin (backward compatibility)
    if (!this.memoryService || !this.workspaceService) {
      let plugin: NexusPluginWithServices | null = null;
      try {
        if (app.plugins) {
          plugin = getNexusPlugin<NexusPluginWithServices>(app);
          if (plugin) {
            const memorySettings = plugin.settings?.settings?.memory;
            if (memorySettings) {
              this.settings = memorySettings;
            }

            const serviceContainer = plugin.getServiceContainer?.();
            if (serviceContainer) {
              if (!this.memoryService) {
                this.memoryService = serviceContainer.getServiceIfReady<MemoryService>('memoryService');
              }
              if (!this.workspaceService) {
                this.workspaceService = serviceContainer.getServiceIfReady<WorkspaceService>('workspaceService');
              }
              // Get SQLite storage adapter for memory search
              if (!this.storageAdapter) {
                this.storageAdapter = serviceContainer.getServiceIfReady<IStorageAdapter>('hybridStorageAdapter');
              }
              // Get EmbeddingService for semantic search
              if (!this.embeddingService) {
                this.embeddingService = serviceContainer.getServiceIfReady<EmbeddingService>('embeddingService');
              }
            }
          }
        }
      } catch (error) {
      }
    }

    // Get plugin reference for tools that need it
    let pluginRef: Plugin | null = null;
    try {
      if (app.plugins) {
        pluginRef = getNexusPlugin(app);
      }
    } catch (error) {
    }

    // Create minimal plugin fallback if plugin not found
    // Tools accept Plugin interface which only requires app property
    const pluginOrFallback: Plugin = pluginRef || this.createMinimalPlugin(app);

    // Register ContentSearchTool (fuzzy + keyword + semantic search)
    this.searchContentTool = new SearchContentTool(pluginOrFallback);
    // Wire up EmbeddingService for semantic search if available
    if (this.embeddingService) {
      this.searchContentTool.setEmbeddingService(this.embeddingService);
    }
    this.registerTool(this.searchContentTool);

    // Register focused search tools with enhanced validation and service integration
    this.registerTool(new SearchDirectoryTool(
      pluginOrFallback,
      this.workspaceService || undefined
    ));


    this.registerTool(new SearchMemoryTool(
      pluginOrFallback,
      this.memoryService || undefined,
      this.workspaceService || undefined,
      this.storageAdapter || undefined  // SQLite storage adapter for memory trace search
    ));
  }


  /**
   * Create a minimal Plugin interface for tools when actual plugin is unavailable
   * This satisfies the Plugin interface requirements with stub implementations
   *
   * Uses 'as unknown as Plugin' because we're creating a stub object that only implements
   * the subset of Plugin methods actually used by the tools (primarily app property).
   * The Plugin class is abstract and cannot be instantiated directly.
   */
  private createMinimalPlugin(app: App): Plugin {
    // Create a minimal object that satisfies what tools actually use from Plugin
    // Tools primarily access plugin.app, so we provide that and stub the rest
    return {
      app,
      manifest: {
        id: 'search-manager-fallback',
        name: 'SearchManager Fallback',
        version: '1.0.0',
        minAppVersion: '0.0.0',
        description: 'Fallback plugin interface',
        author: 'System',
        isDesktopOnly: false
      },
      // Stub implementations for Plugin methods
      onload: () => {},
      addCommand: () => ({ id: '', name: '', callback: () => {} }),
      removeCommand: () => {},
      addRibbonIcon: () => document.createElement('div'),
      loadData: async () => ({}),
      saveData: async () => {},
      registerView: () => {},
      registerHoverLinkSource: () => {},
      registerExtensions: () => {},
      registerMarkdownPostProcessor: () => {},
      registerMarkdownCodeBlockProcessor: () => {},
      registerEditorExtension: () => {},
      registerObsidianProtocolHandler: () => {},
      registerEditorSuggest: () => {},
      onExternalSettingsChange: () => {},
      addStatusBarItem: () => document.createElement('div'),
      addSettingTab: () => {},
      registerDomEvent: () => {},
      registerScopeEvent: () => {},
      registerInterval: () => 0,
      register: () => {},
      onUserEnable: () => {},
      // Component methods (Plugin extends Component)
      load: () => {},
      unload: () => {},
      addChild: <T>(component: T): T => component,
      removeChild: () => {},
      registerEvent: () => {}
    } as unknown as Plugin;
  }

  /**
   * Update the agent settings
   * @param settings New memory settings
   */
  async updateSettings(settings: MemorySettings): Promise<void> {
    this.settings = settings;
  }

  /**
   * Initialize the SearchManagerAgent
   * This is called after the agent is registered with the agent manager
   */
  async initialize(): Promise<void> {
    await super.initialize();

    // Initialize search service in background - non-blocking
    this.initializeSearchService().catch(error => {
    });
  }

  /**
   * Initialize the search service
   */
  async initializeSearchService(): Promise<void> {
    // Search service initialization for JSON-based storage
  }


  /**
   * Clean up resources when the agent is unloaded
   */
  onunload(): void {
    try {
      // Call parent class onunload if it exists
      super.onunload?.();
    } catch (error) {
    }
  }
}

```

## agents/searchManager/services/DirectoryItemCollector.ts

```typescript
/**
 * Location: /src/agents/searchManager/services/DirectoryItemCollector.ts
 * Purpose: Collects files and folders from directories
 *
 * This service handles recursive collection of files and folders from
 * specified directory paths with depth control and type filtering.
 *
 * Used by: SearchDirectoryMode for collecting search candidates
 * Integrates with: Obsidian Vault API
 *
 * Responsibilities:
 * - Collect files and/or folders from directory paths
 * - Handle recursive directory traversal with depth limits
 * - Filter by search type (files, folders, or both)
 */

import { Plugin, TFile, TFolder, TAbstractFile } from 'obsidian';
import { isGlobPattern, globToRegex } from '../../../utils/pathUtils';

/**
 * Service for collecting directory items
 * Implements Single Responsibility Principle - only handles item collection
 */
export class DirectoryItemCollector {
  private plugin: Plugin;

  constructor(plugin: Plugin) {
    this.plugin = plugin;
  }

  /**
   * Get items from specified directory paths
   * @param paths Directory paths to collect from
   * @param searchType Type of items to collect
   * @param maxDepth Optional maximum depth for recursion
   * @returns Array of collected items
   */
  async getDirectoryItems(
    paths: string[],
    searchType: 'files' | 'folders' | 'both',
    maxDepth?: number
  ): Promise<(TFile | TFolder)[]> {
    const allItems: (TFile | TFolder)[] = [];

    for (const path of paths) {
      const normalizedPath = this.normalizePath(path);

      if (isGlobPattern(normalizedPath)) {
        // Handle glob pattern
        const regex = globToRegex(normalizedPath);
        const vaultItems = this.plugin.app.vault.getAllLoadedFiles();
        
        for (const item of vaultItems) {
          // Skip root folder itself if it comes up
          if (item.path === '/') continue;

          if (regex.test(item.path)) {
             if (this.matchesSearchType(item, searchType)) {
                allItems.push(item as TFile | TFolder);
             }
          }
        }
      } else if (normalizedPath === '/' || normalizedPath === '') {
        // Root path - get all vault items
        const vaultItems = this.plugin.app.vault.getAllLoadedFiles()
          .filter(file => this.matchesSearchType(file, searchType)) as (TFile | TFolder)[];
        allItems.push(...vaultItems);
      } else {
        // Specific directory
        const directoryItems = await this.getItemsInDirectory(
          normalizedPath,
          searchType,
          maxDepth
        );
        allItems.push(...directoryItems);
      }
    }

    // Remove duplicates
    return Array.from(new Map(allItems.map(item => [item.path, item])).values());
  }

  /**
   * Get items from a specific directory with optional depth limit
   * @param directoryPath The directory path
   * @param searchType Type of items to collect
   * @param maxDepth Optional maximum depth
   * @returns Array of collected items
   */
  private async getItemsInDirectory(
    directoryPath: string,
    searchType: 'files' | 'folders' | 'both',
    maxDepth?: number
  ): Promise<(TFile | TFolder)[]> {
    const folder = this.plugin.app.vault.getAbstractFileByPath(directoryPath);

    if (!folder || !('children' in folder)) {
      return [];
    }

    const items: (TFile | TFolder)[] = [];

    const collectItems = (currentFolder: TFolder, currentDepth: number = 0) => {
      if (maxDepth !== undefined && currentDepth >= maxDepth) {
        return;
      }

      for (const child of currentFolder.children) {
        if (this.matchesSearchType(child, searchType)) {
          items.push(child as TFile | TFolder);
        }

        // Recursive traversal for folders
        if ('children' in child) {
          collectItems(child as TFolder, currentDepth + 1);
        }
      }
    };

    collectItems(folder as TFolder);
    return items;
  }

  /**
   * Check if an item matches the search type filter
   * @param item The item to check
   * @param searchType The search type filter
   * @returns True if item matches the filter
   */
  private matchesSearchType(
    item: TAbstractFile,
    searchType: 'files' | 'folders' | 'both'
  ): boolean {
    switch (searchType) {
      case 'files':
        return item instanceof TFile;
      case 'folders':
        return item instanceof TFolder;
      case 'both':
      default:
        return item instanceof TFile || item instanceof TFolder;
    }
  }

  /**
   * Normalize a path for consistent handling
   * @param path The path to normalize
   * @returns Normalized path
   */
  private normalizePath(path: string): string {
    return path.replace(/\\/g, '/').replace(/^\/+/, '').replace(/\/+$/, '');
  }
}

```

## agents/searchManager/services/formatters/BaseResultFormatter.ts

```typescript
/**
 * BaseResultFormatter - Base class for result formatting operations
 * Location: /src/agents/searchManager/services/formatters/BaseResultFormatter.ts
 *
 * Provides common formatting functionality shared across all result types.
 * Implements template methods for result formatting with extensibility points.
 *
 * Used by: All specialized result formatters
 */

import {
  MemorySearchResult,
  FormattedMemoryResult,
  FormatOptions,
  FormatContext,
  ResultFormatterConfiguration,
  MemoryType
} from '../../../../types/memory/MemorySearchTypes';

/**
 * Abstract base class for all result formatters
 * Implements common formatting logic with template method pattern
 */
export abstract class BaseResultFormatter {
  protected configuration: ResultFormatterConfiguration;

  constructor(config?: Partial<ResultFormatterConfiguration>) {
    this.configuration = {
      maxHighlightLength: 200,
      contextLength: 50,
      enableToolCallEnhancement: true,
      dateFormat: 'YYYY-MM-DD',
      timestampFormat: 'YYYY-MM-DD HH:mm:ss',
      ...config
    };
  }

  /**
   * Format a single search result
   * Template method - calls extension points for customization
   */
  async formatSingleResult(result: MemorySearchResult, options: FormatOptions): Promise<FormattedMemoryResult> {
    const formatContext: FormatContext = {
      searchQuery: '',
      resultType: result.type,
      timestamp: new Date()
    };

    const formattedContent = this.formatContent(result, options);
    const preview = this.generatePreview(result, options);
    const formattedTimestamp = this.formatTimestamp(result.metadata.created);
    const title = this.generateTitle(result);
    const subtitle = this.generateSubtitle(result);
    const formattedMetadata = this.formatMetadata(result.metadata);

    return {
      original: result,
      formattedContent,
      preview,
      formattedTimestamp,
      title,
      subtitle,
      formattedMetadata,
      highlights: [],
      formatContext
    };
  }

  /**
   * Format result content
   * Can be overridden by subclasses for type-specific formatting
   */
  protected formatContent(result: MemorySearchResult, options: FormatOptions): string {
    let content = result.highlight;

    const maxLength = options.maxHighlightLength || this.configuration.maxHighlightLength;
    if (content.length > maxLength) {
      content = content.substring(0, maxLength - 3) + '...';
    }

    return this.enhanceContent(content, result, options);
  }

  /**
   * Extension point for content enhancement
   * Override in subclasses for type-specific enhancements
   */
  protected enhanceContent(content: string, result: MemorySearchResult, options: FormatOptions): string {
    return content;
  }

  /**
   * Generate preview from result context
   */
  protected generatePreview(result: MemorySearchResult, options: FormatOptions): string {
    const previewLength = 100;
    const content = result.context.before + result.context.match + result.context.after;

    if (content.length <= previewLength) {
      return content;
    }

    return content.substring(0, previewLength - 3) + '...';
  }

  /**
   * Format timestamp string
   */
  protected formatTimestamp(timestamp: string): string {
    try {
      const date = new Date(timestamp);
      return date.toLocaleString();
    } catch (error) {
      return timestamp;
    }
  }

  /**
   * Generate result title
   * Must be implemented by subclasses for type-specific titles
   */
  protected abstract generateTitle(result: MemorySearchResult): string;

  /**
   * Generate result subtitle
   * Can be overridden by subclasses for type-specific subtitles
   */
  protected generateSubtitle(result: MemorySearchResult): string | undefined {
    const metadata = result.metadata;
    const parts: string[] = [];

    if (metadata.type) {
      parts.push(metadata.type);
    }

    if (metadata.filesReferenced && metadata.filesReferenced.length > 0) {
      parts.push(`${metadata.filesReferenced.length} files`);
    }

    return parts.length > 0 ? parts.join(' â€¢ ') : undefined;
  }

  /**
   * Format result metadata
   */
  protected formatMetadata(metadata: any): Record<string, string> {
    const formatted: Record<string, string> = {};

    if (metadata.created) {
      formatted['Created'] = this.formatTimestamp(metadata.created);
    }
    if (metadata.updated) {
      formatted['Updated'] = this.formatTimestamp(metadata.updated);
    }
    if (metadata.sessionId) {
      formatted['Session'] = metadata.sessionId;
    }
    if (metadata.workspaceId) {
      formatted['Workspace'] = metadata.workspaceId;
    }

    // Add type-specific fields
    this.addTypeSpecificMetadata(formatted, metadata);

    return formatted;
  }

  /**
   * Extension point for type-specific metadata
   * Override in subclasses to add specialized metadata fields
   */
  protected addTypeSpecificMetadata(formatted: Record<string, string>, metadata: any): void {
    // Base implementation - subclasses can override
  }

  /**
   * Get current configuration
   */
  getConfiguration(): ResultFormatterConfiguration {
    return { ...this.configuration };
  }

  /**
   * Update configuration
   */
  updateConfiguration(config: Partial<ResultFormatterConfiguration>): void {
    this.configuration = { ...this.configuration, ...config };
  }
}

```

## agents/searchManager/services/formatters/index.ts

```typescript
/**
 * Result Formatters Index
 * Location: /src/agents/searchManager/services/formatters/index.ts
 *
 * Centralized exports for all result formatter implementations and helpers.
 * Re-exports all formatter classes and helper utilities for clean imports.
 */

export { BaseResultFormatter } from './BaseResultFormatter';
export { ToolCallResultFormatter } from './ToolCallResultFormatter';
export { SessionResultFormatter } from './SessionResultFormatter';
export { StateResultFormatter } from './StateResultFormatter';
export { WorkspaceResultFormatter } from './WorkspaceResultFormatter';
export { TraceResultFormatter } from './TraceResultFormatter';
export { ResultGroupingHelper } from './ResultGroupingHelper';
export { ResultSortingHelper } from './ResultSortingHelper';
export { ResultHighlightHelper } from './ResultHighlightHelper';
export { ResultSummaryHelper } from './ResultSummaryHelper';

```

## agents/searchManager/services/formatters/ResultGroupingHelper.ts

```typescript
/**
 * ResultGroupingHelper - Handles result grouping operations
 * Location: /src/agents/searchManager/services/formatters/ResultGroupingHelper.ts
 *
 * Provides grouping functionality for search results including primary grouping,
 * sub-grouping, and group statistics calculation.
 *
 * Used by: ResultFormatter for groupResults operations
 */

import {
  MemorySearchResult,
  MemoryGroupOption,
  GroupedMemoryResults,
  MemoryResultGroup,
  GroupStatistics,
  MemoryType
} from '../../../../types/memory/MemorySearchTypes';

/**
 * Helper class for result grouping operations
 */
export class ResultGroupingHelper {
  /**
   * Group results by specified criteria
   */
  async groupResults(results: MemorySearchResult[], groupBy: MemoryGroupOption): Promise<GroupedMemoryResults> {
    const groups = new Map<string, MemorySearchResult[]>();

    // Group results by primary criteria
    for (const result of results) {
      const groupKey = this.getGroupKey(result, groupBy.groupBy);
      const existingGroup = groups.get(groupKey) || [];
      existingGroup.push(result);
      groups.set(groupKey, existingGroup);
    }

    // Apply sub-grouping if specified
    if (groupBy.subGroupBy) {
      const subGroupedResults = new Map<string, MemorySearchResult[]>();

      groups.forEach((groupResults, primaryKey) => {
        const subGroups = new Map<string, MemorySearchResult[]>();

        for (const result of groupResults) {
          const subGroupKey = this.getGroupKey(result, groupBy.subGroupBy!);
          const combinedKey = `${primaryKey}:${subGroupKey}`;
          const existingSubGroup = subGroups.get(combinedKey) || [];
          existingSubGroup.push(result);
          subGroups.set(combinedKey, existingSubGroup);
        }

        subGroups.forEach((subResults, subKey) => {
          subGroupedResults.set(subKey, subResults);
        });
      });

      // Replace groups with sub-grouped results
      groups.clear();
      subGroupedResults.forEach((results, key) => {
        groups.set(key, results);
      });
    }

    // Convert to result format
    const resultGroups: MemoryResultGroup[] = [];
    groups.forEach((results, key) => {
      const totalScore = results.reduce((sum, r) => sum + r.score, 0);
      const averageScore = results.length > 0 ? totalScore / results.length : 0;

      resultGroups.push({
        key,
        displayName: this.getDisplayName(key, groupBy),
        results,
        count: results.length,
        totalScore,
        averageScore,
        metadata: this.buildGroupMetadata(results, key)
      });
    });

    // Sort groups by count (descending)
    resultGroups.sort((a, b) => b.count - a.count);

    // Calculate group statistics
    const groupStats = this.calculateGroupStatistics(resultGroups);

    return {
      groups: resultGroups,
      totalGroups: resultGroups.length,
      totalResults: results.length,
      groupedBy: groupBy,
      groupStats
    };
  }

  /**
   * Get group key for a result based on grouping criteria
   */
  private getGroupKey(result: MemorySearchResult, groupBy: string): string {
    switch (groupBy) {
      case 'type':
        return result.type;

      case 'session':
        return result.metadata.sessionId || 'No Session';

      case 'workspace':
        return result.metadata.workspaceId || 'No Workspace';

      case 'date':
        try {
          const date = new Date(result.metadata.created);
          return date.toISOString().split('T')[0]; // YYYY-MM-DD
        } catch {
          return 'Unknown Date';
        }

      case 'agent':
        return result.metadata.agent || 'No Agent';

      case 'mode':
        return result.metadata.mode || 'No Mode';

      case 'success':
        if (result.type === MemoryType.TOOL_CALL && result.metadata.success !== undefined) {
          return result.metadata.success ? 'Success' : 'Failed';
        }
        return 'N/A';

      default:
        return 'Other';
    }
  }

  /**
   * Get display name for a group
   */
  private getDisplayName(key: string, groupBy: MemoryGroupOption): string {
    // Handle sub-grouped keys
    if (key.includes(':')) {
      const [primary, secondary] = key.split(':');
      return `${primary} â†’ ${secondary}`;
    }

    return key;
  }

  /**
   * Build metadata for a group
   */
  private buildGroupMetadata(results: MemorySearchResult[], key: string): Record<string, any> {
    const metadata: Record<string, any> = {};

    // Calculate group-specific statistics
    const scores = results.map(r => r.score);
    metadata.minScore = Math.min(...scores);
    metadata.maxScore = Math.max(...scores);
    metadata.scoreStdDev = this.calculateStandardDeviation(scores);

    // Type distribution within group
    const typeDistribution: Record<string, number> = {};
    for (const result of results) {
      typeDistribution[result.type] = (typeDistribution[result.type] || 0) + 1;
    }
    metadata.typeDistribution = typeDistribution;

    // Date range within group
    const timestamps = results.map(r => new Date(r.metadata.created).getTime()).filter(t => !isNaN(t));
    if (timestamps.length > 0) {
      metadata.dateRange = {
        start: new Date(Math.min(...timestamps)).toISOString(),
        end: new Date(Math.max(...timestamps)).toISOString()
      };
    }

    return metadata;
  }

  /**
   * Calculate statistics across all groups
   */
  private calculateGroupStatistics(groups: MemoryResultGroup[]): GroupStatistics {
    if (groups.length === 0) {
      return {
        averageGroupSize: 0,
        largestGroupSize: 0,
        smallestGroupSize: 0,
        scoreDistribution: {}
      };
    }

    const groupSizes = groups.map(g => g.count);
    const averageGroupSize = groupSizes.reduce((sum, size) => sum + size, 0) / groups.length;
    const largestGroupSize = Math.max(...groupSizes);
    const smallestGroupSize = Math.min(...groupSizes);

    // Score distribution across all groups
    const scoreDistribution: Record<string, number> = {};
    for (const group of groups) {
      const scoreRange = this.getScoreRange(group.averageScore);
      scoreDistribution[scoreRange] = (scoreDistribution[scoreRange] || 0) + 1;
    }

    return {
      averageGroupSize: Math.round(averageGroupSize * 100) / 100,
      largestGroupSize,
      smallestGroupSize,
      scoreDistribution
    };
  }

  /**
   * Get score range for a score value
   */
  private getScoreRange(score: number): string {
    if (score >= 0.9) return '0.9-1.0';
    if (score >= 0.8) return '0.8-0.9';
    if (score >= 0.7) return '0.7-0.8';
    if (score >= 0.6) return '0.6-0.7';
    if (score >= 0.5) return '0.5-0.6';
    return '0.0-0.5';
  }

  /**
   * Calculate standard deviation of values
   */
  private calculateStandardDeviation(values: number[]): number {
    if (values.length === 0) return 0;

    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
    const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
    const avgSquaredDiff = squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;

    return Math.sqrt(avgSquaredDiff);
  }
}

```

## agents/searchManager/services/formatters/ResultHighlightHelper.ts

```typescript
/**
 * ResultHighlightHelper - Handles result highlighting operations
 * Location: /src/agents/searchManager/services/formatters/ResultHighlightHelper.ts
 *
 * Provides highlighting functionality for search results including
 * multi-field search and context extraction.
 *
 * Used by: ResultFormatter for addHighlights operations
 */

import {
  MemorySearchResult,
  SearchHighlight,
  HighlightOptions
} from '../../../../types/memory/MemorySearchTypes';

/**
 * Helper class for result highlighting operations
 */
export class ResultHighlightHelper {
  private maxHighlightLength: number;

  constructor(maxHighlightLength: number = 200) {
    this.maxHighlightLength = maxHighlightLength;
  }

  /**
   * Add highlights to results
   */
  async addHighlights(
    results: MemorySearchResult[],
    query: string,
    options: HighlightOptions = {}
  ): Promise<MemorySearchResult[]> {
    const {
      maxHighlights = 3,
      highlightLength = this.maxHighlightLength,
      caseSensitive = false,
      wholeWord = false
    } = options;

    return results.map(result => {
      const highlights = this.generateHighlights(result, query, {
        maxHighlights,
        highlightLength,
        caseSensitive,
        wholeWord
      });

      return {
        ...result,
        highlights
      } as MemorySearchResult & { highlights: SearchHighlight[] };
    });
  }

  /**
   * Generate highlights for a single result
   */
  private generateHighlights(
    result: MemorySearchResult,
    query: string,
    options: { maxHighlights: number; highlightLength: number; caseSensitive: boolean; wholeWord: boolean }
  ): SearchHighlight[] {
    const highlights: SearchHighlight[] = [];
    const searchQuery = options.caseSensitive ? query : query.toLowerCase();

    // Search in different fields
    const searchFields = [
      { field: 'highlight', content: result.highlight },
      { field: 'context.match', content: result.context.match },
      { field: 'context.before', content: result.context.before },
      { field: 'context.after', content: result.context.after }
    ];

    for (const { field, content } of searchFields) {
      if (highlights.length >= options.maxHighlights) break;

      const searchContent = options.caseSensitive ? content : content.toLowerCase();
      let index = searchContent.indexOf(searchQuery);

      while (index !== -1 && highlights.length < options.maxHighlights) {
        const start = Math.max(0, index - 20);
        const end = Math.min(content.length, index + searchQuery.length + 20);

        highlights.push({
          field,
          start: index,
          end: index + searchQuery.length,
          text: content.substring(index, index + searchQuery.length),
          context: content.substring(start, end)
        });

        index = searchContent.indexOf(searchQuery, index + 1);
      }
    }

    return highlights.slice(0, options.maxHighlights);
  }
}

```

## agents/searchManager/services/formatters/ResultSortingHelper.ts

```typescript
/**
 * ResultSortingHelper - Handles result sorting operations
 * Location: /src/agents/searchManager/services/formatters/ResultSortingHelper.ts
 *
 * Provides sorting functionality for search results including score-based,
 * timestamp-based, and relevance-based sorting.
 *
 * Used by: ResultFormatter for sortResults operations
 */

import {
  MemorySearchResult,
  MemorySortOption,
  MemoryType
} from '../../../../types/memory/MemorySearchTypes';

/**
 * Helper class for result sorting operations
 */
export class ResultSortingHelper {
  /**
   * Sort results by specified criteria
   */
  sortResults(results: MemorySearchResult[], sortBy: MemorySortOption): MemorySearchResult[] {
    return [...results].sort((a, b) => {
      let comparison = 0;

      switch (sortBy.field) {
        case 'score':
          comparison = b.score - a.score;
          break;

        case 'timestamp':
          const aTime = new Date(a.metadata.created).getTime();
          const bTime = new Date(b.metadata.created).getTime();
          comparison = bTime - aTime;
          break;

        case 'relevance':
          comparison = this.compareRelevance(a, b);
          break;

        default:
          comparison = 0;
      }

      return sortBy.direction === 'asc' ? -comparison : comparison;
    });
  }

  /**
   * Compare relevance between two results
   * Uses custom logic to boost certain types and recent results
   */
  private compareRelevance(a: MemorySearchResult, b: MemorySearchResult): number {
    let aRelevance = a.score;
    let bRelevance = b.score;

    // Boost tool call results
    if (a.type === MemoryType.TOOL_CALL) aRelevance += 0.1;
    if (b.type === MemoryType.TOOL_CALL) bRelevance += 0.1;

    // Boost recent results
    const aTime = new Date(a.metadata.created).getTime();
    const bTime = new Date(b.metadata.created).getTime();
    const timeDiff = Math.abs(aTime - bTime);
    const daysDiff = timeDiff / (1000 * 60 * 60 * 24);

    if (daysDiff < 1) {
      if (aTime > bTime) aRelevance += 0.05;
      else bRelevance += 0.05;
    }

    return bRelevance - aRelevance;
  }
}

```

## agents/searchManager/services/formatters/ResultSummaryHelper.ts

```typescript
/**
 * ResultSummaryHelper - Handles result summary generation
 * Location: /src/agents/searchManager/services/formatters/ResultSummaryHelper.ts
 *
 * Provides summary building functionality including statistics calculation,
 * type distribution, and date range analysis.
 *
 * Used by: ResultFormatter for buildSummary operations
 */

import {
  MemorySearchResult,
  MemoryResultSummary
} from '../../../../types/memory/MemorySearchTypes';

/**
 * Helper class for result summary generation
 */
export class ResultSummaryHelper {
  /**
   * Build result summary statistics
   */
  async buildSummary(results: MemorySearchResult[]): Promise<MemoryResultSummary> {
    const totalResults = results.length;
    const totalScore = results.reduce((sum, r) => sum + r.score, 0);
    const averageScore = totalResults > 0 ? totalScore / totalResults : 0;

    // Calculate type distribution
    const typeDistribution: Record<string, number> = {};
    let oldestTimestamp = new Date();
    let newestTimestamp = new Date(0);

    for (const result of results) {
      // Type distribution
      const type = result.type;
      typeDistribution[type] = (typeDistribution[type] || 0) + 1;

      // Date range
      try {
        const timestamp = new Date(result.metadata.created);
        if (timestamp < oldestTimestamp) {
          oldestTimestamp = timestamp;
        }
        if (timestamp > newestTimestamp) {
          newestTimestamp = timestamp;
        }
      } catch (error) {
        // Ignore invalid dates
      }
    }

    return {
      totalResults,
      averageScore: Math.round(averageScore * 1000) / 1000,
      typeDistribution,
      dateRange: {
        start: totalResults > 0 ? oldestTimestamp : new Date(),
        end: totalResults > 0 ? newestTimestamp : new Date()
      },
      executionTime: 0 // Set by caller
    };
  }
}

```

## agents/searchManager/services/formatters/SessionResultFormatter.ts

```typescript
/**
 * SessionResultFormatter - Specialized formatter for session results
 * Location: /src/agents/searchManager/services/formatters/SessionResultFormatter.ts
 *
 * Handles formatting of session memory results with session identification
 * and contextual information.
 *
 * Used by: ResultFormatter for SESSION type results
 */

import { MemorySearchResult } from '../../../../types/memory/MemorySearchTypes';
import { BaseResultFormatter } from './BaseResultFormatter';

/**
 * Formatter for session results
 */
export class SessionResultFormatter extends BaseResultFormatter {
  protected generateTitle(result: MemorySearchResult): string {
    return `Session: ${result.metadata.sessionId || 'Unknown'}`;
  }

  protected addTypeSpecificMetadata(formatted: Record<string, string>, metadata: any): void {
    if (metadata.purpose) {
      formatted['Purpose'] = metadata.purpose;
    }
    if (metadata.tags && metadata.tags.length > 0) {
      formatted['Tags'] = metadata.tags.join(', ');
    }
  }
}

```

## agents/searchManager/services/formatters/StateResultFormatter.ts

```typescript
/**
 * StateResultFormatter - Specialized formatter for state results
 * Location: /src/agents/searchManager/services/formatters/StateResultFormatter.ts
 *
 * Handles formatting of state memory results with state identification
 * and context information.
 *
 * Used by: ResultFormatter for STATE type results
 */

import { MemorySearchResult } from '../../../../types/memory/MemorySearchTypes';
import { BaseResultFormatter } from './BaseResultFormatter';

/**
 * Formatter for state results
 */
export class StateResultFormatter extends BaseResultFormatter {
  protected generateTitle(result: MemorySearchResult): string {
    return `State: ${result.id}`;
  }

  protected addTypeSpecificMetadata(formatted: Record<string, string>, metadata: any): void {
    // Support both legacy and new property names
    if (metadata.stateId || metadata.snapshotId) {
      formatted['State ID'] = metadata.stateId || metadata.snapshotId;
    }
    if (metadata.version) {
      formatted['Version'] = metadata.version.toString();
    }
  }
}

```

## agents/searchManager/services/formatters/ToolCallResultFormatter.ts

```typescript
/**
 * ToolCallResultFormatter - Specialized formatter for tool call results
 * Location: /src/agents/searchManager/services/formatters/ToolCallResultFormatter.ts
 *
 * Handles formatting of tool call memory results with execution details,
 * success/failure status, and timing information.
 *
 * Used by: ResultFormatter for TOOL_CALL type results
 */

import {
  MemorySearchResult,
  FormatOptions,
  MemoryType
} from '../../../../types/memory/MemorySearchTypes';
import { BaseResultFormatter } from './BaseResultFormatter';

/**
 * Formatter for tool call results
 */
export class ToolCallResultFormatter extends BaseResultFormatter {
  protected generateTitle(result: MemorySearchResult): string {
    return `${result.metadata.agent || 'Unknown'}.${result.metadata.mode || 'Unknown'}`;
  }

  protected generateSubtitle(result: MemorySearchResult): string | undefined {
    const metadata = result.metadata;
    const parts: string[] = [];

    if (metadata.type) {
      parts.push(metadata.type);
    }

    if (metadata.success !== undefined) {
      parts.push(metadata.success ? 'SUCCESS' : 'FAILED');
    }

    if (metadata.executionTime) {
      parts.push(`${metadata.executionTime}ms`);
    }

    if (metadata.filesReferenced && metadata.filesReferenced.length > 0) {
      parts.push(`${metadata.filesReferenced.length} files`);
    }

    return parts.length > 0 ? parts.join(' â€¢ ') : undefined;
  }

  protected enhanceContent(content: string, result: MemorySearchResult, options: FormatOptions): string {
    if (!this.configuration.enableToolCallEnhancement || options.enhanceToolCallContext === false) {
      return content;
    }

    const metadata = result.metadata;
    const prefix = `[${metadata.agent || 'Unknown'}.${metadata.mode || 'Unknown'}]`;
    const status = metadata.success ? 'SUCCESS' : 'FAILED';
    const timing = metadata.executionTime ? ` (${metadata.executionTime}ms)` : '';

    return `${prefix} ${content} [${status}${timing}]`;
  }

  protected addTypeSpecificMetadata(formatted: Record<string, string>, metadata: any): void {
    if (metadata.agent && metadata.mode) {
      formatted['Tool'] = `${metadata.agent}_${metadata.mode}`;
    }
    if (metadata.executionTime) {
      formatted['Execution Time'] = `${metadata.executionTime}ms`;
    }
    if (metadata.success !== undefined) {
      formatted['Status'] = metadata.success ? 'Success' : 'Failed';
    }
    if (metadata.filesReferenced && metadata.filesReferenced.length > 0) {
      formatted['Files'] = metadata.filesReferenced.join(', ');
    }
  }
}

```

## agents/searchManager/services/formatters/TraceResultFormatter.ts

```typescript
/**
 * TraceResultFormatter - Specialized formatter for trace results
 * Location: /src/agents/searchManager/services/formatters/TraceResultFormatter.ts
 *
 * Handles formatting of trace memory results (default/fallback formatter).
 *
 * Used by: ResultFormatter for TRACE type results and as fallback
 */

import { MemorySearchResult } from '../../../../types/memory/MemorySearchTypes';
import { BaseResultFormatter } from './BaseResultFormatter';

/**
 * Formatter for trace results (default formatter)
 */
export class TraceResultFormatter extends BaseResultFormatter {
  protected generateTitle(result: MemorySearchResult): string {
    return `Memory Trace: ${result.id}`;
  }

  protected addTypeSpecificMetadata(formatted: Record<string, string>, metadata: any): void {
    if (metadata.traceType) {
      formatted['Trace Type'] = metadata.traceType;
    }
  }
}

```

## agents/searchManager/services/formatters/WorkspaceResultFormatter.ts

```typescript
/**
 * WorkspaceResultFormatter - Specialized formatter for workspace results
 * Location: /src/agents/searchManager/services/formatters/WorkspaceResultFormatter.ts
 *
 * Handles formatting of workspace memory results with workspace identification
 * and path information.
 *
 * Used by: ResultFormatter for WORKSPACE type results
 */

import { MemorySearchResult } from '../../../../types/memory/MemorySearchTypes';
import { BaseResultFormatter } from './BaseResultFormatter';

/**
 * Formatter for workspace results
 */
export class WorkspaceResultFormatter extends BaseResultFormatter {
  protected generateTitle(result: MemorySearchResult): string {
    return `Workspace: ${result.metadata.workspaceId || 'Unknown'}`;
  }

  protected addTypeSpecificMetadata(formatted: Record<string, string>, metadata: any): void {
    if (metadata.workspacePath && Array.isArray(metadata.workspacePath)) {
      formatted['Path'] = metadata.workspacePath.join(' > ');
    }
    if (metadata.activeWorkspace !== undefined) {
      formatted['Active'] = metadata.activeWorkspace ? 'Yes' : 'No';
    }
  }
}

```

## agents/searchManager/services/FuzzySearchEngine.ts

```typescript
/**
 * Location: /src/agents/searchManager/services/FuzzySearchEngine.ts
 * Purpose: Performs fuzzy search operations on files and folders
 *
 * This service handles fuzzy matching logic for file and folder searches,
 * scoring results based on name and path matches.
 *
 * Used by: SearchDirectoryMode for fuzzy search operations
 * Integrates with: Obsidian fuzzy search API
 *
 * Responsibilities:
 * - Perform fuzzy searches on file/folder names and paths
 * - Calculate relevance scores for matches
 * - Return scored search results
 */

import { TFile, TFolder, prepareFuzzySearch } from 'obsidian';

/**
 * Search match result with scoring
 */
export interface FuzzyMatch {
  item: TFile | TFolder;
  score: number;
  matchType: string;
}

/**
 * Service for fuzzy search operations
 * Implements Single Responsibility Principle - only handles fuzzy searching
 */
export class FuzzySearchEngine {
  /**
   * Perform fuzzy search on items
   * @param items Items to search through
   * @param query Search query
   * @returns Array of matches with scores
   */
  performFuzzySearch(
    items: (TFile | TFolder)[],
    query: string
  ): FuzzyMatch[] {
    const fuzzySearch = prepareFuzzySearch(query);
    const matches: FuzzyMatch[] = [];

    for (const item of items) {
      let bestScore = 0;
      let bestMatchType = '';

      // Get appropriate name for search
      const itemName = item instanceof TFile ? item.basename : item.name;

      // Search by name
      const nameResult = fuzzySearch(itemName);
      if (nameResult) {
        const normalizedScore = Math.max(0, Math.min(1, 1 + (nameResult.score / 100)));
        if (normalizedScore > bestScore) {
          bestScore = normalizedScore;
          bestMatchType = 'name';
        }
      }

      // Search by full path
      const pathResult = fuzzySearch(item.path);
      if (pathResult) {
        const normalizedScore = Math.max(0, Math.min(1, 1 + (pathResult.score / 100))) * 0.8; // Lower weight for path matches
        if (normalizedScore > bestScore) {
          bestScore = normalizedScore;
          bestMatchType = 'path';
        }
      }

      // Include item if it has any match
      if (bestScore > 0) {
        matches.push({ item, score: bestScore, matchType: bestMatchType });
      }
    }

    return matches;
  }
}

```

## agents/searchManager/services/index.ts

```typescript
/**
 * Search Manager Services Barrel Export
 *
 * Location: src/agents/searchManager/services/index.ts
 * Purpose: Centralizes all search manager service exports
 */

export { MemorySearchProcessor } from './MemorySearchProcessor';
export type { MemorySearchProcessorInterface } from './MemorySearchProcessor';
export { MemorySearchFilters } from './MemorySearchFilters';
export type { MemorySearchFiltersInterface } from './MemorySearchFilters';
export { ResultFormatter } from './ResultFormatter';
export type { ResultFormatterInterface } from './ResultFormatter';
```

## agents/searchManager/services/MemorySearchFilters.ts

```typescript
/**
 * Memory Search Filters
 * 
 * Location: src/agents/searchManager/services/MemorySearchFilters.ts
 * Purpose: Tool call filtering, date ranges, session filtering logic
 * Used by: SearchMemoryMode for applying various filters to search results
 */

import {
  MemorySearchResult,
  MemoryFilterOptions,
  DateRange,
  ToolCallFilter,
  ContentFilterOptions,
  MemoryFilterConfiguration,
  MemoryType
} from '../../../types/memory/MemorySearchTypes';

export interface MemorySearchFiltersInterface {
  filter(results: MemorySearchResult[], options: MemoryFilterOptions): MemorySearchResult[];
  applyDateFilter(results: MemorySearchResult[], dateRange: DateRange): MemorySearchResult[];
  applyContentFilter(results: MemorySearchResult[], pattern: string, options?: ContentFilterOptions): MemorySearchResult[];
  applyToolCallFilter(results: MemorySearchResult[], filter: ToolCallFilter): MemorySearchResult[];
  applyScoreFilter(results: MemorySearchResult[], threshold: number): MemorySearchResult[];
  applySessionFilter(results: MemorySearchResult[], sessionIds: string[]): MemorySearchResult[];
  applyWorkspaceFilter(results: MemorySearchResult[], workspaceIds: string[]): MemorySearchResult[];
  getConfiguration(): MemoryFilterConfiguration;
  updateConfiguration(config: Partial<MemoryFilterConfiguration>): void;
}

export class MemorySearchFilters implements MemorySearchFiltersInterface {
  private configuration: MemoryFilterConfiguration;

  constructor(config?: Partial<MemoryFilterConfiguration>) {
    this.configuration = {
      enableDateFiltering: true,
      enableSessionFiltering: true,
      enableToolCallFiltering: true,
      defaultDateRange: null,
      strictFiltering: false,
      ...config
    };
  }

  /**
   * Apply all configured filters to results
   */
  filter(results: MemorySearchResult[], options: MemoryFilterOptions): MemorySearchResult[] {
    let filtered = results;

    // Apply date filter
    if (this.configuration.enableDateFiltering && options.dateRange) {
      filtered = this.applyDateFilter(filtered, options.dateRange);
    }

    // Apply session filter
    if (this.configuration.enableSessionFiltering && options.filterBySession && options.sessionId) {
      filtered = this.applySessionFilter(filtered, [options.sessionId]);
    }

    // Apply workspace filter
    if (options.workspaceId) {
      filtered = this.applyWorkspaceFilter(filtered, [options.workspaceId]);
    }

    // Apply tool call filters
    if (this.configuration.enableToolCallFiltering && options.toolCallFilters) {
      filtered = this.applyToolCallFilter(filtered, options.toolCallFilters);
    }

    return filtered;
  }

  /**
   * Apply date range filter
   */
  applyDateFilter(results: MemorySearchResult[], dateRange: DateRange): MemorySearchResult[] {
    if (!dateRange) return results;

    const startTime = dateRange.start ? new Date(dateRange.start).getTime() : 0;
    const endTime = dateRange.end ? new Date(dateRange.end).getTime() : Date.now();

    return results.filter(result => {
      try {
        const resultTime = new Date(result.metadata.created).getTime();
        return resultTime >= startTime && resultTime <= endTime;
      } catch (error) {
        // If date parsing fails, include result unless strict filtering is enabled
        return !this.configuration.strictFiltering;
      }
    });
  }

  /**
   * Apply content pattern filter
   */
  applyContentFilter(
    results: MemorySearchResult[], 
    pattern: string, 
    options: ContentFilterOptions = {}
  ): MemorySearchResult[] {
    if (!pattern) return results;

    try {
      const regex = options.regex ? 
        new RegExp(pattern, options.caseSensitive ? 'g' : 'gi') :
        null;
      
      const searchPattern = options.caseSensitive ? pattern : pattern.toLowerCase();

      return results.filter(result => {
        const searchableContent = this.getSearchableContent(result, options.caseSensitive);
        
        if (regex) {
          return regex.test(searchableContent);
        }
        
        if (options.wholeWord) {
          const wordBoundaryPattern = new RegExp(`\\b${this.escapeRegex(searchPattern)}\\b`, 
            options.caseSensitive ? 'g' : 'gi');
          return wordBoundaryPattern.test(searchableContent);
        }
        
        return searchableContent.includes(searchPattern);
      });
    } catch (error) {
      return this.configuration.strictFiltering ? [] : results;
    }
  }

  /**
   * Apply tool call filter
   */
  applyToolCallFilter(results: MemorySearchResult[], filter: ToolCallFilter): MemorySearchResult[] {
    return results.filter(result => {
      // Only apply to tool call results
      if (result.type !== MemoryType.TOOL_CALL) return true;

      return this.matchesToolCallFilter(result, filter);
    });
  }

  /**
   * Apply score threshold filter
   */
  applyScoreFilter(results: MemorySearchResult[], threshold: number): MemorySearchResult[] {
    if (threshold <= 0) return results;
    
    return results.filter(result => result.score >= threshold);
  }

  /**
   * Apply session filter
   */
  applySessionFilter(results: MemorySearchResult[], sessionIds: string[]): MemorySearchResult[] {
    if (!sessionIds || sessionIds.length === 0) return results;

    return results.filter(result => {
      const resultSessionId = result.metadata.sessionId;
      return resultSessionId && sessionIds.includes(resultSessionId);
    });
  }

  /**
   * Apply workspace filter
   */
  applyWorkspaceFilter(results: MemorySearchResult[], workspaceIds: string[]): MemorySearchResult[] {
    if (!workspaceIds || workspaceIds.length === 0) return results;

    return results.filter(result => {
      const resultWorkspaceId = result.metadata.workspaceId;
      return resultWorkspaceId && workspaceIds.includes(resultWorkspaceId);
    });
  }

  /**
   * Apply type filter
   */
  applyTypeFilter(results: MemorySearchResult[], types: MemoryType[]): MemorySearchResult[] {
    if (!types || types.length === 0) return results;

    return results.filter(result => types.includes(result.type as MemoryType));
  }

  /**
   * Apply metadata type filter
   */
  applyMetadataTypeFilter(results: MemorySearchResult[], types: string[]): MemorySearchResult[] {
    if (!types || types.length === 0) return results;

    return results.filter(result => {
      const type = result.metadata.type;
      return type && types.includes(type);
    });
  }

  /**
   * Apply success status filter
   */
  applySuccessFilter(results: MemorySearchResult[], successStatus: boolean): MemorySearchResult[] {
    return results.filter(result => {
      // Only apply to tool call results
      if (result.type !== MemoryType.TOOL_CALL) return true;

      return result.metadata.success === successStatus;
    });
  }

  /**
   * Apply execution time range filter
   */
  applyExecutionTimeFilter(
    results: MemorySearchResult[], 
    minTime?: number, 
    maxTime?: number
  ): MemorySearchResult[] {
    if (minTime === undefined && maxTime === undefined) return results;

    return results.filter(result => {
      // Only apply to tool call results
      if (result.type !== MemoryType.TOOL_CALL) return true;

      const executionTime = result.metadata.executionTime;
      if (executionTime === undefined) return !this.configuration.strictFiltering;

      if (minTime !== undefined && executionTime < minTime) return false;
      if (maxTime !== undefined && executionTime > maxTime) return false;

      return true;
    });
  }

  /**
   * Apply composite filter with multiple criteria
   */
  applyCompositeFilter(
    results: MemorySearchResult[],
    filters: {
      dateRange?: DateRange;
      sessionIds?: string[];
      workspaceIds?: string[];
      types?: MemoryType[];
      metadataTypes?: string[];
      scoreThreshold?: number;
      successStatus?: boolean;
      minExecutionTime?: number;
      maxExecutionTime?: number;
      contentPattern?: string;
      contentOptions?: ContentFilterOptions;
    }
  ): MemorySearchResult[] {
    let filtered = results;

    // Apply each filter in order
    if (filters.dateRange) {
      filtered = this.applyDateFilter(filtered, filters.dateRange);
    }

    if (filters.sessionIds) {
      filtered = this.applySessionFilter(filtered, filters.sessionIds);
    }

    if (filters.workspaceIds) {
      filtered = this.applyWorkspaceFilter(filtered, filters.workspaceIds);
    }

    if (filters.types) {
      filtered = this.applyTypeFilter(filtered, filters.types);
    }

    if (filters.metadataTypes) {
      filtered = this.applyMetadataTypeFilter(filtered, filters.metadataTypes);
    }

    if (filters.scoreThreshold !== undefined) {
      filtered = this.applyScoreFilter(filtered, filters.scoreThreshold);
    }

    if (filters.successStatus !== undefined) {
      filtered = this.applySuccessFilter(filtered, filters.successStatus);
    }

    if (filters.minExecutionTime !== undefined || filters.maxExecutionTime !== undefined) {
      filtered = this.applyExecutionTimeFilter(filtered, filters.minExecutionTime, filters.maxExecutionTime);
    }

    if (filters.contentPattern) {
      filtered = this.applyContentFilter(filtered, filters.contentPattern, filters.contentOptions);
    }

    return filtered;
  }

  /**
   * Get current configuration
   */
  getConfiguration(): MemoryFilterConfiguration {
    return { ...this.configuration };
  }

  /**
   * Update configuration
   */
  updateConfiguration(config: Partial<MemoryFilterConfiguration>): void {
    this.configuration = { ...this.configuration, ...config };
  }

  // Private helper methods

  private matchesToolCallFilter(result: MemorySearchResult, filter: ToolCallFilter): boolean {
    const metadata = result.metadata;

    // Agent filter
    if (filter.agent && metadata.agent !== filter.agent) {
      return false;
    }

    // Mode filter
    if (filter.mode && metadata.mode !== filter.mode) {
      return false;
    }

    // Success filter
    if (filter.success !== undefined && metadata.success !== filter.success) {
      return false;
    }

    // Execution time filters
    const executionTime = metadata.executionTime;
    if (executionTime !== undefined) {
      if (filter.minExecutionTime !== undefined && executionTime < filter.minExecutionTime) {
        return false;
      }
      if (filter.maxExecutionTime !== undefined && executionTime > filter.maxExecutionTime) {
        return false;
      }
    } else if (this.configuration.strictFiltering && 
               (filter.minExecutionTime !== undefined || filter.maxExecutionTime !== undefined)) {
      // In strict mode, reject results without execution time if time filters are specified
      return false;
    }

    return true;
  }

  private getSearchableContent(result: MemorySearchResult, caseSensitive: boolean = false): string {
    const parts = [
      result.highlight,
      result.context.before,
      result.context.match,
      result.context.after,
      JSON.stringify(result.metadata)
    ];

    const content = parts.join(' ');
    return caseSensitive ? content : content.toLowerCase();
  }

  private escapeRegex(string: string): string {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  /**
   * Get filter statistics
   */
  getFilterStats(originalResults: MemorySearchResult[], filteredResults: MemorySearchResult[]): {
    originalCount: number;
    filteredCount: number;
    removedCount: number;
    filterEfficiency: number;
    typeDistribution: Record<string, number>;
  } {
    const originalCount = originalResults.length;
    const filteredCount = filteredResults.length;
    const removedCount = originalCount - filteredCount;
    const filterEfficiency = originalCount > 0 ? (removedCount / originalCount) * 100 : 0;

    // Calculate type distribution of filtered results
    const typeDistribution: Record<string, number> = {};
    for (const result of filteredResults) {
      const type = result.type;
      typeDistribution[type] = (typeDistribution[type] || 0) + 1;
    }

    return {
      originalCount,
      filteredCount,
      removedCount,
      filterEfficiency: Math.round(filterEfficiency * 100) / 100,
      typeDistribution
    };
  }

  /**
   * Validate filter configuration
   */
  validateFilters(filters: MemoryFilterOptions): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Validate date range
    if (filters.dateRange) {
      if (filters.dateRange.start && filters.dateRange.end) {
        const startDate = new Date(filters.dateRange.start);
        const endDate = new Date(filters.dateRange.end);

        if (isNaN(startDate.getTime())) {
          errors.push('Invalid start date format');
        }
        if (isNaN(endDate.getTime())) {
          errors.push('Invalid end date format');
        }
        if (startDate > endDate) {
          errors.push('Start date must be before end date');
        }
      }
    }

    // Validate tool call filters
    if (filters.toolCallFilters) {
      const tcf = filters.toolCallFilters;
      if (tcf.minExecutionTime !== undefined && tcf.minExecutionTime < 0) {
        errors.push('Minimum execution time must be non-negative');
      }
      if (tcf.maxExecutionTime !== undefined && tcf.maxExecutionTime < 0) {
        errors.push('Maximum execution time must be non-negative');
      }
      if (tcf.minExecutionTime !== undefined && 
          tcf.maxExecutionTime !== undefined && 
          tcf.minExecutionTime > tcf.maxExecutionTime) {
        errors.push('Minimum execution time must be less than maximum execution time');
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  /**
   * Create optimized filter chain for performance
   */
  createFilterChain(options: MemoryFilterOptions): ((results: MemorySearchResult[]) => MemorySearchResult[])[] {
    const chain: ((results: MemorySearchResult[]) => MemorySearchResult[])[] = [];

    // Add filters in order of selectivity (most selective first)
    
    // Session filter (very selective)
    if (options.filterBySession && options.sessionId) {
      chain.push((results) => this.applySessionFilter(results, [options.sessionId!]));
    }

    // Workspace filter (selective)
    if (options.workspaceId) {
      chain.push((results) => this.applyWorkspaceFilter(results, [options.workspaceId!]));
    }

    // Tool call filters (moderately selective)
    if (options.toolCallFilters) {
      const filters = options.toolCallFilters;
      chain.push((results) => this.applyToolCallFilter(results, filters));
    }

    // Date filter (less selective)
    if (options.dateRange) {
      const dateRange = options.dateRange;
      chain.push((results) => this.applyDateFilter(results, dateRange));
    }

    return chain;
  }

  /**
   * Apply filter chain efficiently
   */
  applyFilterChain(
    results: MemorySearchResult[], 
    chain: ((results: MemorySearchResult[]) => MemorySearchResult[])[]
  ): MemorySearchResult[] {
    return chain.reduce((currentResults, filter) => {
      if (currentResults.length === 0) return currentResults; // Short-circuit if no results left
      return filter(currentResults);
    }, results);
  }
}
```

## agents/searchManager/services/MemorySearchProcessor.ts

```typescript
/**
 * Memory Search Processor
 * 
 * Location: src/agents/searchManager/services/MemorySearchProcessor.ts
 * Purpose: Core search logic across multiple memory types (traces, sessions, workspaces, etc.)
 * Used by: SearchMemoryMode for processing search requests and enriching results
 */

import { App, Plugin, prepareFuzzySearch } from 'obsidian';
import {
  MemorySearchParameters,
  MemorySearchResult,
  EnrichedMemorySearchResult,
  RawMemoryResult,
  MemorySearchContext,
  MemorySearchExecutionOptions,
  SearchOptions,
  ValidationResult,
  MemoryProcessorConfiguration,
  SearchMethod,
  MemoryType
} from '../../../types/memory/MemorySearchTypes';
import { MemoryService } from "../../memoryManager/services/MemoryService";
import { WorkspaceService, GLOBAL_WORKSPACE_ID } from '../../../services/WorkspaceService';
import { IStorageAdapter } from '../../../database/interfaces/IStorageAdapter';
import { MemoryTraceData, StateMetadata } from '../../../types/storage/HybridStorageTypes';
import { getNexusPlugin } from '../../../utils/pluginLocator';
import type NexusPlugin from '../../../main';

export interface MemorySearchProcessorInterface {
  process(params: MemorySearchParameters): Promise<EnrichedMemorySearchResult[]>;
  validateParameters(params: MemorySearchParameters): ValidationResult;
  executeSearch(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]>;
  enrichResults(results: RawMemoryResult[], context: MemorySearchContext): Promise<EnrichedMemorySearchResult[]>;
  getConfiguration(): MemoryProcessorConfiguration;
  updateConfiguration(config: Partial<MemoryProcessorConfiguration>): Promise<void>;
}

export class MemorySearchProcessor implements MemorySearchProcessorInterface {
  private plugin: Plugin;
  private configuration: MemoryProcessorConfiguration;
  private workspaceService?: WorkspaceService;
  private storageAdapter?: IStorageAdapter;

  constructor(
    plugin: Plugin,
    config?: Partial<MemoryProcessorConfiguration>,
    workspaceService?: WorkspaceService,
    storageAdapter?: IStorageAdapter
  ) {
    this.plugin = plugin;
    this.workspaceService = workspaceService;
    this.storageAdapter = storageAdapter;
    this.configuration = {
      defaultLimit: 20,
      maxLimit: 100,
      defaultSearchMethod: SearchMethod.EXACT,
      enableSemanticSearch: false,
      enableExactSearch: true,
      timeoutMs: 30000,
      ...config
    };
  }

  /**
   * Main processing entry point
   */
  async process(params: MemorySearchParameters): Promise<EnrichedMemorySearchResult[]> {
    // Validate parameters
    const validation = this.validateParameters(params);
    if (!validation.isValid) {
      throw new Error(`Invalid parameters: ${validation.errors.join(', ')}`);
    }

    // Build search context
    const context: MemorySearchContext = {
      params,
      timestamp: new Date()
    };

    // Execute search across all specified memory types
    const searchOptions = this.buildSearchOptions(params);
    const rawResults = await this.executeSearch(params.query, searchOptions);

    // Enrich results with metadata and context
    return this.enrichResults(rawResults, context);
  }

  /**
   * Validates search parameters
   */
  validateParameters(params: MemorySearchParameters): ValidationResult {
    const errors: string[] = [];

    // Required fields
    if (!params.query || params.query.trim().length === 0) {
      errors.push('Query parameter is required and cannot be empty');
    }

    // Limit validation
    if (params.limit !== undefined) {
      if (params.limit < 1) {
        errors.push('Limit must be positive');
      }
      if (params.limit > this.configuration.maxLimit) {
        errors.push(`Limit cannot exceed ${this.configuration.maxLimit}`);
      }
    }

    // Date range validation
    if (params.dateRange) {
      if (params.dateRange.start && params.dateRange.end) {
        const startDate = new Date(params.dateRange.start);
        const endDate = new Date(params.dateRange.end);
        
        if (isNaN(startDate.getTime())) {
          errors.push('Invalid start date format');
        }
        if (isNaN(endDate.getTime())) {
          errors.push('Invalid end date format');
        }
        if (startDate > endDate) {
          errors.push('Start date must be before end date');
        }
      }
    }

    // Tool call filters validation
    if (params.toolCallFilters) {
      const filters = params.toolCallFilters;
      if (filters.minExecutionTime !== undefined && filters.minExecutionTime < 0) {
        errors.push('Minimum execution time must be non-negative');
      }
      if (filters.maxExecutionTime !== undefined && filters.maxExecutionTime < 0) {
        errors.push('Maximum execution time must be non-negative');
      }
      if (filters.minExecutionTime !== undefined && 
          filters.maxExecutionTime !== undefined && 
          filters.minExecutionTime > filters.maxExecutionTime) {
        errors.push('Minimum execution time must be less than maximum execution time');
      }
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  /**
   * Execute search across all memory types
   */
  async executeSearch(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]> {
    const results: RawMemoryResult[] = [];
    const searchPromises: Promise<RawMemoryResult[]>[] = [];

    // Get default memory types if not specified
    const memoryTypes = options.memoryTypes || ['traces', 'toolCalls', 'sessions', 'states', 'workspaces'];
    const limit = options.limit || this.configuration.defaultLimit;

    // Search legacy traces
    if (memoryTypes.includes('traces')) {
      searchPromises.push(this.searchLegacyTraces(query, options));
    }

    // Search tool call traces
    if (memoryTypes.includes('toolCalls')) {
      searchPromises.push(this.searchToolCallTraces(query, options));
    }

    // Search sessions
    if (memoryTypes.includes('sessions')) {
      searchPromises.push(this.searchSessions(query, options));
    }

    // Search states
    if (memoryTypes.includes('states')) {
      searchPromises.push(this.searchStates(query, options));
    }

    // Search workspaces
    if (memoryTypes.includes('workspaces')) {
      searchPromises.push(this.searchWorkspaces(query, options));
    }

    // Execute all searches in parallel
    const searchResults = await Promise.allSettled(searchPromises);
    
    // Collect results from successful searches
    for (const result of searchResults) {
      if (result.status === 'fulfilled') {
        results.push(...result.value);
      } else {
        console.error('[MemorySearchProcessor] Search error:', result.reason);
      }
    }

    // Sort by score and apply limit
    results.sort((a, b) => (b.similarity || 0) - (a.similarity || 0));
    return results.slice(0, limit);
  }

  /**
   * Enrich raw results with metadata and context
   */
  async enrichResults(results: RawMemoryResult[], context: MemorySearchContext): Promise<EnrichedMemorySearchResult[]> {
    const enrichedResults: EnrichedMemorySearchResult[] = [];

    for (const result of results) {
      try {
        const enriched = await this.enrichSingleResult(result, context);
        if (enriched) {
          enrichedResults.push(enriched);
        }
      } catch (error) {
      }
    }

    return enrichedResults;
  }

  /**
   * Get current configuration
   */
  getConfiguration(): MemoryProcessorConfiguration {
    return { ...this.configuration };
  }

  /**
   * Update configuration
   */
  async updateConfiguration(config: Partial<MemoryProcessorConfiguration>): Promise<void> {
    this.configuration = { ...this.configuration, ...config };
  }

  // Private helper methods

  private buildSearchOptions(params: MemorySearchParameters): MemorySearchExecutionOptions {
    return {
      workspaceId: params.workspaceId || params.workspace,
      // Session filtering removed - memory is workspace-scoped, not session-scoped
      sessionId: undefined,
      limit: params.limit || this.configuration.defaultLimit,
      toolCallFilters: params.toolCallFilters
    };
  }

  private async searchLegacyTraces(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]> {
    const workspaceId = options.workspaceId || GLOBAL_WORKSPACE_ID;

    // Use new storage adapter if available
    if (this.storageAdapter) {
      try {
        const result = await this.storageAdapter.searchTraces(
          workspaceId,
          query,
          options.sessionId
        );

        // Convert MemoryTraceData to RawMemoryResult format
        return result.map((trace: MemoryTraceData) => ({
          trace: {
            id: trace.id,
            workspaceId: trace.workspaceId,
            sessionId: trace.sessionId,
            timestamp: trace.timestamp,
            type: trace.type || 'generic',
            content: trace.content,
            metadata: trace.metadata
          },
          similarity: 1.0 // SQLite FTS doesn't provide scores, default to 1.0
        }));
      } catch (error) {
        console.error('[MemorySearchProcessor] Error searching traces via storage adapter:', error);
        return [];
      }
    }

    // Legacy path: use WorkspaceService
    const workspaceService = this.workspaceService || this.getWorkspaceService();

    if (!workspaceService) {
      return [];
    }

    try {
      // Get the entire workspace
      const workspace = await workspaceService.getWorkspace(workspaceId);
      if (!workspace) {
        return [];
      }

      // Use Obsidian's native fuzzy search API
      const fuzzySearch = prepareFuzzySearch(query.toLowerCase());
      const results: RawMemoryResult[] = [];

      // Loop through all sessions
      if (workspace.sessions) {
        for (const [sessionId, session] of Object.entries(workspace.sessions)) {
          // Loop through all traces in each session
          const traces = Object.values(session.memoryTraces || {});

          for (const trace of traces) {
            // Convert THIS trace to JSON string
            const traceJSON = JSON.stringify(trace);

            // Fuzzy search this individual trace's JSON
            const match = fuzzySearch(traceJSON);

            if (match) {
              // Normalize fuzzy score (negative to positive)
              const normalizedScore = Math.max(0, Math.min(1, 1 + (match.score / 100)));

              // Return the FULL trace object with workspaceId and sessionId added
              results.push({
                trace: {
                  ...trace,
                  workspaceId,
                  sessionId
                },
                similarity: normalizedScore
              });
            }
          }
        }
      }

      // Sort by score (highest first)
      results.sort((a, b) => (b.similarity || 0) - (a.similarity || 0));

      // Apply limit if specified
      const limited = options.limit ? results.slice(0, options.limit) : results;

      return limited;
    } catch (error) {
      console.error('[MemorySearchProcessor] Error searching legacy traces:', error);
      return [];
    }
  }

  /**
   * Extract searchable text from a memory trace
   * Combines all relevant fields for comprehensive search
   */
  private getSearchableText(trace: any): string {
    const parts: string[] = [];
    
    if (trace.content) parts.push(trace.content);
    if (trace.type) parts.push(trace.type);
    if (trace.metadata) {
      // Include metadata fields in search
      if (trace.metadata.tool) parts.push(trace.metadata.tool);
      if (trace.metadata.params) {
        // Stringify params for search
        try {
          parts.push(JSON.stringify(trace.metadata.params));
        } catch (e) {
          // Ignore JSON errors
        }
      }
    }
    
    return parts.join(' ');
  }

  private async searchToolCallTraces(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]> {
    // MemoryTraceService not available in simplified architecture
    return [];
  }

  private async searchSessions(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]> {
    const memoryService = this.getMemoryService();
    if (!memoryService) return [];

    try {
      const sessionsResult = await memoryService.getSessions(options.workspaceId || GLOBAL_WORKSPACE_ID);
      const sessions = sessionsResult.items;
      const queryLower = query.toLowerCase();
      const results: RawMemoryResult[] = [];

      for (const session of sessions) {
        let score = 0;
        
        // Check name match
        if ((session.name || '').toLowerCase().includes(queryLower)) {
          score += 0.9;
        }
        
        // Check description match
        if (session.description?.toLowerCase().includes(queryLower)) {
          score += 0.8;
        }

        if (score > 0) {
          results.push({
            trace: session,
            similarity: score
          });
        }
      }

      return results;
    } catch (error) {
      console.error('[MemorySearchProcessor] Error searching sessions:', error);
      return [];
    }
  }

  private async searchStates(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]> {
    const memoryService = this.getMemoryService();
    if (!memoryService) return [];

    try {
      const statesResult = await memoryService.getStates(options.workspaceId || GLOBAL_WORKSPACE_ID, options.sessionId);
      const queryLower = query.toLowerCase();
      const results: RawMemoryResult[] = [];

      for (const state of statesResult.items) {
        let score = 0;

        // Check name match
        if (state.name.toLowerCase().includes(queryLower)) {
          score += 0.9;
        }

        // Note: State items from getStates don't have description, only id/name/created/state

        if (score > 0) {
          results.push({
            trace: state,
            similarity: score
          });
        }
      }

      return results;
    } catch (error) {
      console.error('[MemorySearchProcessor] Error searching states:', error);
      return [];
    }
  }

  private async searchWorkspaces(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]> {
    const workspaceService = this.getWorkspaceService();
    if (!workspaceService) return [];

    try {
      const workspaces = await workspaceService.listWorkspaces();
      const queryLower = query.toLowerCase();
      const results: RawMemoryResult[] = [];

      for (const workspace of workspaces) {
        let score = 0;
        
        // Check name match
        if (workspace.name.toLowerCase().includes(queryLower)) {
          score += 0.9;
        }
        
        // Check description match
        if (workspace.description?.toLowerCase().includes(queryLower)) {
          score += 0.8;
        }

        if (score > 0) {
          results.push({
            trace: workspace,
            similarity: score
          });
        }
      }

      return results;
    } catch (error) {
      console.error('[MemorySearchProcessor] Error searching workspaces:', error);
      return [];
    }
  }

  private async searchToolCallsExact(query: string, options: MemorySearchExecutionOptions): Promise<RawMemoryResult[]> {
    // MemoryTraceService not available in simplified architecture
    return [];
  }

  private async enrichSingleResult(result: RawMemoryResult, context: MemorySearchContext): Promise<EnrichedMemorySearchResult | null> {
    const trace = result.trace;
    const query = context.params.query;

    try {
      // Determine result type
      const resultType = this.determineResultType(trace);

      // Generate highlight
      const highlight = this.generateHighlight(trace, query);

      // Build metadata
      const metadata = this.buildMetadata(trace, resultType);

      // Generate context
      const searchContext = this.generateSearchContext(trace, query, resultType);

      const enrichedResult: EnrichedMemorySearchResult = {
        type: resultType,
        id: trace.id,
        highlight,
        metadata,
        context: searchContext,
        score: result.similarity || 0,
        _rawTrace: trace  // Attach raw trace for downstream processing
      };

      return enrichedResult;
    } catch (error) {
      console.error('[MemorySearchProcessor] Failed to enrich result:', {
        error,
        traceId: trace?.id,
        trace
      });
      return null;
    }
  }

  private determineResultType(trace: any): MemoryType {
    // Check for tool call specific properties
    if ('toolCallId' in trace && trace.toolCallId) return MemoryType.TOOL_CALL;
    // Check for session specific properties
    if ('name' in trace && 'startTime' in trace && trace.startTime !== undefined) return MemoryType.SESSION;
    // Check for state specific properties
    if ('name' in trace && 'timestamp' in trace && trace.timestamp !== undefined) return MemoryType.STATE;
    // Check for workspace specific properties
    if ('name' in trace && 'created' in trace && trace.created !== undefined) return MemoryType.WORKSPACE;
    return MemoryType.TRACE;
  }

  private generateHighlight(trace: any, query: string): string {
    const maxLength = 200;
    const content = trace.content || trace.description || trace.name || '';
    const queryLower = query.toLowerCase();
    const contentLower = content.toLowerCase();
    
    const index = contentLower.indexOf(queryLower);
    if (index === -1) {
      return content.substring(0, maxLength) + (content.length > maxLength ? '...' : '');
    }
    
    const start = Math.max(0, index - 50);
    const end = Math.min(content.length, index + query.length + 50);
    
    let highlight = content.substring(start, end);
    if (start > 0) highlight = '...' + highlight;
    if (end < content.length) highlight = highlight + '...';
    
    return highlight;
  }

  private buildMetadata(trace: any, resultType: MemoryType): any {
    const metadata = trace.metadata || {};
    const context = metadata.context || {};
    const baseMetadata = {
      created: trace.timestamp ? new Date(trace.timestamp).toISOString() : 
               trace.startTime ? new Date(trace.startTime).toISOString() :
               trace.created ? new Date(trace.created).toISOString() : 
               new Date().toISOString(),
      sessionId: context.sessionId || trace.sessionId,
      workspaceId: context.workspaceId || trace.workspaceId,
      primaryGoal: context.primaryGoal || '',
      filesReferenced: this.getFilesReferenced(trace),
      type: trace.type
    };

    if (resultType === MemoryType.TOOL_CALL) {
      return {
        ...baseMetadata,
        toolUsed: metadata.tool?.id || trace.toolName,
        modeUsed: metadata.tool?.mode || trace.mode,
        toolCallId: trace.toolCallId,
        agent: metadata.tool?.agent || trace.agent,
        mode: metadata.tool?.mode || trace.mode,
        executionTime: trace.executionContext?.timing?.executionTime,
        success: metadata.outcome?.success ?? trace.metadata?.response?.success,
        errorMessage: metadata.outcome?.error?.message || trace.metadata?.response?.error?.message,
        affectedResources: trace.relationships?.affectedResources || metadata.legacy?.relatedFiles || []
      };
    }

    return {
      ...baseMetadata,
      toolUsed: metadata.tool?.id || metadata.legacy?.params?.tool || trace.metadata?.tool,
      modeUsed: metadata.tool?.mode || '',
      updated: trace.endTime ? new Date(trace.endTime).toISOString() : 
               trace.lastAccessed ? new Date(trace.lastAccessed).toISOString() : undefined
    };
  }

  private generateSearchContext(trace: any, query: string, resultType: MemoryType): any {
    const content = trace.content || trace.description || trace.name || '';
    const context = this.generateBasicContext(content, query);

    if (resultType === MemoryType.TOOL_CALL) {
      return this.enhanceToolCallContext(context, trace);
    }

    return context;
  }

  private generateBasicContext(content: string, query: string): any {
    const queryLower = query.toLowerCase();
    const contentLower = content.toLowerCase();
    const index = contentLower.indexOf(queryLower);
    
    if (index === -1) {
      return {
        before: '',
        match: content.substring(0, 100),
        after: ''
      };
    }
    
    const matchStart = index;
    const matchEnd = index + query.length;
    
    return {
      before: content.substring(Math.max(0, matchStart - 50), matchStart),
      match: content.substring(matchStart, matchEnd),
      after: content.substring(matchEnd, Math.min(content.length, matchEnd + 50))
    };
  }

  private enhanceToolCallContext(context: any, toolCallTrace: any): any {
    const toolMetadata = toolCallTrace.metadata?.tool;
    const toolInfo = toolMetadata ? `${toolMetadata.agent}.${toolMetadata.mode}` : `${toolCallTrace.agent}.${toolCallTrace.mode}`;
    const success = toolCallTrace.metadata?.outcome?.success ?? toolCallTrace.metadata?.response?.success;
    const statusInfo = success === false ? 'FAILED' : 'SUCCESS';
    const executionTime = toolCallTrace.executionContext?.timing?.executionTime;
    
    return {
      before: `[${toolInfo}] ${context.before}`,
      match: context.match,
      after: `${context.after} [${statusInfo}${executionTime ? ` - ${executionTime}ms` : ''}]`
    };
  }

  private deduplicateResults(results: RawMemoryResult[]): RawMemoryResult[] {
    const seen = new Set<string>();
    const unique: RawMemoryResult[] = [];
    
    for (const result of results) {
      const id = result.trace?.id;
      if (id && !seen.has(id)) {
        seen.add(id);
        unique.push(result);
      }
    }
    
    return unique;
  }

  private getFilesReferenced(trace: any): string[] {
    const metadata = trace.metadata || {};
    if (Array.isArray(metadata.input?.files) && metadata.input.files.length > 0) {
      return metadata.input.files;
    }

    if (Array.isArray(metadata.legacy?.relatedFiles) && metadata.legacy.relatedFiles.length > 0) {
      return metadata.legacy.relatedFiles;
    }

    if (Array.isArray(trace.relationships?.relatedFiles) && trace.relationships.relatedFiles.length > 0) {
      return trace.relationships.relatedFiles;
    }

    return [];
  }

  // Service access methods
  private getMemoryService(): MemoryService | undefined {
    try {
      const app: App = this.plugin.app;
      const plugin = getNexusPlugin(app) as NexusPlugin | null;
      if (plugin) {
        return plugin.getServiceIfReady<MemoryService>('memoryService') || undefined;
      }
      return undefined;
    } catch (error) {
      return undefined;
    }
  }


  private getWorkspaceService(): WorkspaceService | undefined {
    try {
      const app: App = this.plugin.app;
      const plugin = getNexusPlugin(app) as NexusPlugin | null;
      if (plugin) {
        return plugin.getServiceIfReady<WorkspaceService>('workspaceService') || undefined;
      }
      return undefined;
    } catch (error) {
      return undefined;
    }
  }
}

```

## agents/searchManager/services/ResultFormatter.ts

```typescript
/**
 * Result Formatter
 *
 * Location: src/agents/searchManager/services/ResultFormatter.ts
 * Purpose: Result highlighting, metadata processing, response formatting
 * Used by: SearchMemoryMode for formatting search results and building summaries
 *
 * Refactored: Extracted specialized formatters and helpers for better maintainability.
 */

import {
  MemorySearchResult,
  FormattedMemoryResult,
  FormatOptions,
  MemorySortOption,
  MemoryGroupOption,
  GroupedMemoryResults,
  PaginatedMemoryResults,
  PaginationOptions,
  MemoryResultSummary,
  HighlightOptions,
  ResultFormatterConfiguration,
  MemoryType
} from '../../../types/memory/MemorySearchTypes';
import { BaseResultFormatter } from './formatters/BaseResultFormatter';
import { ToolCallResultFormatter } from './formatters/ToolCallResultFormatter';
import { SessionResultFormatter } from './formatters/SessionResultFormatter';
import { StateResultFormatter } from './formatters/StateResultFormatter';
import { WorkspaceResultFormatter } from './formatters/WorkspaceResultFormatter';
import { TraceResultFormatter } from './formatters/TraceResultFormatter';
import { ResultGroupingHelper } from './formatters/ResultGroupingHelper';
import { ResultSortingHelper } from './formatters/ResultSortingHelper';
import { ResultHighlightHelper } from './formatters/ResultHighlightHelper';
import { ResultSummaryHelper } from './formatters/ResultSummaryHelper';

export interface ResultFormatterInterface {
  format(results: MemorySearchResult[], options: FormatOptions): Promise<FormattedMemoryResult[]>;
  groupResults(results: MemorySearchResult[], groupBy: MemoryGroupOption): Promise<GroupedMemoryResults>;
  sortResults(results: MemorySearchResult[], sortBy: MemorySortOption): MemorySearchResult[];
  buildSummary(results: MemorySearchResult[]): Promise<MemoryResultSummary>;
  paginate(results: MemorySearchResult[], pagination: PaginationOptions): PaginatedMemoryResults;
  addHighlights(results: MemorySearchResult[], query: string, options?: HighlightOptions): Promise<MemorySearchResult[]>;
  getConfiguration(): ResultFormatterConfiguration;
  updateConfiguration(config: Partial<ResultFormatterConfiguration>): void;
}

export class ResultFormatter implements ResultFormatterInterface {
  private configuration: ResultFormatterConfiguration;
  private formatters: Map<MemoryType, BaseResultFormatter>;
  private groupingHelper: ResultGroupingHelper;
  private sortingHelper: ResultSortingHelper;
  private highlightHelper: ResultHighlightHelper;
  private summaryHelper: ResultSummaryHelper;

  constructor(config?: Partial<ResultFormatterConfiguration>) {
    this.configuration = {
      maxHighlightLength: 200,
      contextLength: 50,
      enableToolCallEnhancement: true,
      dateFormat: 'YYYY-MM-DD',
      timestampFormat: 'YYYY-MM-DD HH:mm:ss',
      ...config
    };

    // Initialize specialized formatters
    this.formatters = new Map<MemoryType, BaseResultFormatter>();
    this.formatters.set(MemoryType.TOOL_CALL, new ToolCallResultFormatter(this.configuration));
    this.formatters.set(MemoryType.SESSION, new SessionResultFormatter(this.configuration));
    this.formatters.set(MemoryType.STATE, new StateResultFormatter(this.configuration));
    this.formatters.set(MemoryType.WORKSPACE, new WorkspaceResultFormatter(this.configuration));
    this.formatters.set(MemoryType.TRACE, new TraceResultFormatter(this.configuration));

    // Initialize helpers
    this.groupingHelper = new ResultGroupingHelper();
    this.sortingHelper = new ResultSortingHelper();
    this.highlightHelper = new ResultHighlightHelper(this.configuration.maxHighlightLength);
    this.summaryHelper = new ResultSummaryHelper();
  }

  /**
   * Format search results according to options
   */
  async format(results: MemorySearchResult[], options: FormatOptions): Promise<FormattedMemoryResult[]> {
    const formatted: FormattedMemoryResult[] = [];

    for (const result of results) {
      try {
        const formatter = this.getFormatter(result.type);
        const formattedResult = await formatter.formatSingleResult(result, options);
        formatted.push(formattedResult);
      } catch (error) {
      }
    }

    return formatted;
  }

  /**
   * Group results by specified criteria
   */
  async groupResults(results: MemorySearchResult[], groupBy: MemoryGroupOption): Promise<GroupedMemoryResults> {
    return this.groupingHelper.groupResults(results, groupBy);
  }

  /**
   * Sort results by specified criteria
   */
  sortResults(results: MemorySearchResult[], sortBy: MemorySortOption): MemorySearchResult[] {
    return this.sortingHelper.sortResults(results, sortBy);
  }

  /**
   * Build result summary statistics
   */
  async buildSummary(results: MemorySearchResult[]): Promise<MemoryResultSummary> {
    return this.summaryHelper.buildSummary(results);
  }

  /**
   * Apply result pagination
   */
  paginate(results: MemorySearchResult[], pagination: PaginationOptions): PaginatedMemoryResults {
    const { page, pageSize, totalItems } = pagination;
    const actualTotalItems = totalItems || results.length;
    const totalPages = Math.ceil(actualTotalItems / pageSize);

    const startIndex = page * pageSize;
    const endIndex = Math.min(startIndex + pageSize, results.length);
    const items = results.slice(startIndex, endIndex);

    return {
      items,
      page,
      pageSize,
      totalItems: actualTotalItems,
      totalPages,
      hasNextPage: page < totalPages - 1,
      hasPreviousPage: page > 0
    };
  }

  /**
   * Generate result highlights
   */
  async addHighlights(
    results: MemorySearchResult[],
    query: string,
    options: HighlightOptions = {}
  ): Promise<MemorySearchResult[]> {
    return this.highlightHelper.addHighlights(results, query, options);
  }

  /**
   * Get current configuration
   */
  getConfiguration(): ResultFormatterConfiguration {
    return { ...this.configuration };
  }

  /**
   * Update configuration
   */
  updateConfiguration(config: Partial<ResultFormatterConfiguration>): void {
    this.configuration = { ...this.configuration, ...config };

    // Update configuration for all formatters
    this.formatters.forEach(formatter => {
      formatter.updateConfiguration(this.configuration);
    });
  }

  /**
   * Get formatter for specific memory type
   */
  private getFormatter(type: 'trace' | 'toolCall' | 'session' | 'state' | 'workspace'): BaseResultFormatter {
    const formatter = this.formatters.get(type as MemoryType);
    if (formatter) {
      return formatter;
    }

    // Return trace formatter as default
    return this.formatters.get(MemoryType.TRACE)!;
  }
}

```

## agents/searchManager/services/SearchFilterApplicator.ts

```typescript
/**
 * Location: /src/agents/searchManager/services/SearchFilterApplicator.ts
 * Purpose: Applies filters to search results
 *
 * This service handles applying various filters to search candidates
 * including file type, depth, pattern, and date range filters.
 *
 * Used by: SearchDirectoryMode for filtering search candidates
 * Integrates with: Obsidian file system API
 *
 * Responsibilities:
 * - Apply file type filters
 * - Apply depth filters
 * - Apply regex pattern filters
 * - Apply date range filters
 */

import { TFile, TFolder } from 'obsidian';

/**
 * Filter parameters for search operations
 */
export interface SearchFilters {
  fileTypes?: string[];
  depth?: number;
  pattern?: string;
  dateRange?: {
    start?: string;
    end?: string;
  };
}

/**
 * Service for applying search filters
 * Implements Single Responsibility Principle - only handles filtering
 */
export class SearchFilterApplicator {
  /**
   * Apply all filters to items
   * @param items Items to filter
   * @param filters Filter parameters
   * @returns Filtered items
   */
  applyFilters(
    items: (TFile | TFolder)[],
    filters: SearchFilters
  ): (TFile | TFolder)[] {
    let filtered = items;

    // Apply each filter in sequence
    if (filters.fileTypes && filters.fileTypes.length > 0) {
      filtered = this.applyFileTypeFilter(filtered, filters.fileTypes);
    }

    if (filters.depth !== undefined) {
      filtered = this.applyDepthFilter(filtered, filters.depth);
    }

    if (filters.pattern) {
      filtered = this.applyPatternFilter(filtered, filters.pattern);
    }

    if (filters.dateRange) {
      filtered = this.applyDateRangeFilter(filtered, filters.dateRange);
    }

    return filtered;
  }

  /**
   * Apply file type filter
   * @param items Items to filter
   * @param fileTypes Allowed file types
   * @returns Filtered items
   */
  private applyFileTypeFilter(
    items: (TFile | TFolder)[],
    fileTypes: string[]
  ): (TFile | TFolder)[] {
    const allowedTypes = fileTypes.map(type => type.toLowerCase());
    return items.filter(item => {
      if (item instanceof TFile) {
        return allowedTypes.includes(item.extension.toLowerCase());
      }
      return true; // Keep folders when file type filter is applied
    });
  }

  /**
   * Apply depth filter
   * @param items Items to filter
   * @param maxDepth Maximum depth
   * @returns Filtered items
   */
  private applyDepthFilter(
    items: (TFile | TFolder)[],
    maxDepth: number
  ): (TFile | TFolder)[] {
    return items.filter(item => {
      const pathDepth = item.path.split('/').filter(p => p.length > 0).length;
      return pathDepth <= maxDepth;
    });
  }

  /**
   * Apply regex pattern filter
   * @param items Items to filter
   * @param pattern Regex pattern
   * @returns Filtered items
   */
  private applyPatternFilter(
    items: (TFile | TFolder)[],
    pattern: string
  ): (TFile | TFolder)[] {
    try {
      const regex = new RegExp(pattern, 'i');
      return items.filter(item => {
        const name = item instanceof TFile ? item.basename : item.name;
        return regex.test(item.path) || regex.test(name);
      });
    } catch (error) {
      // Invalid regex - return items unfiltered
      return items;
    }
  }

  /**
   * Apply date range filter
   * @param items Items to filter
   * @param dateRange Date range filter
   * @returns Filtered items
   */
  private applyDateRangeFilter(
    items: (TFile | TFolder)[],
    dateRange: { start?: string; end?: string }
  ): (TFile | TFolder)[] {
    const startDate = dateRange.start ? new Date(dateRange.start).getTime() : 0;
    const endDate = dateRange.end ? new Date(dateRange.end).getTime() : Date.now();

    return items.filter(item => {
      if (item instanceof TFile) {
        const modified = item.stat.mtime;
        return modified >= startDate && modified <= endDate;
      }
      return true; // Keep folders when date filter is applied
    });
  }
}

```

## agents/searchManager/services/SearchResultFormatter.ts

```typescript
/**
 * Location: /src/agents/searchManager/services/SearchResultFormatter.ts
 * Purpose: Formats search results for directory search operations
 *
 * This service handles transforming search matches into enhanced result objects
 * with metadata, snippets, and type-specific formatting.
 *
 * Used by: SearchDirectoryMode for formatting search results
 * Integrates with: Obsidian Vault API for content access
 *
 * Responsibilities:
 * - Transform matches into DirectoryItem results
 * - Extract content snippets from files
 * - Format file and folder metadata
 */

import { TFile, TFolder } from 'obsidian';

/**
 * Directory item structure for search results (lean format)
 */
export interface DirectoryItem {
  path: string;
  type: 'file' | 'folder';
  snippet?: string;  // For files only
}

/**
 * Match information from search operations
 */
export interface SearchMatch {
  item: TFile | TFolder;
  score: number;
  matchType: string;
}

/**
 * Service for formatting search results
 * Implements Single Responsibility Principle - only handles result formatting
 */
export class SearchResultFormatter {
  private app: any;

  constructor(app: any) {
    this.app = app;
  }

  /**
   * Transform search matches into formatted results
   * @param matches Array of search matches
   * @param includeContent Whether to include content snippets
   * @returns Array of formatted DirectoryItem results
   */
  async transformResults(
    matches: SearchMatch[],
    includeContent: boolean = true
  ): Promise<DirectoryItem[]> {
    const results: DirectoryItem[] = [];

    for (const match of matches) {
      const item = match.item;
      const isFile = item instanceof TFile;

      const result: DirectoryItem = {
        path: item.path,
        type: isFile ? 'file' : 'folder'
      };

      // Add snippet for files if content requested
      if (isFile && includeContent) {
        const snippet = await this.extractSnippet(item as TFile);
        if (snippet) {
          result.snippet = snippet;
        }
      }

      results.push(result);
    }

    return results;
  }

  /**
   * Extract content snippet from a file
   * @param file The file to extract from
   * @returns Content snippet or error message
   */
  private async extractSnippet(file: TFile): Promise<string> {
    try {
      const content = await this.app.vault.read(file);
      const lines = content.split('\n');
      const firstFewLines = lines.slice(0, 3).join(' ');
      return firstFewLines.length > 200
        ? firstFewLines.substring(0, 200) + '...'
        : firstFewLines;
    } catch (error) {
      return 'Content not available';
    }
  }

}

```

## agents/searchManager/tools/index.ts

```typescript
// Export all search tools
export * from './searchContent';
export * from './searchDirectory';
export * from './searchMemory';

```

## agents/searchManager/tools/searchContent.ts

```typescript
import { Plugin, TFile, prepareFuzzySearch } from 'obsidian';
import { BaseTool } from '../../baseTool';
import { getErrorMessage } from '../../../utils/errorUtils';
import { BRAND_NAME } from '../../../constants/branding';
import { isGlobPattern, globToRegex, normalizePath } from '../../../utils/pathUtils';
import { EmbeddingService } from '../../../services/embeddings/EmbeddingService';
import { EmbeddingManager } from '../../../services/embeddings/EmbeddingManager';
import { CommonParameters } from '../../../types';

/**
 * Extended plugin interface that includes optional embedding manager
 */
interface PluginWithEmbeddings extends Plugin {
  embeddingManager?: EmbeddingManager;
}

/**
 * Internal search result with scoring
 * Used internally for ranking before returning clean results to caller
 */
interface ScoredSearchResult {
  filePath: string;
  frontmatter?: Record<string, any>;
  content?: string;
  _score: number; // Internal property for sorting
}

export interface ContentSearchParams extends CommonParameters {
  query: string;
  semantic?: boolean;  // Default: false (keyword search). Set true for vector/embedding search
  limit?: number;
  includeContent?: boolean;
  snippetLength?: number;
  paths?: string[];
}

export interface ContentSearchResult {
  success: boolean;
  results: Array<{
    filePath: string;
    frontmatter?: Record<string, any>;
    content?: string;  // Keyword search only
  }>;
  error?: string;
}

/**
 * Content search tool with both semantic (vector) and keyword search capabilities
 *
 * - semantic: true â†’ Uses embedding-based vector similarity search (best for conceptual queries)
 * - semantic: false â†’ Uses Obsidian's fuzzy + keyword search (best for exact matches)
 */
export class SearchContentTool extends BaseTool<ContentSearchParams, ContentSearchResult> {
  private plugin: Plugin;
  private embeddingService: EmbeddingService | null = null;

  constructor(plugin: Plugin) {
    super(
      'searchContent',
      'Content Search',
      'Search vault files. Set semantic=true for AI-powered conceptual search using local embeddings (best for concepts/related ideas), or semantic=false for keyword/fuzzy search (best for exact matches). Semantic search is desktop-only and becomes available once the embedding system initializes in the background (first run may take longer while the model downloads).',
      '2.0.0'
    );
    this.plugin = plugin;
  }

  /**
   * Set the embedding service for semantic search
   */
  setEmbeddingService(service: EmbeddingService): void {
    this.embeddingService = service;
  }

  /**
   * Lazily get the embedding service from the plugin
   * This handles the timing issue where EmbeddingManager initializes after VaultLibrarian
   */
  private getEmbeddingService(): EmbeddingService | null {
    // Return cached service if available
    if (this.embeddingService) {
      return this.embeddingService;
    }

    // Try to get from plugin's embeddingManager
    try {
      const pluginWithEmbeddings = this.plugin as PluginWithEmbeddings;
      if (pluginWithEmbeddings.embeddingManager) {
        const service = pluginWithEmbeddings.embeddingManager.getService();
        if (service) {
          this.embeddingService = service; // Cache for future use
          return service;
        }
      }
    } catch (error) {
    }

    return null;
  }

  async execute(params: ContentSearchParams): Promise<ContentSearchResult> {
    const startTime = performance.now();

    try {
      if (!params.query || params.query.trim().length === 0) {
        return this.prepareResult(false, undefined, 'Query parameter is required and cannot be empty');
      }

      const searchParams = {
        query: params.query.trim(),
        semantic: params.semantic ?? false, // Default to keyword search (always available)
        limit: params.limit || 10,
        includeContent: params.includeContent !== false,
        snippetLength: params.snippetLength || 200,
        paths: params.paths || []
      };

      // Use semantic search if requested
      if (searchParams.semantic) {
        return await this.performSemanticSearch(searchParams, startTime);
      }

      // Otherwise use keyword/fuzzy search
      return await this.performKeywordFuzzySearch(searchParams, startTime);

    } catch (error) {
      console.error(`[${BRAND_NAME}] Content search failed:`, error);
      return this.prepareResult(false, undefined, `Search failed: ${getErrorMessage(error)}`);
    }
  }

  /**
   * Perform semantic (vector) search using embeddings
   */
  private async performSemanticSearch(
    searchParams: { query: string; limit: number; paths: string[]; includeContent: boolean; snippetLength: number },
    startTime: number
  ): Promise<ContentSearchResult> {
    // Lazily get the embedding service (handles timing issues)
    const embeddingService = this.getEmbeddingService();

    if (!embeddingService) {
      return this.prepareResult(false, undefined, 'Semantic search is not available yet. The embedding system may still be initializing (and may need to download the embedding model on first run). Try again in a moment, or use semantic=false for keyword search.');
    }

    if (!embeddingService.isServiceEnabled()) {
      return this.prepareResult(false, undefined, 'Embedding service is disabled (mobile platform or initialization failed). Use semantic=false for keyword search.');
    }

    // Check if we have any embeddings
    const stats = await embeddingService.getStats();
    if (stats.noteCount === 0) {
      return this.prepareResult(false, undefined, 'No embeddings found. The vault is likely still being indexed. Please wait for indexing to complete, or use semantic=false for keyword search.');
    }

    try {
      // Use EmbeddingService.semanticSearch()
      const semanticResults = await embeddingService.semanticSearch(searchParams.query, searchParams.limit * 2); // Get extra for path filtering

      if (semanticResults.length === 0) {
        return this.prepareResult(false, undefined, 'Semantic search returned no results. This may indicate an issue with the vector database. Please check the console for errors.');
      }

      // Filter by paths if specified
      let filteredResults = semanticResults;
      if (searchParams.paths.length > 0) {
        const globPatterns = searchParams.paths
          .filter(p => isGlobPattern(p))
          .map(p => globToRegex(p));

        const literalPaths = searchParams.paths
          .filter(p => !isGlobPattern(p))
          .map(p => normalizePath(p));

        filteredResults = semanticResults.filter(result => {
          const matchesLiteral = literalPaths.some(path => {
            // Empty path (from "/") matches everything
            if (path === '') return true;
            return result.notePath.startsWith(path);
          });
          const matchesGlob = globPatterns.some(regex => regex.test(result.notePath));
          return matchesLiteral || matchesGlob;
        });
      }

      // Convert to lean result format (just filePath + frontmatter)
      const results: Array<{ filePath: string; frontmatter?: Record<string, any> }> = [];
      for (const result of filteredResults.slice(0, searchParams.limit)) {
        const file = this.plugin.app.vault.getAbstractFileByPath(result.notePath);
        if (file instanceof TFile) {
          // Get frontmatter only
          let frontmatter: Record<string, any> | undefined;
          const fileCache = this.plugin.app.metadataCache.getFileCache(file);
          if (fileCache?.frontmatter) {
            frontmatter = { ...fileCache.frontmatter };
            delete frontmatter.position;
          }

          const entry: { filePath: string; frontmatter?: Record<string, any> } = {
            filePath: result.notePath
          };
          if (frontmatter && Object.keys(frontmatter).length > 0) {
            entry.frontmatter = frontmatter;
          }
          results.push(entry);
        }
      }

      const executionTime = performance.now() - startTime;

      return this.prepareResult(true, {
        results
      });

    } catch (error) {
      console.error(`[${BRAND_NAME}] Semantic search failed:`, error);
      return this.prepareResult(false, undefined, `Semantic search failed: ${getErrorMessage(error)}. Try semantic=false for keyword search.`);
    }
  }

  /**
   * Perform keyword/fuzzy search (original behavior)
   */
  private async performKeywordFuzzySearch(
    searchParams: { query: string; limit: number; paths: string[]; includeContent: boolean; snippetLength: number },
    startTime: number
  ): Promise<ContentSearchResult> {
    // Get all markdown files
    let allFiles = this.plugin.app.vault.getMarkdownFiles();

    // Filter by paths if specified
    if (searchParams.paths.length > 0) {
      const globPatterns = searchParams.paths
        .filter(p => isGlobPattern(p))
        .map(p => globToRegex(p));

      const literalPaths = searchParams.paths
        .filter(p => !isGlobPattern(p))
        .map(p => normalizePath(p));

      allFiles = allFiles.filter(file => {
        const matchesLiteral = literalPaths.some(path => {
          // Empty path (from "/") matches everything
          if (path === '') return true;
          return file.path.startsWith(path);
        });
        const matchesGlob = globPatterns.some(regex => regex.test(file.path));
        return matchesLiteral || matchesGlob;
      });
    }

    // Perform combined fuzzy + keyword search
    const searchResults = await this.performCombinedSearch(
      searchParams.query,
      allFiles,
      searchParams.limit,
      searchParams.includeContent,
      searchParams.snippetLength
    );

    const executionTime = performance.now() - startTime;

    return this.prepareResult(true, {
      results: searchResults
    });
  }

  /**
   * Perform combined fuzzy and keyword search with result ranking
   */
  private async performCombinedSearch(
    query: string,
    files: TFile[],
    limit: number,
    includeContent: boolean,
    snippetLength: number
  ): Promise<ContentSearchResult['results']> {
    const normalizedQuery = query.toLowerCase();
    const fuzzySearch = prepareFuzzySearch(normalizedQuery);
    const allResults: ScoredSearchResult[] = [];

    for (const file of files) {
      const results = await this.searchInFile(
        file,
        query,
        normalizedQuery,
        fuzzySearch,
        includeContent,
        snippetLength
      );
      allResults.push(...results);
    }

    // Sort by internal score (higher is better) and take top results
    allResults.sort((a, b) => (b._score || 0) - (a._score || 0));
    // Strip internal score before returning
    const finalResults = allResults.slice(0, limit).map(r => {
      const { _score, ...rest } = r;
      return rest;
    });
    return finalResults;
  }

  /**
   * Search within a single file using multiple methods
   */
  private async searchInFile(
    file: TFile,
    originalQuery: string,
    normalizedQuery: string,
    fuzzySearch: (text: string) => { score: number } | null,
    includeContent: boolean,
    snippetLength: number
  ): Promise<ScoredSearchResult[]> {
    const results: ScoredSearchResult[] = [];
    let maxScore = 0;
    let contentSnippet = '';

    // 1. Fuzzy search on filename
    const filename = file.basename;
    const fuzzyResult = fuzzySearch(filename);
    let fuzzyScore = 0;

    if (fuzzyResult) {
      // Normalize fuzzy score (fuzzy scores are negative, closer to 0 is better)
      fuzzyScore = Math.max(0, Math.min(1, 1 + (fuzzyResult.score / 100)));
      maxScore = Math.max(maxScore, fuzzyScore);
    }

    // 2. Keyword search in file content and extract frontmatter
    let keywordScore = 0;
    let frontmatter: Record<string, any> | undefined = undefined;

    if (includeContent) {
      try {
        const fileContent = await this.plugin.app.vault.read(file);

        // Extract frontmatter using Obsidian's metadata cache
        const fileCache = this.plugin.app.metadataCache.getFileCache(file);
        if (fileCache?.frontmatter) {
          frontmatter = { ...fileCache.frontmatter };
          // Remove the position property as it's internal metadata
          delete frontmatter.position;
        }

        const keywordResult = this.performKeywordSearch(originalQuery, normalizedQuery, fileContent, snippetLength);

        if (keywordResult.found) {
          keywordScore = keywordResult.score;
          contentSnippet = keywordResult.snippet;

          if (keywordScore > maxScore) {
            maxScore = keywordScore;
          }
        }
      } catch (error) {
      }
    } else {
      // Even if not including content, still extract frontmatter
      try {
        const fileCache = this.plugin.app.metadataCache.getFileCache(file);
        if (fileCache?.frontmatter) {
          frontmatter = { ...fileCache.frontmatter };
          delete frontmatter.position;
        }
      } catch (error) {
      }
    }

    // 3. Combined scoring for files that match both fuzzy and keyword
    if (fuzzyScore > 0 && keywordScore > 0) {
      // Weighted combination: 60% keyword + 40% fuzzy
      maxScore = (keywordScore * 0.6) + (fuzzyScore * 0.4);
    }

    // Only include files with matches
    if (maxScore > 0) {
      // If no content snippet from keyword search, use file path
      if (!contentSnippet && includeContent) {
        contentSnippet = `File: ${file.path}`;
      }

      const entry: ScoredSearchResult = {
        filePath: file.path,
        content: contentSnippet,
        _score: maxScore
      };
      if (frontmatter && Object.keys(frontmatter).length > 0) {
        entry.frontmatter = frontmatter;
      }
      results.push(entry);
    }

    return results;
  }

  /**
   * Perform keyword search in file content
   */
  private performKeywordSearch(
    originalQuery: string,
    normalizedQuery: string,
    content: string,
    snippetLength: number
  ): { found: boolean; score: number; snippet: string } {
    const normalizedContent = content.toLowerCase();

    // Look for exact phrase match first (highest score)
    const exactIndex = normalizedContent.indexOf(normalizedQuery);
    if (exactIndex !== -1) {
      return {
        found: true,
        score: 0.9,
        snippet: this.extractSnippet(content, exactIndex, originalQuery.length, snippetLength)
      };
    }

    // Look for individual word matches
    const queryWords = normalizedQuery.split(/\s+/).filter(word => word.length > 2);
    const wordMatches = queryWords.filter(word => normalizedContent.includes(word));

    if (wordMatches.length === 0) {
      return { found: false, score: 0, snippet: '' };
    }

    // Score based on word match ratio
    const matchRatio = wordMatches.length / queryWords.length;
    const score = Math.max(0.3, matchRatio * 0.8);

    // Find snippet around first word match
    const firstMatch = wordMatches[0];
    const firstMatchIndex = normalizedContent.indexOf(firstMatch);

    return {
      found: true,
      score,
      snippet: this.extractSnippet(content, firstMatchIndex, firstMatch.length, snippetLength)
    };
  }

  /**
   * Extract content snippet around a match
   */
  private extractSnippet(content: string, matchIndex: number, matchLength: number, snippetLength: number): string {
    const halfSnippet = Math.floor(snippetLength / 2);
    const start = Math.max(0, matchIndex - halfSnippet);
    const end = Math.min(content.length, matchIndex + matchLength + halfSnippet);

    let snippet = content.substring(start, end);

    // Add ellipsis if truncated
    if (start > 0) snippet = '...' + snippet;
    if (end < content.length) snippet = snippet + '...';

    return snippet.trim();
  }

  /**
   * Get parameter schema for MCP tool definition
   */
  getParameterSchema() {
    const toolSchema = {
      type: 'object',
      title: 'Content Search Params',
      description: 'Search vault files. REQUIRED: Set "semantic" parameter to choose search mode.',
      properties: {
        query: {
          type: 'string',
          description: 'Search query to find files and content.'
        },
        semantic: {
          type: 'boolean',
          description: 'true = AI-powered conceptual search (desktop only, best for concepts/related ideas). false = keyword/fuzzy search (default, best for exact matches).',
          default: false
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results to return (default: 10)',
          minimum: 1,
          maximum: 50,
          default: 10
        },
        includeContent: {
          type: 'boolean',
          description: 'For keyword search only: include content snippets (default: true). Ignored for semantic search.',
          default: true
        },
        snippetLength: {
          type: 'number',
          description: 'For keyword search only: length of content snippets (default: 200). Ignored for semantic search.',
          minimum: 50,
          maximum: 1000,
          default: 200
        },
        paths: {
          type: 'array',
          description: 'Restrict search to specific folder paths. Supports glob patterns.',
          items: { type: 'string' }
        }
      },
      required: ['query'],
      additionalProperties: false
    };

    return this.getMergedSchema(toolSchema);
  }

  /**
   * Get result schema for MCP tool definition
   */
  getResultSchema() {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the search was successful'
        },
        results: {
          type: 'array',
          description: 'Search results ranked by relevance',
          items: {
            type: 'object',
            properties: {
              filePath: {
                type: 'string',
                description: 'Path to the file'
              },
              frontmatter: {
                type: 'object',
                description: 'File frontmatter if present',
                additionalProperties: true
              },
              content: {
                type: 'string',
                description: 'Content snippet (keyword search only)'
              }
            },
            required: ['filePath']
          }
        },
        error: {
          type: 'string',
          description: 'Error message if failed'
        }
      },
      required: ['success', 'results'],
      additionalProperties: false
    };
  }
}

```

## agents/searchManager/tools/searchDirectory.ts

```typescript
/**
 * Location: /src/agents/searchManager/tools/searchDirectory.ts
 * Purpose: Unified search tool for files and folders using fuzzy matching
 *
 * This file handles directory search operations with fuzzy matching,
 * filtering, and result formatting capabilities.
 *
 * Used by: VaultLibrarian agent for directory search operations
 * Integrates with: WorkspaceService for workspace context
 * Refactored: Now uses dedicated services for item collection, filtering,
 *             fuzzy searching, and result formatting following SOLID principles
 */

import { Plugin } from 'obsidian';
import { BaseTool } from '../../baseTool';
import { getErrorMessage } from '../../../utils/errorUtils';
import { CommonParameters } from '../../../types/mcp/AgentTypes';
import { WorkspaceService, GLOBAL_WORKSPACE_ID } from '../../../services/WorkspaceService';

// Import refactored services
import { DirectoryItemCollector } from '../services/DirectoryItemCollector';
import { SearchFilterApplicator, SearchFilters } from '../services/SearchFilterApplicator';
import { FuzzySearchEngine } from '../services/FuzzySearchEngine';
import { SearchResultFormatter, DirectoryItem } from '../services/SearchResultFormatter';

/**
 * Directory search parameters interface
 */
export interface SearchDirectoryParams extends CommonParameters {
  // REQUIRED PARAMETERS
  query: string;
  paths: string[];

  // OPTIONAL PARAMETERS
  searchType?: 'files' | 'folders' | 'both';
  fileTypes?: string[];
  depth?: number;
  includeContent?: boolean;
  limit?: number;
  pattern?: string;
  dateRange?: {
    start?: string;
    end?: string;
  };
  workspaceId?: string;
}

export interface SearchDirectoryResult {
  success: boolean;
  results: DirectoryItem[];
  error?: string;
}

/**
 * Unified search tool for both files and folders using fuzzy matching
 *
 * Follows SOLID principles with service composition:
 * - DirectoryItemCollector: Collects files/folders from paths
 * - SearchFilterApplicator: Applies various filters
 * - FuzzySearchEngine: Performs fuzzy matching
 * - SearchResultFormatter: Formats results with metadata
 */
export class SearchDirectoryTool extends BaseTool<SearchDirectoryParams, SearchDirectoryResult> {
  private plugin: Plugin;
  private workspaceService?: WorkspaceService;

  // Composed services following Dependency Inversion Principle
  private itemCollector: DirectoryItemCollector;
  private filterApplicator: SearchFilterApplicator;
  private searchEngine: FuzzySearchEngine;
  private resultFormatter: SearchResultFormatter;

  constructor(plugin: Plugin, workspaceService?: WorkspaceService) {
    super(
      'searchDirectory',
      'Search Directory',
      'FOCUSED directory search with REQUIRED paths parameter. Search for files and/or folders within specific directory paths using fuzzy matching and optional workspace context. Requires: query (search terms) and paths (directory paths to search - cannot be empty).',
      '2.0.0'
    );

    this.plugin = plugin;
    this.workspaceService = workspaceService;

    // Initialize composed services
    this.itemCollector = new DirectoryItemCollector(plugin);
    this.filterApplicator = new SearchFilterApplicator();
    this.searchEngine = new FuzzySearchEngine();
    this.resultFormatter = new SearchResultFormatter(plugin.app);
  }

  async execute(params: SearchDirectoryParams): Promise<SearchDirectoryResult> {
    try {
      // Validate parameters
      const validationError = this.validateParams(params);
      if (validationError) {
        return this.createErrorResult(validationError);
      }

      const query = params.query.trim();
      const limit = params.limit || 20;
      const searchType = params.searchType || 'both';

      // Get items from specified directories using item collector
      const items = await this.itemCollector.getDirectoryItems(
        params.paths,
        searchType,
        params.depth
      );

      // Apply workspace context if available
      const contextualItems = await this.applyWorkspaceContext(items, params.workspaceId);

      // Apply filters using filter applicator
      const filters: SearchFilters = {
        fileTypes: params.fileTypes,
        depth: params.depth,
        pattern: params.pattern,
        dateRange: params.dateRange
      };
      const filteredItems = this.filterApplicator.applyFilters(contextualItems, filters);

      // Perform fuzzy search using search engine
      const matches = this.searchEngine.performFuzzySearch(filteredItems, query);

      // Sort and limit results
      matches.sort((a, b) => b.score - a.score);
      const topMatches = matches.slice(0, limit);

      // Transform to enhanced format using result formatter
      const results = await this.resultFormatter.transformResults(
        topMatches,
        params.includeContent !== false
      );

      return this.prepareResult(true, {
        results
      });

    } catch (error) {
      return this.createErrorResult(`Directory search failed: ${getErrorMessage(error)}`);
    }
  }

  /**
   * Validate search parameters
   * @param params Params to validate
   * @returns Error message if invalid, null if valid
   */
  private validateParams(params: SearchDirectoryParams): string | null {
    if (!params.query || params.query.trim().length === 0) {
      return 'Query parameter is required and cannot be empty';
    }

    if (!params.paths || params.paths.length === 0) {
      return 'Paths parameter is required and cannot be empty';
    }

    return null;
  }

  /**
   * Create an error result with diagnostics
   * @param errorMessage The error message
   * @returns Error result
   */
  protected createErrorResult(
    errorMessage: string
  ): SearchDirectoryResult {
    return this.prepareResult(false, undefined, errorMessage);
  }


  /**
   * Apply workspace context for boosted relevance (doesn't filter)
   * @param items Items to apply context to
   * @param workspaceId Optional workspace ID
   * @returns Items (potentially boosted if workspace context available)
   */
  private async applyWorkspaceContext(
    items: any[],
    workspaceId?: string
  ): Promise<any[]> {
    if (!this.workspaceService || !workspaceId || workspaceId === GLOBAL_WORKSPACE_ID) {
      return items;
    }

    try {
      const workspace = await this.workspaceService.getWorkspace(workspaceId);
      if (!workspace) {
        return items;
      }

      // For directory search, workspace context can boost relevance but doesn't filter
      // This maintains the explicit directory paths while adding workspace awareness
      return items;

    } catch (error) {
      return items;
    }
  }

  getParameterSchema() {
    const toolSchema = {
      type: 'object',
      title: 'Search Directory',
      description: 'Search for files and folders within directory paths.',
      properties: {
        query: {
          type: 'string',
          description: 'Search term to find in file/folder names and paths. Fuzzy matching is automatic.',
          minLength: 1
        },
        paths: {
          type: 'array',
          items: { type: 'string' },
          minItems: 1,
          description: 'Directory paths to search within. Supports glob patterns. Use ["/"] for entire vault.'
        },
        searchType: {
          type: 'string',
          enum: ['files', 'folders', 'both'],
          description: 'What to search for: "files", "folders", or "both"',
          default: 'both'
        },
        fileTypes: {
          type: 'array',
          items: { type: 'string' },
          description: 'Filter by file extensions without dots'
        },
        depth: {
          type: 'number',
          description: 'Maximum directory depth to search (1-10)',
          minimum: 1,
          maximum: 10
        },
        pattern: {
          type: 'string',
          description: 'Regular expression pattern to filter paths'
        },
        dateRange: {
          type: 'object',
          properties: {
            start: {
              type: 'string',
              format: 'date',
              description: 'Start date (YYYY-MM-DD)'
            },
            end: {
              type: 'string',
              format: 'date',
              description: 'End date (YYYY-MM-DD)'
            }
          },
          description: 'Filter results by modification date range'
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results (1-100)',
          default: 20,
          minimum: 1,
          maximum: 100
        },
        includeContent: {
          type: 'boolean',
          description: 'Include content snippets from files',
          default: true
        }
      },
      required: ['query', 'paths'],
      additionalProperties: true,
      errorHelp: {
        missingQuery: 'The "query" parameter is required. Do NOT use "filter" - use "query" instead. Example: { "query": "summary", "paths": ["/"] }',
        missingPaths: 'The "paths" parameter is required and must be a non-empty array. Specify directories to search. Example: { "query": "summary", "paths": ["/"] }',
        emptyPaths: 'The "paths" array cannot be empty. Provide at least one directory path to search within.',
        commonMistakes: [
          'Using "filter" instead of "query" - always use "query"',
          'Forgetting the "paths" array - it\'s required',
          'Using wildcards (*) in query - just use plain text',
          'Providing paths as a string instead of array - wrap in brackets: ["/"]'
        ]
      }
    };

    return this.getMergedSchema(toolSchema);
  }

  getResultSchema() {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the search was successful'
        },
        results: {
          type: 'array',
          description: 'Search results ranked by relevance',
          items: {
            type: 'object',
            properties: {
              path: {
                type: 'string',
                description: 'Full path to the item'
              },
              type: {
                type: 'string',
                enum: ['file', 'folder'],
                description: 'Type of the item'
              },
              snippet: {
                type: 'string',
                description: 'Content snippet (files only)'
              }
            },
            required: ['path', 'type']
          }
        },
        error: {
          type: 'string',
          description: 'Error message if failed'
        }
      },
      required: ['success', 'results']
    };
  }
}

```

## agents/searchManager/tools/searchMemory.ts

```typescript
import { Plugin } from 'obsidian';
import { BaseTool } from '../../baseTool';
import { getErrorMessage } from '../../../utils/errorUtils';
import {
  MemorySearchParameters,
  MemorySearchResult,
  EnrichedMemorySearchResult,
  SearchMemoryModeResult,
  DateRange
} from '../../../types/memory/MemorySearchTypes';
import { MemorySearchProcessor, MemorySearchProcessorInterface } from '../services/MemorySearchProcessor';
import { MemorySearchFilters, MemorySearchFiltersInterface } from '../services/MemorySearchFilters';
import { ResultFormatter, ResultFormatterInterface } from '../services/ResultFormatter';
import { CommonParameters } from '../../../types/mcp/AgentTypes';
import { MemoryService } from "../../memoryManager/services/MemoryService";
import { WorkspaceService, GLOBAL_WORKSPACE_ID } from '../../../services/WorkspaceService';
import { IStorageAdapter } from '../../../database/interfaces/IStorageAdapter';
import { addRecommendations, Recommendation } from '../../../utils/recommendationUtils';
import { NudgeHelpers } from '../../../utils/nudgeHelpers';

/**
 * Memory types available for search (simplified after MemoryManager refactor)
 * - 'traces': Tool execution traces (includes tool calls)
 * - 'states': Workspace states (snapshots of work context)
 */
export type MemoryType = 'traces' | 'states';

/**
 * Session filtering options
 */
export interface SessionFilterOptions {
  currentSessionOnly?: boolean;     // Filter to current session (default: false)
  specificSessions?: string[];      // Filter to specific session IDs
  excludeSessions?: string[];       // Exclude specific session IDs
}

/**
 * Temporal filtering options for time-based search
 */
export interface TemporalFilterOptions {
  since?: string | Date;           // Results since this timestamp
  until?: string | Date;           // Results until this timestamp
  lastNHours?: number;             // Results from last N hours
  lastNDays?: number;              // Results from last N days
}

/**
 * Memory search parameters interface (simplified after MemoryManager refactor)
 */
export interface SearchMemoryParams extends CommonParameters {
  // REQUIRED PARAMETERS
  query: string;
  workspaceId: string;  // Required - states and traces are workspace-scoped

  // OPTIONAL PARAMETERS
  memoryTypes?: MemoryType[];  // 'traces' and/or 'states'
  searchMethod?: 'semantic' | 'exact' | 'mixed';
  sessionFiltering?: SessionFilterOptions;
  temporalFiltering?: TemporalFilterOptions;
  limit?: number;
  includeMetadata?: boolean;
  includeContent?: boolean;

  // Additional properties to match MemorySearchParams
  workspace?: string;
  dateRange?: DateRange;
  toolCallFilters?: any;
}

// SearchMemoryResult extends the base type
export interface SearchMemoryResult extends SearchMemoryModeResult {}

// Legacy interface names for backward compatibility
export type { MemorySearchResult };
export type { SearchMemoryModeResult };

/**
 * Search tool focused on memory traces, sessions, states, and workspaces
 * Optimized with extracted services for better maintainability and testability
 */
export class SearchMemoryTool extends BaseTool<SearchMemoryParams, SearchMemoryResult> {
  private plugin: Plugin;
  private processor: MemorySearchProcessorInterface;
  private filters: MemorySearchFiltersInterface;
  private formatter: ResultFormatterInterface;
  private memoryService?: MemoryService;
  private workspaceService?: WorkspaceService;
  private storageAdapter?: IStorageAdapter;

  constructor(
    plugin: Plugin,
    memoryService?: MemoryService,
    workspaceService?: WorkspaceService,
    storageAdapter?: IStorageAdapter,
    processor?: MemorySearchProcessorInterface,
    filters?: MemorySearchFiltersInterface,
    formatter?: ResultFormatterInterface
  ) {
    super(
      'searchMemory',
      'Search Memory',
      'MEMORY-FOCUSED search with mandatory workspaceId parameter. Search through memory traces and states within a workspace context. Traces include tool execution history. States capture workspace snapshots. Requires: query (search terms) and workspaceId (workspace context).',
      '2.0.0'
    );

    this.plugin = plugin;
    this.memoryService = memoryService;
    this.workspaceService = workspaceService;
    this.storageAdapter = storageAdapter;

    // Initialize services with dependency injection support
    // Pass storageAdapter to processor for new backend support
    this.processor = processor || new MemorySearchProcessor(plugin, undefined, workspaceService, storageAdapter);
    this.filters = filters || new MemorySearchFilters();
    this.formatter = formatter || new ResultFormatter();
  }

  private isThinContext(context: any): boolean {
    if (!context || typeof context !== 'object') {
      return true;
    }

    const keys = Object.keys(context);
    if (keys.length === 0) {
      return true;
    }

    const nonIdKeys = keys.filter(key => !['sessionId', 'workspaceId'].includes(key));
    return nonIdKeys.length === 0;
  }

  async execute(params: SearchMemoryParams): Promise<SearchMemoryResult> {
    try {
      // Simple parameter validation
      if (!params.query || params.query.trim().length === 0) {
        return this.prepareResult(false, undefined, 'Query parameter is required and cannot be empty');
      }

      // Apply default workspace if not provided
      const workspaceId = params.workspaceId || GLOBAL_WORKSPACE_ID;
      const searchParams = { ...params, workspaceId };

      // Core processing through extracted services
      let results = await this.processor.process(searchParams);
      
      // Skip filters - return results directly
      
      // Transform results to simple format with just content, tool, and context
      // Use the raw trace data attached during enrichment
      const simplifiedResults = results.map((result: EnrichedMemorySearchResult) => {
        try {
          // Access the raw trace that was attached during enrichment
          const trace = result._rawTrace;
          if (!trace) {
            return null;
          }

          // Target canonical metadata context first, then legacy fallbacks
          let context = trace.metadata?.context;
          let source = 'metadata.context';

          const legacyParamsContext = trace.metadata?.legacy?.params?.context;
          const legacyResultContext = trace.metadata?.legacy?.result?.context;

          if (this.isThinContext(context) && legacyParamsContext) {
            context = legacyParamsContext;
            source = 'legacy.params';
          }

          if (this.isThinContext(context) && legacyResultContext) {
            context = legacyResultContext;
            source = 'legacy.result';
          }

          // Safety check: Ensure it's actually an object before trying to clean it
          if (context && typeof context === 'object' && !Array.isArray(context)) {
            // Clone it so we don't mutate the original data
            context = { ...context };

            // Remove the technical IDs we don't want
            delete context.sessionId;
            delete context.workspaceId;
          } else {
            // Fallback to empty if it's not a valid object
            context = {};
          }
          
          const entry: any = {
            content: trace.content || ''
          };
          if (trace.metadata?.tool) {
            entry.tool = trace.metadata.tool;
          }
          if (context && Object.keys(context).length > 0) {
            entry.context = context;
          }
          return entry;
        } catch (error) {
          return null;
        }
      });
      
      // Filter out nulls
      const finalResults = simplifiedResults.filter(r => r !== null);

      const result = this.prepareResult(true, {
        results: finalResults
      });

      // Generate nudges based on memory search results
      const nudges = this.generateMemorySearchNudges(results);

      return addRecommendations(result, nudges);

    } catch (error) {
      console.error('[SearchMemoryTool] Search error:', error);
      return this.prepareResult(false, undefined, `Memory search failed: ${getErrorMessage(error)}`);
    }
  }

  getParameterSchema() {
    // Create the enhanced tool-specific schema
    const toolSchema = {
      type: 'object',
      title: 'Memory Search Params',
      description: 'MEMORY-FOCUSED search with workspace context. Search through memory traces (tool execution history) and states (workspace snapshots) with temporal filtering.',
      properties: {
        query: {
          type: 'string',
          description: 'Search query to find in memory content',
          minLength: 1
        },
        workspaceId: {
          type: 'string',
          description: 'Workspace context for memory search. Use listWorkspaces to see available workspaces.'
        },
        memoryTypes: {
          type: 'array',
          items: {
            type: 'string',
            enum: ['traces', 'states']
          },
          description: 'Types of memory to search. "traces" includes tool execution history. "states" includes workspace snapshots. Defaults to both types.',
          default: ['traces', 'states']
        },
        dateRange: {
          type: 'object',
          properties: {
            start: {
              type: 'string',
              format: 'date',
              description: 'Start date for filtering results (ISO format)'
            },
            end: {
              type: 'string',
              format: 'date',
              description: 'End date for filtering results (ISO format)'
            }
          },
          description: 'Filter results by date range'
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results to return',
          default: 20,
          minimum: 1,
          maximum: 100
        },
        toolCallFilters: {
          type: 'object',
          properties: {
            agent: {
              type: 'string',
              description: 'Filter by agent name'
            },
            tool: {
              type: 'string',
              description: 'Filter by tool name'
            },
            success: {
              type: 'boolean',
              description: 'Filter by success status (true for successful, false for failed)'
            },
            minExecutionTime: {
              type: 'number',
              description: 'Minimum execution time in milliseconds'
            },
            maxExecutionTime: {
              type: 'number',
              description: 'Maximum execution time in milliseconds'
            }
          },
          description: 'Additional filters for tool call traces'
        },
        searchMethod: {
          type: 'string',
          enum: ['semantic', 'exact', 'mixed'],
          description: 'Search method to use',
          default: 'mixed'
        }
      },
      required: ['query', 'workspaceId']
    };

    // Merge with common schema (sessionId and context) - removing duplicate definitions
    return this.getMergedSchema(toolSchema);
  }

  getResultSchema() {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the search was successful'
        },
        results: {
          type: 'array',
          description: 'Memory traces ranked by relevance',
          items: {
            type: 'object',
            properties: {
              content: {
                type: 'string',
                description: 'The trace content'
              },
              tool: {
                type: 'string',
                description: 'Tool that created this trace (if applicable)'
              },
              context: {
                type: 'object',
                description: 'Additional context from the trace'
              }
            },
            required: ['content']
          }
        },
        error: {
          type: 'string',
          description: 'Error message if failed'
        }
      },
      required: ['success', 'results']
    };
  }

  /**
   * Generate nudges based on memory search results
   */
  private generateMemorySearchNudges(results: any[]): Recommendation[] {
    const nudges: Recommendation[] = [];

    if (!Array.isArray(results) || results.length === 0) {
      return nudges;
    }

    // Check for previous states in results
    const previousStatesNudge = NudgeHelpers.checkPreviousStates(results);
    if (previousStatesNudge) {
      nudges.push(previousStatesNudge);
    }

    // Check for workspace sessions in results
    const workspaceSessionsNudge = NudgeHelpers.checkWorkspaceSessions(results);
    if (workspaceSessionsNudge) {
      nudges.push(workspaceSessionsNudge);
    }

    return nudges;
  }
}

```

## agents/searchManager/types.ts

```typescript
import { CommonParameters, CommonResult } from '../../types';





/**
 * Graph boost options for enhancing search results using graph connections
 * Note: Graph boost is now hardcoded into the RRF calculation with sensible defaults
 * These options are maintained for internal use but no longer exposed to users
 */
export interface GraphBoostOptions {
  // Internal parameters - no longer user-facing since graph boost is hardcoded
}


/**
 * Universal search category types
 */
export type CategoryType =
  | 'files'
  | 'folders'
  | 'content'
  | 'workspaces'
  | 'sessions'
  | 'states'
  | 'memory_traces'
  | 'tags'
  | 'properties';

/**
 * Universal search parameters
 */
export interface UniversalSearchParams extends CommonParameters, GraphBoostOptions {
  /**
   * Search query across all content types
   * Supports metadata filtering syntax: "tag:javascript priority:high content query"
   */
  query: string;

  /**
   * Search strategy type - controls weighting of semantic/keyword/fuzzy search methods
   * - 'exact': 70% keyword, 20% semantic, 10% fuzzy (for specific terms)
   * - 'conceptual': 60% semantic, 30% keyword, 10% fuzzy (for topics)
   * - 'exploratory': 80% semantic, 15% fuzzy, 5% keyword (for questions)
   * - 'mixed': 40% semantic, 40% keyword, 20% fuzzy (balanced)
   */
  queryType?: 'exact' | 'conceptual' | 'exploratory' | 'mixed';
  
  /**
   * Maximum number of results per category (default: 10)
   */
  limit?: number;
  
  /**
   * Categories to exclude from search
   */
  excludeCategories?: CategoryType[];
  
  /**
   * Categories to prioritize (return more results)
   */
  prioritizeCategories?: CategoryType[];
  
  /**
   * Paths to restrict search to
   */
  paths?: string[];
  
  /**
   * Whether to include content snippets in results (default: true)
   */
  includeContent?: boolean;
  
  /**
   * Length of context window around search matches (in characters)
   * Creates snippets with this many characters before and after the match
   * Required parameter for all searches
   */
  snippetLength: number;
  
  /**
   * Force semantic search even if traditional might be better (default: auto-detect)
   */
  forceSemanticSearch?: boolean;
  
  /**
   * Additional metadata filters (alternative to query syntax)
   */
  metadataFilters?: {
    /**
     * Tags to filter by (AND logic if multiple)
     */
    tags?: string[];
    
    /**
     * Properties to filter by (field: value pairs)
     */
    properties?: Record<string, any>;
    
    /**
     * Logic operator for combining filters ('AND' | 'OR')
     */
    operator?: 'AND' | 'OR';
  };
}

/**
 * Search result item for any category
 */
export interface UniversalSearchResultItem {
  /**
   * Item identifier (file path, workspace id, etc.)
   */
  id: string;
  
  /**
   * Display title/name
   */
  title: string;
  
  /**
   * Content snippet or description
   */
  snippet?: string;
  
  /**
   * Search relevance score (0-1)
   */
  score: number;
  
  /**
   * Search method used for this result
   */
  searchMethod: 'semantic' | 'fuzzy' | 'exact' | 'hybrid';
  
  /**
   * Category-specific metadata
   */
  metadata?: Record<string, any>;
  
  /**
   * File metadata (tags, properties) if applicable
   */
  fileMetadata?: {
    tags?: string[];
    properties?: Record<string, any>;
    aliases?: string[];
  };
  
  /**
   * Full content (if includeContent is true)
   */
  content?: string;
}

/**
 * Search results for a specific category
 */
export interface SearchResultCategory {
  /**
   * Total number of results found in this category
   */
  count: number;
  
  /**
   * Top results (up to limit)
   */
  results: UniversalSearchResultItem[];
  
  /**
   * Whether more results are available beyond the limit
   */
  hasMore: boolean;
  
  /**
   * Primary search method used for this category
   */
  searchMethod: 'semantic' | 'fuzzy' | 'exact' | 'hybrid';
  
  /**
   * Whether semantic search was available for this category
   */
  semanticAvailable: boolean;
}

/**
 * Universal search results organized by category
 */
export interface UniversalSearchResult extends CommonResult {
  /**
   * Original search query
   */
  query: string;
  
  /**
   * Total number of results across all categories
   */
  totalResults: number;
  
  /**
   * Search execution time in milliseconds
   */
  executionTime: number;
  
  /**
   * Results organized by category
   */
  categories: {
    files?: SearchResultCategory;
    folders?: SearchResultCategory;
    content?: SearchResultCategory;
    workspaces?: SearchResultCategory;
    sessions?: SearchResultCategory;
    states?: SearchResultCategory;
    memory_traces?: SearchResultCategory;
    tags?: SearchResultCategory;
    properties?: SearchResultCategory;
  };
  
  /**
   * Overall search strategy information
   */
  searchStrategy: {
    semanticAvailable: boolean;
    categoriesSearched: CategoryType[];
    categoriesExcluded: CategoryType[];
    fallbacksUsed: CategoryType[];
    metadataFiltersApplied?: {
      tags?: string[];
      properties?: Record<string, any>;
      operator?: 'AND' | 'OR';
      filesFilteredByMetadata?: number;
    };
  };
  
  /**
   * Suggested prompt for using ContentManager's batchContent mode to read the most relevant files
   * This encourages deeper exploration of search results by reading full file contents
   */
  contextPrompt?: string;
}

/**
 * Batch universal search parameters
 */
export interface BatchUniversalSearchParams extends CommonParameters {
  /**
   * Array of universal search queries to execute
   */
  searches: UniversalSearchParams[];
  
  /**
   * Whether to merge all results into a single response
   */
  mergeResults?: boolean;
  
  /**
   * Maximum concurrent searches to execute (default: 5)
   */
  maxConcurrency?: number;
}

/**
 * Batch universal search results
 */
export interface BatchUniversalSearchResult extends CommonResult {
  /**
   * Individual search results (if mergeResults is false)
   */
  searches?: UniversalSearchResult[];
  
  /**
   * Merged search results (if mergeResults is true)
   */
  merged?: {
    totalQueries: number;
    totalResults: number;
    combinedCategories: {
      files?: SearchResultCategory;
      folders?: SearchResultCategory;
      content?: SearchResultCategory;
      workspaces?: SearchResultCategory;
      sessions?: SearchResultCategory;
      states?: SearchResultCategory;
      memory_traces?: SearchResultCategory;
      tags?: SearchResultCategory;
      properties?: SearchResultCategory;
    };
  };
  
  /**
   * Execution statistics
   */
  stats: {
    totalExecutionTimeMS: number;
    queriesExecuted: number;
    queriesFailed: number;
    avgExecutionTimeMS: number;
  };
}


```

## agents/storageManager/storageManager.ts

```typescript
import { App, TFile, TFolder } from 'obsidian';
import { BaseAgent } from '../baseAgent';
import {
  ListTool,
  CreateFolderTool,
  MoveTool,
  CopyTool,
  ArchiveTool,
  OpenTool
} from './tools';
import { sanitizeVaultName } from '../../utils/vaultUtils';

/**
 * Agent for file system operations in storage
 * Environment-agnostic: works with Obsidian vault, filesystem, cloud storage, etc.
 */
export class StorageManagerAgent extends BaseAgent {
  private app: App;
  private vaultName: string;
  private isGettingDescription = false;

  /**
   * Create a new StorageManagerAgent
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'storageManager',
      'File system operations for storage',
      '1.0.0'
    );

    this.app = app;
    this.vaultName = sanitizeVaultName(app.vault.getName());

    // Register simplified CRUA tools
    this.registerTool(new ListTool(app));
    this.registerTool(new CreateFolderTool(app));
    this.registerTool(new MoveTool(app));
    this.registerTool(new CopyTool(app));
    this.registerTool(new ArchiveTool(app));
    this.registerTool(new OpenTool(app));
  }

  /**
   * Dynamic description that includes current storage structure
   */
  get description(): string {
    const baseDescription = 'File system operations for storage';

    // Prevent infinite recursion
    if (this.isGettingDescription) {
      return `[${this.vaultName}] ${baseDescription}`;
    }

    this.isGettingDescription = true;
    try {
      const storageContext = this.getStorageStructureSummary();
      return `[${this.vaultName}] ${baseDescription}\n\n${storageContext}`;
    } finally {
      this.isGettingDescription = false;
    }
  }

  /**
   * Get a summary of the storage structure
   * @returns Formatted string with storage structure information
   * @private
   */
  private getStorageStructureSummary(): string {
    try {
      const markdownFiles = this.app.vault.getMarkdownFiles();
      const rootFolder = this.app.vault.getRoot();

      // Get root folders (folders directly in storage root)
      const rootFolders = rootFolder.children
        .filter(child => child instanceof TFolder)
        .map(folder => folder.name)
        .sort(); // Sort alphabetically for consistent display

      // Count files in each root folder
      const folderStructure: string[] = [];

      for (const folderName of rootFolders) {
        const filesInFolder = markdownFiles.filter(file =>
          file.path.startsWith(folderName + '/')
        ).length;
        folderStructure.push(`   â””â”€â”€ ${folderName}/ (${filesInFolder} files)`);
      }

      // Count files in root
      const rootFiles = markdownFiles.filter(file =>
        !file.path.includes('/')
      ).length;

      const summary = [
        `ðŸ“ Storage Structure: ${markdownFiles.length} files, ${rootFolders.length} root folders`
      ];

      if (rootFiles > 0) {
        summary.push(`   â””â”€â”€ / (${rootFiles} files in root)`);
      }

      summary.push(...folderStructure);

      return summary.join('\n');
    } catch (error) {
      return `ðŸ“ Storage Structure: Unable to load storage information (${error})`;
    }
  }
}

```

## agents/storageManager/tools/archive.ts

```typescript
import { App, TFile, TFolder } from 'obsidian';
import { BaseTool } from '../../baseTool';
import { ArchiveParams, ArchiveResult } from '../types';
import { FileOperations } from '../utils/FileOperations';
import { createErrorMessage } from '../../../utils/errorUtils';
import { normalizePath } from '../../../utils/pathUtils';

/**
 * Location: src/agents/storageManager/tools/archive.ts
 * Purpose: Safely archive files and folders with timestamp preservation
 * Relationships: Uses FileOperations for move logic
 */

/**
 * Tool for archiving files and folders (moves to .archive/ with timestamp)
 */
export class ArchiveTool extends BaseTool<ArchiveParams, ArchiveResult> {
  private app: App;

  /**
   * Create a new ArchiveTool
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'archive',
      'Archive',
      'Safely archive a file or folder (moves to .archive/ with timestamp)',
      '1.0.0'
    );

    this.app = app;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise that resolves with the result of archiving
   */
  async execute(params: ArchiveParams): Promise<ArchiveResult> {
    const { path } = params;

    try {
      // Normalize path
      const normalizedPath = normalizePath(path);

      // Check if source exists and determine type
      const sourceItem = this.app.vault.getAbstractFileByPath(normalizedPath);
      if (!sourceItem) {
        return this.prepareResult(
          false,
          undefined,
          `File or folder not found: "${path}". Use list to see available items, or searchContent to find files by name.`
        );
      }

      // Generate timestamp for archive folder
      const now = new Date();
      const timestamp = this.formatTimestamp(now);

      // Construct archive path: .archive/[YYYY-MM-DD_HH-mm-ss]/[original-path]
      const archivePath = `.archive/${timestamp}/${normalizedPath}`;

      // Ensure .archive directory exists
      await FileOperations.ensureFolder(this.app, '.archive');

      // Move item to archive (auto-detects file vs folder)
      if (sourceItem instanceof TFile) {
        await FileOperations.moveNote(this.app, normalizedPath, archivePath, false);
      } else if (sourceItem instanceof TFolder) {
        await FileOperations.moveFolder(this.app, normalizedPath, archivePath, false);
      } else {
        return this.prepareResult(false, undefined, `Unknown item type at path: ${path}`);
      }

      // Success - LLM already knows the path it passed
      return this.prepareResult(true);
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Failed to archive: ', error));
    }
  }

  /**
   * Format timestamp for archive folder name
   * @param date Date to format
   * @returns Formatted timestamp string (YYYY-MM-DD_HH-mm-ss)
   */
  private formatTimestamp(date: Date): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');

    return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
  }

  /**
   * Get the JSON schema for the tool's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const toolSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to file or folder to archive'
        }
      },
      required: ['path'],
      description: 'Archive a file or folder by moving it to .archive/[YYYY-MM-DD_HH-mm-ss]/[original-path]. Auto-detects file vs folder. Creates .archive/ if needed.'
    };

    // Merge with common schema (sessionId and context)
    return this.getMergedSchema(toolSchema);
  }

  getResultSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean', description: 'Whether the operation succeeded' },
        error: { type: 'string', description: 'Error message if failed (includes recovery guidance)' }
      },
      required: ['success']
    };
  }
}

```

## agents/storageManager/tools/baseDirectory.ts

```typescript
import { App, TFolder } from 'obsidian';
import { BaseTool } from '../../baseTool';
import { CommonParameters, CommonResult } from '../../../types';

/**
 * Base class for directory listing operations
 * Provides common functionality for tools that work with directories
 */
export abstract class BaseDirectoryTool<T extends CommonParameters, R extends CommonResult> extends BaseTool<T, R> {
  protected app: App;

  constructor(slug: string, name: string, description: string, version: string, app: App) {
    super(slug, name, description, version);
    this.app = app;
  }

  /**
   * Normalize directory path by removing leading slash and handling special cases for root
   * @param path Path to normalize
   * @returns Normalized path (empty string for root)
   */
  protected normalizeDirectoryPath(path: string): string {
    // Handle special cases for root directory
    if (!path || path === '/' || path === '.') {
      return '';
    }
    // Remove leading slash if present
    return path.startsWith('/') ? path.slice(1) : path;
  }

  /**
   * Get a folder from the vault by path
   * @param path Directory path (normalized or not)
   * @returns TFolder instance
   * @throws Error if folder not found
   */
  protected async getFolder(path: string): Promise<TFolder> {
    const normalizedPath = this.normalizeDirectoryPath(path);

    // Handle root directory case
    if (normalizedPath === '') {
      return this.app.vault.getRoot();
    }

    // Get folder by path - use getAbstractFileByPath for folders
    const folder = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (!folder || !(folder instanceof TFolder)) {
      // Provide recovery guidance
      throw new Error(`Folder not found: "${normalizedPath}". Try storageManager.list with path "" (root) to see available folders, or use searchManager.searchDirectory to find folders by name.`);
    }

    return folder;
  }

  /**
   * Get standardized directory path schema for JSON schema
   * @returns Schema object for directory path parameter
   */
  protected getDirectoryPathSchema(): any {
    return {
      type: 'string',
      description: 'Directory path (required). Use empty string (""), "/" or "." for root directory',
      default: ''
    };
  }

  /**
   * Generate helpful message for root directory operations
   * @param normalizedPath The normalized path (empty string indicates root)
   * @param operationType Type of operation being performed
   * @returns Helpful message or undefined
   */
  protected getRootDirectoryMessage(normalizedPath: string, operationType: string): string | undefined {
    if (normalizedPath === '') {
      return `${operationType} in root directory only. This may not include all items in the vault - many may be organized in subfolders. Use storageManager.list with depth to explore the full vault structure.`;
    }
    return undefined;
  }
}

```

## agents/storageManager/tools/copy.ts

```typescript
import { App } from 'obsidian';
import { BaseTool } from '../../baseTool';
import { CopyParams, CopyResult } from '../types';
import { FileOperations } from '../utils/FileOperations';
import { createErrorMessage } from '../../../utils/errorUtils';

/**
 * Location: src/agents/storageManager/tools/copy.ts
 * Purpose: Duplicate a file to a new location
 * Relationships: Uses FileOperations for copy logic
 */

/**
 * Tool for copying/duplicating files
 */
export class CopyTool extends BaseTool<CopyParams, CopyResult> {
  private app: App;

  /**
   * Create a new CopyTool
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'copy',
      'Copy',
      'Duplicate a file',
      '1.0.0'
    );

    this.app = app;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise that resolves with the result of copying the file
   */
  async execute(params: CopyParams): Promise<CopyResult> {
    try {
      if (!params.path) {
        return this.prepareResult(false, undefined, 'Source path is required');
      }

      if (!params.newPath) {
        return this.prepareResult(false, undefined, 'Destination path is required');
      }

      await FileOperations.duplicateNote(
        this.app,
        params.path,
        params.newPath,
        params.overwrite || false,
        false // autoIncrement not supported in simplified API
      );

      // Success - LLM already knows the paths it passed
      return this.prepareResult(true);
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Failed to copy file: ', error));
    }
  }

  /**
   * Get the JSON schema for the tool's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const toolSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Source file path'
        },
        newPath: {
          type: 'string',
          description: 'Destination path for the copy'
        },
        overwrite: {
          type: 'boolean',
          description: 'Overwrite if destination exists (default: false)',
          default: false
        }
      },
      required: ['path', 'newPath']
    };

    // Merge with common schema (workspace context)
    return this.getMergedSchema(toolSchema);
  }

  getResultSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean', description: 'Whether the operation succeeded' },
        error: { type: 'string', description: 'Error message if failed (includes recovery guidance)' }
      },
      required: ['success']
    };
  }
}

```

## agents/storageManager/tools/createFolder.ts

```typescript
import { App } from 'obsidian';
import { BaseTool } from '../../baseTool';
import { CreateFolderParams, CreateFolderResult } from '../types';
import { FileOperations } from '../utils/FileOperations';
import { createErrorMessage } from '../../../utils/errorUtils';

/**
 * Tool to create a new folder
 */
export class CreateFolderTool extends BaseTool<CreateFolderParams, CreateFolderResult> {
  private app: App;

  /**
   * Create a new CreateFolderTool
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'createFolder',
      'Create Folder',
      'Create a new folder in the vault',
      '1.0.0'
    );
    this.app = app;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise resolving to the result
   */
  async execute(params: CreateFolderParams): Promise<CreateFolderResult> {
    try {
      if (!params.path) {
        return this.prepareResult(false, undefined, 'Path is required');
      }

      if (typeof FileOperations?.createFolder === 'function') {
        await FileOperations.createFolder(this.app, params.path);
      } else {
        const existingFolder = this.app.vault.getAbstractFileByPath(params.path);
        if (!existingFolder) {
          await this.app.vault.createFolder(params.path);
        }
      }

      // Success - LLM already knows the path it passed
      return this.prepareResult(true);
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Failed to create folder: ', error));
    }
  }

  /**
   * Get the parameter schema
   */
  getParameterSchema(): Record<string, any> {
    // Create the tool-specific schema
    const toolSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path of the folder to create (REQUIRED)'
        }
      },
      required: ['path']
    };

    // Merge with common schema (workspace context)
    return this.getMergedSchema(toolSchema);
  }

  getResultSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean', description: 'Whether the operation succeeded' },
        error: { type: 'string', description: 'Error message if failed (includes recovery guidance)' }
      },
      required: ['success']
    };
  }
}

```

## agents/storageManager/tools/index.ts

```typescript
// Simplified tools following CRUA pattern
export * from './list';
export * from './createFolder';
export * from './move';
export * from './copy';
export * from './archive';
export * from './open';

```

## agents/storageManager/tools/list.ts

```typescript
import { App, TFile, TFolder } from 'obsidian';
import { BaseDirectoryTool } from './baseDirectory';
import { ListParams, ListResult } from '../types';
import { createErrorMessage } from '../../../utils/errorUtils';
import { filterByName, FILTER_DESCRIPTION } from '../../../utils/filterUtils';

/**
 * Location: src/agents/storageManager/tools/list.ts
 * Purpose: List files and folders in a directory with optional filtering
 * Relationships: Uses BaseDirectoryTool for common directory operations
 */

/**
 * Tool to list directory contents
 */
export class ListTool extends BaseDirectoryTool<ListParams, ListResult> {

  /**
   * Create a new ListTool
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'list',
      'List',
      'List contents of a directory',
      '1.0.0',
      app
    );
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise resolving to the result
   */
  async execute(params: ListParams): Promise<ListResult> {
    try {
      // Default to vault root if no path provided
      const path = params.path ?? '';

      // Get the folder using base class method
      const parentFolder = await this.getFolder(path);
      const normalizedPath = this.normalizeDirectoryPath(path);

      // Get contents (depth 0 = current folder only)
      const allFiles = this.getFilesRecursively(parentFolder, 0);
      const allFolders = this.getFoldersRecursively(parentFolder, 0);

      // Apply filter if provided
      let filteredFiles = allFiles;
      let filteredFolders = allFolders;

      if (params.filter) {
        filteredFiles = filterByName(allFiles, params.filter);
        filteredFolders = filterByName(allFolders, params.filter);
      }

      // Prepare result data
      const result: any = {};

      // Map files to required format
      const fileData = filteredFiles.map(file => ({
        name: file.name,
        path: file.path,
        size: file.stat.size,
        created: file.stat.ctime,
        modified: file.stat.mtime
      }));

      // Sort files by modified date (newest first)
      fileData.sort((a, b) => b.modified - a.modified);
      result.files = fileData;

      // Map folders to required format
      const folderData = filteredFolders.map(folder => ({
        name: folder.name,
        path: folder.path
      }));

      // Sort folders alphabetically
      folderData.sort((a, b) => a.name.localeCompare(b.name));
      result.folders = folderData;

      // Add summary
      result.summary = {
        fileCount: filteredFiles.length,
        folderCount: filteredFolders.length,
        totalItems: filteredFiles.length + filteredFolders.length
      };

      // Generate helpful message
      const message = this.getRootDirectoryMessage(normalizedPath, 'Listing directory contents');

      return this.prepareResult(
        true,
        result,
        message
      );

    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Failed to list directory contents: ', error));
    }
  }

  /**
   * Recursively get files up to specified depth
   * @param folder The folder to start from
   * @param depth The maximum depth to traverse (0 = current folder only)
   * @returns Array of files
   */
  private getFilesRecursively(folder: TFolder, depth: number): TFile[] {
    const result: TFile[] = [];

    // Get direct children that are files
    const childFiles = (folder.children || []).filter(child => child instanceof TFile) as TFile[];
    result.push(...childFiles);

    // If depth > 0, recursively get files from subfolders
    if (depth > 0) {
      const childFolders = (folder.children || []).filter(child => child instanceof TFolder) as TFolder[];
      for (const childFolder of childFolders) {
        const subFiles = this.getFilesRecursively(childFolder, depth - 1);
        result.push(...subFiles);
      }
    }

    return result;
  }

  /**
   * Recursively get folders up to specified depth
   * @param folder The folder to start from
   * @param depth The maximum depth to traverse (0 = current folder only)
   * @returns Array of folders
   */
  private getFoldersRecursively(folder: TFolder, depth: number): TFolder[] {
    const result: TFolder[] = [];

    // Get direct children that are folders
    const childFolders = (folder.children || []).filter(child => child instanceof TFolder) as TFolder[];
    result.push(...childFolders);

    // If depth > 0, recursively get subfolders
    if (depth > 0) {
      for (const childFolder of childFolders) {
        const subfolders = this.getFoldersRecursively(childFolder, depth - 1);
        result.push(...subfolders);
      }
    }

    return result;
  }

  /**
   * Get the parameter schema
   */
  getParameterSchema(): any {
    const toolSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Directory path (optional). Use empty string (""), "/" or "." for vault root. Defaults to vault root.',
          default: ''
        },
        filter: {
          type: 'string',
          description: FILTER_DESCRIPTION
        }
      },
      required: []
    };

    return this.getMergedSchema(toolSchema);
  }

  /**
   * Get the result schema
   */
  getResultSchema(): any {
    const baseSchema = super.getResultSchema();

    // Extend the base schema to include our specific data
    baseSchema.properties.data = {
      type: 'object',
      properties: {
        files: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              name: { type: 'string' },
              path: { type: 'string' },
              size: { type: 'number' },
              created: { type: 'number' },
              modified: { type: 'number' }
            }
          }
        },
        folders: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              name: { type: 'string' },
              path: { type: 'string' }
            }
          }
        },
        summary: {
          type: 'object',
          properties: {
            fileCount: { type: 'number' },
            folderCount: { type: 'number' },
            totalItems: { type: 'number' }
          }
        }
      }
    };

    return baseSchema;
  }
}

```

## agents/storageManager/tools/move.ts

```typescript
import { App, TFile, TFolder } from 'obsidian';
import { BaseTool } from '../../baseTool';
import { MoveParams, MoveResult } from '../types';
import { FileOperations } from '../utils/FileOperations';
import { createErrorMessage } from '../../../utils/errorUtils';
import { normalizePath } from '../../../utils/pathUtils';

/**
 * Location: src/agents/storageManager/tools/move.ts
 * Purpose: Move or rename files and folders (auto-detects type)
 * Relationships: Uses FileOperations for move logic
 */

/**
 * Tool for moving or renaming files and folders
 */
export class MoveTool extends BaseTool<MoveParams, MoveResult> {
  private app: App;

  /**
   * Create a new MoveTool
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'move',
      'Move',
      'Move or rename a file or folder',
      '1.0.0'
    );

    this.app = app;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise that resolves with the result of moving the file or folder
   */
  async execute(params: MoveParams): Promise<MoveResult> {
    const { path, newPath, overwrite } = params;

    try {
      // Normalize paths
      const normalizedPath = normalizePath(path);

      // Check if source exists and determine type
      const sourceItem = this.app.vault.getAbstractFileByPath(normalizedPath);
      if (!sourceItem) {
        return this.prepareResult(
          false,
          undefined,
          `File or folder not found: "${path}". Use list to see available items, or searchContent to find files by name.`
        );
      }

      // Auto-detect and move accordingly
      if (sourceItem instanceof TFile) {
        await FileOperations.moveNote(this.app, path, newPath, overwrite);
      } else if (sourceItem instanceof TFolder) {
        await FileOperations.moveFolder(this.app, path, newPath, overwrite);
      } else {
        return this.prepareResult(false, undefined, `Unknown item type at path: ${path}`);
      }

      // Success - LLM already knows the paths it passed
      return this.prepareResult(true);
    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Failed to move: ', error));
    }
  }

  /**
   * Get the JSON schema for the tool's parameters
   * @returns JSON schema object
   */
  getParameterSchema(): any {
    const toolSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Source path (file or folder)'
        },
        newPath: {
          type: 'string',
          description: 'Destination path'
        },
        overwrite: {
          type: 'boolean',
          description: 'Overwrite if destination exists (default: false)',
          default: false
        }
      },
      required: ['path', 'newPath'],
      description: 'Move or rename a file or folder (auto-detects type)'
    };

    // Merge with common schema (sessionId and context)
    return this.getMergedSchema(toolSchema);
  }

  getResultSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean', description: 'Whether the operation succeeded' },
        error: { type: 'string', description: 'Error message if failed (includes recovery guidance)' }
      },
      required: ['success']
    };
  }
}

```

## agents/storageManager/tools/open.ts

```typescript
import { App, TFile, WorkspaceLeaf } from 'obsidian';
import { BaseTool } from '../../baseTool';
import { OpenParams, OpenResult } from '../types';
import { createErrorMessage } from '../../../utils/errorUtils';
import { smartNormalizePath } from '../../../utils/pathUtils';

/**
 * Location: src/agents/storageManager/tools/open.ts
 * Purpose: Open a file in the Obsidian editor
 * Relationships: Uses Obsidian workspace API for file opening
 */

/**
 * Tool to open a file in the vault
 */
export class OpenTool extends BaseTool<OpenParams, OpenResult> {
  private app: App;

  /**
   * Create a new OpenTool
   * @param app Obsidian app instance
   */
  constructor(app: App) {
    super(
      'open',
      'Open',
      'Open a file in the editor',
      '1.0.0'
    );
    this.app = app;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise resolving to the result
   */
  async execute(params: OpenParams): Promise<OpenResult> {
    try {
      // Validate parameters
      if (!params.path) {
        return this.prepareResult(false, undefined, 'Path is required');
      }

      // Apply smart normalization for note operations (includes .md extension handling)
      const normalizedPath = smartNormalizePath(params.path, false, 'NOTE');

      // Get the file
      const file = this.app.vault.getAbstractFileByPath(normalizedPath);
      if (!file || !(file instanceof TFile)) {
        return this.prepareResult(
          false,
          undefined,
          `File not found: "${normalizedPath}". Use list to see available files, or searchContent to find files by name.`
        );
      }

      // Determine how to open the file
      const mode = params.mode || 'current';
      let leaf: WorkspaceLeaf;

      switch (mode) {
        case 'tab':
          leaf = this.app.workspace.getLeaf('tab');
          break;
        case 'split':
          leaf = this.app.workspace.getLeaf('split');
          break;
        case 'window':
          leaf = this.app.workspace.getLeaf('window');
          break;
        case 'current':
        default:
          leaf = this.app.workspace.getLeaf(false);
          break;
      }

      // Open the file
      await leaf.openFile(file);

      // Focus if requested
      if (params.focus !== false) {
        this.app.workspace.setActiveLeaf(leaf, { focus: true });
      }

      return this.prepareResult(true, {
          path: file.path,
          opened: true,
          mode: mode
        });

    } catch (error) {
      return this.prepareResult(false, undefined, createErrorMessage('Failed to open file: ', error));
    }
  }

  /**
   * Get the parameter schema
   */
  getParameterSchema(): any {
    const toolSchema = {
      type: 'object',
      properties: {
        path: {
          type: 'string',
          description: 'Path to the file to open'
        },
        mode: {
          type: 'string',
          enum: ['tab', 'split', 'window', 'current'],
          description: 'Where to open the file (tab, split, window, or current)',
          default: 'current'
        },
        focus: {
          type: 'boolean',
          description: 'Whether to focus the opened file',
          default: true
        }
      },
      required: ['path']
    };

    return this.getMergedSchema(toolSchema);
  }

  /**
   * Get the result schema
   */
  getResultSchema(): any {
    const baseSchema = super.getResultSchema();

    // Extend the base schema to include our specific data
    baseSchema.properties.data = {
      type: 'object',
      properties: {
        path: { type: 'string' },
        opened: { type: 'boolean' },
        mode: { type: 'string' }
      }
    };

    return baseSchema;
  }
}

```

## agents/storageManager/types.ts

```typescript
import { CommonParameters } from '../../types';

/**
 * Arguments for listing directory contents
 */
export interface ListParams extends CommonParameters {
  /**
   * Directory path (optional, defaults to vault root)
   */
  path?: string;

  /**
   * Optional filter pattern
   */
  filter?: string;
}

/**
 * Result of listing directory contents
 */
export interface ListResult {
  /**
   * Whether the operation was successful
   */
  success: boolean;

  /**
   * Error message if listing failed
   */
  error?: string;

  /**
   * Result data
   */
  data?: {
    files: Array<{
      name: string;
      path: string;
      size: number;
      created: number;
      modified: number;
    }>;
    folders: Array<{
      name: string;
      path: string;
    }>;
    summary: {
      fileCount: number;
      folderCount: number;
      totalItems: number;
    };
  };
}

/**
 * Arguments for creating a note
 */
export interface CreateNoteParams extends CommonParameters {
  /**
   * Path to the note
   */
  path: string;

  /**
   * Content of the note
   */
  content: string;

  /**
   * Whether to overwrite if the note already exists
   */
  overwrite?: boolean;
}

/**
 * Result of creating a note
 */
export interface CreateNoteResult {
  /**
   * Path to the note
   */
  path: string;

  /**
   * Whether the note was created successfully
   */
  success: boolean;

  /**
   * Error message if creation failed
   */
  error?: string;

  /**
   * Whether the note already existed
   */
  existed?: boolean;
}

/**
 * Arguments for creating a folder
 */
export interface CreateFolderParams extends CommonParameters {
  /**
   * Path to the folder
   */
  path: string;
}

/**
 * Result of creating a folder
 */
export interface CreateFolderResult {
  /**
   * Path to the folder
   */
  path: string;
  
  /**
   * Whether the folder was created successfully
   */
  success: boolean;
  
  /**
   * Error message if creation failed
   */
  error?: string;
  
  /**
   * Whether the folder already existed
   */
  existed?: boolean;
}

/**
 * Arguments for deleting a note
 */
export interface DeleteNoteParams extends CommonParameters {
  /**
   * Path to the note
   */
  path: string;
}

/**
 * Result of deleting a note
 */
export interface DeleteNoteResult {
  /**
   * Path to the note
   */
  path: string;
  
  /**
   * Whether the note was deleted successfully
   */
  success: boolean;
  
  /**
   * Error message if deletion failed
   */
  error?: string;
}

/**
 * Arguments for deleting a folder
 */
export interface DeleteFolderParams extends CommonParameters {
  /**
   * Path to the folder
   */
  path: string;
  
  /**
   * Whether to delete recursively
   */
  recursive?: boolean;
}

/**
 * Result of deleting a folder
 */
export interface DeleteFolderResult {
  /**
   * Path to the folder
   */
  path: string;
  
  /**
   * Whether the folder was deleted successfully
   */
  success: boolean;
  
  /**
   * Error message if deletion failed
   */
  error?: string;
}

/**
 * Arguments for moving a note
 */
export interface MoveNoteParams extends CommonParameters {
  /**
   * Path to the note
   */
  path: string;
  
  /**
   * New path for the note
   */
  newPath: string;
  
  /**
   * Whether to overwrite if a note already exists at the new path
   */
  overwrite?: boolean;
}

/**
 * Result of moving a note
 */
export interface MoveNoteResult {
  /**
   * Original path of the note
   */
  path: string;
  
  /**
   * New path of the note
   */
  newPath: string;
  
  /**
   * Whether the note was moved successfully
   */
  success: boolean;
  
  /**
   * Error message if move failed
   */
  error?: string;
}

/**
 * Arguments for moving a folder
 */
export interface MoveFolderParams extends CommonParameters {
  /**
   * Path to the folder
   */
  path: string;
  
  /**
   * New path for the folder
   */
  newPath: string;
  
  /**
   * Whether to overwrite if a folder already exists at the new path
   */
  overwrite?: boolean;
}

/**
 * Result of moving a folder
 */
export interface MoveFolderResult {
  /**
   * Original path of the folder
   */
  path: string;
  
  /**
   * New path of the folder
   */
  newPath: string;
  
  /**
   * Whether the folder was moved successfully
   */
  success: boolean;
  
  /**
   * Error message if move failed
   */
  error?: string;
}

/**
 * Arguments for duplicating a note
 */
export interface DuplicateNoteParams extends CommonParameters {
  /**
   * Path to the source note to duplicate
   */
  sourcePath: string;
  
  /**
   * Path for the duplicate note
   */
  targetPath: string;
  
  /**
   * Whether to overwrite if a note already exists at the target path
   */
  overwrite?: boolean;
  
  /**
   * Whether to auto-increment the filename if target exists (e.g., "note copy.md", "note copy 2.md")
   * This takes precedence over overwrite when both are true
   */
  autoIncrement?: boolean;
}

/**
 * Result of duplicating a note
 */
export interface DuplicateNoteResult {
  /**
   * Original path of the source note
   */
  sourcePath: string;
  
  /**
   * Final path of the duplicated note
   */
  targetPath: string;
  
  /**
   * Whether the note was duplicated successfully
   */
  success: boolean;
  
  /**
   * Error message if duplication failed
   */
  error?: string;
  
  /**
   * Whether the target path was auto-incremented due to conflicts
   */
  wasAutoIncremented?: boolean;
  
  /**
   * Whether an existing file was overwritten
   */
  wasOverwritten?: boolean;
}
/**
 * Arguments for moving a file or folder
 */
export interface MoveParams extends CommonParameters {
  /**
   * Source path (file or folder)
   */
  path: string;

  /**
   * Destination path
   */
  newPath: string;

  /**
   * Whether to overwrite if destination exists
   */
  overwrite?: boolean;
}

/**
 * Result of moving a file or folder
 */
export interface MoveResult {
  /**
   * Whether the operation was successful
   */
  success: boolean;

  /**
   * Error message if move failed
   */
  error?: string;
}

/**
 * Arguments for copying a file
 */
export interface CopyParams extends CommonParameters {
  /**
   * Source file path
   */
  path: string;

  /**
   * Destination path
   */
  newPath: string;

  /**
   * Whether to overwrite if destination exists
   */
  overwrite?: boolean;
}

/**
 * Result of copying a file
 */
export interface CopyResult {
  /**
   * Whether the operation was successful
   */
  success: boolean;

  /**
   * Error message if copy failed
   */
  error?: string;
}

/**
 * Arguments for archiving a file or folder
 */
export interface ArchiveParams extends CommonParameters {
  /**
   * Path to file or folder to archive
   */
  path: string;
}

/**
 * Result of archiving a file or folder
 */
export interface ArchiveResult {
  /**
   * Whether the operation was successful
   */
  success: boolean;

  /**
   * Error message if archive failed
   */
  error?: string;
}

/**
 * Arguments for opening a file
 */
export interface OpenParams extends CommonParameters {
  /**
   * Path to the file to open
   */
  path: string;

  /**
   * Where to open the file
   * - 'tab': Open in new tab
   * - 'split': Open in horizontal split
   * - 'window': Open in new window
   * - 'current': Open in current tab (default)
   */
  mode?: 'tab' | 'split' | 'window' | 'current';

  /**
   * Whether to focus the opened file
   */
  focus?: boolean;
}

/**
 * Result of opening a file
 */
export interface OpenResult {
  /**
   * Path to the opened file
   */
  path: string;

  /**
   * Whether the file was opened successfully
   */
  success: boolean;

  /**
   * Error message if opening failed
   */
  error?: string;

  /**
   * Whether the file was opened in the specified mode
   */
  opened: boolean;

  /**
   * The actual mode used to open the file
   */
  mode: 'tab' | 'split' | 'window' | 'current';
}

/**
 * DEPRECATED - Use OpenParams instead
 */
export interface OpenNoteParams extends CommonParameters {
  /**
   * Path to the note to open
   */
  path: string;

  /**
   * Where to open the note
   * - 'tab': Open in new tab
   * - 'split': Open in horizontal split
   * - 'window': Open in new window
   * - 'current': Open in current tab (default)
   */
  mode?: 'tab' | 'split' | 'window' | 'current';

  /**
   * Whether to focus the opened note
   */
  focus?: boolean;
}

/**
 * DEPRECATED - Use OpenResult instead
 */
export interface OpenNoteResult {
  /**
   * Path to the opened note
   */
  path: string;

  /**
   * Whether the note was opened successfully
   */
  success: boolean;

  /**
   * Error message if opening failed
   */
  error?: string;

  /**
   * Whether the note was opened in the specified mode
   */
  opened: boolean;

  /**
   * The actual mode used to open the note
   */
  mode: 'tab' | 'split' | 'window' | 'current';
}

/**
 * Arguments for listing directory contents
 */
export interface ListDirectoryParams extends CommonParameters {
  /**
   * Directory path to list contents from (required)
   * Use empty string (""), "/" or "." for root directory
   */
  path: string;
  
  /**
   * Optional filter pattern for files and folders
   */
  filter?: string;
  
  /**
   * Recursive depth for directory traversal (optional)
   * 0 = only current directory (default)
   * 1 = current directory + immediate subdirectories
   * 2 = current directory + subdirectories + their subdirectories
   * etc.
   */
  depth?: number;
  
  /**
   * Include files in results (default: true). Set false for folders only.
   */
  includeFiles?: boolean;
}

/**
 * Result of listing directory contents
 */
export interface ListDirectoryResult {
  /**
   * Directory path that was listed
   */
  path: string;
  
  /**
   * List of files found
   */
  files: string[];
  
  /**
   * List of folders found
   */
  folders: string[];
  
  /**
   * Whether the operation was successful
   */
  success: boolean;
  
  /**
   * Error message if listing failed
   */
  error?: string;
  
  /**
   * Total number of items found
   */
  totalCount: number;
}

```

## agents/storageManager/utils/FileOperations.ts

```typescript
import { App, TFile, TFolder } from 'obsidian';
import { smartNormalizePath, normalizePath } from '../../../utils/pathUtils';

/**
 * Utility class for file operations
 */
export class FileOperations {
  /**
   * Create a note
   * @param app Obsidian app instance
   * @param path Path to the note
   * @param content Content of the note
   * @param overwrite Whether to overwrite if the note already exists
   * @returns Promise that resolves with the created file and whether it already existed
   * @throws Error if creation fails
   */
  static async createNote(
    app: App,
    path: string,
    content: string,
    overwrite = false
  ): Promise<{ file: TFile; existed: boolean }> {
    // Apply smart normalization for note operations (includes .md extension handling)
    const normalizedPath = smartNormalizePath(path, false, 'NOTE');
    
    // Check if the file already exists
    const existingFile = app.vault.getAbstractFileByPath(normalizedPath);
    if (existingFile) {
      if (existingFile instanceof TFile) {
        if (overwrite) {
          // Overwrite the existing file
          await app.vault.modify(existingFile, content);
          return { file: existingFile, existed: true };
        } else {
          throw new Error(`File already exists: ${path}`);
        }
      } else {
        throw new Error(`Path exists but is not a file: ${path}`);
      }
    }
    
    // Ensure the parent folder exists
    const folderPath = normalizedPath.substring(0, normalizedPath.lastIndexOf('/'));
    if (folderPath) {
      await FileOperations.ensureFolder(app, folderPath);
    }
    
    // Create the file
    const file = await app.vault.create(normalizedPath, content);
    return { file, existed: false };
  }
  
  /**
   * Create a folder
   * @param app Obsidian app instance
   * @param path Path to the folder
   * @returns Promise that resolves with whether the folder already existed
   * @throws Error if creation fails
   */
  static async createFolder(app: App, path: string): Promise<boolean> {
    // Normalize path to remove any leading slash
    const normalizedPath = normalizePath(path);
    
    // Check if the folder already exists
    const existingFolder = app.vault.getAbstractFileByPath(normalizedPath);
    if (existingFolder) {
      if (existingFolder instanceof TFolder) {
        return true;
      } else {
        throw new Error(`Path exists but is not a folder: ${path}`);
      }
    }
    
    // Create the folder
    await app.vault.createFolder(normalizedPath);
    return false;
  }
  
  /**
   * Ensure a folder exists
   * @param app Obsidian app instance
   * @param path Path to the folder
   * @returns Promise that resolves when the folder exists
   */
  static async ensureFolder(app: App, path: string): Promise<void> {
    // Normalize path to remove any leading slash
    const normalizedPath = normalizePath(path);
    
    const folders = normalizedPath.split('/').filter((p: string) => p.length > 0);
    let currentPath = '';
    
    for (const folder of folders) {
      currentPath += folder;
      
      try {
        await FileOperations.createFolder(app, currentPath);
      } catch (error) {
        // Ignore errors if the folder already exists
      }
      
      currentPath += '/';
    }
  }
  
  /**
   * Delete a note
   * @param app Obsidian app instance
   * @param path Path to the note
   * @returns Promise that resolves when the note is deleted
   * @throws Error if deletion fails
   */
  static async deleteNote(app: App, path: string): Promise<void> {
    // Normalize path to remove any leading slash
    const normalizedPath = normalizePath(path);
    
    const file = app.vault.getAbstractFileByPath(normalizedPath);
    if (!file) {
      throw new Error(`File not found: ${path}`);
    }
    
    if (!(file instanceof TFile)) {
      throw new Error(`Path is not a file: ${path}`);
    }
    
    await app.vault.delete(file);
  }
  
  /**
   * Delete a folder
   * @param app Obsidian app instance
   * @param path Path to the folder
   * @param recursive Whether to delete recursively
   * @returns Promise that resolves when the folder is deleted
   * @throws Error if deletion fails
   */
  static async deleteFolder(app: App, path: string, recursive = false): Promise<void> {
    // Normalize path to remove any leading slash
    const normalizedPath = normalizePath(path);
    
    const folder = app.vault.getAbstractFileByPath(normalizedPath);
    if (!folder) {
      throw new Error(`Folder not found: ${path}`);
    }
    
    if (!(folder instanceof TFolder)) {
      throw new Error(`Path is not a folder: ${path}`);
    }
    
    if (!recursive && folder.children.length > 0) {
      throw new Error(`Folder is not empty: ${path}`);
    }
    
    await app.vault.delete(folder, true);
  }
  
  /**
   * Move a note
   * @param app Obsidian app instance
   * @param path Path to the note
   * @param newPath New path for the note
   * @param overwrite Whether to overwrite if a note already exists at the new path
   * @returns Promise that resolves when the note is moved
   * @throws Error if move fails
   */
  static async moveNote(
    app: App,
    path: string,
    newPath: string,
    overwrite = false
  ): Promise<void> {
    // Normalize paths to remove any leading slashes
    const normalizedPath = normalizePath(path);
    const normalizedNewPath = normalizePath(newPath);
    
    const file = app.vault.getAbstractFileByPath(normalizedPath);
    if (!file) {
      throw new Error(`File not found: ${path}`);
    }
    
    if (!(file instanceof TFile)) {
      throw new Error(`Path is not a file: ${path}`);
    }
    
    // Check if the destination already exists
    const existingFile = app.vault.getAbstractFileByPath(normalizedNewPath);
    if (existingFile) {
      if (overwrite) {
        await app.vault.delete(existingFile);
      } else {
        throw new Error(`Destination already exists: ${newPath}`);
      }
    }
    
    // Ensure the parent folder exists
    const folderPath = normalizedNewPath.substring(0, normalizedNewPath.lastIndexOf('/'));
    if (folderPath) {
      await FileOperations.ensureFolder(app, folderPath);
    }
    
    await app.vault.rename(file, normalizedNewPath);
  }
  
  /**
   * Move a folder
   * @param app Obsidian app instance
   * @param path Path to the folder
   * @param newPath New path for the folder
   * @param overwrite Whether to overwrite if a folder already exists at the new path
   * @returns Promise that resolves when the folder is moved
   * @throws Error if move fails
   */
  static async moveFolder(
    app: App,
    path: string,
    newPath: string,
    overwrite = false
  ): Promise<void> {
    // Normalize paths to remove any leading slashes
    const normalizedPath = normalizePath(path);
    const normalizedNewPath = normalizePath(newPath);
    
    const folder = app.vault.getAbstractFileByPath(normalizedPath);
    if (!folder) {
      throw new Error(`Folder not found: ${path}`);
    }
    
    if (!(folder instanceof TFolder)) {
      throw new Error(`Path is not a folder: ${path}`);
    }
    
    // Check if the destination already exists
    const existingFolder = app.vault.getAbstractFileByPath(normalizedNewPath);
    if (existingFolder) {
      if (overwrite) {
        await app.vault.delete(existingFolder, true);
      } else {
        throw new Error(`Destination already exists: ${newPath}`);
      }
    }
    
    // Ensure the parent folder exists
    const parentPath = normalizedNewPath.substring(0, normalizedNewPath.lastIndexOf('/'));
    if (parentPath) {
      await FileOperations.ensureFolder(app, parentPath);
    }
    
    await app.vault.rename(folder, normalizedNewPath);
  }
  
  /**
   * Duplicate a note
   * @param app Obsidian app instance
   * @param sourcePath Path to the source note
   * @param targetPath Path for the duplicate note
   * @param overwrite Whether to overwrite if target exists
   * @param autoIncrement Whether to auto-increment filename if target exists
   * @returns Promise that resolves with duplication details
   * @throws Error if duplication fails
   */
  static async duplicateNote(
    app: App,
    sourcePath: string,
    targetPath: string,
    overwrite = false,
    autoIncrement = false
  ): Promise<{
    sourcePath: string;
    targetPath: string;
    wasAutoIncremented: boolean;
    wasOverwritten: boolean;
  }> {
    // Normalize paths to remove any leading slashes
    const normalizedSourcePath = normalizePath(sourcePath);
    const normalizedTargetPath = normalizePath(targetPath);

    // Check if source file exists
    const sourceFile = app.vault.getAbstractFileByPath(normalizedSourcePath);
    if (!sourceFile) {
      throw new Error(`Source file not found: ${sourcePath}`);
    }

    if (!(sourceFile instanceof TFile)) {
      throw new Error(`Source path is not a file: ${sourcePath}`);
    }

    // Read source content
    const sourceContent = await app.vault.read(sourceFile);
    
    let finalTargetPath = normalizedTargetPath;
    let wasAutoIncremented = false;
    let wasOverwritten = false;

    // Handle existing target file
    let existingTarget = app.vault.getAbstractFileByPath(finalTargetPath);
    
    if (existingTarget) {
      if (autoIncrement) {
        // Auto-increment filename until we find an available one
        let counter = 1;
        const pathParts = finalTargetPath.split('.');
        const extension = pathParts.length > 1 ? `.${pathParts.pop()}` : '';
        const basePath = pathParts.join('.');
        
        do {
          const suffix = counter === 1 ? ' copy' : ` copy ${counter}`;
          finalTargetPath = `${basePath}${suffix}${extension}`;
          existingTarget = app.vault.getAbstractFileByPath(finalTargetPath);
          counter++;
        } while (existingTarget && counter < 1000); // Safety limit
        
        if (counter >= 1000) {
          throw new Error('Too many duplicates - unable to find available filename');
        }
        
        wasAutoIncremented = counter > 1;
      } else if (overwrite) {
        // Delete existing file
        await app.vault.delete(existingTarget);
        wasOverwritten = true;
      } else {
        throw new Error(`Target file already exists: ${targetPath}`);
      }
    }

    // Ensure target directory exists
    const targetFolderPath = finalTargetPath.substring(0, finalTargetPath.lastIndexOf('/'));
    if (targetFolderPath) {
      await FileOperations.ensureFolder(app, targetFolderPath);
    }

    // Create the duplicate
    await app.vault.create(finalTargetPath, sourceContent);

    return {
      sourcePath: normalizedSourcePath,
      targetPath: finalTargetPath,
      wasAutoIncremented,
      wasOverwritten
    };
  }
}

```

## agents/toolManager/toolManager.ts

```typescript
/**
 * ToolManager Agent
 * Provides the two-tool architecture: getTools and useTool
 *
 * This agent consolidates all tool access through a unified interface,
 * enforcing context-first design and reducing token usage.
 */

import { App } from 'obsidian';
import { BaseAgent } from '../baseAgent';
import { IAgent } from '../interfaces/IAgent';
import { GetToolsTool, UseToolTool } from './tools';

/**
 * Schema data injected at startup for dynamic tool descriptions
 * Allows Claude to see available workspaces, custom agents, and vault structure
 * without needing to call discovery tools first.
 */
export interface SchemaData {
  workspaces: { name: string; description?: string }[];
  customAgents: { name: string; description?: string }[];
  vaultRoot: string[];
}

/**
 * Configuration for ToolManager agent
 */
export const ToolManagerConfig = {
  name: 'toolManager',
  displayName: 'Tool Manager',
  description: 'Discover and execute tools across all agents with unified context',
  version: '1.0.0'
};

/**
 * Agent for tool discovery and execution
 * Provides the two-tool interface: getTools + useTool
 */
export class ToolManagerAgent extends BaseAgent {
  private app: App;
  private allAgents: Map<string, IAgent>;

  /**
   * Create a new ToolManagerAgent
   * @param app Obsidian app instance
   * @param agentRegistry Map of all registered agents (excluding toolManager itself)
   * @param schemaData Dynamic data for tool descriptions (workspaces, custom agents, vault structure)
   */
  constructor(app: App, agentRegistry: Map<string, IAgent>, schemaData?: SchemaData) {
    super(
      ToolManagerConfig.name,
      ToolManagerConfig.description,
      ToolManagerConfig.version
    );

    this.app = app;
    this.allAgents = agentRegistry;

    // Default schema data if not provided
    const data: SchemaData = schemaData || { workspaces: [], customAgents: [], vaultRoot: [] };

    // Register the two tools with schema data
    this.registerTool(new GetToolsTool(agentRegistry, data));
    this.registerTool(new UseToolTool(app, agentRegistry, data.workspaces));
  }

  /**
   * Get the agent registry
   * @returns Map of agent name to agent instance
   */
  getAgentRegistry(): Map<string, IAgent> {
    return this.allAgents;
  }
}

```

## agents/toolManager/tools/getTools.ts

```typescript
/**
 * GetToolsTool - Discovery tool for the two-tool architecture
 * Returns tool schemas for requested agents/tools
 *
 * Note: This tool implements ITool directly instead of extending BaseTool
 * because it's a discovery tool that doesn't require context parameters.
 */

import { ITool } from '../../interfaces/ITool';
import { GetToolsParams, GetToolsResult, ToolSchema, getToolContextSchema } from '../types';
import { IAgent } from '../../interfaces/IAgent';
import { getErrorMessage } from '../../../utils/errorUtils';
import { SchemaData } from '../toolManager';

/**
 * Internal-only tools hidden from external MCP clients (Claude Desktop)
 * These tools require internal chat context and won't work via MCP.
 */
const INTERNAL_ONLY_TOOLS = new Set<string>([
  'subagent'  // Internal chat UI only - requires conversation context
]);

/**
 * Tool for discovering available tools and their schemas
 * Implements ITool directly since it doesn't need context parameters
 */
export class GetToolsTool implements ITool<GetToolsParams, GetToolsResult> {
  slug: string;
  name: string;
  description: string;
  version: string;

  private agentRegistry: Map<string, IAgent>;

  /**
   * Create a new GetToolsTool
   * @param agentRegistry Map of agent name to agent instance
   * @param schemaData Dynamic data for description (workspaces, custom agents, vault structure)
   */
  constructor(agentRegistry: Map<string, IAgent>, schemaData: SchemaData) {
    this.slug = 'getTools';
    this.name = 'Get Tools';
    this.version = '1.0.0';
    this.agentRegistry = agentRegistry;

    // Build description AFTER agentRegistry is set (uses actual registered agents)
    this.description = this.buildDescription(schemaData);
  }

  /**
   * Build the dynamic description from actual registered agents
   * Filters out internal-only tools that should not be exposed to MCP clients
   */
  private buildDescription(schemaData: SchemaData): string {
    const lines = [
      'Get parameter schemas for specific tools.',
      ''
    ];

    // Build from actual registered agents (single source of truth)
    // Filter out internal-only tools that shouldn't be exposed externally
    lines.push('Agents:');
    for (const [agentName, agent] of this.agentRegistry) {
      if (agentName === 'toolManager') continue;
      const tools = agent.getTools()
        .map(t => t.slug)
        .filter(slug => !INTERNAL_ONLY_TOOLS.has(slug));
      // Only list agent if it has visible tools
      if (tools.length > 0) {
        lines.push(`${agentName}: [${tools.join(',')}]`);
      }
    }

    // Custom agents section
    if (schemaData.customAgents.length > 0) {
      lines.push('');
      lines.push('Custom Agents:');
      for (const agent of schemaData.customAgents) {
        lines.push(`- "${agent.name}": ${agent.description || 'No description'}`);
      }
    }

    // Workspaces section
    lines.push('');
    lines.push('Workspaces: [default' + (schemaData.workspaces.length > 0 ? ',' + schemaData.workspaces.map(w => w.name).join(',') : '') + ']');

    // Vault structure section (compact)
    if (schemaData.vaultRoot.length > 0) {
      const folders = schemaData.vaultRoot.slice(0, 5);
      if (schemaData.vaultRoot.length > 5) folders.push('...');
      lines.push('Vault: [' + folders.join(',') + ']');
    }

    return lines.join('\n');
  }

  /**
   * Execute the tool
   * @param params Tool parameters with request array
   * @returns Promise that resolves with tool schemas
   */
  async execute(params: GetToolsParams): Promise<GetToolsResult> {
    try {
      const { request } = params;
      const resultSchemas: ToolSchema[] = [];
      const notFound: string[] = [];

      // REQUIRE at least 1 agent/tool - don't allow empty requests
      if (!request || !Array.isArray(request) || request.length === 0) {
        return {
          success: false,
          error: 'Request array is required. Example: { "request": [{ "agent": "storageManager", "tools": ["list"] }] }. See tool description for available agents and tools.'
        };
      }

      // Process each request item in the array
      for (const item of request) {
        const agentName = item.agent;
        const toolNames = item.tools;

        // Validate item structure
        if (!agentName || typeof agentName !== 'string') {
          notFound.push('Missing or invalid "agent" field in request item');
          continue;
        }

        const agent = this.agentRegistry.get(agentName);
        if (!agent) {
          notFound.push(`Agent "${agentName}" not found`);
          continue;
        }

        // Validate tools array
        if (!toolNames || !Array.isArray(toolNames) || toolNames.length === 0) {
          notFound.push(`Agent "${agentName}" requires "tools" array with at least one tool name`);
          continue;
        }

        // Get specific tools (skip internal-only tools)
        for (const toolSlug of toolNames) {
          if (INTERNAL_ONLY_TOOLS.has(toolSlug)) {
            notFound.push(`Tool "${toolSlug}" not found in agent "${agentName}"`);
            continue;
          }
          const tool = agent.getTool(toolSlug);
          if (!tool) {
            notFound.push(`Tool "${toolSlug}" not found in agent "${agentName}"`);
            continue;
          }
          const schema = this.buildToolSchema(agentName, tool);
          resultSchemas.push(schema);
        }
      }

      // Build result
      const result: GetToolsResult = {
        success: true,
        data: { tools: resultSchemas }
      };

      // Add warning about not found items
      if (notFound.length > 0) {
        result.error = `Some items not found: ${notFound.join(', ')}`;
      }

      return result;
    } catch (error) {
      return {
        success: false,
        error: `Error getting tools: ${getErrorMessage(error)}`
      };
    }
  }

  /**
   * Build a ToolSchema from an agent and tool
   */
  private buildToolSchema(agentName: string, tool: { slug: string; description: string; getParameterSchema(): unknown }): ToolSchema {
    // Get the full parameter schema
    const fullSchema = tool.getParameterSchema() as Record<string, unknown>;

    // Strip common parameters (context, workspaceContext) - LLM doesn't need to see these
    // since useTool handles context at the top level
    const strippedSchema = this.stripCommonParams(fullSchema);

    return {
      agent: agentName,
      tool: tool.slug,
      description: tool.description,
      inputSchema: strippedSchema
    };
  }

  /**
   * Strip common parameters from schema that are handled by useTool
   */
  private stripCommonParams(schema: Record<string, unknown>): Record<string, unknown> {
    const result = { ...schema };

    // Remove common params from properties
    if (result.properties && typeof result.properties === 'object') {
      const props = { ...(result.properties as Record<string, unknown>) };
      delete props.context;
      delete props.workspaceContext;
      result.properties = props;
    }

    // Remove from required array if present
    if (result.required && Array.isArray(result.required)) {
      result.required = result.required.filter(
        (r: string) => r !== 'context' && r !== 'workspaceContext'
      );
    }

    return result;
  }

  /**
   * Get the JSON schema for the tool's parameters
   * Context is REQUIRED - provides session tracking and memory/goal for traces
   */
  getParameterSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        context: getToolContextSchema(),
        request: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              agent: {
                type: 'string',
                description: 'Agent name'
              },
              tools: {
                type: 'array',
                items: { type: 'string' },
                minItems: 1,
                description: 'Tool names to get schemas for'
              }
            },
            required: ['agent', 'tools']
          },
          minItems: 1,
          description: 'Array of agent/tools requests'
        }
      },
      required: ['context', 'request']
    };
  }

  /**
   * Get the JSON schema for the tool's result
   */
  getResultSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean' },
        error: { type: 'string' },
        data: {
          type: 'object',
          properties: {
            tools: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  agent: { type: 'string', description: 'Agent name' },
                  tool: { type: 'string', description: 'Tool name' },
                  description: { type: 'string', description: 'Tool description' },
                  inputSchema: { type: 'object', description: 'Parameter schema' }
                },
                required: ['agent', 'tool', 'description', 'inputSchema']
              }
            }
          }
        }
      },
      required: ['success']
    };
  }
}

```

## agents/toolManager/tools/index.ts

```typescript
/**
 * ToolManager tool exports
 */
export { GetToolsTool } from './getTools';
export { UseToolTool } from './useTools';

```

## agents/toolManager/tools/useTools.ts

```typescript
/**
 * UseToolTool - Execution tool for the two-tool architecture
 * Single entry point for executing tools with context-first design
 *
 * Note: This tool implements ITool directly instead of extending BaseTool
 * because it uses a different context format (ToolContext) than CommonParameters.
 */

import { App } from 'obsidian';
import { ITool } from '../../interfaces/ITool';
import { UseToolParams, UseToolResult, ToolCallParams, ToolCallResult, ToolContext, getToolContextSchema } from '../types';
import { IAgent } from '../../interfaces/IAgent';
import { getErrorMessage } from '../../../utils/errorUtils';
import { getNexusPlugin } from '../../../utils/pluginLocator';
import { WorkspaceService } from '../../../services/WorkspaceService';

/** Workspace info for validation */
interface WorkspaceInfo {
  name: string;
  description?: string;
}

/**
 * Tool for executing other tools with unified context
 * Implements ITool directly since UseToolParams has its own context format
 */
export class UseToolTool implements ITool<UseToolParams, UseToolResult> {
  slug: string;
  name: string;
  description: string;
  version: string;

  private app: App;
  private agentRegistry: Map<string, IAgent>;
  private knownWorkspaces: WorkspaceInfo[];

  /**
   * Create a new UseToolTool
   * @param app Obsidian app instance
   * @param agentRegistry Map of agent name to agent instance
   * @param workspaces Known workspaces for validation by name
   */
  constructor(app: App, agentRegistry: Map<string, IAgent>, workspaces: WorkspaceInfo[] = []) {
    this.slug = 'useTools';
    this.name = 'Use Tools';
    this.description = 'Execute tools with context. Fill context FIRST (memoryâ†’goalâ†’constraints), then specify tools to call. Context ensures memory/goal are captured for each trace.';
    this.version = '1.0.0';

    this.app = app;
    this.agentRegistry = agentRegistry;
    this.knownWorkspaces = workspaces;
  }

  /**
   * Execute the tool
   * @param params Tool parameters
   * @returns Promise that resolves with execution results
   */
  async execute(params: UseToolParams): Promise<UseToolResult> {
    try {
      // Validate context
      const contextErrors = this.validateContext(params.context);
      if (contextErrors.length > 0) {
        return {
          success: false,
          error: `Invalid context: ${contextErrors.join(', ')}`
        };
      }

      // Validate workspaceId exists
      const workspaceError = await this.validateWorkspaceId(params.context.workspaceId);
      if (workspaceError) {
        return {
          success: false,
          error: workspaceError
        };
      }

      // Validate calls array
      if (!params.calls || params.calls.length === 0) {
        return {
          success: false,
          error: 'calls array is required. Structure: calls: [{ agent: "agentName", tool: "toolName", params: {...} }]'
        };
      }

      // Execute based on strategy
      const strategy = params.strategy || 'serial';
      let results: ToolCallResult[];

      if (strategy === 'parallel') {
        results = await this.executeParallel(params.context, params.calls);
      } else {
        results = await this.executeSerial(params.context, params.calls);
      }

      // Determine overall success
      const allSucceeded = results.every(r => r.success);

      // Format each result with its own success/error status
      const formatResult = (r: ToolCallResult): Record<string, unknown> => {
        if (r.success) {
          // Success: spread object data, nest primitives/arrays
          if (r.data !== undefined && typeof r.data === 'object' && r.data !== null && !Array.isArray(r.data)) {
            return { success: true, ...(r.data as Record<string, unknown>) };
          } else if (r.data !== undefined) {
            return { success: true, data: r.data };
          }
          return { success: true };
        }
        // Failure: include error
        return { success: false, error: r.error || 'Unknown error' };
      };

      // Single call: flatten directly
      if (results.length === 1) {
        const formatted = formatResult(results[0]);
        return {
          success: results[0].success,
          ...(results[0].success ? {} : { error: (formatted as { error?: string }).error }),
          data: formatted
        };
      }

      // Multiple calls: each result has its own success/error
      const formattedResults = results.map(formatResult);
      const failCount = results.filter(r => !r.success).length;

      return {
        success: allSucceeded,
        ...(allSucceeded ? {} : { error: `${failCount} of ${results.length} failed` }),
        data: { results: formattedResults }
      };
    } catch (error) {
      return {
        success: false,
        error: `Error executing tools: ${getErrorMessage(error)}`
      };
    }
  }

  /**
   * Validate the context block
   * Returns recovery-oriented error messages
   */
  private validateContext(context: ToolContext): string[] {
    const errors: string[] = [];

    if (!context) {
      errors.push('context is required. Structure: { workspaceId, sessionId, memory, goal }');
      return errors;
    }

    if (!context.workspaceId || typeof context.workspaceId !== 'string') {
      errors.push('context.workspaceId is required (use "default" for global workspace)');
    }

    if (!context.sessionId || typeof context.sessionId !== 'string') {
      errors.push('context.sessionId is required (any descriptive name, e.g. "blog_writing_session")');
    }

    if (!context.memory || typeof context.memory !== 'string') {
      errors.push('context.memory is required (1-3 sentences: what has happened in this conversation so far)');
    }

    if (!context.goal || typeof context.goal !== 'string') {
      errors.push('context.goal is required (1-3 sentences: what you are trying to accomplish right now)');
    }

    // constraints is optional, but if provided should be a string
    if (context.constraints !== undefined && context.constraints !== null && typeof context.constraints !== 'string') {
      errors.push('context.constraints must be a string if provided');
    }

    return errors;
  }

  /**
   * Validate workspaceId exists (by name or UUID)
   * Returns error message with available workspaces if invalid, null if valid
   */
  private async validateWorkspaceId(workspaceId: string): Promise<string | null> {
    // "default" is always valid (global workspace)
    if (workspaceId === 'default') {
      return null;
    }

    // First, check if it matches a known workspace NAME (case-insensitive)
    const byName = this.knownWorkspaces.find(w =>
      w.name.toLowerCase() === workspaceId.toLowerCase()
    );
    if (byName) {
      return null; // Valid - matched by name
    }

    // If not found by name, check if it's a valid UUID via WorkspaceService
    try {
      const plugin = getNexusPlugin(this.app);
      if (!plugin) {
        return null; // Plugin not ready, allow to proceed
      }

      const workspaceService = (plugin as { workspaceService?: WorkspaceService }).workspaceService;
      if (!workspaceService) {
        return null; // Service not ready, allow to proceed
      }

      // Check if it matches by UUID
      const workspaces = await workspaceService.listWorkspaces();
      const byUuid = workspaces.find(w => w.id === workspaceId);
      if (byUuid) {
        return null; // Valid - matched by UUID
      }

      // Not found - build error message with available workspace NAMES
      const availableNames = this.knownWorkspaces.length > 0
        ? this.knownWorkspaces.map(w => `"${w.name}"`).join(', ')
        : '(none created yet)';
      return `Invalid workspace "${workspaceId}". Available: "default" (global), ${availableNames}`;
    } catch {
      return null; // Error, allow to proceed
    }
  }

  /**
   * Execute calls serially (one at a time)
   * Stops on first error unless continueOnFailure is set
   */
  private async executeSerial(context: ToolContext, calls: ToolCallParams[]): Promise<ToolCallResult[]> {
    const results: ToolCallResult[] = [];

    for (const call of calls) {
      const result = await this.executeCall(context, call);
      results.push(result);

      // Stop on failure unless continueOnFailure is set
      if (!result.success && !call.continueOnFailure) {
        break;
      }
    }

    return results;
  }

  /**
   * Execute calls in parallel
   */
  private async executeParallel(context: ToolContext, calls: ToolCallParams[]): Promise<ToolCallResult[]> {
    const promises = calls.map(call => this.executeCall(context, call));
    return Promise.all(promises);
  }

  /**
   * Execute a single tool call
   */
  private async executeCall(context: ToolContext, call: ToolCallParams): Promise<ToolCallResult> {
    const { agent: agentName, tool: toolSlug } = call;

    // Handle LLM confusion: accept both "params" and "parameters"
    const callWithAny = call as ToolCallParams & { parameters?: Record<string, unknown> };
    const params = call.params || callWithAny.parameters || {};

    // Validate agent and tool are provided
    if (!agentName) {
      const availableAgents = Array.from(this.agentRegistry.keys()).join(', ');
      return {
        agent: agentName || 'unknown',
        tool: toolSlug || 'unknown',
        success: false,
        error: `"agent" is required in each call. Available agents: ${availableAgents}`
      };
    }

    if (!toolSlug) {
      return {
        agent: agentName,
        tool: 'unknown',
        success: false,
        error: `"tool" is required in each call. Use getTools({ request: { "${agentName}": [] } }) to see available tools for ${agentName}.`
      };
    }

    // Get agent
    const agent = this.agentRegistry.get(agentName);
    if (!agent) {
      const availableAgents = Array.from(this.agentRegistry.keys()).join(', ');
      return {
        agent: agentName,
        tool: toolSlug,
        success: false,
        error: `Agent "${agentName}" not found. Available agents: ${availableAgents}. Use getTools({ request: { "agentName": [] } }) to see an agent's tools.`
      };
    }

    // Check tool exists
    const toolInstance = agent.getTool(toolSlug);
    if (!toolInstance) {
      const availableTools = agent.getTools().map(t => t.slug).join(', ');
      return {
        agent: agentName,
        tool: toolSlug,
        success: false,
        error: `Tool "${toolSlug}" not found in agent "${agentName}". Available tools: ${availableTools}`
      };
    }

    try {
      // Execute tool with ONLY its specific params
      // Context is handled at useTool level - individual tools don't need it
      const toolResult = await toolInstance.execute(params || {});

      // Build minimal result
      const result: ToolCallResult = {
        agent: agentName,
        tool: toolSlug,
        success: toolResult.success
      };

      // Only include error if failed
      if (!toolResult.success && toolResult.error) {
        result.error = toolResult.error;
      }

      // Only include data if present (for tools that return data)
      if (toolResult.success && toolResult.data !== undefined && toolResult.data !== null) {
        result.data = toolResult.data;
      }

      return result;
    } catch (error) {
      return {
        agent: agentName,
        tool: toolSlug,
        success: false,
        error: `Error executing ${agentName}_${toolSlug}: ${getErrorMessage(error)}`
      };
    }
  }

  /**
   * Get the JSON schema for the tool's parameters
   */
  getParameterSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        context: getToolContextSchema(),
        strategy: {
          type: 'string',
          enum: ['serial', 'parallel'],
          default: 'serial',
          description: 'Execution strategy: serial (stop on error) or parallel (run all)'
        },
        calls: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              agent: {
                type: 'string',
                description: 'Agent name'
              },
              tool: {
                type: 'string',
                description: 'Tool name'
              },
              params: {
                type: 'object',
                description: 'Tool-specific parameters'
              },
              continueOnFailure: {
                type: 'boolean',
                description: 'Continue despite errors (serial only)'
              }
            },
            required: ['agent', 'tool', 'params']
          },
          minItems: 1,
          description: 'Tool calls to execute'
        }
      },
      required: ['context', 'calls']
    };
  }

  /**
   * Get the JSON schema for the tool's result
   */
  getResultSchema(): Record<string, unknown> {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'True if all calls succeeded'
        },
        error: {
          type: 'string',
          description: 'Error message if any calls failed'
        },
        data: {
          type: 'object',
          properties: {
            results: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  agent: { type: 'string', description: 'Agent that executed the tool' },
                  tool: { type: 'string', description: 'Tool that was executed' },
                  success: { type: 'boolean', description: 'Whether this call succeeded' },
                  error: { type: 'string', description: 'Error message if failed' },
                  data: { description: 'Result data (only for tools that return data)' }
                },
                required: ['agent', 'tool', 'success']
              }
            }
          }
        }
      },
      required: ['success']
    };
  }
}

```

## agents/toolManager/types.ts

```typescript
/**
 * Type definitions for ToolManager agent
 * Follows existing CommonParameters/CommonResult patterns
 */

import type { CommonResult } from '../../types';
import type { ToolContext } from '../../types/mcp/AgentTypes';

// Re-export ToolContext from central location
export type { ToolContext } from '../../types/mcp/AgentTypes';

// ==================== GetTools Types ====================

/**
 * Single request item for getTools
 * Explicit structure with named fields for LLM clarity
 */
export interface ToolRequestItem {
  /** Agent name (e.g., "storageManager", "contentManager") */
  agent: string;

  /** Array of tool names to get schemas for */
  tools: string[];
}

/**
 * GetTools parameters - requires context for session tracking
 */
export interface GetToolsParams {
  /** Context for this request (required for session tracking) */
  context: ToolContext;

  /**
   * Array of agent/tools requests
   * Example: [{ agent: "storageManager", tools: ["list"] }]
   */
  request: ToolRequestItem[];
}

/**
 * Shared JSON schema for ToolContext
 * Used by both getTools and useTool parameter schemas
 */
export function getToolContextSchema(): Record<string, unknown> {
  return {
    type: 'object',
    properties: {
      workspaceId: {
        type: 'string',
        description: 'Workspace ID. Use "default" for global workspace, or use memoryManager_listWorkspaces to see available workspaces. Do NOT make up workspace IDs.'
      },
      sessionId: {
        type: 'string',
        description: 'Session identifier - provide any name, a standard ID will be assigned and returned. Use the assigned ID for subsequent calls.'
      },
      memory: { type: 'string', description: 'Essence of conversation so far (1-3 sentences)' },
      goal: { type: 'string', description: 'Current objective (1-3 sentences)' },
      constraints: { type: 'string', description: 'Rules/limits to follow (optional, 1-3 sentences)' }
    },
    required: ['workspaceId', 'sessionId', 'memory', 'goal'],
    description: 'Context for session tracking. Fill this FIRST before other parameters.'
  };
}

/**
 * Tool schema returned by getTools
 * Organized by agent for clarity
 */
export interface ToolSchema {
  /** Agent that owns this tool */
  agent: string;

  /** Tool name (without agent prefix) */
  tool: string;

  /** Tool description */
  description: string;

  /** Parameter schema WITHOUT common parameters (context stripped) */
  inputSchema: Record<string, unknown>;
}

/**
 * GetTools result - organized by agent
 */
export interface GetToolsResult extends CommonResult {
  success: boolean;
  error?: string;
  data?: {
    tools: ToolSchema[];
  };
}

// ==================== UseTool Types ====================

/**
 * Individual tool call within useTool
 */
export interface ToolCallParams {
  /** Agent name (e.g., "storageManager") */
  agent: string;

  /** Tool name (e.g., "list") */
  tool: string;

  /** Tool-specific parameters (context injected automatically) */
  params: Record<string, unknown>;

  /** If true, continue executing remaining calls even if this one fails */
  continueOnFailure?: boolean;
}

/**
 * UseToolParams uses the new ToolContext schema (memory/goal/constraints)
 */
export interface UseToolParams {
  /** Context shared by all tool calls */
  context: ToolContext;

  /**
   * Execution strategy (default: 'serial')
   * - serial: Execute one at a time, stop on first error (unless continueOnFailure)
   * - parallel: Execute all concurrently
   */
  strategy?: 'serial' | 'parallel';

  /** Tool calls to execute */
  calls: ToolCallParams[];
}

/**
 * Result for a single tool call
 */
export interface ToolCallResult {
  /** Agent that executed the tool */
  agent: string;

  /** Tool that was executed */
  tool: string;

  /** Whether this call succeeded */
  success: boolean;

  /** Error message if this call failed */
  error?: string;

  /** Result data - only for tools that return data (readContent, searches) */
  data?: unknown;
}

/**
 * Failure detail for lean error reporting
 */
export interface ToolFailure {
  agent: string;
  tool: string;
  error?: string;
}

/**
 * UseTool result - lean format
 * - Success single: { success: true, data: <tool's data directly> }
 * - Success multiple: { success: true, data: { results: [data1, data2] } }
 * - Failure: { success: false, error: "...", data: { failures: [...] } }
 */
export interface UseToolResult extends CommonResult {
  success: boolean;
  error?: string;
  data?: unknown; // Flexible: can be tool's data directly, or { results: [] } or { failures: [] }
}

```

## components/Accordion.ts

```typescript
import { Component } from 'obsidian';

/**
 * A collapsible accordion component for Obsidian plugin settings
 * Provides smooth animations and mobile-friendly interaction
 */
export class Accordion extends Component {
    containerEl: HTMLElement;
    contentEl: HTMLElement;
    isOpen: boolean;

    /**
     * Create a new accordion
     * @param containerEl Parent container element
     * @param title Accordion header title
     * @param defaultOpen Whether accordion is open by default
     */
    constructor(containerEl: HTMLElement, title: string, defaultOpen = false) {
        super();
        
        this.containerEl = containerEl;
        this.isOpen = defaultOpen;
        
        // Create main accordion container
        const accordionEl = this.containerEl.createEl('div', {
            cls: 'mcp-accordion'
        });

        // Create container to scope selectors
        const accordionContainer = accordionEl.createEl('div', {
            cls: 'mcp-accordion-container'
        });

        // Create header with toggle button
        const headerEl = accordionContainer.createEl('div', {
            cls: 'mcp-accordion-header'
        });

        const toggleButton = headerEl.createEl('button', {
            cls: 'mcp-accordion-toggle'
        });

        // Add title
        toggleButton.createEl('span', {
            text: title,
            cls: 'mcp-accordion-title'
        });

        // Add expand/collapse icon
        toggleButton.createEl('span', {
            cls: `mcp-accordion-icon ${this.isOpen ? 'is-open' : ''}`
        });

        // Create content container
        this.contentEl = accordionContainer.createEl('div', {
            cls: `mcp-accordion-content ${this.isOpen ? 'is-open' : ''}`
        });

        // Toggle on click - using registerDomEvent for auto-cleanup
        this.registerDomEvent(toggleButton, 'click', () => {
            this.toggle(accordionContainer);
        });
    }

    /**
     * Toggle accordion open/closed state
     * @param container The accordion container element to toggle
     */
    toggle(container: HTMLElement): void {
        this.isOpen = !this.isOpen;
        
        // Update icon - scoped to this container
        const iconEl = container.querySelector('.mcp-accordion-icon');
        if (iconEl) {
            iconEl.classList.toggle('is-open');
        }
        
        // Update content - scoped to this container
        const contentEl = container.querySelector('.mcp-accordion-content');
        if (contentEl) {
            contentEl.classList.toggle('is-open');
        }
    }

    /**
     * Get the content element to add children to
     */
    getContentEl(): HTMLElement {
        const innerContent = this.contentEl.createEl('div');
        return innerContent;
    }
}

```

## components/Card.ts

```typescript
/**
 * Reusable Card Component
 * Matches the existing Custom Agent card styling and behavior
 */

import { ToggleComponent, Component, setIcon } from 'obsidian';

export interface CardAction {
  icon: string; // Obsidian icon name (e.g., 'edit', 'trash') - uses setIcon
  label: string; // aria-label for accessibility
  onClick: () => void;
}

export interface CardConfig {
  title: string;
  description: string;
  isEnabled?: boolean;
  showToggle?: boolean; // Whether to show the toggle switch
  onToggle?: (enabled: boolean) => void;
  onEdit?: () => void;
  onDelete?: () => void;
  additionalActions?: CardAction[];
}

export class Card {
  private containerEl: HTMLElement;
  private cardEl: HTMLElement;
  private config: CardConfig;
  private component?: Component;

  constructor(containerEl: HTMLElement, config: CardConfig, component?: Component) {
    this.containerEl = containerEl;
    this.config = config;
    this.component = component;
    this.cardEl = this.createCard();
  }

  /**
   * Safely register a DOM event - uses Component.registerDomEvent if available,
   * otherwise falls back to plain addEventListener (cleanup handled by DOM removal)
   */
  private safeRegisterDomEvent<K extends keyof HTMLElementEventMap>(
    el: HTMLElement,
    type: K,
    handler: (ev: HTMLElementEventMap[K]) => void
  ): void {
    if (this.component) {
      this.component.registerDomEvent(el, type, handler);
    } else {
      el.addEventListener(type, handler);
    }
  }

  /**
   * Create the card element with standard styling
   */
  private createCard(): HTMLElement {
    const cardEl = this.containerEl.createDiv('agent-management-card');
    
    // Header with name and toggle
    const headerEl = cardEl.createDiv('agent-management-card-header');
    const titleEl = headerEl.createDiv('agent-management-card-title');
    titleEl.setText(this.config.title);
    
    const actionsEl = headerEl.createDiv('agent-management-card-actions');
    
    // Toggle switch using Obsidian's ToggleComponent (only if showToggle is true)
    if (this.config.showToggle && this.config.onToggle) {
      const toggleContainer = actionsEl.createDiv('agent-management-toggle');
      new ToggleComponent(toggleContainer)
        .setValue(this.config.isEnabled || false)
        .onChange(async (value) => {
          this.config.isEnabled = value;
          this.config.onToggle!(value);
        });
    }
    
    if (this.config.onEdit) {
      const editBtn = actionsEl.createEl('button', {
        cls: 'clickable-icon agent-management-edit-btn',
        attr: { 'aria-label': 'Edit' }
      });
      setIcon(editBtn, 'edit');
      const editHandler = () => this.config.onEdit!();
      this.safeRegisterDomEvent(editBtn, 'click', editHandler);
    }

    if (this.config.onDelete) {
      const deleteBtn = actionsEl.createEl('button', {
        cls: 'clickable-icon agent-management-delete-btn',
        attr: { 'aria-label': 'Delete' }
      });
      setIcon(deleteBtn, 'trash');
      const deleteHandler = () => this.config.onDelete!();
      this.safeRegisterDomEvent(deleteBtn, 'click', deleteHandler);
    }

    if (this.config.additionalActions) {
      this.config.additionalActions.forEach(action => {
        const actionBtn = actionsEl.createEl('button', {
          cls: 'clickable-icon agent-management-action-btn',
          attr: { 'aria-label': action.label }
        });
        setIcon(actionBtn, action.icon);
        this.safeRegisterDomEvent(actionBtn, 'click', action.onClick);
      });
    }
    
    // Description (only show if not empty)
    if (this.config.description && this.config.description.trim()) {
      const descEl = cardEl.createDiv('agent-management-card-description');
      descEl.setText(this.config.description);
    }
    
    return cardEl;
  }

  /**
   * Update the card's configuration and refresh display
   */
  updateConfig(config: Partial<CardConfig>): void {
    this.config = { ...this.config, ...config };
    this.refresh();
  }

  /**
   * Update the card's enabled state
   */
  setEnabled(enabled: boolean): void {
    this.config.isEnabled = enabled;
    // Just update the internal state - don't create new toggle components
    // The toggle state will be reflected when the card is refreshed
  }

  /**
   * Update the card's title
   */
  setTitle(title: string): void {
    this.config.title = title;
    const titleEl = this.cardEl.querySelector('.agent-management-card-title');
    if (titleEl) {
      titleEl.textContent = title;
    }
  }

  /**
   * Update the card's description
   */
  setDescription(description: string): void {
    this.config.description = description;
    
    // Remove existing description element
    const existingDescEl = this.cardEl.querySelector('.agent-management-card-description');
    if (existingDescEl) {
      existingDescEl.remove();
    }
    
    // Add new description element only if not empty
    if (description && description.trim()) {
      const descEl = this.cardEl.createDiv('agent-management-card-description');
      descEl.setText(description);
    }
  }

  /**
   * Refresh the entire card display
   */
  private refresh(): void {
    this.cardEl.remove();
    this.cardEl = this.createCard();
  }

  /**
   * Remove the card from the DOM
   */
  remove(): void {
    this.cardEl.remove();
  }

  /**
   * Get the card's DOM element
   */
  getElement(): HTMLElement {
    return this.cardEl;
  }

  /**
   * Check if the card is enabled
   */
  isEnabled(): boolean {
    return this.config.isEnabled || false;
  }
}
```

## components/CardManager.ts

```typescript
/**
 * Unified Card Manager Component
 * Generic card management system for agents, providers, and other card-based UIs
 */

import { ButtonComponent } from 'obsidian';
import { Card, CardConfig } from './Card';

export interface CardItem {
    id: string;
    name: string;
    description?: string;
    isEnabled: boolean;
}

export interface CardManagerConfig<T extends CardItem> {
    containerEl: HTMLElement;
    title: string;
    addButtonText: string;
    emptyStateText: string;
    items: T[];
    onAdd: () => void;
    onToggle: (item: T, enabled: boolean) => Promise<void>;
    onEdit: (item: T) => void;
    onDelete?: (item: T) => void;
    showToggle?: boolean;
    showAddButton?: boolean;
}

export class CardManager<T extends CardItem> {
    private config: CardManagerConfig<T>;
    private cardsContainer!: HTMLElement;
    private cards: Map<string, Card> = new Map();

    constructor(config: CardManagerConfig<T>) {
        this.config = config;
        this.buildContent();
    }

    /**
     * Build the card manager content
     */
    private buildContent(): void {
        this.config.containerEl.empty();

        // Add button section (optional)
        if (this.config.showAddButton !== false) {
            this.createAddButton();
        }

        // Cards container
        this.cardsContainer = this.config.containerEl.createDiv('card-manager-grid');
        this.refreshCards();
    }

    /**
     * Create the add button
     */
    private createAddButton(): void {
        const addButtonContainer = this.config.containerEl.createDiv('card-manager-add-button');
        new ButtonComponent(addButtonContainer)
            .setButtonText(this.config.addButtonText)
            .setCta()
            .onClick(() => this.config.onAdd());
    }

    /**
     * Refresh the cards display
     */
    public refreshCards(): void {
        this.cardsContainer.empty();
        this.cards.clear();

        if (this.config.items.length === 0) {
            this.cardsContainer.createDiv('card-manager-empty')
                .setText(this.config.emptyStateText);
            return;
        }

        this.config.items.forEach(item => this.createCard(item));
    }

    /**
     * Create a card for a single item
     */
    private createCard(item: T): void {
        const cardConfig: CardConfig = {
            title: item.name,
            description: item.description || '',
            isEnabled: item.isEnabled,
            showToggle: this.config.showToggle !== false,
            onToggle: async (enabled: boolean) => {
                // Update the item's enabled state BEFORE calling the callback
                // This prevents race conditions where refreshCards() uses stale data
                item.isEnabled = enabled;
                await this.config.onToggle(item, enabled);
                // Don't call refreshCards() - the toggle already reflects the new state
                // and the item is already updated in place
            },
            onEdit: () => this.config.onEdit(item),
            onDelete: this.config.onDelete ? () => this.config.onDelete!(item) : undefined
        };

        const card = new Card(this.cardsContainer, cardConfig);
        this.cards.set(item.id, card);
    }

    /**
     * Update the items and refresh display
     */
    public updateItems(items: T[]): void {
        this.config.items = items;
        this.refreshCards();
    }

    /**
     * Get a card by item ID
     */
    public getCard(itemId: string): Card | undefined {
        return this.cards.get(itemId);
    }
}
```

## components/ConfigModal.ts

```typescript
import { App, FileSystemAdapter, Modal, Platform, Setting, normalizePath } from 'obsidian';
import * as path from 'path';
import { getAllPluginIds, getPrimaryServerKey, BRAND_NAME } from '../constants/branding';

/**
 * Configuration modal for the plugin
 * Provides setup instructions for different operating systems
 */
export class ConfigModal extends Modal {
    private activeTab = 'windows';
    private tabButtons: Record<string, HTMLElement> = {};
    private tabContents: Record<string, HTMLElement> = {};
    private isFirstTimeSetup = true;
    
    /**
     * Create a new configuration modal
     * @param app Obsidian app instance
     * @param settings Settings instance (optional)
     */
    constructor(app: App) {
        super(app);
    }
    
    /**
     * Called when the modal is opened
     */
    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        
        contentEl.createEl('h2', { text: 'MCP Configuration' });

        // Add configuration type toggle
        const toggleContainer = contentEl.createDiv({ cls: 'mcp-config-toggle' });
        toggleContainer.createEl('span', { text: 'Configuration Type:', cls: 'mcp-config-label' });
        new Setting(toggleContainer)
            .setName('First Time Setup')
            .setDesc('Toggle between first-time setup and adding to existing configuration')
            .addToggle(toggle => toggle
                .setValue(this.isFirstTimeSetup)
                .onChange(value => {
                    this.isFirstTimeSetup = value;
                    void this.updateConfigDisplay();
                }));

        // Create tab container
        const tabContainer = contentEl.createDiv({ cls: 'mcp-config-tabs' });
        
        // Add tab buttons
        this.createTabButtons(tabContainer);
        
        // Create content container
        const contentContainer = contentEl.createDiv({ cls: 'mcp-config-content' });
        
        // Create tab contents
        this.createWindowsTab(contentContainer);
        this.createMacTab(contentContainer);
        this.createLinuxTab(contentContainer);
        
        // Show default tab
        this.showTab(this.activeTab);
        
        // Add CSS
        this.addStyles();
        
        // Close button
        new Setting(contentEl)
            .addButton(button => button
                .setButtonText('Close')
                .onClick(() => {
                    this.close();
                }));
    }
    
    /**
     * Create tab buttons
     * @param container Container element
     */
    private createTabButtons(container: HTMLElement) {
        const tabButtonContainer = container.createDiv({ cls: 'mcp-tab-buttons' });
        
        // Windows tab button
        const windowsButton = tabButtonContainer.createEl('button', {
            text: 'Windows',
            cls: 'mcp-tab-button'
        });
        windowsButton.addEventListener('click', () => this.showTab('windows'));
        this.tabButtons['windows'] = windowsButton;

        // Mac tab button
        const macButton = tabButtonContainer.createEl('button', {
            text: 'Mac',
            cls: 'mcp-tab-button'
        });
        macButton.addEventListener('click', () => this.showTab('mac'));
        this.tabButtons['mac'] = macButton;

        // Linux tab button
        const linuxButton = tabButtonContainer.createEl('button', {
            text: 'Linux',
            cls: 'mcp-tab-button'
        });
        linuxButton.addEventListener('click', () => this.showTab('linux'));
        this.tabButtons['linux'] = linuxButton;
        
        // Auto-select current platform
        if (Platform.isMacOS) {
            this.activeTab = 'mac';
        } else if (Platform.isLinux) {
            this.activeTab = 'linux';
        }
    }
    
    /**
     * Create Windows tab content
     * @param container Container element
     */
    private createWindowsTab(container: HTMLElement) {
        const windowsContent = container.createDiv({ cls: 'mcp-tab-content hidden' });
        this.tabContents['windows'] = windowsContent;
        
        const instructions = windowsContent.createEl('div');
        instructions.createEl('p', { text: `To configure Claude Desktop to work with ${BRAND_NAME} on Windows:` });

        const steps = instructions.createEl('ol');

        // Step 1: Create config file through Claude Desktop
        const step1 = steps.createEl('li');
        step1.appendText('Open Claude Desktop â†’ ');
        step1.createEl('strong', { text: 'Settings' });
        step1.appendText(' â†’ ');
        step1.createEl('strong', { text: 'Developer' });
        step1.appendText(' â†’ ');
        step1.createEl('strong', { text: 'Edit Config' });
        step1.appendText(' (this creates the config file if it doesn\'t exist)');

        // Step 2: Alternative - use file link
        const step2 = steps.createEl('li');
        step2.appendText('Alternatively, open the config file directly: ');

        const configPath = '%AppData%\\Claude\\claude_desktop_config.json';
        const configLink = step2.createEl('a', {
            text: configPath,
            href: '#'
        });

        configLink.addEventListener('click', async (e) => {
            e.preventDefault();
            // Try to open the file with system's default program
            const actualPath = this.getWindowsConfigPath();
            window.open('file:///' + actualPath.replace(/\\/g, '/'), '_blank');
        });

        // Step 3: Copy configuration
        steps.createEl('li', { text: 'Copy the following JSON configuration:' });
        
        const codeBlock = windowsContent.createEl('pre');
        const codeEl = codeBlock.createEl('code', {
            text: JSON.stringify(this.getConfigurationSyncPlaceholder(), null, 2)
        });
        
        // Copy button
        const copyButton = windowsContent.createEl('button', {
            text: 'Copy Configuration',
            cls: 'mod-cta'
        });
        
        this.populateTabConfig('windows', codeEl, copyButton);
        
        // Remaining steps
        steps.createEl('li', { text: this.isFirstTimeSetup
            ? 'Paste this into your config file, replacing any existing content'
            : 'Add this to the mcpServers section of your existing config file'
        });
        steps.createEl('li', { text: 'Save the file and restart Claude Desktop' });
    }
    
    /**
     * Create Mac tab content
     * @param container Container element
     */
    private createMacTab(container: HTMLElement) {
        const macContent = container.createDiv({ cls: 'mcp-tab-content hidden' });
        this.tabContents['mac'] = macContent;
        
        const instructions = macContent.createEl('div');
        instructions.createEl('p', { text: `To configure Claude Desktop to work with ${BRAND_NAME} on Mac:` });

        const steps = instructions.createEl('ol');

        // Step 1: Create config file through Claude Desktop
        const step1 = steps.createEl('li');
        step1.appendText('Open Claude Desktop â†’ ');
        step1.createEl('strong', { text: 'Settings' });
        step1.appendText(' â†’ ');
        step1.createEl('strong', { text: 'Developer' });
        step1.appendText(' â†’ ');
        step1.createEl('strong', { text: 'Edit Config' });
        step1.appendText(' (this creates the config file if it doesn\'t exist)');

        // Step 2: Alternative - use file link
        const step2 = steps.createEl('li');
        step2.appendText('Alternatively, open the config file directly: ');

        const configPath = '~/Library/Application Support/Claude/claude_desktop_config.json';
        const configLink = step2.createEl('a', {
            text: configPath,
            href: '#'
        });

        configLink.addEventListener('click', async (e) => {
            e.preventDefault();
            // Try to open the file with system's default program
            const actualPath = this.getMacConfigPath();
            window.open('file://' + actualPath, '_blank');
        });

        // Step 3: Copy configuration
        steps.createEl('li', { text: 'Copy the following JSON configuration:' });

        const codeBlock = macContent.createEl('pre');
        const codeEl = codeBlock.createEl('code', {
            text: JSON.stringify(this.getConfigurationSyncPlaceholder(), null, 2)
        });
        
        // Copy button
        const copyButton = macContent.createEl('button', {
            text: 'Copy Configuration',
            cls: 'mod-cta'
        });
        
        this.populateTabConfig('mac', codeEl, copyButton);
        
        // Remaining steps
        steps.createEl('li', { text: this.isFirstTimeSetup
            ? 'Paste this into your config file, replacing any existing content'
            : 'Add this to the mcpServers section of your existing config file'
        });
        steps.createEl('li', { text: 'Save the file and restart Claude Desktop' });
    }
    
    /**
     * Create Linux tab content
     * @param container Container element
     */
    private createLinuxTab(container: HTMLElement) {
        const linuxContent = container.createDiv({ cls: 'mcp-tab-content hidden' });
        this.tabContents['linux'] = linuxContent;
        
        const instructions = linuxContent.createEl('div');
        instructions.createEl('p', { text: `To configure Claude Desktop to work with ${BRAND_NAME} on Linux:` });

        const steps = instructions.createEl('ol');

        // Step 1: Create config file through Claude Desktop
        const step1 = steps.createEl('li');
        step1.appendText('Open Claude Desktop â†’ ');
        step1.createEl('strong', { text: 'Settings' });
        step1.appendText(' â†’ ');
        step1.createEl('strong', { text: 'Developer' });
        step1.appendText(' â†’ ');
        step1.createEl('strong', { text: 'Edit Config' });
        step1.appendText(' (this creates the config file if it doesn\'t exist)');

        // Step 2: Alternative - use file link
        const step2 = steps.createEl('li');
        step2.appendText('Alternatively, open the config file directly: ');

        const configPath = '~/.config/Claude/claude_desktop_config.json';
        const configLink = step2.createEl('a', {
            text: configPath,
            href: '#'
        });

        configLink.addEventListener('click', async (e) => {
            e.preventDefault();
            // Try to open the file with system's default program
            const actualPath = this.getLinuxConfigPath();
            window.open('file://' + actualPath, '_blank');
        });

        // Step 3: Copy configuration
        steps.createEl('li', { text: 'Copy the following JSON configuration:' });

        const codeBlock = linuxContent.createEl('pre');
        const codeEl = codeBlock.createEl('code', {
            text: JSON.stringify(this.getConfigurationSyncPlaceholder(), null, 2)
        });
        
        // Copy button
        const copyButton = linuxContent.createEl('button', {
            text: 'Copy Configuration',
            cls: 'mod-cta'
        });
        
        this.populateTabConfig('linux', codeEl, copyButton);
        
        // Remaining steps
        steps.createEl('li', { text: this.isFirstTimeSetup
            ? 'Paste this into your config file, replacing any existing content'
            : 'Add this to the mcpServers section of your existing config file'
        });
        steps.createEl('li', { text: 'Save the file and restart Claude Desktop' });
    }
    
    /**
     * Show a specific tab
     * @param tabId Tab ID to show
     */
    private showTab(tabId: string) {
        // Update active tab
        this.activeTab = tabId;
        
        // Update button styles
        for (const [id, button] of Object.entries(this.tabButtons)) {
            if (id === tabId) {
                button.addClass('mcp-tab-active');
            } else {
                button.removeClass('mcp-tab-active');
            }
        }
        
        // Show/hide content
        for (const [id, content] of Object.entries(this.tabContents)) {
            if (id === tabId) {
                content.removeClass('hidden');
                content.addClass('active');
            } else {
                content.addClass('hidden');
                content.removeClass('active');
            }
        }
    }
    
    /**
     * Add CSS styles for the modal (now implemented in styles.css)
     */
    private addStyles() {
        // All styles are now in the global styles.css file
    }
    
    /**
     * Get the configuration object for a specific OS
     * @param os Operating system (windows, mac, linux)
     * @returns Configuration object
     */
    /**
     * Update the configuration display based on selected mode
     */
    private async updateConfigDisplay() {
        // Update all tab contents with new configuration
        for (const tabId of Object.keys(this.tabContents)) {
            const content = this.tabContents[tabId];
            const codeBlock = content.querySelector('pre code') as HTMLElement | null;
            const copyButton = content.querySelector('button.mod-cta') as HTMLButtonElement | null;
            if (codeBlock && copyButton) {
                await this.populateTabConfig(tabId, codeBlock, copyButton);
            }
        }
    }

    /**
     * Get the configuration object for a specific OS
     * @param os Operating system (windows, mac, linux)
     * @returns Configuration object
     */
    /**
     * Get the configuration object for a specific OS
     * @param os Operating system (windows, mac, linux)
     * @returns Configuration object
     */
    private async getConfiguration(os: string) {
        const connectorPath = await this.getConnectorPath(os);
        const serverKey = getPrimaryServerKey(this.app.vault.getName());
        
        // Create server configuration
        const serverConfig = {
            command: "node",
            args: [connectorPath]
        };
        
        // Return different configurations based on setup type
        if (this.isFirstTimeSetup) {
            return {
                mcpServers: {
                    [serverKey]: serverConfig
                }
            };
        } else {
            return {
                [serverKey]: serverConfig
            };
        }
    }
    
    /**
     * Get the connector path for a specific OS
     * @param os Operating system (windows, mac, linux)
     * @returns Connector path
     */
    private async getConnectorPath(_os: string): Promise<string> {
        const vaultRoot = this.getVaultBasePath();
        const adapter = this.app.vault.adapter;
        const pluginFolders = getAllPluginIds();
        for (const folder of pluginFolders) {
            // Use vault-relative path for adapter checks
            const relativeConnectorPath = normalizePath(`.obsidian/plugins/${folder}/connector.js`);
            try {
                const exists = await adapter.exists(relativeConnectorPath);
                if (exists) {
                    // Prefer absolute path when available (desktop FileSystemAdapter)
                    if (vaultRoot) {
                        return path.join(vaultRoot, relativeConnectorPath);
                    }
                    return relativeConnectorPath;
                }
            } catch (error) {
                // Fall through and try next folder
            }
        }

        // Default to the primary folder even if we couldn't verify existence
        const fallbackRelative = normalizePath(`.obsidian/plugins/${pluginFolders[0]}/connector.js`);
        return vaultRoot ? path.join(vaultRoot, fallbackRelative) : fallbackRelative;
    }

    /**
     * Get a placeholder config synchronously for initial render
     * Updated asynchronously once paths resolve
     */
    private getConfigurationSyncPlaceholder() {
        const serverKey = getPrimaryServerKey(this.app.vault.getName());
        return {
            mcpServers: {
                [serverKey]: {
                    command: 'node',
                    args: ['<resolving connector path...>']
                }
            }
        };
    }

    /**
     * Populate tab config code block and copy handler once paths resolve
     */
    private async populateTabConfig(tabId: string, codeEl: HTMLElement, copyButton: HTMLButtonElement) {
        try {
            const config = await this.getConfiguration(tabId);
            codeEl.textContent = JSON.stringify(config, null, 2);
            copyButton.onclick = () => {
                navigator.clipboard.writeText(JSON.stringify(config, null, 2));
                copyButton.setText('Copied!');
                setTimeout(() => copyButton.setText('Copy Configuration'), 2000);
            };
        } catch (error) {
            console.error(`[ConfigModal] Failed to populate config for ${tabId}:`, error);
            codeEl.textContent = 'Failed to load configuration. See console for details.';
        }
    }

    /**
     * Resolve the vault's base filesystem path if available
     */
    private getVaultBasePath(): string | null {
        const adapter = this.app.vault.adapter;
        if (adapter instanceof FileSystemAdapter) {
            return adapter.getBasePath();
        }
        return null;
    }
    
    /**
     * Get the Windows config path
     * @returns Windows config path
     */
    private getWindowsConfigPath(): string {
        return path.join(process.env.APPDATA || '', 'Claude', 'claude_desktop_config.json');
    }
    
    /**
     * Get the Mac config path
     * @returns Mac config path
     */
    private getMacConfigPath(): string {
        return path.join(process.env.HOME || '', 'Library', 'Application Support', 'Claude', 'claude_desktop_config.json');
    }
    
    /**
     * Get the Linux config path
     * @returns Linux config path
     */
    private getLinuxConfigPath(): string {
        return path.join(process.env.HOME || '', '.config', 'Claude', 'claude_desktop_config.json');
    }
    
    /**
     * Called when the modal is closed
     */
    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

```

## components/llm-provider/index.ts

```typescript
/**
 * LLM Provider Modal Components
 *
 * Barrel exports for provider-specific modal components.
 */

// Types
export * from './types';

// Provider modals
export { NexusProviderModal } from './providers/NexusProviderModal';
export { OllamaProviderModal } from './providers/OllamaProviderModal';
export { LMStudioProviderModal } from './providers/LMStudioProviderModal';
export { GenericProviderModal } from './providers/GenericProviderModal';

```

## components/llm-provider/providers/GenericProviderModal.ts

```typescript
/**
 * GenericProviderModal
 *
 * Provider modal for API-key based providers (OpenAI, Anthropic, Google, etc.).
 * Handles API key input, validation, and model toggles.
 */

import { Setting, Notice } from 'obsidian';
import {
  IProviderModal,
  ProviderModalConfig,
  ProviderModalDependencies,
} from '../types';
import { LLMValidationService } from '../../../services/llm/validation/ValidationService';
import { ModelWithProvider } from '../../../services/StaticModelsService';

export class GenericProviderModal implements IProviderModal {
  private config: ProviderModalConfig;
  private deps: ProviderModalDependencies;

  // UI elements
  private container: HTMLElement | null = null;
  private apiKeyInput: HTMLInputElement | null = null;
  private modelsContainer: HTMLElement | null = null;

  // State
  private apiKey: string = '';
  private models: ModelWithProvider[] = [];
  private isValidated: boolean = false;
  private validationTimeout: ReturnType<typeof setTimeout> | null = null;

  constructor(config: ProviderModalConfig, deps: ProviderModalDependencies) {
    this.config = config;
    this.deps = deps;

    // Initialize from existing config
    this.apiKey = config.config.apiKey || '';
  }

  /**
   * Render the generic provider configuration UI
   */
  render(container: HTMLElement): void {
    this.container = container;
    container.empty();

    this.renderApiKeySection(container);
    this.renderModelsSection(container);
  }

  /**
   * Render API key input section
   */
  private renderApiKeySection(container: HTMLElement): void {
    container.createEl('h2', { text: 'API Key' });

    new Setting(container)
      .setDesc(`Enter your ${this.config.providerName} API key (format: ${this.config.keyFormat})`)
      .addText(text => {
        this.apiKeyInput = text.inputEl;
        this.apiKeyInput.type = 'password';
        this.apiKeyInput.addClass('llm-provider-input');

        text
          .setPlaceholder(`Enter your ${this.config.providerName} API key`)
          .setValue(this.apiKey)
          .onChange(value => {
            this.apiKey = value;
            this.handleApiKeyChange(value);
          });
      })
      .addButton(button => {
        button
          .setButtonText('Get Key')
          .setTooltip(`Open ${this.config.providerName} API key page`)
          .onClick(() => {
            window.open(this.config.signupUrl, '_blank');
          });
      });
  }

  /**
   * Handle API key input changes
   */
  private handleApiKeyChange(value: string): void {
    this.isValidated = false;

    if (this.apiKeyInput) {
      this.apiKeyInput.removeClass('success');
      this.apiKeyInput.removeClass('error');
    }

    // Clear validation cache
    this.config.config.lastValidated = undefined;
    this.config.config.validationHash = undefined;

    // Clear existing timeout
    if (this.validationTimeout) {
      clearTimeout(this.validationTimeout);
      this.validationTimeout = null;
    }

    if (value.trim()) {
      this.apiKeyInput?.addClass('validating');

      // Auto-validate after delay
      this.validationTimeout = setTimeout(() => {
        this.validateApiKey();
      }, 2000);

      // Auto-enable
      if (!this.config.config.enabled) {
        this.config.config.enabled = true;
        this.saveConfig();
      }
    } else {
      this.apiKeyInput?.removeClass('validating');
    }
  }

  /**
   * Render models section
   */
  private renderModelsSection(container: HTMLElement): void {
    container.createEl('h2', { text: 'Available Models' });
    this.modelsContainer = container.createDiv('models-container');

    this.loadModels();
  }

  /**
   * Load models from static service
   */
  private loadModels(): void {
    if (!this.modelsContainer) return;

    try {
      this.models = this.deps.staticModelsService.getModelsForProvider(this.config.providerId);
      this.displayModels();
    } catch (error) {
      console.error('[GenericProvider] Error loading models:', error);
      this.modelsContainer.empty();
      const errorDiv = this.modelsContainer.createDiv('models-error');
      const titleP = errorDiv.createEl('p');
      titleP.createEl('strong', { text: 'Error loading models:' });
      errorDiv.createEl('p', { text: error instanceof Error ? error.message : 'Unknown error' });
    }
  }

  /**
   * Display loaded models with toggles
   */
  private displayModels(): void {
    if (!this.modelsContainer) return;
    this.modelsContainer.empty();

    if (this.models.length === 0) {
      this.modelsContainer.createDiv('models-empty')
        .textContent = 'No models available. Check your API key and try again.';
      return;
    }

    const modelsList = this.modelsContainer.createDiv('models-list');

    this.models.forEach(model => {
      const modelEl = modelsList.createDiv('model-item');

      const modelRow = modelEl.createDiv('model-row');
      modelRow.addClass('llm-provider-model-row');

      // Model name
      const modelNameEl = modelRow.createDiv('model-name llm-provider-model-name');
      modelNameEl.textContent = model.name;

      // Model toggle
      const currentEnabled = this.config.config.models?.[model.id]?.enabled ?? true;
      const toggleContainer = modelRow.createDiv('model-toggle-container');
      toggleContainer.addClass('llm-provider-model-toggle');

      new Setting(toggleContainer)
        .addToggle(toggle => toggle
          .setValue(currentEnabled)
          .onChange(enabled => {
            // Initialize models object if needed
            if (!this.config.config.models) {
              this.config.config.models = {};
            }
            if (!this.config.config.models[model.id]) {
              this.config.config.models[model.id] = { enabled: true };
            }

            this.config.config.models[model.id].enabled = enabled;
            this.saveConfig();
          })
        );
    });
  }

  /**
   * Validate API key
   */
  private async validateApiKey(): Promise<void> {
    const apiKey = this.apiKey.trim();

    if (!apiKey) {
      new Notice('Please enter an API key first');
      return;
    }

    this.apiKeyInput?.removeClass('success');
    this.apiKeyInput?.removeClass('error');
    this.apiKeyInput?.addClass('validating');

    try {
      const result = await LLMValidationService.validateApiKey(
        this.config.providerId,
        apiKey,
        {
          forceValidation: true,
          providerConfig: this.config.config,
          onValidationSuccess: (hash: string, timestamp: number) => {
            this.config.config.lastValidated = timestamp;
            this.config.config.validationHash = hash;
          }
        }
      );

      if (result.success) {
        this.isValidated = true;
        this.apiKeyInput?.removeClass('validating');
        this.apiKeyInput?.removeClass('error');
        this.apiKeyInput?.addClass('success');

        this.config.config.apiKey = apiKey;
        this.config.config.enabled = true;
        this.saveConfig();

        new Notice(`${this.config.providerName} API key validated successfully!`);
      } else {
        throw new Error(result.error || 'API key validation failed');
      }

    } catch (error) {
      console.error('[GenericProvider] Validation failed:', error);

      this.isValidated = false;
      this.apiKeyInput?.removeClass('validating');
      this.apiKeyInput?.removeClass('success');
      this.apiKeyInput?.addClass('error');

      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      new Notice(`${this.config.providerName} API key validation failed: ${errorMessage}`);
    }
  }

  /**
   * Save configuration
   */
  private saveConfig(): void {
    this.config.onConfigChange(this.config.config);
  }

  /**
   * Get current configuration
   */
  getConfig(): import('../../../types').LLMProviderConfig {
    return {
      ...this.config.config,
      apiKey: this.apiKey,
    };
  }

  /**
   * Clean up resources
   */
  destroy(): void {
    if (this.validationTimeout) {
      clearTimeout(this.validationTimeout);
      this.validationTimeout = null;
    }

    this.container = null;
    this.apiKeyInput = null;
    this.modelsContainer = null;
  }
}

```

## components/llm-provider/providers/LMStudioProviderModal.ts

```typescript
/**
 * LMStudioProviderModal
 *
 * Provider modal for LM Studio - local LLM server with OpenAI-compatible API.
 * Handles server URL configuration and automatic model discovery.
 */

import { Setting, Notice, requestUrl } from 'obsidian';
import {
  IProviderModal,
  ProviderModalConfig,
  ProviderModalDependencies,
} from '../types';

export class LMStudioProviderModal implements IProviderModal {
  private config: ProviderModalConfig;
  private deps: ProviderModalDependencies;

  // UI elements
  private container: HTMLElement | null = null;
  private urlInput: HTMLInputElement | null = null;
  private discoverButton: HTMLButtonElement | null = null;
  private modelsContainer: HTMLElement | null = null;

  // State
  private serverUrl: string = 'http://127.0.0.1:1234';
  private discoveredModels: string[] = [];
  private isValidated: boolean = false;
  private validationTimeout: ReturnType<typeof setTimeout> | null = null;

  constructor(config: ProviderModalConfig, deps: ProviderModalDependencies) {
    this.config = config;
    this.deps = deps;

    // Initialize from existing config
    this.serverUrl = config.config.apiKey || 'http://127.0.0.1:1234';
  }

  /**
   * Render the LM Studio provider configuration UI
   */
  render(container: HTMLElement): void {
    this.container = container;
    container.empty();

    this.renderServerSection(container);
    this.renderModelsSection(container);
    this.renderHelpSection(container);
  }

  /**
   * Render server URL configuration section
   */
  private renderServerSection(container: HTMLElement): void {
    container.createEl('h2', { text: 'Server URL' });

    new Setting(container)
      .setDesc('Enter your LM Studio server URL (default: http://127.0.0.1:1234)')
      .addText(text => {
        this.urlInput = text.inputEl;
        this.urlInput.addClass('llm-provider-input');

        text
          .setPlaceholder('http://127.0.0.1:1234')
          .setValue(this.serverUrl)
          .onChange(value => {
            this.serverUrl = value;
            this.handleUrlChange(value);
          });
      })
      .addButton(button => {
        this.discoverButton = button.buttonEl;
        button
          .setButtonText('Discover Models')
          .setTooltip('Connect to LM Studio server and discover available models')
          .onClick(() => this.discoverModels());
      });
  }

  /**
   * Handle URL input changes
   */
  private handleUrlChange(value: string): void {
    this.isValidated = false;

    if (this.urlInput) {
      this.urlInput.removeClass('success');
      this.urlInput.removeClass('error');
    }

    // Clear validation cache
    this.config.config.lastValidated = undefined;
    this.config.config.validationHash = undefined;

    // Clear existing timeout
    if (this.validationTimeout) {
      clearTimeout(this.validationTimeout);
      this.validationTimeout = null;
    }

    if (value.trim()) {
      this.urlInput?.addClass('validating');

      // Auto-discover after delay
      this.validationTimeout = setTimeout(() => {
        this.discoverModels();
      }, 2000);

      // Auto-enable
      if (!this.config.config.enabled) {
        this.config.config.enabled = true;
        this.saveConfig();
      }
    } else {
      this.urlInput?.removeClass('validating');
    }
  }

  /**
   * Render models section
   */
  private renderModelsSection(container: HTMLElement): void {
    container.createEl('h2', { text: 'Models' });
    this.modelsContainer = container.createDiv('lmstudio-models-container');
    this.updateModelsDisplay();
  }

  /**
   * Update models display
   */
  private updateModelsDisplay(): void {
    if (!this.modelsContainer) return;
    this.modelsContainer.empty();

    const descDiv = this.modelsContainer.createDiv('setting-item-description');

    if (this.discoveredModels.length > 0) {
      const titleP = descDiv.createEl('p');
      titleP.createEl('strong', { text: `Discovered Models (${this.discoveredModels.length}):` });

      const ul = descDiv.createEl('ul');
      ul.addClass('llm-provider-model-list');

      this.discoveredModels.forEach(model => {
        const li = ul.createEl('li');
        li.createEl('code', { text: model });
      });
    } else {
      const p = descDiv.createEl('p');
      p.createEl('em', { text: 'No models discovered yet. Click "Discover Models" to scan the server.' });
    }
  }

  /**
   * Render help section
   */
  private renderHelpSection(container: HTMLElement): void {
    const helpDiv = container.createDiv('setting-item');
    const descDiv = helpDiv.createDiv('setting-item-description');

    const details = descDiv.createEl('details');
    const summary = details.createEl('summary', { text: 'Setup Help' });
    summary.addClass('llm-provider-help-summary');

    const contentDiv = details.createDiv();
    contentDiv.addClass('llm-provider-help-content');

    const titleP = contentDiv.createEl('p');
    titleP.createEl('strong', { text: 'To configure LM Studio:' });

    const ol = contentDiv.createEl('ol');
    ol.addClass('llm-provider-help-list');
    ol.createEl('li', { text: 'Open LM Studio and load your desired model(s)' });
    ol.createEl('li', { text: 'Start the local server (usually on port 1234)' });
    ol.createEl('li', { text: 'Click "Discover Models" to fetch available models' });
    ol.createEl('li', { text: 'The first discovered model will be used by default' });
  }

  /**
   * Discover models from LM Studio server
   */
  private async discoverModels(): Promise<void> {
    const serverUrl = this.serverUrl.trim();

    if (!serverUrl) {
      new Notice('Please enter a server URL first');
      return;
    }

    // Validate URL format
    try {
      new URL(serverUrl);
    } catch {
      new Notice('Please enter a valid URL (e.g., http://127.0.0.1:1234)');
      return;
    }

    // Show discovering state
    if (this.discoverButton) {
      this.discoverButton.textContent = 'Discovering...';
      this.discoverButton.disabled = true;
    }

    try {
      // Query LM Studio's OpenAI-compatible /v1/models endpoint
      const modelsResponse = await requestUrl({
        url: `${serverUrl}/v1/models`,
        method: 'GET'
      });

      if (modelsResponse.status !== 200) {
        throw new Error(`Server not responding: ${modelsResponse.status}. Make sure LM Studio server is running.`);
      }

      const modelsData = modelsResponse.json;

      if (!modelsData.data || !Array.isArray(modelsData.data)) {
        throw new Error('Invalid response format from LM Studio server');
      }

      // Extract model IDs
      this.discoveredModels = modelsData.data.map((model: any) => model.id);

      if (this.discoveredModels.length === 0) {
        new Notice('No models loaded in LM Studio. Please load a model first.');
        return;
      }

      new Notice(`LM Studio connected! Discovered ${this.discoveredModels.length} model(s).`);

      this.isValidated = true;
      this.urlInput?.removeClass('validating');
      this.urlInput?.removeClass('error');
      this.urlInput?.addClass('success');

      // Save validated config
      this.config.config.apiKey = serverUrl;
      this.config.config.enabled = true;
      this.saveConfig();

      // Update models display
      this.updateModelsDisplay();

    } catch (error) {
      console.error('[LMStudioProvider] Discovery failed:', error);

      this.isValidated = false;
      this.urlInput?.removeClass('validating');
      this.urlInput?.removeClass('success');
      this.urlInput?.addClass('error');

      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      new Notice(`LM Studio discovery failed: ${errorMessage}`);
    } finally {
      if (this.discoverButton) {
        this.discoverButton.textContent = 'Discover Models';
        this.discoverButton.disabled = false;
      }
    }
  }

  /**
   * Save configuration
   */
  private saveConfig(): void {
    this.config.onConfigChange(this.config.config);
  }

  /**
   * Get current configuration
   */
  getConfig(): import('../../../types').LLMProviderConfig {
    return {
      ...this.config.config,
      apiKey: this.serverUrl,
    };
  }

  /**
   * Clean up resources
   */
  destroy(): void {
    if (this.validationTimeout) {
      clearTimeout(this.validationTimeout);
      this.validationTimeout = null;
    }

    this.container = null;
    this.urlInput = null;
    this.discoverButton = null;
    this.modelsContainer = null;
  }
}

```

## components/llm-provider/providers/NexusProviderModal.ts

```typescript
/**
 * NexusProviderModal
 *
 * Minimal modal for Nexus model management.
 * Handles: GPU detection, model download, cache management.
 * Does NOT handle: Loading models to GPU (done in ChatView).
 */

import { Setting, Notice } from 'obsidian';
import {
  IProviderModal,
  ProviderModalConfig,
  ProviderModalDependencies,
} from '../types';
import { WebLLMVRAMDetector } from '../../../services/llm/adapters/webllm/WebLLMVRAMDetector';
import { WebLLMAdapter } from '../../../services/llm/adapters/webllm/WebLLMAdapter';
import { VRAMInfo, WebLLMModelSpec } from '../../../services/llm/adapters/webllm/types';
import { WEBLLM_MODELS, getModelsForVRAM, getWebLLMModel } from '../../../services/llm/adapters/webllm/WebLLMModels';

type DeviceStatus = 'checking' | 'compatible' | 'limited' | 'incompatible';

/**
 * Extended HTMLElement with download progress tracking properties.
 * These properties are attached to the action area container to enable
 * live UI updates during download without full re-renders.
 */
interface ActionAreaWithProgress extends HTMLElement {
  _progressFill?: HTMLElement;
  _statusText?: HTMLElement;
}

export class NexusProviderModal implements IProviderModal {
  private config: ProviderModalConfig;

  // UI containers
  private deviceCard: HTMLElement | null = null;
  private modelSection: HTMLElement | null = null;
  private actionArea: ActionAreaWithProgress | null = null;

  // State
  private vramInfo: VRAMInfo | null = null;
  private adapter: WebLLMAdapter | null = null;
  private selectedModelId: string = '';
  private cachedModels: Map<string, boolean> = new Map();
  private isDownloading: boolean = false;
  private downloadProgress: number = 0;
  private downloadStage: string = '';

  constructor(config: ProviderModalConfig, deps: ProviderModalDependencies) {
    this.config = config;
    this.selectedModelId = config.config.webllmModel || WEBLLM_MODELS[0]?.id || '';
    this.adapter = new WebLLMAdapter(deps.vault);
  }

  /**
   * Main render entry point
   */
  render(container: HTMLElement): void {
    container.empty();
    container.addClass('nexus-modal');

    // Description at top
    container.createEl('p', {
      text: 'Run AI locally on your device. Works offline, completely private, no API costs.',
      cls: 'nexus-description'
    });

    // Device card
    this.deviceCard = container.createDiv('nexus-device-card');
    this.renderDeviceCard('checking');

    // Model section (hidden until device check complete)
    this.modelSection = container.createDiv('nexus-model-section');
    this.modelSection.addClass('llm-provider-hidden');

    // Start device detection
    this.detectDevice();
  }

  /**
   * Detect GPU capabilities and update UI
   */
  private async detectDevice(): Promise<void> {
    try {
      this.vramInfo = await WebLLMVRAMDetector.detect();

      if (!this.vramInfo.webGPUSupported) {
        this.renderDeviceCard('incompatible');
        return;
      }

      const availableModels = getModelsForVRAM(this.vramInfo.estimatedVRAM);

      if (availableModels.length === 0) {
        this.renderDeviceCard('limited');
        return;
      }

      // Check cache for all compatible models
      await this.checkAllModelCache(availableModels);

      this.renderDeviceCard('compatible');

      // Auto-enable provider
      if (!this.config.config.enabled) {
        this.config.config.enabled = true;
        this.config.onConfigChange(this.config.config);
      }

      // Show model section
      if (this.modelSection) {
        this.modelSection.removeClass('llm-provider-hidden');
        this.modelSection.addClass('llm-provider-visible');
        this.renderModelSection(availableModels);
      }

    } catch (error) {
      console.error('[NexusModal] Device detection failed:', error);
      this.renderDeviceCard('incompatible', error instanceof Error ? error.message : 'Detection failed');
    }
  }

  /**
   * Render device status - only show if there's a problem
   */
  private renderDeviceCard(status: DeviceStatus, errorMessage?: string): void {
    if (!this.deviceCard) return;
    this.deviceCard.empty();

    // Only show status for checking, limited, or incompatible
    if (status === 'checking') {
      const row = this.deviceCard.createDiv('nexus-device-row');
      row.createSpan({ text: 'â—Œ', cls: 'nexus-device-icon nexus-icon-spin' });
      row.createSpan({ text: 'Checking compatibility...', cls: 'nexus-device-text' });
      return;
    }

    if (status === 'compatible') {
      // Don't show anything - everything is fine
      return;
    }

    if (status === 'limited') {
      const row = this.deviceCard.createDiv('nexus-device-row nexus-device-warning');
      row.createSpan({ text: 'âš ', cls: 'nexus-device-icon' });
      row.createSpan({ text: 'Limited GPU memory - smaller models only', cls: 'nexus-device-text' });
      return;
    }

    // Incompatible
    const row = this.deviceCard.createDiv('nexus-device-row nexus-device-error');
    row.createSpan({ text: 'âœ—', cls: 'nexus-device-icon' });
    row.createSpan({
      text: errorMessage || 'WebGPU not supported (requires Chrome 113+, Edge 113+, or Safari 17+)',
      cls: 'nexus-device-text'
    });
  }

  /**
   * Check browser cache for all models
   */
  private async checkAllModelCache(models: WebLLMModelSpec[]): Promise<void> {
    for (const model of models) {
      const isCached = await this.isModelCached(model.id);
      this.cachedModels.set(model.id, isCached);
    }
  }

  /**
   * Check if a specific model is cached
   */
  private async isModelCached(modelId: string): Promise<boolean> {
    try {
      if (!('caches' in window)) return false;

      const cacheNames = await caches.keys();

      // WebLLM uses cache names containing the model ID
      return cacheNames.some(name => {
        const lowerName = name.toLowerCase();
        const lowerModelId = modelId.toLowerCase();
        return lowerName.includes('webllm') ||
               lowerName.includes('tvmjs') ||
               lowerName.includes(lowerModelId);
      });
    } catch {
      return false;
    }
  }

  /**
   * Render model selection section
   */
  private renderModelSection(availableModels: WebLLMModelSpec[]): void {
    if (!this.modelSection) return;
    this.modelSection.empty();

    // Ensure selected model is valid
    const selectedModel = getWebLLMModel(this.selectedModelId) || availableModels[0];
    if (selectedModel) {
      this.selectedModelId = selectedModel.id;
    }

    // Model dropdown
    const dropdownContainer = this.modelSection.createDiv('nexus-dropdown-container');
    dropdownContainer.createEl('label', { text: 'Model', cls: 'nexus-label' });

    new Setting(dropdownContainer)
      .addDropdown(dropdown => {
        availableModels.forEach(model => {
          dropdown.addOption(model.id, model.name);
        });

        dropdown.setValue(this.selectedModelId);
        dropdown.onChange(async (value) => {
          this.selectedModelId = value;
          this.config.config.webllmModel = value;

          // Extract quantization
          const match = value.match(/(q[458]f16)/);
          if (match) {
            this.config.config.webllmQuantization = match[1] as 'q4f16' | 'q5f16' | 'q8f16';
          }

          this.config.onConfigChange(this.config.config);
          this.renderActionArea();
        });
      });

    // Action area
    this.actionArea = this.modelSection.createDiv('nexus-action-area') as ActionAreaWithProgress;
    this.renderActionArea();
  }

  /**
   * Render action area based on current state
   */
  private renderActionArea(): void {
    if (!this.actionArea) return;
    this.actionArea.empty();

    const model = getWebLLMModel(this.selectedModelId);
    if (!model) return;

    const isCached = this.cachedModels.get(this.selectedModelId) || false;

    if (this.isDownloading) {
      this.renderDownloadProgress();
    } else if (isCached) {
      this.renderDownloadedState();
    } else {
      this.renderDownloadButton(model);
    }
  }

  /**
   * Render download button using native Obsidian Setting
   */
  private renderDownloadButton(model: WebLLMModelSpec): void {
    if (!this.actionArea) return;

    new Setting(this.actionArea)
      .setClass('nexus-download-setting')
      .addButton(button => button
        .setButtonText(`Download Â· ${model.vramRequired} GB`)
        .setCta()
        .onClick(() => this.startDownload(model)));
  }

  /**
   * Render downloaded state - just delete button (dropdown already shows "Saved")
   */
  private renderDownloadedState(): void {
    if (!this.actionArea) return;

    new Setting(this.actionArea)
      .setClass('nexus-delete-setting')
      .addButton(button => {
        const btn = button
          .setButtonText('Delete from cache')
          .setWarning()
          .onClick(async () => {
            btn.setButtonText('Deleting...');
            btn.setDisabled(true);

            try {
              await this.clearModelCache();
              this.cachedModels.set(this.selectedModelId, false);
              new Notice('Model deleted from cache');
              this.renderActionArea();
            } catch (error) {
              new Notice(`Failed to delete: ${error instanceof Error ? error.message : 'Unknown error'}`);
              btn.setButtonText('Delete from cache');
              btn.setDisabled(false);
            }
          });
        return btn;
      });
  }

  /**
   * Render download progress
   */
  private renderDownloadProgress(): void {
    if (!this.actionArea) return;

    const container = this.actionArea.createDiv('nexus-progress-container');

    // Progress bar
    const barBg = container.createDiv('nexus-progress-bar');
    const barFill = barBg.createDiv('nexus-progress-fill');
    barFill.addClass('llm-provider-progress-fill');
    barFill.style.width = `${this.downloadProgress}%`;

    // Status row with progress text
    const statusRow = container.createDiv('nexus-progress-row');
    const statusText = statusRow.createSpan({
      text: `${this.downloadStage} Â· ${this.downloadProgress}%`,
      cls: 'nexus-progress-text'
    });

    // Cancel button using Setting API for proper Obsidian styling
    new Setting(statusRow)
      .setClass('nexus-cancel-setting')
      .addButton(button => button
        .setButtonText('Cancel')
        .onClick(() => {
          this.isDownloading = false;
          this.downloadProgress = 0;
          this.downloadStage = '';
          this.renderActionArea();
        }));

    // Store references for live updates during download
    if (this.actionArea) {
      this.actionArea._progressFill = barFill;
      this.actionArea._statusText = statusText;
    }
  }

  /**
   * Start model download
   */
  private async startDownload(model: WebLLMModelSpec): Promise<void> {
    if (!this.adapter) return;

    this.isDownloading = true;
    this.downloadProgress = 0;
    this.downloadStage = 'Initializing';
    this.renderActionArea();

    try {
      await this.adapter.initialize();

      await this.adapter.loadModel(model, (progress: number, stage: string) => {
        if (!this.isDownloading) return; // Cancelled

        this.downloadProgress = Math.round(progress * 100);
        this.downloadStage = stage;

        // Update UI without full re-render
        if (this.actionArea) {
          const fill = this.actionArea._progressFill;
          const text = this.actionArea._statusText;
          if (fill) {
            fill.style.width = `${this.downloadProgress}%`;
          }
          if (text) {
            text.textContent = `${stage} Â· ${this.downloadProgress}%`;
          }
        }
      });

      // Download complete
      this.isDownloading = false;
      this.cachedModels.set(this.selectedModelId, true);

      // Unload from GPU - we only wanted to download
      if (this.adapter.isModelLoaded()) {
        await this.adapter.unloadModel();
      }

      new Notice(`${model.name} downloaded successfully!`);
      this.renderActionArea();

    } catch (error) {
      console.error('[NexusModal] Download failed:', error);
      this.isDownloading = false;
      new Notice(`Download failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      this.renderActionArea();
    }
  }

  /**
   * Clear browser cache for WebLLM models
   */
  private async clearModelCache(): Promise<void> {
    if ('caches' in window) {
      const cacheNames = await caches.keys();
      for (const name of cacheNames) {
        if (name.includes('webllm') || name.includes('tvmjs') || name.includes('mlc')) {
          await caches.delete(name);
        }
      }
    }

    if ('indexedDB' in window) {
      const databases = await indexedDB.databases?.() || [];
      for (const db of databases) {
        if (db.name && (db.name.includes('webllm') || db.name.includes('tvmjs') || db.name.includes('mlc'))) {
          indexedDB.deleteDatabase(db.name);
        }
      }
    }
  }

  /**
   * Get current configuration
   */
  getConfig(): import('../../../types').LLMProviderConfig {
    return {
      ...this.config.config,
      webllmModel: this.selectedModelId,
    };
  }

  /**
   * Clean up resources
   */
  destroy(): void {
    this.deviceCard = null;
    this.modelSection = null;
    this.actionArea = null;
  }
}

```

## components/llm-provider/providers/OllamaProviderModal.ts

```typescript
/**
 * OllamaProviderModal
 *
 * Provider modal for Ollama - local LLM server.
 * Handles server URL configuration, model name input, and connection testing.
 */

import { Setting, Notice, requestUrl } from 'obsidian';
import {
  IProviderModal,
  ProviderModalConfig,
  ProviderModalDependencies,
} from '../types';

export class OllamaProviderModal implements IProviderModal {
  private config: ProviderModalConfig;
  private deps: ProviderModalDependencies;

  // UI elements
  private container: HTMLElement | null = null;
  private urlInput: HTMLInputElement | null = null;
  private modelInput: HTMLInputElement | null = null;
  private testButton: HTMLButtonElement | null = null;

  // State
  private serverUrl: string = 'http://127.0.0.1:11434';
  private modelName: string = '';
  private isValidated: boolean = false;
  private validationTimeout: ReturnType<typeof setTimeout> | null = null;

  constructor(config: ProviderModalConfig, deps: ProviderModalDependencies) {
    this.config = config;
    this.deps = deps;

    // Initialize from existing config
    this.serverUrl = config.config.apiKey || 'http://127.0.0.1:11434';
    this.modelName = config.config.ollamaModel || '';
  }

  /**
   * Render the Ollama provider configuration UI
   */
  render(container: HTMLElement): void {
    this.container = container;
    container.empty();

    this.renderServerSection(container);
    this.renderModelSection(container);
    this.renderHelpSection(container);
  }

  /**
   * Render server URL configuration section
   */
  private renderServerSection(container: HTMLElement): void {
    container.createEl('h2', { text: 'Server URL' });

    new Setting(container)
      .setDesc('Enter your Ollama server URL (default: http://127.0.0.1:11434)')
      .addText(text => {
        this.urlInput = text.inputEl;
        this.urlInput.addClass('llm-provider-input');

        text
          .setPlaceholder('http://127.0.0.1:11434')
          .setValue(this.serverUrl)
          .onChange(value => {
            this.serverUrl = value;
            this.handleUrlChange(value);
          });
      })
      .addButton(button => {
        this.testButton = button.buttonEl;
        button
          .setButtonText('Test Connection')
          .setTooltip('Test connection to Ollama server with the configured model')
          .onClick(() => this.testConnection());
      });
  }

  /**
   * Handle URL input changes
   */
  private handleUrlChange(value: string): void {
    this.isValidated = false;

    if (this.urlInput) {
      this.urlInput.removeClass('success');
      this.urlInput.removeClass('error');
    }

    // Clear validation cache
    this.config.config.lastValidated = undefined;
    this.config.config.validationHash = undefined;

    // Clear existing timeout
    if (this.validationTimeout) {
      clearTimeout(this.validationTimeout);
      this.validationTimeout = null;
    }

    if (value.trim()) {
      this.urlInput?.addClass('validating');

      // Auto-validate after delay
      this.validationTimeout = setTimeout(() => {
        if (this.modelName.trim()) {
          this.testConnection();
        }
      }, 2000);

      // Auto-enable
      if (!this.config.config.enabled) {
        this.config.config.enabled = true;
        this.saveConfig();
      }
    } else {
      this.urlInput?.removeClass('validating');
    }
  }

  /**
   * Render model configuration section
   */
  private renderModelSection(container: HTMLElement): void {
    container.createEl('h2', { text: 'Model' });

    new Setting(container)
      .setName('Default Model')
      .setDesc('Enter the name of the Ollama model to use')
      .addText(text => {
        this.modelInput = text.inputEl;

        text
          .setPlaceholder('e.g., llama3.1, mistral, phi3')
          .setValue(this.modelName)
          .onChange(value => {
            this.modelName = value;
            this.config.config.ollamaModel = value;

            if (value.trim()) {
              this.saveConfig();
            }
          });
      });
  }

  /**
   * Render help section
   */
  private renderHelpSection(container: HTMLElement): void {
    const helpDiv = container.createDiv('setting-item');
    const descDiv = helpDiv.createDiv('setting-item-description');

    const details = descDiv.createEl('details');
    const summary = details.createEl('summary', { text: 'Setup Help' });
    summary.addClass('llm-provider-help-summary');

    const contentDiv = details.createDiv();
    contentDiv.addClass('llm-provider-help-content');

    const titleP = contentDiv.createEl('p');
    titleP.createEl('strong', { text: 'To configure Ollama:' });

    const ol = contentDiv.createEl('ol');
    ol.addClass('llm-provider-help-list');

    const li1 = ol.createEl('li');
    li1.appendText('Install the model: ');
    li1.createEl('code', { text: 'ollama pull [model-name]' });

    ol.createEl('li', { text: 'Common models: llama3.1, mistral, codellama, phi3, gemma' });

    const li3 = ol.createEl('li');
    li3.appendText('View installed models: ');
    li3.createEl('code', { text: 'ollama list' });

    ol.createEl('li', { text: 'Enter the exact model name above' });
  }

  /**
   * Test connection to Ollama server
   */
  private async testConnection(): Promise<void> {
    const serverUrl = this.serverUrl.trim();
    const modelName = this.modelName.trim();

    if (!serverUrl) {
      new Notice('Please enter a server URL first');
      return;
    }

    if (!modelName) {
      new Notice('Please enter a model name first');
      return;
    }

    // Validate URL format
    try {
      new URL(serverUrl);
    } catch {
      new Notice('Please enter a valid URL (e.g., http://127.0.0.1:11434)');
      return;
    }

    // Show testing state
    if (this.testButton) {
      this.testButton.textContent = 'Testing...';
      this.testButton.disabled = true;
    }

    try {
      // Test if server is running
      const serverResponse = await requestUrl({
        url: `${serverUrl}/api/tags`,
        method: 'GET'
      });

      if (serverResponse.status !== 200) {
        throw new Error(`Server not responding: ${serverResponse.status}`);
      }

      // Check if model is available
      const serverData = serverResponse.json;
      const availableModels = serverData.models || [];
      const modelExists = availableModels.some((model: any) => model.name === modelName);

      if (!modelExists) {
        const modelList = availableModels.map((m: any) => m.name).join(', ') || 'none';
        new Notice(`Model '${modelName}' not found. Available: ${modelList}`);
        return;
      }

      // Test model with simple generation
      const testResponse = await requestUrl({
        url: `${serverUrl}/api/generate`,
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: modelName,
          prompt: 'Hello',
          stream: false,
          options: { num_predict: 5 }
        })
      });

      if (testResponse.status !== 200) {
        throw new Error(`Model test failed: ${testResponse.status}`);
      }

      const testData = testResponse.json;
      if (testData.response) {
        new Notice(`Ollama connection successful! Model '${modelName}' is working.`);

        this.isValidated = true;
        this.urlInput?.removeClass('validating');
        this.urlInput?.removeClass('error');
        this.urlInput?.addClass('success');

        // Save validated config
        this.config.config.apiKey = serverUrl;
        this.config.config.enabled = true;
        this.config.config.ollamaModel = this.modelName;
        this.saveConfig();
      } else {
        throw new Error('Model test returned invalid response');
      }

    } catch (error) {
      console.error('[OllamaProvider] Connection test failed:', error);

      this.isValidated = false;
      this.urlInput?.removeClass('validating');
      this.urlInput?.removeClass('success');
      this.urlInput?.addClass('error');

      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      new Notice(`Ollama test failed: ${errorMessage}`);
    } finally {
      if (this.testButton) {
        this.testButton.textContent = 'Test Connection';
        this.testButton.disabled = false;
      }
    }
  }

  /**
   * Save configuration
   */
  private saveConfig(): void {
    this.config.onConfigChange(this.config.config);
  }

  /**
   * Get current configuration
   */
  getConfig(): import('../../../types').LLMProviderConfig {
    return {
      ...this.config.config,
      apiKey: this.serverUrl,
      ollamaModel: this.modelName,
    };
  }

  /**
   * Clean up resources
   */
  destroy(): void {
    if (this.validationTimeout) {
      clearTimeout(this.validationTimeout);
      this.validationTimeout = null;
    }

    this.container = null;
    this.urlInput = null;
    this.modelInput = null;
    this.testButton = null;
  }
}

```

## components/llm-provider/types.ts

```typescript
/**
 * LLM Provider Modal Types
 *
 * Shared interfaces for provider-specific modal components.
 * Each provider (Nexus, Ollama, LM Studio, Generic API) implements IProviderModal.
 */

import { App, Vault } from 'obsidian';
import { LLMProviderConfig } from '../../types';
import { LLMProviderManager } from '../../services/llm/providers/ProviderManager';
import { StaticModelsService } from '../../services/StaticModelsService';

/**
 * Interface for provider-specific modal content
 * Each provider implements this to render its configuration UI
 */
export interface IProviderModal {
  /**
   * Render the provider-specific content into the container
   */
  render(container: HTMLElement): void;

  /**
   * Validate the current configuration
   * @returns true if valid, false otherwise
   */
  validate?(): Promise<boolean>;

  /**
   * Get the current configuration to save
   */
  getConfig(): LLMProviderConfig;

  /**
   * Clean up resources when modal closes
   */
  destroy(): void;
}

/**
 * Configuration passed to provider modals
 */
export interface ProviderModalConfig {
  /** Provider identifier (e.g., 'webllm', 'ollama', 'openai') */
  providerId: string;

  /** Display name for the provider */
  providerName: string;

  /** Format hint for API key (e.g., 'sk-...') */
  keyFormat: string;

  /** URL to get API key */
  signupUrl: string;

  /** Current provider configuration */
  config: LLMProviderConfig;

  /** Callback when configuration changes (for auto-save) */
  onConfigChange: (config: LLMProviderConfig) => void;
}

/**
 * Dependencies injected into provider modals
 */
export interface ProviderModalDependencies {
  app: App;
  vault: Vault;
  providerManager: LLMProviderManager;
  staticModelsService: StaticModelsService;
}

/**
 * Nexus (WebLLM) model states
 */
export type NexusModelState =
  | 'not_downloaded'  // Model not in browser cache
  | 'downloading'     // Currently downloading from HuggingFace
  | 'downloaded'      // In browser cache, not loaded to GPU
  | 'loading'         // Loading into GPU memory
  | 'loaded'          // Ready for inference in GPU
  | 'error';          // Error state

/**
 * Nexus loading progress callback
 */
export interface NexusLoadingCallbacks {
  onLoadStart?: () => void;
  onLoadProgress?: (progress: number, stage: string) => void;
  onLoadComplete?: () => void;
  onLoadError?: (error: string) => void;
}

```

## components/LLMProviderModal.ts

```typescript
/**
 * LLMProviderModal - Thin Orchestrator
 *
 * Modal for configuring LLM providers. Delegates to provider-specific
 * modal components based on the provider type.
 *
 * SOLID Refactoring: Reduced from 1,178 lines to ~150 lines.
 * Provider-specific logic extracted to:
 * - NexusProviderModal (WebLLM/local GPU)
 * - OllamaProviderModal (local server)
 * - LMStudioProviderModal (local server)
 * - GenericProviderModal (API-key providers)
 */

import { Modal, App, Notice } from 'obsidian';
import { LLMProviderConfig } from '../types';
import { LLMProviderManager } from '../services/llm/providers/ProviderManager';
import { StaticModelsService } from '../services/StaticModelsService';
import {
  IProviderModal,
  ProviderModalConfig,
  ProviderModalDependencies,
} from './llm-provider/types';
import { NexusProviderModal } from './llm-provider/providers/NexusProviderModal';
import { OllamaProviderModal } from './llm-provider/providers/OllamaProviderModal';
import { LMStudioProviderModal } from './llm-provider/providers/LMStudioProviderModal';
import { GenericProviderModal } from './llm-provider/providers/GenericProviderModal';

/**
 * Configuration for LLMProviderModal
 * Kept for backward compatibility with existing callers
 */
export interface LLMProviderModalConfig {
  providerId: string;
  providerName: string;
  keyFormat: string;
  signupUrl: string;
  config: LLMProviderConfig;
  onSave: (config: LLMProviderConfig) => void;
}

/**
 * LLM Provider Configuration Modal
 * Thin orchestrator that delegates to provider-specific modal components
 */
export class LLMProviderModal extends Modal {
  private config: LLMProviderModalConfig;
  private providerManager: LLMProviderManager;
  private staticModelsService: StaticModelsService;

  // Provider-specific modal component
  private providerModal: IProviderModal | null = null;

  // Auto-save state
  private autoSaveTimeout: ReturnType<typeof setTimeout> | null = null;
  private saveStatusEl: HTMLElement | null = null;

  constructor(app: App, config: LLMProviderModalConfig, providerManager: LLMProviderManager) {
    super(app);
    this.config = config;
    this.providerManager = providerManager;
    this.staticModelsService = StaticModelsService.getInstance();
  }

  onOpen(): void {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass('llm-provider-modal');

    // Modal title
    contentEl.createEl('h1', { text: `Configure ${this.config.providerName}` });

    // Provider content container
    const providerContainer = contentEl.createDiv('provider-modal-content');

    // Create provider-specific modal component
    this.providerModal = this.createProviderModal();
    this.providerModal.render(providerContainer);

    // Footer with status and close button
    this.createFooter(contentEl);
  }

  onClose(): void {
    const { contentEl } = this;

    // Clean up provider modal
    if (this.providerModal) {
      this.providerModal.destroy();
      this.providerModal = null;
    }

    // Clean up auto-save timeout
    if (this.autoSaveTimeout) {
      clearTimeout(this.autoSaveTimeout);
      this.autoSaveTimeout = null;
    }

    contentEl.empty();
  }

  /**
   * Create the appropriate provider modal based on provider type
   */
  private createProviderModal(): IProviderModal {
    const deps = this.createDependencies();
    const modalConfig = this.createProviderConfig();

    switch (this.config.providerId) {
      case 'webllm':
        return new NexusProviderModal(modalConfig, deps);

      case 'ollama':
        return new OllamaProviderModal(modalConfig, deps);

      case 'lmstudio':
        return new LMStudioProviderModal(modalConfig, deps);

      default:
        return new GenericProviderModal(modalConfig, deps);
    }
  }

  /**
   * Create dependencies for provider modals
   */
  private createDependencies(): ProviderModalDependencies {
    return {
      app: this.app,
      vault: this.app.vault,
      providerManager: this.providerManager,
      staticModelsService: this.staticModelsService,
    };
  }

  /**
   * Create provider modal config
   */
  private createProviderConfig(): ProviderModalConfig {
    return {
      providerId: this.config.providerId,
      providerName: this.config.providerName,
      keyFormat: this.config.keyFormat,
      signupUrl: this.config.signupUrl,
      config: { ...this.config.config },
      onConfigChange: (config: LLMProviderConfig) => this.handleConfigChange(config),
    };
  }

  /**
   * Handle configuration changes from provider modals
   */
  private handleConfigChange(config: LLMProviderConfig): void {
    // Update local config
    this.config.config = config;

    // Auto-save with debouncing
    this.autoSave();
  }

  /**
   * Auto-save with debouncing and visual feedback
   */
  private autoSave(): void {
    if (this.autoSaveTimeout) {
      clearTimeout(this.autoSaveTimeout);
    }

    this.showSaveStatus('Saving...');

    this.autoSaveTimeout = setTimeout(() => {
      // Get final config from provider modal
      if (this.providerModal) {
        this.config.config = this.providerModal.getConfig();
      }

      // Call the save callback
      this.config.onSave(this.config.config);
      this.showSaveStatus('Saved');

      // Reset status after 2 seconds
      setTimeout(() => {
        this.showSaveStatus('Ready');
      }, 2000);
    }, 500);
  }

  /**
   * Create footer with status and close button
   */
  private createFooter(contentEl: HTMLElement): void {
    const footer = contentEl.createDiv('modal-status-container llm-provider-status-container');

    // Save status indicator
    this.saveStatusEl = footer.createDiv('save-status');
    this.showSaveStatus('Ready');

    // Close button
    const buttonContainer = footer.createDiv('modal-button-container');
    const closeBtn = buttonContainer.createEl('button', { text: 'Close', cls: 'mod-cta' });
    closeBtn.addEventListener('click', () => this.close());
  }

  /**
   * Show save status with visual feedback
   */
  private showSaveStatus(status: string): void {
    if (this.saveStatusEl) {
      this.saveStatusEl.textContent = status;
      this.saveStatusEl.className = `save-status save-status-${status.toLowerCase()}`;
    }
  }
}

```

## components/ProgressBar.ts

```typescript
import { type App, Component } from 'obsidian';

/**
 * Interface for progress update data
 */
export interface ProgressUpdateData {
    total: number;
    processed: number;
    remaining: number;
    operationId?: string;
}

/**
 * Interface for progress completion data
 */
export interface ProgressCompleteData {
    success: boolean;
    processed: number;
    failed: number;
    error?: string;
    operationId: string;
}

/**
 * Interface for progress cancellation data
 */
export interface ProgressCancelData {
    operationId: string;
}

/**
 * ProgressBar component for displaying progress
 * Uses custom event handling to show progress of operations like indexing
 */
export class ProgressBar {
    private container: HTMLElement;
    private progressBar: HTMLElement;
    private progressText: HTMLElement;
    private cancelButton: HTMLElement;
    private component?: Component;

    private progress = 0;
    private total = 0;
    private operationId = '';

    // Custom event handlers
    private onProgressHandler!: (data: ProgressUpdateData) => void;
    private onCompleteHandler!: (data: ProgressCompleteData) => void;

    /**
     * Create a new progress bar component
     *
     * @param containerEl Container element to append to
     * @param app Obsidian app instance for event handling
     * @param component Optional Component for registerDomEvent
     */
    constructor(containerEl: HTMLElement, _app: App, component?: Component) {
        // App parameter marked with underscore as it's not currently used
        this.component = component;

        // Create the container
        this.container = containerEl.createDiv({ cls: 'mcp-progress-container' });
        this.container.addClass('mcp-progress-container-hidden');

        // Progress info
        const infoContainer = this.container.createDiv({ cls: 'mcp-progress-info' });
        this.progressText = infoContainer.createSpan({ cls: 'mcp-progress-text' });

        // Progress bar
        const barContainer = this.container.createDiv({ cls: 'mcp-progress-bar-container' });
        this.progressBar = barContainer.createDiv({ cls: 'mcp-progress-bar' });

        // Cancel button
        this.cancelButton = this.container.createDiv({
            cls: 'mcp-progress-cancel',
            text: 'Cancel'
        });

        const cancelHandler = () => {
            this.triggerCancel();
        };
        this.safeRegisterDomEvent(this.cancelButton, 'click', cancelHandler);

        // Create event handlers
        this.setupEventHandlers();

        // Initialize with hidden state
        this.hide();
    }

    /**
     * Safely register a DOM event - uses Component.registerDomEvent if available,
     * otherwise falls back to plain addEventListener (cleanup handled by DOM removal)
     */
    private safeRegisterDomEvent<K extends keyof HTMLElementEventMap>(
        el: HTMLElement,
        type: K,
        handler: (ev: HTMLElementEventMap[K]) => void
    ): void {
        if (this.component) {
            this.component.registerDomEvent(el, type, handler);
        } else {
            el.addEventListener(type, handler);
        }
    }
    
    /**
     * Set up event handlers using a custom approach
     */
    private setupEventHandlers(): void {
        // Create progress update handler
        this.onProgressHandler = (data: ProgressUpdateData) => {
            // Progress update received
            
            // Update progress
            this.total = data.total;
            this.progress = data.processed;
            
            // Store operation ID for resume functionality
            if (data.operationId) {
                this.operationId = data.operationId;
            }
            
            // Update UI
            this.updateProgressBar();
            
            // Show the progress bar if not already visible
            this.show();
        };
        
        // Create completion handler
        this.onCompleteHandler = (data: ProgressCompleteData) => {
            // Progress completion received
            
            // Update the progress bar one last time to show completion
            if (data.processed > 0 && this.total > 0) {
                this.progress = data.processed;
                this.updateProgressBar();
            }
            
            // Hide the progress bar
            setTimeout(() => {
                this.hide();
            }, 2000); // Give user time to see completion
        };
        
        // Create cancellation handler
        const onCancelHandler = (data: ProgressCancelData) => {
            // Progress cancellation received
            
            // Only process if this is for our current operation
            if (data.operationId === this.operationId) {
                // Update text to show cancellation
                this.progressText.setText(`Indexing cancelled: ${this.progress} / ${this.total}`);
                
                // Hide the progress bar after a delay
                setTimeout(() => {
                    this.hide();
                }, 1000);
            }
        };
        
        // Expose handlers as global methods to be called from other components
        // @ts-ignore - Adding methods to window for inter-component communication
        window.mcpProgressHandlers = {
            updateProgress: this.onProgressHandler,
            completeProgress: this.onCompleteHandler,
            cancelProgress: onCancelHandler
        };
    }
    
    /**
     * Show the progress bar
     */
    show(): void {
        this.container.removeClass('mcp-progress-container-hidden');
        this.container.addClass('mcp-progress-container-visible');
    }

    /**
     * Hide the progress bar
     */
    hide(): void {
        this.container.removeClass('mcp-progress-container-visible');
        this.container.addClass('mcp-progress-container-hidden');
    }
    
    /**
     * Update the progress bar UI
     */
    private updateProgressBar(): void {
        // Calculate percentage
        const percent = this.total > 0 ? Math.floor((this.progress / this.total) * 100) : 0;
        
        // Update bar width
        this.progressBar.style.width = `${percent}%`;
        
        // Update text
        this.progressText.setText(`Indexing: ${this.progress} / ${this.total} (${percent}%)`);
    }
    
    /**
     * Trigger cancel operation event
     */
    private triggerCancel(): void {
        // Call global cancel handler if available
        // @ts-ignore - Using global methods for inter-component communication
        if (window.mcpProgressHandlers && window.mcpProgressHandlers.cancelProgress) {
            // @ts-ignore
            window.mcpProgressHandlers.cancelProgress({
                operationId: this.operationId
            });
        }
        
        // Hide progress bar
        this.hide();
    }
}
```

## components/shared/ChatSettingsRenderer.ts

```typescript
/**
 * ChatSettingsRenderer - Shared settings UI for DefaultsTab and ChatSettingsModal
 *
 * Renders identical UI in both places:
 * - Provider + Model (same section)
 * - Reasoning toggle + Effort slider
 * - Image generation settings
 * - Workspace + Agent
 * - Context notes
 *
 * The difference is only WHERE data is saved (via callbacks).
 */

import { App, Setting } from 'obsidian';
import { LLMProviderManager } from '../../services/llm/providers/ProviderManager';
import { StaticModelsService } from '../../services/StaticModelsService';
import { LLMProviderSettings, ThinkingEffort } from '../../types/llm/ProviderTypes';
import { FilePickerRenderer } from '../workspace/FilePickerRenderer';
import { isDesktop, isProviderCompatible } from '../../utils/platform';

/**
 * Current settings state
 */
export interface ChatSettings {
  provider: string;
  model: string;
  // Agent Model - used for executePrompt when chat model is local
  agentProvider?: string;
  agentModel?: string;
  thinking: {
    enabled: boolean;
    effort: ThinkingEffort;
  };
  temperature: number; // 0.0-1.0, controls randomness
  imageProvider: 'google' | 'openrouter';
  imageModel: string;
  workspaceId: string | null;
  promptId: string | null;
  contextNotes: string[];
}

/**
 * Local providers that can't be used for executePrompt
 */
const LOCAL_PROVIDERS = ['webllm', 'ollama', 'lmstudio'];

/**
 * Available options for dropdowns
 */
export interface ChatSettingsOptions {
  workspaces: Array<{
    id: string;
    name: string;
    context?: {
      dedicatedAgent?: {
        agentId: string;
        agentName: string;
      };
    };
  }>;
  prompts: Array<{ id: string; name: string }>;
}

/**
 * Callbacks for when settings change
 */
export interface ChatSettingsCallbacks {
  onSettingsChange: (settings: ChatSettings) => void;
}

/**
 * Renderer configuration
 */
export interface ChatSettingsRendererConfig {
  app: App;
  llmProviderSettings: LLMProviderSettings;
  initialSettings: ChatSettings;
  options: ChatSettingsOptions;
  callbacks: ChatSettingsCallbacks;
}

const PROVIDER_NAMES: Record<string, string> = {
  webllm: 'Nexus (Local)',
  ollama: 'Ollama',
  lmstudio: 'LM Studio',
  openai: 'OpenAI',
  anthropic: 'Anthropic',
  google: 'Google AI',
  mistral: 'Mistral AI',
  groq: 'Groq',
  openrouter: 'OpenRouter',
  requesty: 'Requesty',
  perplexity: 'Perplexity'
};

const EFFORT_LEVELS: ThinkingEffort[] = ['low', 'medium', 'high'];
const EFFORT_LABELS: Record<ThinkingEffort, string> = {
  low: 'Low',
  medium: 'Medium',
  high: 'High'
};

const IMAGE_MODELS: Record<string, Array<{ id: string; name: string }>> = {
  google: [
    { id: 'gemini-2.5-flash-image', name: 'Nano Banana (Fast)' },
    { id: 'gemini-3-pro-image-preview', name: 'Nano Banana Pro (Advanced)' }
  ],
  openrouter: [
    { id: 'gemini-2.5-flash-image', name: 'Nano Banana (Fast)' },
    { id: 'gemini-3-pro-image-preview', name: 'Nano Banana Pro (Advanced)' },
    { id: 'flux-2-pro', name: 'FLUX.2 Pro' },
    { id: 'flux-2-flex', name: 'FLUX.2 Flex' }
  ]
};

export class ChatSettingsRenderer {
  private container: HTMLElement;
  private config: ChatSettingsRendererConfig;
  private providerManager: LLMProviderManager;
  private staticModelsService: StaticModelsService;
  private settings: ChatSettings;

  // UI references
  private effortSection?: HTMLElement;
  private contextNotesListEl?: HTMLElement;

  constructor(container: HTMLElement, config: ChatSettingsRendererConfig) {
    this.container = container;
    this.config = config;
    this.settings = { ...config.initialSettings };
    this.staticModelsService = StaticModelsService.getInstance();

    this.providerManager = new LLMProviderManager(
      config.llmProviderSettings,
      config.app.vault
    );
  }

  render(): void {
    this.container.empty();
    this.container.addClass('chat-settings-renderer');

    // Vertical layout
    this.renderModelSection(this.container);
    this.renderAgentModelSection(this.container);
    this.renderTemperatureSection(this.container);
    this.renderReasoningSection(this.container);
    this.renderImageSection(this.container);
    this.renderContextSection(this.container);
  }

  private notifyChange(): void {
    this.config.callbacks.onSettingsChange({ ...this.settings });
  }

  private getEnabledProviders(): string[] {
    const llmSettings = this.config.llmProviderSettings;
    return Object.keys(llmSettings.providers).filter(id => {
      const config = llmSettings.providers[id];
      if (!config?.enabled) return false;
      if (!isProviderCompatible(id)) return false;
      // WebLLM doesn't need an API key
      if (id === 'webllm') return true;
      // Local providers store the server URL in apiKey
      return !!config.apiKey;
    });
  }

  // ========== MODEL SECTION ==========

  private renderModelSection(parent: HTMLElement): void {
    const section = parent.createDiv('csr-section');
    section.createDiv('csr-section-header').setText('Chat Model');
    const content = section.createDiv('csr-section-content');

    // Provider
    new Setting(content)
      .setName('Provider')
      .addDropdown(dropdown => {
        const providers = this.getEnabledProviders();

        // If the currently-selected provider isn't usable on this platform (e.g. desktop-only
        // providers on mobile), fall back to the first available option.
        if (providers.length > 0 && !providers.includes(this.settings.provider)) {
          const nextProvider = providers[0];
          this.settings.provider = nextProvider;
          this.settings.model = '';
          void this.getDefaultModelForProvider(nextProvider).then((modelId) => {
            // Avoid stomping if user changed provider during async load
            if (this.settings.provider !== nextProvider) return;
            this.settings.model = modelId;
            this.notifyChange();
            this.render();
          });
        }

        if (providers.length === 0) {
          dropdown.addOption('', 'No providers enabled');
        } else {
          providers.forEach(id => {
            dropdown.addOption(id, PROVIDER_NAMES[id] || id);
          });
        }

        dropdown.setValue(this.settings.provider);
        dropdown.onChange(async (value) => {
          this.settings.provider = value;
          this.settings.model = await this.getDefaultModelForProvider(value);
          this.notifyChange();
          this.render();
        });
      });

    // Model
    const providerId = this.settings.provider;

    if (providerId === 'ollama') {
      new Setting(content)
        .setName('Model')
        .addText(text => text
          .setValue(this.settings.model || '')
          .setDisabled(true)
          .setPlaceholder('Configure in Ollama settings'));
    } else {
      new Setting(content)
        .setName('Model')
        .addDropdown(async dropdown => {
          if (!providerId) {
            dropdown.addOption('', 'Select a provider first');
            return;
          }

          try {
            const models = await this.providerManager.getModelsForProvider(providerId);

            if (models.length === 0) {
              dropdown.addOption('', 'No models available');
            } else {
              models.forEach(model => {
                dropdown.addOption(model.id, model.name);
              });

              const exists = models.some(m => m.id === this.settings.model);
              if (exists) {
                dropdown.setValue(this.settings.model);
              } else if (models.length > 0) {
                this.settings.model = models[0].id;
                dropdown.setValue(this.settings.model);
                this.notifyChange();
              }
            }

            dropdown.onChange((value) => {
              this.settings.model = value;
              this.notifyChange();
              // Re-render to update reasoning visibility
              this.render();
            });
          } catch {
            dropdown.addOption('', 'Error loading models');
          }
        });
    }
  }

  // ========== AGENT MODEL SECTION ==========

  /**
   * Render Agent Model section - always shown, excludes local providers.
   * This model is used for executePrompt and other API-dependent operations.
   */
  private renderAgentModelSection(parent: HTMLElement): void {
    const section = parent.createDiv('csr-section');
    section.createDiv('csr-section-header').setText('Agent Model');
    const desc = section.createDiv('csr-section-desc');
    const descText = desc.createSpan();
    descText.setText('Cloud model for AI actions');
    const infoIcon = desc.createSpan({ cls: 'csr-info-icon' });
    infoIcon.setText(' â“˜');
    infoIcon.setAttribute('aria-label', 'Saved prompts and automations require a cloud API.');
    infoIcon.addClass('clickable-icon');
    const content = section.createDiv('csr-section-content');

    // Get only API-based providers (exclude local ones)
    const apiProviders = this.getEnabledProviders().filter(id => !LOCAL_PROVIDERS.includes(id));

    // Provider dropdown
    new Setting(content)
      .setName('Provider')
      .addDropdown(dropdown => {
        // If the currently-selected agent provider isn't available, fall back to first API provider
        if (apiProviders.length > 0 && this.settings.agentProvider && !apiProviders.includes(this.settings.agentProvider)) {
          const nextProvider = apiProviders[0];
          this.settings.agentProvider = nextProvider;
          this.settings.agentModel = '';
          void this.getDefaultModelForProvider(nextProvider).then((modelId) => {
            if (this.settings.agentProvider !== nextProvider) return;
            this.settings.agentModel = modelId;
            this.notifyChange();
            this.render();
          });
        }

        if (apiProviders.length === 0) {
          dropdown.addOption('', 'No cloud providers enabled');
        } else {
          apiProviders.forEach(id => {
            dropdown.addOption(id, PROVIDER_NAMES[id] || id);
          });
        }

        dropdown.setValue(this.settings.agentProvider || '');
        dropdown.onChange(async (value) => {
          this.settings.agentProvider = value || undefined;
          this.settings.agentModel = value ? await this.getDefaultModelForProvider(value) : undefined;
          this.notifyChange();
          this.render();
        });
      });

    // Model dropdown - always shown (mirrors Chat Model pattern)
    const agentProviderId = this.settings.agentProvider;

    new Setting(content)
      .setName('Model')
      .addDropdown(async dropdown => {
        if (!agentProviderId) {
          dropdown.addOption('', 'Select a provider first');
          return;
        }

        try {
          const models = await this.providerManager.getModelsForProvider(agentProviderId);

          if (models.length === 0) {
            dropdown.addOption('', 'No models available');
          } else {
            models.forEach(model => {
              dropdown.addOption(model.id, model.name);
            });

            const exists = models.some(m => m.id === this.settings.agentModel);
            if (exists) {
              dropdown.setValue(this.settings.agentModel!);
            } else if (models.length > 0) {
              this.settings.agentModel = models[0].id;
              dropdown.setValue(this.settings.agentModel);
              this.notifyChange();
            }
          }

          dropdown.onChange((value) => {
            this.settings.agentModel = value;
            this.notifyChange();
          });
        } catch {
          dropdown.addOption('', 'Error loading models');
        }
      });
  }

  // ========== TEMPERATURE SECTION ==========

  private renderTemperatureSection(parent: HTMLElement): void {
    const section = parent.createDiv('csr-section');
    section.createDiv('csr-section-header').setText('Temperature');
    const content = section.createDiv('csr-section-content');

    // Create container for slider row with value display
    const tempSetting = new Setting(content)
      .setName('Creativity')
      .setDesc('Lower = more focused, Higher = more creative');

    // Add value display span
    const valueDisplay = tempSetting.controlEl.createSpan({ cls: 'csr-temp-value' });
    valueDisplay.setText(this.settings.temperature.toFixed(1));

    // Add Obsidian slider component
    tempSetting.addSlider(slider => {
      slider
        .setLimits(0, 1, 0.1)
        .setValue(this.settings.temperature)
        .setDynamicTooltip()
        .onChange((value: number) => {
          this.settings.temperature = value;
          valueDisplay.setText(value.toFixed(1));
          this.notifyChange();
        });
      return slider;
    });
  }

  // ========== REASONING SECTION ==========

  private renderReasoningSection(parent: HTMLElement): void {
    const supportsThinking = this.checkModelSupportsThinking();
    if (!supportsThinking) return;

    const section = parent.createDiv('csr-section');
    section.createDiv('csr-section-header').setText('Reasoning');
    const content = section.createDiv('csr-section-content');

    // Reasoning toggle
    new Setting(content)
      .setName('Enable')
      .setDesc('Think step-by-step')
      .addToggle(toggle => toggle
        .setValue(this.settings.thinking.enabled)
        .onChange(value => {
          this.settings.thinking.enabled = value;
          this.notifyChange();
          this.updateEffortVisibility();
        }));

    // Effort slider
    this.effortSection = content.createDiv('csr-effort-row');
    if (!this.settings.thinking.enabled) {
      this.effortSection.addClass('is-hidden');
    }

    const effortSetting = new Setting(this.effortSection)
      .setName('Effort');

    const valueDisplay = effortSetting.controlEl.createSpan({ cls: 'csr-effort-value' });
    valueDisplay.setText(EFFORT_LABELS[this.settings.thinking.effort]);

    effortSetting.addSlider(slider => {
      slider
        .setLimits(0, 2, 1)
        .setValue(EFFORT_LEVELS.indexOf(this.settings.thinking.effort))
        .onChange((value: number) => {
          this.settings.thinking.effort = EFFORT_LEVELS[value];
          valueDisplay.setText(EFFORT_LABELS[this.settings.thinking.effort]);
          this.notifyChange();
        });
      return slider;
    });
  }

  private updateEffortVisibility(): void {
    if (!this.effortSection) return;

    if (this.settings.thinking.enabled) {
      this.effortSection.removeClass('is-hidden');
    } else {
      this.effortSection.addClass('is-hidden');
    }
  }

  // ========== IMAGE SECTION ==========

  private renderImageSection(parent: HTMLElement): void {
    const section = parent.createDiv('csr-section');
    section.createDiv('csr-section-header').setText('Image Model');
    const content = section.createDiv('csr-section-content');

    // Provider
    new Setting(content)
      .setName('Provider')
      .addDropdown(dropdown => {
        const providers: Array<{ id: 'google' | 'openrouter'; name: string }> = isDesktop()
          ? [
            { id: 'google', name: 'Google AI' },
            { id: 'openrouter', name: 'OpenRouter' }
          ]
          : [{ id: 'openrouter', name: 'OpenRouter' }];

        // If current selection isn't supported on this platform, fall back.
        if (!providers.some(p => p.id === this.settings.imageProvider)) {
          this.settings.imageProvider = providers[0].id;
          this.settings.imageModel = IMAGE_MODELS[this.settings.imageProvider]?.[0]?.id || '';
          this.notifyChange();
        }

        providers.forEach(p => dropdown.addOption(p.id, p.name));

        dropdown.setValue(this.settings.imageProvider);
        dropdown.onChange((value) => {
          this.settings.imageProvider = value as 'google' | 'openrouter';
          this.settings.imageModel = IMAGE_MODELS[value]?.[0]?.id || '';
          this.notifyChange();
          this.render();
        });
      });

    // Model
    const models = IMAGE_MODELS[this.settings.imageProvider] || [];
    new Setting(content)
      .setName('Model')
      .addDropdown(dropdown => {
        models.forEach(m => {
          dropdown.addOption(m.id, m.name);
        });

        const exists = models.some(m => m.id === this.settings.imageModel);
        if (exists) {
          dropdown.setValue(this.settings.imageModel);
        } else if (models.length > 0) {
          this.settings.imageModel = models[0].id;
          dropdown.setValue(this.settings.imageModel);
        }

        dropdown.onChange((value) => {
          this.settings.imageModel = value;
          this.notifyChange();
        });
      });
  }

  // ========== CONTEXT SECTION ==========

  private renderContextSection(parent: HTMLElement): void {
    const section = parent.createDiv('csr-section');
    section.createDiv('csr-section-header').setText('Context');
    const content = section.createDiv('csr-section-content');

    // Workspace
    new Setting(content)
      .setName('Workspace')
      .addDropdown(dropdown => {
        dropdown.addOption('', 'None');

        this.config.options.workspaces.forEach(w => {
          dropdown.addOption(w.id, w.name);
        });

        dropdown.setValue(this.settings.workspaceId || '');
        dropdown.onChange((value) => {
          this.settings.workspaceId = value || null;
          this.notifyChange();
          this.syncWorkspacePrompt(value);
        });
      });

    // Prompt
    new Setting(content)
      .setName('Prompt')
      .addDropdown(dropdown => {
        dropdown.addOption('', 'None');

        this.config.options.prompts.forEach(p => {
          dropdown.addOption(p.name, p.name);
        });

        dropdown.setValue(this.settings.promptId || '');
        dropdown.onChange((value) => {
          this.settings.promptId = value || null;
          this.notifyChange();
        });
      });

    // Context Notes header with Add button
    const notesHeader = content.createDiv('csr-notes-header');
    notesHeader.createSpan().setText('Context Notes');
    const addBtn = notesHeader.createEl('button', { cls: 'csr-add-btn' });
    addBtn.setText('+ Add');
    addBtn.onclick = () => this.openNotePicker();

    this.contextNotesListEl = content.createDiv('csr-notes-list');
    this.renderContextNotesList();
  }

  private async syncWorkspacePrompt(workspaceId: string | null): Promise<void> {
    if (!workspaceId) return;

    const workspace = this.config.options.workspaces.find(w => w.id === workspaceId);
    // dedicatedAgent field stored for backward compat, but contains prompt info
    if (workspace?.context?.dedicatedAgent?.agentId) {
      const promptId = workspace.context.dedicatedAgent.agentId;
      const prompt = this.config.options.prompts.find(p => p.id === promptId || p.name === promptId);
      if (prompt) {
        this.settings.promptId = prompt.name;
        this.notifyChange();
        this.render();
      }
    }
  }

  private renderContextNotesList(): void {
    if (!this.contextNotesListEl) return;
    this.contextNotesListEl.empty();

    if (this.settings.contextNotes.length === 0) {
      this.contextNotesListEl.createDiv({ cls: 'csr-notes-empty', text: 'No files added' });
      return;
    }

    this.settings.contextNotes.forEach((notePath, index) => {
      const item = this.contextNotesListEl!.createDiv('csr-note-item');
      item.createSpan({ cls: 'csr-note-path', text: notePath });
      const removeBtn = item.createEl('button', { cls: 'csr-note-remove', text: 'Ã—' });
      removeBtn.onclick = () => {
        this.settings.contextNotes.splice(index, 1);
        this.notifyChange();
        this.renderContextNotesList();
      };
    });
  }

  private async openNotePicker(): Promise<void> {
    const selectedPaths = await FilePickerRenderer.openModal(this.config.app, {
      title: 'Select Context Notes',
      excludePaths: this.settings.contextNotes
    });

    if (selectedPaths.length > 0) {
      this.settings.contextNotes.push(...selectedPaths);
      this.notifyChange();
      this.renderContextNotesList();
    }
  }

  // ========== HELPERS ==========

  private async getDefaultModelForProvider(providerId: string): Promise<string> {
    if (providerId === 'ollama') {
      return this.config.llmProviderSettings.providers.ollama?.ollamaModel || '';
    }

    try {
      const models = await this.providerManager.getModelsForProvider(providerId);
      return models[0]?.id || '';
    } catch {
      return '';
    }
  }

  private checkModelSupportsThinking(): boolean {
    if (!this.settings.provider || !this.settings.model) return false;

    const model = this.staticModelsService.findModel(this.settings.provider, this.settings.model);
    return model?.capabilities?.supportsThinking ?? false;
  }

  getSettings(): ChatSettings {
    return { ...this.settings };
  }
}

```

## components/TabContainer.ts

```typescript
/**
 * Reusable Tab Container Component
 * Matches the existing Memory Manager tab styling and behavior
 */

import { Component } from 'obsidian';

export interface TabConfig {
  key: string;
  label: string;
}

export class TabContainer {
  private containerEl: HTMLElement;
  private tabContainer!: HTMLElement;
  private contentContainer!: HTMLElement;
  private tabs: Record<string, HTMLElement> = {};
  private contents: Record<string, HTMLElement> = {};
  private activeTabKey: string;
  private onTabChange?: (tabKey: string) => void;
  private component?: Component;

  constructor(
    containerEl: HTMLElement,
    tabConfigs: TabConfig[],
    defaultTab: string = tabConfigs[0]?.key,
    onTabChange?: (tabKey: string) => void,
    component?: Component
  ) {
    this.containerEl = containerEl;
    this.activeTabKey = defaultTab;
    this.onTabChange = onTabChange;
    this.component = component;

    this.createTabStructure(tabConfigs);
  }

  /**
   * Safely register a DOM event - uses Component.registerDomEvent if available,
   * otherwise falls back to plain addEventListener (cleanup handled by DOM removal)
   */
  private safeRegisterDomEvent<K extends keyof HTMLElementEventMap>(
    el: HTMLElement,
    type: K,
    handler: (ev: HTMLElementEventMap[K]) => void
  ): void {
    if (this.component) {
      this.component.registerDomEvent(el, type, handler);
    } else {
      el.addEventListener(type, handler);
    }
  }

  /**
   * Create the tab structure using Memory Manager styling
   */
  private createTabStructure(tabConfigs: TabConfig[]): void {
    // Create tabs container (same as memory-settings-tabs)
    this.tabContainer = this.containerEl.createDiv({ cls: 'memory-settings-tabs' });
    
    // Create tab buttons
    tabConfigs.forEach(config => {
      const tabEl = this.tabContainer.createDiv({
        cls: 'memory-tab',
        text: config.label
      });

      const clickHandler = () => this.switchToTab(config.key);
      this.safeRegisterDomEvent(tabEl, 'click', clickHandler);
      this.tabs[config.key] = tabEl;
    });

    // Content container (same as memory-tab-content)
    this.contentContainer = this.containerEl.createDiv({ cls: 'memory-tab-content' });
    
    // Create content panes
    tabConfigs.forEach(config => {
      const contentEl = this.contentContainer.createDiv({ cls: 'memory-tab-pane' });
      this.contents[config.key] = contentEl;
    });

    // Set initial active tab
    this.switchToTab(this.activeTabKey);
  }

  /**
   * Switch to a specific tab (same logic as Memory Manager)
   */
  private switchToTab(tabKey: string): void {
    this.activeTabKey = tabKey;
    
    // Remove active class from all tabs and contents
    Object.values(this.tabs).forEach(t => t.removeClass('active'));
    Object.values(this.contents).forEach(c => c.removeClass('active'));
    
    // Add active class to clicked tab and corresponding content
    this.tabs[tabKey]?.addClass('active');
    this.contents[tabKey]?.addClass('active');
    
    // Call callback if provided
    this.onTabChange?.(tabKey);
  }

  /**
   * Get content container for a specific tab
   */
  getTabContent(tabKey: string): HTMLElement | undefined {
    return this.contents[tabKey];
  }

  /**
   * Get the currently active tab key
   */
  getActiveTab(): string {
    return this.activeTabKey;
  }

  /**
   * Programmatically switch to a tab
   */
  activateTab(tabKey: string): void {
    if (this.contents[tabKey]) {
      this.switchToTab(tabKey);
    }
  }
}
```

## components/UnifiedTabs.ts

```typescript
/**
 * Unified Tabs Component
 * Exact replication of Memory Manager tab pattern for consistent UI across the plugin
 */

import { Component } from 'obsidian';

export interface UnifiedTabConfig {
  key: string;
  label: string;
}

export interface UnifiedTabsOptions {
  containerEl: HTMLElement;
  tabs: UnifiedTabConfig[];
  defaultTab?: string;
  onTabChange?: (tabKey: string) => void;
  component?: Component;
}

export class UnifiedTabs {
  private containerEl: HTMLElement;
  private tabContainer!: HTMLElement;
  private contentContainer!: HTMLElement;
  private tabs: Record<string, HTMLElement> = {};
  private contents: Record<string, HTMLElement> = {};
  private activeTabKey: string;
  private onTabChange?: (tabKey: string) => void;
  private component?: Component;

  constructor(options: UnifiedTabsOptions) {
    this.containerEl = options.containerEl;
    this.activeTabKey = options.defaultTab || options.tabs[0]?.key || '';
    this.onTabChange = options.onTabChange;
    this.component = options.component;

    this.createTabStructure(options.tabs);
    this.activateDefaultTab();
  }

  /**
   * Safely register a DOM event - uses Component.registerDomEvent if available,
   * otherwise falls back to plain addEventListener (cleanup handled by DOM removal)
   */
  private safeRegisterDomEvent<K extends keyof HTMLElementEventMap>(
    el: HTMLElement,
    type: K,
    handler: (ev: HTMLElementEventMap[K]) => void
  ): void {
    if (this.component) {
      this.component.registerDomEvent(el, type, handler);
    } else {
      el.addEventListener(type, handler);
    }
  }

  /**
   * Create the tab structure exactly like MemorySettingsTab
   */
  private createTabStructure(tabConfigs: UnifiedTabConfig[]): void {
    // Create tabs container with exact same class as Memory Manager
    this.tabContainer = this.containerEl.createDiv({ cls: 'memory-settings-tabs' });
    
    // Create individual tab elements exactly like Memory Manager
    tabConfigs.forEach(config => {
      this.tabs[config.key] = this.tabContainer.createDiv({ 
        cls: 'memory-tab', 
        text: config.label 
      });
    });

    // Content container with exact same class as Memory Manager
    this.contentContainer = this.containerEl.createDiv({ cls: 'memory-tab-content' });
    
    // Create content panes exactly like Memory Manager
    tabConfigs.forEach(config => {
      this.contents[config.key] = this.contentContainer.createDiv({ 
        cls: 'memory-tab-pane' 
      });
    });

    // Setup tab switching logic exactly like Memory Manager
    Object.entries(this.tabs).forEach(([key, tab]) => {
      const clickHandler = () => {
        this.switchToTab(key);
      };
      this.safeRegisterDomEvent(tab, 'click', clickHandler);
    });
  }

  /**
   * Switch to a specific tab using exact Memory Manager logic
   */
  private switchToTab(tabKey: string): void {
    this.activeTabKey = tabKey;
    
    // Remove active class from all tabs and contents (exact Memory Manager pattern)
    Object.values(this.tabs).forEach(t => t.removeClass('active'));
    Object.values(this.contents).forEach(c => c.removeClass('active'));
    
    // Add active class to clicked tab and corresponding content (exact Memory Manager pattern)
    this.tabs[tabKey]?.addClass('active');
    this.contents[tabKey]?.addClass('active');
    
    // Call callback if provided
    this.onTabChange?.(tabKey);
  }

  /**
   * Activate the default tab
   */
  private activateDefaultTab(): void {
    if (this.activeTabKey && this.tabs[this.activeTabKey]) {
      this.switchToTab(this.activeTabKey);
    } else if (Object.keys(this.tabs).length > 0) {
      // Fallback to first tab
      const firstTabKey = Object.keys(this.tabs)[0];
      this.activeTabKey = firstTabKey;
      this.switchToTab(firstTabKey);
    }
  }

  /**
   * Get content container for a specific tab
   */
  getTabContent(tabKey: string): HTMLElement | undefined {
    return this.contents[tabKey];
  }

  /**
   * Get the currently active tab key
   */
  getActiveTab(): string {
    return this.activeTabKey;
  }

  /**
   * Programmatically switch to a tab
   */
  activateTab(tabKey: string): void {
    if (this.contents[tabKey]) {
      this.switchToTab(tabKey);
    }
  }

  /**
   * Get all tab keys
   */
  getTabKeys(): string[] {
    return Object.keys(this.tabs);
  }

  /**
   * Update a tab's label
   */
  updateTabLabel(tabKey: string, newLabel: string): void {
    if (this.tabs[tabKey]) {
      this.tabs[tabKey].textContent = newLabel;
    }
  }

  /**
   * Check if a tab exists
   */
  hasTab(tabKey: string): boolean {
    return !!this.tabs[tabKey];
  }

  /**
   * Destroy the tabs component
   */
  destroy(): void {
    this.containerEl.empty();
    this.tabs = {};
    this.contents = {};
  }
}
```

## components/workspace/FilePickerRenderer.ts

```typescript
import { App, TFile, TFolder, setIcon, ButtonComponent, TextComponent, Modal, Component } from 'obsidian';

const DEBOUNCE_MS = 150;

/**
 * FilePickerRenderer - Folder tree with lazy loading and checkboxes
 *
 * Features:
 * - Lazy loading: only loads folder children when expanded
 * - Search filter: filters tree to matching files/folders
 * - Multi-select: checkboxes for selecting multiple files
 * - Workspace-aware: respects workspace rootFolder
 */
export class FilePickerRenderer {
  private selectedFiles: Set<string>;
  private expandedFolders: Set<string> = new Set();
  private treeContainer?: HTMLElement;
  private searchComponent?: TextComponent;
  private searchQuery: string = '';
  private searchTimeout?: ReturnType<typeof setTimeout>;
  private rootPath: string;
  private title: string;

  constructor(
    private app: App,
    private onSelect: (filePath: string) => void,
    private onCancel: () => void,
    initialSelection?: string,
    workspaceRootFolder?: string,
    title?: string,
    private component?: Component
  ) {
    // Support single or multiple initial selection
    this.selectedFiles = new Set(initialSelection ? [initialSelection] : []);

    // Use workspace root folder or vault root
    this.rootPath = workspaceRootFolder && workspaceRootFolder !== '/'
      ? workspaceRootFolder
      : '/';

    this.title = title || 'Select Files';
  }

  /**
   * Safely register a DOM event - uses Component.registerDomEvent if available,
   * otherwise falls back to plain addEventListener (cleanup handled by DOM removal)
   */
  private safeRegisterDomEvent<K extends keyof HTMLElementEventMap>(
    el: HTMLElement,
    type: K,
    handler: (ev: HTMLElementEventMap[K]) => void
  ): void {
    if (this.component) {
      this.component.registerDomEvent(el, type, handler);
    } else {
      // Fallback: Modal/parent container handles cleanup when removed
      el.addEventListener(type, handler);
    }
  }

  /**
   * Render the file picker view
   */
  render(container: HTMLElement): void {
    container.empty();

    // Header
    const header = container.createDiv('nexus-file-picker-header');

    const leftSection = header.createDiv('nexus-file-picker-left');
    new ButtonComponent(leftSection)
      .setButtonText('â† Back')
      .onClick(() => this.onCancel());
    leftSection.createEl('h3', { text: this.title });

    const actions = header.createDiv('nexus-file-picker-actions');
    new ButtonComponent(actions)
      .setButtonText('Done')
      .setCta()
      .onClick(() => this.handleDone());

    // Search input
    const searchField = container.createDiv('nexus-form-field');
    this.searchComponent = new TextComponent(searchField);
    this.searchComponent.setPlaceholder('Filter files and folders...');
    this.searchComponent.onChange((value) => {
      this.debouncedSearch(value);
    });

    // Tree container
    this.treeContainer = container.createDiv('nexus-folder-tree');

    // Render root
    this.renderRoot();
  }

  /**
   * Debounced search to prevent excessive re-renders
   */
  private debouncedSearch(query: string): void {
    if (this.searchTimeout) {
      clearTimeout(this.searchTimeout);
    }
    this.searchTimeout = setTimeout(() => {
      this.searchQuery = query.toLowerCase().trim();
      // When searching, auto-expand folders that have matches
      if (this.searchQuery) {
        this.expandFoldersWithMatches();
      }
      this.renderRoot();
    }, DEBOUNCE_MS);
  }

  /**
   * Expand all folders that contain matching files
   */
  private expandFoldersWithMatches(): void {
    if (!this.searchQuery) return;

    const rootFolder = this.getRootFolder();
    if (!rootFolder) return;

    this.expandedFolders.clear();
    this.findAndExpandMatchingFolders(rootFolder);
  }

  /**
   * Recursively find folders with matching children and expand them
   */
  private findAndExpandMatchingFolders(folder: TFolder): boolean {
    let hasMatch = false;

    for (const child of folder.children) {
      if (child instanceof TFolder) {
        // Check if folder name matches
        if (child.name.toLowerCase().includes(this.searchQuery)) {
          hasMatch = true;
        }
        // Recursively check children
        if (this.findAndExpandMatchingFolders(child)) {
          hasMatch = true;
        }
      } else if (child instanceof TFile) {
        if (child.name.toLowerCase().includes(this.searchQuery)) {
          hasMatch = true;
        }
      }
    }

    if (hasMatch) {
      this.expandedFolders.add(folder.path);
    }

    return hasMatch;
  }

  /**
   * Check if item matches search query
   */
  private matchesSearch(name: string): boolean {
    if (!this.searchQuery) return true;
    return name.toLowerCase().includes(this.searchQuery);
  }

  /**
   * Check if folder contains any matching items (for filtering)
   */
  private folderHasMatches(folder: TFolder): boolean {
    if (!this.searchQuery) return true;

    for (const child of folder.children) {
      if (child instanceof TFolder) {
        if (this.matchesSearch(child.name) || this.folderHasMatches(child)) {
          return true;
        }
      } else if (child instanceof TFile) {
        if (this.matchesSearch(child.name)) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Get the root folder
   */
  private getRootFolder(): TFolder | null {
    if (this.rootPath === '/') {
      return this.app.vault.getRoot();
    } else {
      const abstractFile = this.app.vault.getAbstractFileByPath(this.rootPath);
      return abstractFile instanceof TFolder ? abstractFile : null;
    }
  }

  /**
   * Render the root folder(s)
   */
  private renderRoot(): void {
    if (!this.treeContainer) return;
    this.treeContainer.empty();

    const rootFolder = this.getRootFolder();

    if (!rootFolder) {
      this.treeContainer.createDiv({
        text: 'Folder not found',
        cls: 'nexus-file-picker-empty'
      });
      return;
    }

    // Render children of root (don't show root itself)
    const hasVisibleItems = this.renderFolderChildren(rootFolder, this.treeContainer, 0);

    if (!hasVisibleItems && this.searchQuery) {
      this.treeContainer.createDiv({
        text: 'No matching files found',
        cls: 'nexus-file-picker-empty'
      });
    }
  }

  /**
   * Render children of a folder
   * Returns true if any items were rendered
   */
  private renderFolderChildren(folder: TFolder, container: HTMLElement, depth: number): boolean {
    // Sort: folders first, then files, alphabetically
    const children = [...folder.children].sort((a, b) => {
      const aIsFolder = a instanceof TFolder;
      const bIsFolder = b instanceof TFolder;
      if (aIsFolder && !bIsFolder) return -1;
      if (!aIsFolder && bIsFolder) return 1;
      return a.name.localeCompare(b.name);
    });

    let renderedCount = 0;

    for (const child of children) {
      if (child instanceof TFolder) {
        // Show folder if it matches or has matching children
        if (this.matchesSearch(child.name) || this.folderHasMatches(child)) {
          this.renderFolderRow(child, container, depth);
          renderedCount++;
        }
      } else if (child instanceof TFile) {
        // Show file if it matches search
        if (this.matchesSearch(child.name)) {
          this.renderFileRow(child, container, depth);
          renderedCount++;
        }
      }
    }

    // Empty folder message (only when not searching)
    if (renderedCount === 0 && !this.searchQuery) {
      const empty = container.createDiv({ cls: 'nexus-tree-empty' });
      empty.dataset.depth = String(depth + 1);
      empty.textContent = 'Empty folder';
    }

    return renderedCount > 0;
  }

  /**
   * Render a folder row with expand/collapse
   */
  private renderFolderRow(folder: TFolder, container: HTMLElement, depth: number): void {
    const isExpanded = this.expandedFolders.has(folder.path);

    const row = container.createDiv({ cls: 'nexus-tree-row nexus-tree-folder' });
    row.dataset.depth = String(depth);

    // Folder icon (changes based on expanded state)
    const iconEl = row.createSpan({ cls: 'nexus-tree-icon' });
    setIcon(iconEl, isExpanded ? 'folder-open' : 'folder');

    // Folder name
    row.createSpan({ text: folder.name, cls: 'nexus-tree-name' });

    // Click to expand/collapse
    const clickHandler = () => {
      if (isExpanded) {
        this.expandedFolders.delete(folder.path);
      } else {
        this.expandedFolders.add(folder.path);
      }
      this.renderRoot(); // Re-render tree
    };
    this.safeRegisterDomEvent(row, 'click', clickHandler);

    // Render children if expanded
    if (isExpanded) {
      const childrenContainer = container.createDiv({ cls: 'nexus-tree-children' });
      this.renderFolderChildren(folder, childrenContainer, depth + 1);
    }
  }

  /**
   * Render a file row with checkbox
   */
  private renderFileRow(file: TFile, container: HTMLElement, depth: number): void {
    const isSelected = this.selectedFiles.has(file.path);

    const row = container.createDiv({ cls: 'nexus-tree-row nexus-tree-file' });
    row.dataset.depth = String(depth);

    // Checkbox
    const checkbox = row.createEl('input', { type: 'checkbox', cls: 'nexus-tree-checkbox' });
    checkbox.checked = isSelected;
    const changeHandler = (e: Event) => {
      e.stopPropagation();
      if (checkbox.checked) {
        this.selectedFiles.add(file.path);
      } else {
        this.selectedFiles.delete(file.path);
      }
    };
    this.safeRegisterDomEvent(checkbox, 'change', changeHandler);

    // File icon
    const iconEl = row.createSpan({ cls: 'nexus-tree-icon' });
    setIcon(iconEl, 'file-text');

    // File name
    row.createSpan({ text: file.name, cls: 'nexus-tree-name' });

    // Click row to toggle checkbox
    const rowClickHandler = (e: MouseEvent) => {
      if (e.target !== checkbox) {
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event('change'));
      }
    };
    this.safeRegisterDomEvent(row, 'click', rowClickHandler);
  }

  /**
   * Handle done - return first selected file (for single selection mode)
   */
  private handleDone(): void {
    const selected = Array.from(this.selectedFiles);
    if (selected.length > 0) {
      // For now, return first selected file (maintains compatibility)
      this.onSelect(selected[0]);
    } else {
      this.onCancel();
    }
  }

  /**
   * Get all selected file paths
   */
  getSelectedPaths(): string[] {
    return Array.from(this.selectedFiles);
  }

  /**
   * Get currently selected file path (first one, for compatibility)
   */
  getSelectedPath(): string {
    const paths = this.getSelectedPaths();
    return paths.length > 0 ? paths[0] : '';
  }

  /**
   * Open file picker in a modal - reusable anywhere
   * @param app Obsidian App instance
   * @param options Configuration options
   * @returns Promise with selected file paths (empty array if cancelled)
   */
  static openModal(
    app: App,
    options: {
      title?: string;
      rootFolder?: string;
      initialSelection?: string[];
      excludePaths?: string[];
    } = {}
  ): Promise<string[]> {
    return new Promise((resolve) => {
      const modal = new Modal(app);
      modal.titleEl.setText(options.title || 'Select Files');
      modal.modalEl.addClass('file-picker-modal');

      let pickerInstance: FilePickerRenderer;

      pickerInstance = new FilePickerRenderer(
        app,
        () => {
          // Done callback - return all selected paths
          const paths = pickerInstance.getSelectedPaths();
          const filtered = options.excludePaths
            ? paths.filter(p => !options.excludePaths!.includes(p))
            : paths;
          resolve(filtered);
          modal.close();
        },
        () => {
          // Cancel callback
          resolve([]);
          modal.close();
        },
        options.initialSelection?.join(','),
        options.rootFolder || '/'
        // Note: No component passed - modal handles its own lifecycle
      );

      pickerInstance.render(modal.contentEl);
      modal.open();
    });
  }
}

```

## components/workspace/WorkflowEditorRenderer.ts

```typescript
import { Setting, ButtonComponent } from 'obsidian';

/**
 * Workflow data structure
 */
export interface Workflow {
  name: string;
  when: string;
  steps: string;
}

/**
 * WorkflowEditorRenderer - Reusable workflow editor form
 *
 * Responsibilities:
 * - Render workflow editor form (name, when, steps)
 * - Handle form field changes
 * - Validate workflow data
 * - Handle save/cancel actions
 *
 * Used by:
 * - MemorySettingsTab (settings inline editing)
 * - WorkspaceEditModal (modal editing)
 */
export class WorkflowEditorRenderer {
  private workflow: Workflow;
  private isNewWorkflow: boolean;

  constructor(
    private onSave: (workflow: Workflow) => void,
    private onCancel: () => void
  ) {
    this.workflow = { name: '', when: '', steps: '' };
    this.isNewWorkflow = true;
  }

  /**
   * Render the workflow editor view
   */
  render(container: HTMLElement, workflow: Workflow, isNew: boolean): void {
    container.empty();

    this.workflow = { ...workflow };
    this.isNewWorkflow = isNew;

    // Header with back button
    const header = container.createDiv('nexus-workflow-header');

    new ButtonComponent(header)
      .setButtonText('â† Back to Workspace')
      .onClick(() => this.onCancel());

    header.createEl('h2', {
      text: isNew ? 'Create Workflow' : 'Edit Workflow',
      cls: 'nexus-workflow-title'
    });

    // Workflow form
    const form = container.createDiv('nexus-workflow-form');

    // Workflow Name
    new Setting(form)
      .setName('Workflow Name')
      .setDesc('What do you call this workflow?')
      .addText(text => text
        .setPlaceholder('e.g., New Application, Follow-up, Interview Prep')
        .setValue(this.workflow.name)
        .onChange(value => {
          this.workflow.name = value;
        }));

    // When to Use
    new Setting(form)
      .setName('When to Use')
      .setDesc('When should this workflow be used?')
      .addText(text => text
        .setPlaceholder('e.g., When applying to new position')
        .setValue(this.workflow.when)
        .onChange(value => {
          this.workflow.when = value;
        }));

    // Steps Section
    new Setting(form)
      .setName('Steps')
      .setDesc('Define the step-by-step process for this workflow (one per line or as paragraphs)')
      .addTextArea(text => text
        .setPlaceholder('e.g., Research company\nCustomize cover letter\nApply\nTrack')
        .setValue(this.workflow.steps)
        .onChange(value => {
          this.workflow.steps = value;
        }));

    // Action buttons
    const actionsContainer = container.createDiv('nexus-form-actions');

    new ButtonComponent(actionsContainer)
      .setButtonText('Save Workflow')
      .setCta()
      .onClick(() => this.handleSave());

    new ButtonComponent(actionsContainer)
      .setButtonText('Cancel')
      .onClick(() => this.onCancel());
  }

  /**
   * Handle save button click
   */
  private handleSave(): void {
    // Validate workflow data
    if (!this.workflow.name.trim()) {
      alert('Workflow name is required');
      return;
    }

    if (!this.workflow.when.trim()) {
      alert('Please specify when this workflow should be used');
      return;
    }

    if (!this.workflow.steps.trim()) {
      alert('At least one step is required');
      return;
    }

    this.onSave(this.workflow);
  }

  /**
   * Get current workflow data
   */
  getWorkflow(): Workflow {
    return { ...this.workflow };
  }
}

```

## components/workspace/WorkspaceFormRenderer.ts

```typescript
import { App, DropdownComponent, TextComponent, TextAreaComponent, ButtonComponent } from 'obsidian';
import { ProjectWorkspace } from '../../database/workspace-types';
import { CustomPrompt } from '../../types/mcp/CustomPromptTypes';

/**
 * WorkspaceFormRenderer - Single scrollable workspace form
 *
 * Responsibilities:
 * - Render all sections in one scrollable view
 * - Render workflows section with summaries
 * - Render key files section with list
 * - Manage formData binding
 * - Delegate workflow editing to WorkflowEditorRenderer
 * - Delegate file picking to FilePickerRenderer
 */
export class WorkspaceFormRenderer {
  constructor(
    private app: App,
    private formData: Partial<ProjectWorkspace>,
    private availableAgents: CustomPrompt[],
    private onWorkflowEdit: (index?: number) => void,
    private onFilePick: (index: number) => void,
    private onRefresh: () => void
  ) {}

  /**
   * Render the scrollable form
   */
  render(container: HTMLElement): void {
    const form = container.createDiv('nexus-workspace-form');

    // Basic Info section
    this.renderBasicInfoSection(form);

    // Context section
    this.renderContextSection(form);

    // Agent & Files section
    this.renderAgentFilesSection(form);
  }

  /**
   * Destroy - no cleanup needed
   */
  destroy(): void {}

  /**
   * Render Basic Info section
   */
  private renderBasicInfoSection(container: HTMLElement): void {
    const section = container.createDiv('nexus-form-section');
    section.createEl('h4', { text: 'Basic Info', cls: 'nexus-section-header' });

    // Name field
    const nameField = section.createDiv('nexus-form-field');
    nameField.createEl('label', { text: 'Name', cls: 'nexus-form-label' });
    const nameInput = new TextComponent(nameField);
    nameInput.setPlaceholder('My Workspace');
    nameInput.setValue(this.formData.name || '');
    nameInput.onChange((value) => {
      this.formData.name = value;
    });

    // Description field
    const descField = section.createDiv('nexus-form-field');
    descField.createEl('label', { text: 'Description', cls: 'nexus-form-label' });
    const descInput = new TextAreaComponent(descField);
    descInput.setPlaceholder('Brief description of this workspace...');
    descInput.setValue(this.formData.description || '');
    descInput.onChange((value) => {
      this.formData.description = value;
    });

    // Root Folder field
    const folderField = section.createDiv('nexus-form-field');
    folderField.createEl('label', { text: 'Root Folder', cls: 'nexus-form-label' });
    const folderInput = new TextComponent(folderField);
    folderInput.setPlaceholder('/');
    folderInput.setValue(this.formData.rootFolder || '/');
    folderInput.onChange((value) => {
      this.formData.rootFolder = value;
    });
  }

  /**
   * Render Context section
   */
  private renderContextSection(container: HTMLElement): void {
    const section = container.createDiv('nexus-form-section');
    section.createEl('h4', { text: 'Context', cls: 'nexus-section-header' });

    // Ensure context exists
    if (!this.formData.context) {
      this.formData.context = {
        purpose: '',
        workflows: [],
        keyFiles: [],
        preferences: ''
      };
    }

    // Purpose field
    const purposeField = section.createDiv('nexus-form-field');
    purposeField.createEl('label', { text: 'Purpose', cls: 'nexus-form-label' });
    const purposeInput = new TextComponent(purposeField);
    purposeInput.setPlaceholder('What is this workspace for?');
    purposeInput.setValue(this.formData.context?.purpose || '');
    purposeInput.onChange((value) => {
      if (this.formData.context) {
        this.formData.context.purpose = value;
      }
    });

    // Preferences field
    const prefsField = section.createDiv('nexus-form-field');
    prefsField.createEl('label', { text: 'Preferences', cls: 'nexus-form-label' });
    const prefsInput = new TextAreaComponent(prefsField);
    prefsInput.setPlaceholder('Guidelines: tone, focus areas, constraints...');
    prefsInput.setValue(this.formData.context?.preferences || '');
    prefsInput.onChange((value) => {
      if (this.formData.context) {
        this.formData.context.preferences = value;
      }
    });
    prefsInput.inputEl.rows = 3;

    // Workflows section
    this.renderWorkflowsSection(section);
  }

  /**
   * Render Agent & Files section
   */
  private renderAgentFilesSection(container: HTMLElement): void {
    const section = container.createDiv('nexus-form-section');
    section.createEl('h4', { text: 'Agent & Files', cls: 'nexus-section-header' });

    // Ensure context exists
    if (!this.formData.context) {
      this.formData.context = {
        purpose: '',
        workflows: [],
        keyFiles: [],
        preferences: ''
      };
    }

    // Dedicated Agent field
    const agentField = section.createDiv('nexus-form-field');
    agentField.createEl('label', { text: 'Dedicated Agent', cls: 'nexus-form-label' });

    const dropdownContainer = agentField.createDiv('nexus-dropdown-container');
    const dropdown = new DropdownComponent(dropdownContainer);

    dropdown.addOption('', 'None');
    this.availableAgents.forEach(agent => {
      dropdown.addOption(agent.id, agent.name);
    });

    const currentAgentId = this.formData.context?.dedicatedAgent?.agentId || '';
    dropdown.setValue(currentAgentId);

    dropdown.onChange((value) => {
      if (!this.formData.context) {
        this.formData.context = {
          purpose: '', workflows: [], keyFiles: [], preferences: ''
        };
      }

      if (value) {
        const selectedAgent = this.availableAgents.find(agent => agent.id === value);
        if (selectedAgent) {
          this.formData.context.dedicatedAgent = {
            agentId: selectedAgent.id,
            agentName: selectedAgent.name
          };
        }
      } else {
        delete this.formData.context.dedicatedAgent;
      }
    });

    // Key Files section
    this.renderKeyFilesSection(section);
  }

  /**
   * Render Workflows subsection
   */
  private renderWorkflowsSection(container: HTMLElement): void {
    const subsection = container.createDiv('nexus-form-field');
    subsection.createEl('label', { text: 'Workflows', cls: 'nexus-form-label' });

    // Ensure workflows array exists
    if (!this.formData.context?.workflows) {
      this.formData.context = this.formData.context || {
        purpose: '', workflows: [], keyFiles: [], preferences: ''
      };
      this.formData.context.workflows = [];
    }

    const listContainer = subsection.createDiv('nexus-item-list');

    if (this.formData.context.workflows.length === 0) {
      listContainer.createEl('span', { text: 'None', cls: 'nexus-form-hint' });
    } else {
      this.formData.context.workflows.forEach((workflow, index) => {
        const item = listContainer.createDiv('nexus-item-row');

        const info = item.createDiv('nexus-item-info');
        const workflowName = workflow.name || `Workflow ${index + 1}`;
        info.createEl('span', { text: workflowName, cls: 'nexus-item-title' });

        const actions = item.createDiv('nexus-item-actions');
        new ButtonComponent(actions)
          .setButtonText('Edit')
          .onClick(() => this.onWorkflowEdit(index));
        new ButtonComponent(actions)
          .setButtonText('Ã—')
          .setWarning()
          .onClick(() => {
            this.formData.context!.workflows!.splice(index, 1);
            this.onRefresh();
          });
      });
    }

    new ButtonComponent(subsection)
      .setButtonText('+ Add Workflow')
      .onClick(() => {
        this.formData.context!.workflows!.push({ name: '', when: '', steps: '' });
        this.onWorkflowEdit(this.formData.context!.workflows!.length - 1);
      });
  }

  /**
   * Render Key Files subsection
   */
  private renderKeyFilesSection(container: HTMLElement): void {
    const subsection = container.createDiv('nexus-form-field');
    subsection.createEl('label', { text: 'Key Files', cls: 'nexus-form-label' });

    if (!this.formData.context?.keyFiles) {
      this.formData.context = this.formData.context || {
        purpose: '', workflows: [], keyFiles: [], preferences: ''
      };
      this.formData.context.keyFiles = [];
    }

    const listContainer = subsection.createDiv('nexus-item-list');

    const updateKeyFilesList = () => {
      listContainer.empty();

      if (this.formData.context!.keyFiles!.length === 0) {
        listContainer.createEl('span', { text: 'None', cls: 'nexus-form-hint' });
      } else {
        this.formData.context!.keyFiles!.forEach((filePath, index) => {
          const item = listContainer.createDiv('nexus-item-row');

          const input = new TextComponent(item);
          input.setPlaceholder('path/to/file.md');
          input.setValue(filePath);
          input.onChange((value) => {
            this.formData.context!.keyFiles![index] = value;
          });

          const actions = item.createDiv('nexus-item-actions');
          new ButtonComponent(actions)
            .setButtonText('Browse')
            .onClick(() => this.onFilePick(index));
          new ButtonComponent(actions)
            .setButtonText('Ã—')
            .setWarning()
            .onClick(() => {
              this.formData.context!.keyFiles!.splice(index, 1);
              updateKeyFilesList();
            });
        });
      }
    };

    updateKeyFilesList();

    new ButtonComponent(subsection)
      .setButtonText('+ Add Key File')
      .onClick(() => {
        const newIndex = this.formData.context!.keyFiles!.length;
        this.formData.context!.keyFiles!.push('');
        this.onFilePick(newIndex);
      });
  }
}

```

## config.ts

```typescript
/**
 * Plugin configuration
 */
export const CONFIG = {
    /**
     * Plugin name
     */
    PLUGIN_NAME: 'Nexus',
    
    /**
     * Plugin version
     */
    VERSION: '2.6.3',
    
    /**
     * Default port for the MCP server
     */
    DEFAULT_PORT: 3001,
    
    /**
     * Default host for the MCP server
     */
    DEFAULT_HOST: 'localhost',
    
    /**
     * Default timeout for requests (in milliseconds)
     */
    DEFAULT_TIMEOUT: 1200000,
    
    /**
     * Maximum number of concurrent requests
     */
    MAX_CONCURRENT_REQUESTS: 100
};

```

## config/agentConfigs.ts

```typescript
/**
 * Agent Configuration for Bounded Context Tool Packs
 *
 * Location: /src/config/agentConfigs.ts
 * Purpose: Define agent descriptors for the bounded context tool discovery system
 *
 * This file contains simple agent descriptors with name and description,
 * used by the two-tier tool discovery system to expose agents to LLM providers.
 */

export interface AgentDescriptor {
  name: string;        // Agent identifier (e.g., "promptManager", "searchManager")
  description: string; // What this agent does (shown in enum description)
}

/**
 * The 6 core agents available in the Nexus plugin
 * These map directly to the agent implementations in /src/agents/
 */
export const AGENTS: AgentDescriptor[] = [
  {
    name: "promptManager",
    description: "Custom prompts, LLM integration, image generation, subagent spawning"
  },
  {
    name: "contentManager",
    description: "Note reading, editing, appending, replacing content in vault files"
  },
  {
    name: "searchManager",
    description: "Advanced search (universal, file search, directory search, memory search)"
  },
  {
    name: "storageManager",
    description: "File/folder operations (list, createFolder, move, copy, archive, open)"
  },
  {
    name: "memoryManager",
    description: "Session management, workspace management, and states"
  }
  // Temporarily hidden (2025-11-06) - See /src/config/toolVisibility.ts
  // {
  //   name: "commandManager",
  //   description: "Obsidian command palette execution"
  // }
];

```

## config/toolVisibility.ts

```typescript
/**
 * Tool Visibility Configuration
 *
 * Controls which agents and tools are exposed as MCP tools.
 * Set `hidden: true` to temporarily disable tools without deleting code.
 *
 * This configuration affects:
 * - Claude Desktop MCP tool list
 * - Internal chat bounded context tool discovery
 * - Agent tool registration at initialization
 */

export interface ModeVisibilityConfig {
    hidden: boolean;
    reason?: string;
}

export interface AgentVisibilityConfig {
    hidden?: boolean;  // If true, hides entire agent
    reason?: string;
    modes?: {
        [modeName: string]: ModeVisibilityConfig;
    };
}

export const TOOL_VISIBILITY: {
    [agentName: string]: AgentVisibilityConfig;
} = {
    commandManager: {
        hidden: true,
        reason: 'Causing issues and not providing enough value currently (2025-11-06)'
    }
};

/**
 * Check if an agent should be hidden
 */
export function isAgentHidden(agentName: string): boolean {
    const config = TOOL_VISIBILITY[agentName];
    return config?.hidden === true;
}

/**
 * Check if a specific tool should be hidden
 */
export function isModeHidden(agentName: string, modeName: string): boolean {
    const config = TOOL_VISIBILITY[agentName];

    // If entire agent is hidden, all tools are hidden
    if (config?.hidden === true) {
        return true;
    }

    // Check specific tool visibility
    return config?.modes?.[modeName]?.hidden === true;
}

/**
 * Get the reason why a tool is hidden (for logging/debugging)
 */
export function getHiddenReason(agentName: string, modeName?: string): string | undefined {
    const config = TOOL_VISIBILITY[agentName];

    if (modeName && config?.modes?.[modeName]) {
        return config.modes[modeName].reason;
    }

    return config?.reason;
}

```

## connector.ts

```typescript
import { App, Plugin, Events } from 'obsidian';
import NexusPlugin from './main';
import { SessionContextManager, WorkspaceContext } from './services/SessionContextManager';
import type { ServiceManager } from './core/ServiceManager';
import { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';
import { logger } from './utils/logger';
import { CustomPromptStorageService } from "./agents/promptManager/services/CustomPromptStorageService";
import { generateSessionId, formatSessionInstructions, isStandardSessionId } from './utils/sessionUtils';
import { getContextSchema } from './utils/schemaUtils';
// ToolCallCaptureService removed in simplified architecture

// Extracted services
import { MCPConnectionManager, MCPConnectionManagerInterface } from './services/mcp/MCPConnectionManager';
import { ToolCallRouter, ToolCallRouterInterface } from './services/mcp/ToolCallRouter';
import { AgentRegistrationService, AgentRegistrationServiceInterface } from './services/agent/AgentRegistrationService';
import { ToolCallTraceService } from './services/trace/ToolCallTraceService';

// Type definitions
import { AgentToolParams } from './types/agent/AgentTypes';
import { SearchManagerAgent } from './agents';
import { MemoryManagerAgent } from './agents';
import { AGENTS } from './config/agentConfigs';
import { IAgent } from './agents/interfaces/IAgent';
import { ITool } from './agents/interfaces/ITool';

/**
 * Type guard to check if a plugin is a NexusPlugin instance
 */
function isNexusPlugin(plugin: Plugin | NexusPlugin): plugin is NexusPlugin {
    return 'getServiceContainer' in plugin && 'settings' in plugin;
}

/**
 * MCP Connector
 * Orchestrates MCP server operations through extracted services:
 * - MCPConnectionManager: Handles server lifecycle
 * - ToolCallRouter: Routes tool calls to agents/tools
 * - AgentRegistrationService: Manages agent initialization and registration
 */
export class MCPConnector {
    private connectionManager: MCPConnectionManagerInterface;
    private toolRouter: ToolCallRouterInterface;
    private agentRegistry: AgentRegistrationServiceInterface;
    private events: Events;
    private sessionContextManager: SessionContextManager | null = null;
    private customPromptStorage?: CustomPromptStorageService;
    private serviceManager?: ServiceManager;

    constructor(
        private app: App,
        private plugin: Plugin | NexusPlugin
    ) {
        // Initialize core components - use Obsidian's Events API
        this.events = new Events();
        // SessionContextManager will be retrieved from ServiceManager via lazy getter

        // Get service manager reference
        if (this.plugin && isNexusPlugin(this.plugin)) {
            this.serviceManager = this.plugin.getServiceContainer();
        }

        // Initialize custom prompt storage if possible
        // Note: Settings might not be fully loaded yet, so we'll check again during initialization
        const pluginSettings = this.plugin && isNexusPlugin(this.plugin) ? this.plugin.settings : null;
        if (pluginSettings) {
            try {
                this.customPromptStorage = new CustomPromptStorageService(pluginSettings);
                logger.systemLog('CustomPromptStorageService initialized successfully');
            } catch (error) {
                logger.systemError(error as Error, 'CustomPromptStorageService Initialization');
                this.customPromptStorage = undefined;
            }
        } else {
            logger.systemWarn('Plugin settings not available during MCPConnector construction - will retry during initialization');
        }
        
        // Initialize extracted services
        // Note: SessionContextManager will be retrieved lazily from ServiceManager when needed
        this.connectionManager = new MCPConnectionManager(
            this.app,
            this.plugin,
            this.events,
            this.serviceManager,
            this.customPromptStorage,
            (toolName: string, params: any) => this.onToolCall(toolName, params),
            (toolName: string, params: any, response: any, success: boolean, executionTime: number) => this.onToolResponse(toolName, params, response, success, executionTime)
        );

        this.toolRouter = new ToolCallRouter();

        this.agentRegistry = new AgentRegistrationService(
            this.app,
            this.plugin,
            this.events,
            this.serviceManager,
            this.customPromptStorage
        );
    }

    /**
     * Lazy getter for SessionContextManager from ServiceManager
     * Ensures we use the properly initialized instance with SessionService injected
     */
    private getSessionContextManagerFromService(): SessionContextManager {
        if (!this.sessionContextManager) {
            if (!this.serviceManager) {
                throw new Error('[MCPConnector] ServiceManager not available - cannot get SessionContextManager');
            }

            this.sessionContextManager = this.serviceManager.getServiceIfReady('sessionContextManager');

            if (!this.sessionContextManager) {
                throw new Error('[MCPConnector] SessionContextManager not available from ServiceManager');
            }
        }
        return this.sessionContextManager;
    }

    /**
     * Handle tool call responses - now handled by ToolCallTraceService via MCPConnectionManager
     */
    private async onToolResponse(toolName: string, params: any, response: any, success: boolean, executionTime: number): Promise<void> {
        // Tool call tracing is now handled by ToolCallTraceService
        // This callback is kept for backward compatibility
    }

    /**
     * Handle tool calls - now handled by ToolCallTraceService via MCPConnectionManager
     */
    private async onToolCall(toolName: string, params: any): Promise<void> {
        // Tool call tracing is now handled by ToolCallTraceService
        // This callback is kept for backward compatibility
    }
    
    /**
     * Check if this tool call is workspace-related
     */
    private isWorkspaceOperation(toolName: string, params: any): boolean {
        const workspaceTools = [
            'memoryManager.switchWorkspace',
            'memoryManager.createWorkspace',
            'memoryManager.getWorkspace',
            'searchManager.search'
        ];
        
        return workspaceTools.some(tool => toolName.includes(tool)) || 
               (params && (params.workspaceId || params.workspace));
    }
    
    /**
     * Extract workspace ID from tool parameters
     */
    private extractWorkspaceId(params: any): string | null {
        if (params?.workspaceId) return params.workspaceId;
        if (params?.workspace) return params.workspace;
        if (params?.params?.workspaceId) return params.params.workspaceId;
        return null;
    }
    
    /**
     * Initialize all agents - delegates to AgentRegistrationService
     */
    public async initializeAgents(): Promise<void> {
        try {
            // Ensure customPromptStorage is available if settings are now loaded
            if (!this.customPromptStorage) {
                const pluginSettings = this.plugin && isNexusPlugin(this.plugin) ? this.plugin.settings : null;
                if (pluginSettings) {
                    try {
                        this.customPromptStorage = new CustomPromptStorageService(pluginSettings);

                        // Update the agent registry with the new storage service
                        this.agentRegistry = new AgentRegistrationService(
                            this.app,
                            this.plugin,
                            this.events,
                            this.serviceManager,
                            this.customPromptStorage
                        );

                        logger.systemLog('CustomPromptStorageService initialized during agent initialization');
                    } catch (error) {
                        logger.systemError(error as Error, 'Late CustomPromptStorageService Initialization');
                    }
                }
            }
            
            // Initialize connection manager first
            await this.connectionManager.initialize();
            
            // Set up tool router with server reference
            const server = this.connectionManager.getServer();
            if (server) {
                this.toolRouter.setServer(server);
            }
            
            // Initialize all agents through the registration service
            await this.agentRegistry.initializeAllAgents();

            // Register agents with server through the registration service
            this.agentRegistry.registerAgentsWithServer((agent: IAgent) => {
                if (server) {
                    server.registerAgent(agent);
                }
            });
            
            // Reinitialize request router with registered agents
            this.connectionManager.reinitializeRequestRouter();

            logger.systemLog('Agent initialization completed successfully');
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'Agent Initialization');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to initialize agents',
                error
            );
        }
    }
    
    /**
     * Call a tool using the new agent-mode architecture with integrated tool call capture
     * Now delegates to ToolCallRouter service for validation and execution
     */
    /**
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     * META-TOOLS: Special Exception to Standard Agent/Mode Pattern
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     *
     * The following tools are defined directly in connector.ts and do NOT
     * follow the standard agent/mode pattern used by all other tools.
     *
     * Current Meta-Tools:
     * - get_tools: Dynamic tool discovery for bounded context architecture
     *
     * What get_tools Does:
     * Allows LLMs to discover and load tool schemas on-demand by requesting
     * specific agents (e.g., storageManager, contentManager). Instead of
     * overwhelming the LLM with all 46 tools upfront, get_tools provides
     * just-in-time access to the tools needed for the current task.
     *
     * Why This Exception Exists:
     * - Tool discovery is a meta-operation, not a domain operation
     * - Requires direct access to agent registry and connector internals
     * - Must dynamically generate schemas based on registered agents
     * - Bounded context architecture intentionally has this meta-layer
     *
     * If adding more meta-tools in the future, consider creating a
     * dedicated meta-tools service to maintain consistency.
     * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     */

    /**
     * Get available tools for ChatService - Two-Tool Architecture
     * Returns only toolManager_getTools and toolManager_useTools
     *
     * This is the new two-tool architecture that replaces the old 50+ tool surface.
     * LLMs discover tools via getTools (which lists all available agents/tools in its description),
     * then execute tools via useTools with unified context.
     */
    getAvailableTools(): unknown[] {
        // Get toolManager agent
        const toolManagerAgent = this.agentRegistry?.getAgent('toolManager');

        if (!toolManagerAgent) {
            logger.systemWarn('ToolManager agent not yet initialized - returning empty tools list');
            return [];
        }

        // Get tools from toolManager (getTools and useTools)
        const toolManagerTools = toolManagerAgent.getTools();

        // Convert to MCP tool format
        // Use underscore separator (not dots) for API compatibility
        return toolManagerTools.map((tool: ITool<unknown, unknown>) => ({
            name: `toolManager_${tool.slug}`,
            description: tool.description,
            inputSchema: tool.getParameterSchema()
        }));
    }

    /**
     * Get overview of all agents and their available tools (no schemas)
     * Used when get_tools is called with empty tools array
     */
    private getAgentToolOverview(): Record<string, { description: string; tools: string[] }> {
        const overview: Record<string, { description: string; tools: string[] }> = {};

        if (!this.agentRegistry) {
            return overview;
        }

        const registeredAgents = this.agentRegistry.getAllAgents();

        for (const [agentName, agent] of registeredAgents) {
            const tools = agent.getTools();
            const agentDescription = agent.description;

            overview[agentName] = {
                description: agentDescription,
                tools: tools.map((tool: ITool<unknown, unknown>) => tool.slug || tool.name || 'unknown')
            };
        }

        return overview;
    }

    /**
     * Get schemas for specific tool names (called via get_tools meta-tool)
     * Returns clean schemas WITHOUT common parameters to reduce context bloat
     *
     * @param toolNames Array of specific tool names like ["contentManager_createNote", "searchManager_searchDirectory"]
     */
    private getToolsForSpecificNames(toolNames: string[]): Array<{ name: string; description: string; inputSchema: Record<string, unknown> }> {
        const toolSchemas: Array<{ name: string; description: string; inputSchema: Record<string, unknown> }> = [];

        if (!this.agentRegistry) {
            return [];
        }

        const registeredAgents = this.agentRegistry.getAllAgents();

        for (const toolName of toolNames) {
            // Parse tool name: "contentManager_createNote" -> agentName="contentManager", toolSlug="createNote"
            const parts = toolName.split('_');
            if (parts.length < 2) {
                continue; // Invalid tool name format
            }

            const agentName = parts[0];
            const toolSlug = parts.slice(1).join('_'); // Handle tool names with underscores

            // Find the agent
            const agent = registeredAgents.get(agentName);
            if (!agent) {
                continue; // Agent not found
            }

            // Find the tool
            const tools = agent.getTools();
            const toolInstance = tools.find((t: ITool<unknown, unknown>) =>
                (t.slug || t.name) === toolSlug
            );

            if (!toolInstance) {
                continue; // Tool not found
            }

            // Get and clean the schema
            if (typeof toolInstance.getParameterSchema === 'function') {
                try {
                    const paramSchema = toolInstance.getParameterSchema();

                    // Strip common parameters to reduce context bloat
                    // The instruction in get_tools result will tell LLM to add them
                    const cleanSchema = this.stripCommonParameters(paramSchema);

                    toolSchemas.push({
                        name: toolName,
                        description: toolInstance.description || `Execute ${toolSlug} on ${agentName}`,
                        inputSchema: cleanSchema
                    });
                } catch (error) {
                    // Skip tools with invalid schemas
                }
            }
        }

        return toolSchemas;
    }

    /**
     * Strip common parameters from tool schema to reduce context bloat
     * Common parameters (context, workspaceContext, sessionId) are documented in get_tools instruction
     */
    private stripCommonParameters(schema: any): any {
        if (!schema || !schema.properties) {
            return schema;
        }

        const { context, workspaceContext, sessionId, ...cleanProperties } = schema.properties;
        const cleanRequired = (schema.required || []).filter(
            (field: string) => field !== 'context' && field !== 'workspaceContext' && field !== 'sessionId'
        );

        return {
            ...schema,
            properties: cleanProperties,
            required: cleanRequired.length > 0 ? cleanRequired : undefined
        };
    }

    async callTool(params: AgentToolParams): Promise<unknown> {
        try {
            const { agent, tool, params: toolParams } = params;

            // ========================================
            // BOUNDED CONTEXT TOOL DISCOVERY - Intercept get_tools meta-tool
            // ========================================
            if (agent === 'get' && tool === 'tools') {
                // This is a call to the get_tools meta-tool
                const toolParamsTyped = toolParams as Record<string, unknown>;
                const contextTyped = toolParamsTyped.context as Record<string, unknown> | undefined;
                const toolNames = (toolParamsTyped.tools || contextTyped?.tools || []) as string[];

                if (!Array.isArray(toolNames)) {
                    return {
                        success: false,
                        error: 'tools parameter must be an array'
                    };
                }

                const sessionId = contextTyped?.sessionId as string | undefined;
                const workspaceId = (contextTyped?.workspaceId || 'default') as string;

                // TIER 1: Discovery mode (empty array) - return agent/tool overview
                if (toolNames.length === 0) {
                    const overview = this.getAgentToolOverview();

                    return {
                        success: true,
                        overview: overview,
                        sessionId: sessionId,
                        workspaceId: workspaceId,
                        instruction: 'Above is the overview of all available agents and their tools. To use specific tools, call get_tools again with the exact tool names (e.g., get_tools({ tools: ["contentManager_createNote", "searchManager_searchDirectory"] }))'
                    };
                }

                // TIER 2: Specific tool retrieval - return schemas for requested tools
                const tools = this.getToolsForSpecificNames(toolNames);

                if (tools.length === 0) {
                    return {
                        success: false,
                        error: `No valid tools found for the requested names: ${toolNames.join(', ')}. Make sure to use exact tool names like "contentManager_createNote".`
                    };
                }

                // Instruction for LLM to add common parameters to every tool call
                // Uses new memory/goal/constraints format (not legacy sessionDescription/sessionMemory)
                const instruction = `
IMPORTANT: All ${tools.length} tools returned require a 'context' parameter that was omitted from schemas to reduce token usage.

You MUST add the following 'context' object to EVERY tool call:

{
  "context": {
    "workspaceId": "${workspaceId}",
    "sessionId": "${sessionId || 'REQUIRED'}",
    "memory": "Essence of conversation so far (1-3 sentences)",
    "goal": "Current objective (1-3 sentences)",
    "constraints": "Optional rules/limits to follow (1-3 sentences)"
  }
}

The 4 required fields are: workspaceId, sessionId, memory, goal. constraints is optional.
Update memory and goal as the conversation evolves.
Keep workspaceId and sessionId values EXACTLY as shown above throughout the conversation.
`.trim();

                return {
                    success: true,
                    tools: tools,
                    requestedTools: toolNames,
                    toolCount: tools.length,
                    instruction: instruction
                };
            }

            // ========================================
            // SESSION VALIDATION & WORKSPACE CONTEXT INJECTION
            // ========================================

            // Type the toolParams for proper access
            const typedParams = toolParams as Record<string, unknown> & {
                context?: Record<string, unknown>;
                sessionId?: string;
                workspaceContext?: { workspaceId?: string };
            };

            // 1. SESSION ID VALIDATION: Extract and validate/generate sessionId first
            const providedSessionId = (typedParams.context?.sessionId || typedParams.sessionId) as string | undefined;
            let validatedSessionId: string;
            let isNewSession = false;
            let isNonStandardId = false;

            if (!providedSessionId || !isStandardSessionId(providedSessionId)) {
                // No sessionId or non-standard format - generate a new one
                validatedSessionId = generateSessionId();
                isNewSession = true;
                isNonStandardId = !!providedSessionId; // True if they provided a friendly name
            } else {
                // Valid standard sessionId - use it
                validatedSessionId = providedSessionId;
            }

            // 2. INJECT VALIDATED SESSION ID into all relevant locations
            if (!typedParams.context) {
                typedParams.context = {};
            }
            typedParams.context.sessionId = validatedSessionId;
            typedParams.sessionId = validatedSessionId;

            // 3. WORKSPACE CONTEXT LOOKUP FROM SESSION
            const sessionContextManager = this.getSessionContextManagerFromService();
            const workspaceContext = sessionContextManager.getWorkspaceContext(validatedSessionId);

            if (workspaceContext) {
                // Inject workspace context from session
                typedParams.workspaceContext = workspaceContext;
                typedParams.context.workspaceId = workspaceContext.workspaceId;
            } else {
                // Fallback to default if no session workspace
                if (!typedParams.workspaceContext) {
                    typedParams.workspaceContext = { workspaceId: 'default' };
                } else if (!typedParams.workspaceContext.workspaceId) {
                    typedParams.workspaceContext.workspaceId = 'default';
                }

                if (typedParams.context && !typedParams.context.workspaceId) {
                    typedParams.context.workspaceId = typedParams.workspaceContext.workspaceId;
                }
            }

            // Delegate validation and execution to ToolCallRouter
            this.toolRouter.validateBatchOperations(typedParams);
            const startTime = Date.now();
            const result = await this.toolRouter.executeAgentTool(agent, tool, typedParams);
            const executionTime = Date.now() - startTime;

            // ========================================
            // CAPTURE TOOL CALL TRACE TO WORKSPACE
            // ========================================
            const traceService = this.serviceManager?.getServiceIfReady<ToolCallTraceService>('toolCallTraceService');
            if (traceService && typeof traceService.captureToolCall === 'function') {
                const toolTraceName = `${agent}_${tool}`;
                const resultObj = result as Record<string, unknown> | null;
                const success = !resultObj?.error;

                traceService.captureToolCall(
                    toolTraceName,
                    typedParams,
                    result,
                    success,
                    executionTime
                ).catch((err: Error) => {
                    // Silent error handling for tool trace capture
                });
            }

            // Don't inject sessionId/workspaceId into result - LLM already knows these
            // since it passed them in. Adding them wastes tokens.
            // Session instructions only needed for new sessions via MCP Server path.

            return result;
            
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            throw new McpError(
                ErrorCode.InvalidParams,
                (error as Error).message || 'Failed to call tool',
                error
            );
        }
    }
    /**
     * Start the MCP server - delegates to MCPConnectionManager
     */
    async start(): Promise<void> {
        try {
            // Initialize agents and connection manager first
            await this.initializeAgents();

            // Then start the server
            await this.connectionManager.start();
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'Server Start');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to start MCP server',
                error
            );
        }
    }
    
    /**
     * Stop the MCP server - delegates to MCPConnectionManager
     */
    async stop(): Promise<void> {
        try {
            await this.connectionManager.stop();
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'Server Stop');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to stop MCP server',
                error
            );
        }
    }
    
    /**
     * Get the MCP server instance - delegates to MCPConnectionManager
     */
    getServer(): any {
        return this.connectionManager.getServer();
    }
    
    /**
     * Get the connection manager instance
     */
    getConnectionManager(): MCPConnectionManagerInterface {
        return this.connectionManager;
    }
    
    /**
     * Get the tool router instance
     */
    getToolRouter(): ToolCallRouterInterface {
        return this.toolRouter;
    }
    
    /**
     * Get the agent registry instance
     */
    getAgentRegistry(): AgentRegistrationServiceInterface {
        return this.agentRegistry;
    }
    
    /**
     * Get the events instance (Obsidian Events API)
     */
    getEvents(): Events {
        return this.events;
    }
    
    /**
     * Get the search manager instance - delegates to AgentRegistrationService
     */
    getSearchManager(): SearchManagerAgent | null {
        return this.agentRegistry.getAgent('searchManager') as SearchManagerAgent | null;
    }
    
    /**
     * Get the memory manager instance - delegates to AgentRegistrationService
     */
    getMemoryManager(): MemoryManagerAgent | null {
        return this.agentRegistry.getAgent('memoryManager') as MemoryManagerAgent | null;
    }
    
    
    /**
     * Get the session context manager instance
     */
    getSessionContextManager(): SessionContextManager {
        return this.getSessionContextManagerFromService();
    }
    
    /**
     * Set default workspace context for all new sessions
     * The default context will be used when a session doesn't have an explicit workspace context
     * 
     * @param workspaceId Workspace ID 
     * @param workspacePath Optional hierarchical path within the workspace
     * @returns True if successful
     */
    setDefaultWorkspaceContext(workspaceId: string, workspacePath?: string[]): boolean {
        if (!workspaceId) {
            logger.systemWarn('Cannot set default workspace context with empty workspaceId');
            return false;
        }
        
        const context: WorkspaceContext = {
            workspaceId,
            workspacePath,
            activeWorkspace: true
        };
        
        this.getSessionContextManagerFromService().setDefaultWorkspaceContext(context);
        return true;
    }

    /**
     * Clear the default workspace context
     */
    clearDefaultWorkspaceContext(): void {
        this.getSessionContextManagerFromService().setDefaultWorkspaceContext(null);
    }
    
    /**
     * Set workspace context for a specific session
     * 
     * @param sessionId Session ID
     * @param workspaceId Workspace ID
     * @param workspacePath Optional hierarchical path within the workspace
     * @returns True if successful
     */
    setSessionWorkspaceContext(sessionId: string, workspaceId: string, workspacePath?: string[]): boolean {
        if (!sessionId || !workspaceId) {
            logger.systemWarn('Cannot set session workspace context with empty sessionId or workspaceId');
            return false;
        }
        
        const context: WorkspaceContext = {
            workspaceId,
            workspacePath,
            activeWorkspace: true
        };
        
        this.getSessionContextManagerFromService().setWorkspaceContext(sessionId, context);
        return true;
    }
}

```

## constants/branding.ts

```typescript
import { sanitizeVaultName } from '../utils/vaultUtils';

export const BRAND_NAME = 'Nexus';
export const LEGACY_BRAND_NAME = 'Claudesidian';

export const PLUGIN_IDS = {
    current: 'nexus',
    legacy: ['claudesidian-mcp']
} as const;

export const SERVER_KEY_PREFIXES = {
    current: 'nexus',
    legacy: ['claudesidian-mcp']
} as const;

export const PIPE_NAME_PREFIXES = {
    current: 'nexus_mcp',
    legacy: ['claudesidian_mcp']
} as const;

export const CHAT_VIEW_TYPES = {
    current: 'nexus-chat',
    legacy: ['claudesidian-chat']
} as const;

export const SERVER_LABELS = {
    current: 'nexus',
    legacy: ['claudesidian']
} as const;

export function getAllPluginIds(): string[] {
    return [PLUGIN_IDS.current, ...PLUGIN_IDS.legacy];
}

export function getAllServerKeyPrefixes(): string[] {
    return [SERVER_KEY_PREFIXES.current, ...SERVER_KEY_PREFIXES.legacy];
}

export function getAllPipePrefixes(): string[] {
    return [PIPE_NAME_PREFIXES.current, ...PIPE_NAME_PREFIXES.legacy];
}

export function getAllServerLabels(): string[] {
    return [SERVER_LABELS.current, ...SERVER_LABELS.legacy];
}

export function buildServerKeyFromSanitized(
    sanitizedVaultName: string,
    prefix: string
): string {
    return `${prefix}-${sanitizedVaultName}`;
}

export function getServerKeyCandidates(vaultName: string): string[] {
    const sanitized = sanitizeVaultName(vaultName);
    const prefixes = Array.from(new Set(getAllServerKeyPrefixes()));
    return prefixes.map(prefix => buildServerKeyFromSanitized(sanitized, prefix));
}

export function getPrimaryServerKey(vaultName: string): string {
    const sanitized = sanitizeVaultName(vaultName);
    return buildServerKeyFromSanitized(sanitized, SERVER_KEY_PREFIXES.current);
}

export function buildIpcPath(
    sanitizedVaultName: string,
    isWindows: boolean,
    prefix: string
): string {
    return isWindows
        ? `\\\\.\\pipe\\${prefix}_${sanitizedVaultName}`
        : `/tmp/${prefix}_${sanitizedVaultName}.sock`;
}

export function getIpcPathCandidates(
    vaultName: string,
    isWindows: boolean
): string[] {
    const sanitized = sanitizeVaultName(vaultName);
    const prefixes = Array.from(new Set(getAllPipePrefixes()));
    return prefixes.map(prefix => buildIpcPath(sanitized, isWindows, prefix));
}

export function getPrimaryIpcPath(vaultName: string, isWindows: boolean): string {
    const sanitized = sanitizeVaultName(vaultName);
    return buildIpcPath(sanitized, isWindows, PIPE_NAME_PREFIXES.current);
}

```

## core/background/BackgroundProcessor.ts

```typescript
/**
 * Location: /src/core/background/BackgroundProcessor.ts
 * 
 * Background Processor - Handles background tasks, startup processing, and validation
 * 
 * This service extracts background processing logic from PluginLifecycleManager,
 * managing deferred operations and non-critical startup tasks.
 */

import { Notice } from 'obsidian';
import type { Plugin } from 'obsidian';
import type { Settings } from '../../settings';
import type { SettingsView } from '../../settings/SettingsView';
import { UpdateManager } from '../../utils/UpdateManager';

export interface BackgroundProcessorConfig {
    plugin: Plugin;
    settings: Settings;
    serviceManager: any;
    settingsTab?: SettingsView;
    getService: <T>(name: string, timeoutMs?: number) => Promise<T | null>;
    waitForService: <T>(serviceName: string, timeoutMs?: number) => Promise<T | null>;
    isInitialized: () => boolean;
}

export class BackgroundProcessor {
    private config: BackgroundProcessorConfig;
    private hasRunBackgroundStartup: boolean = false;

    constructor(config: BackgroundProcessorConfig) {
        this.config = config;
    }

    /**
     * Start background startup processing - runs independently after plugin initialization
     */
    startBackgroundStartupProcessing(): void {
        // Prevent multiple background startup processes
        if (this.hasRunBackgroundStartup) {
            return;
        }
        
        // Run startup processing in background without blocking plugin initialization
        setTimeout(async () => {
            try {
                // Double-check to prevent race conditions
                if (this.hasRunBackgroundStartup) {
                    return;
                }
                
                this.hasRunBackgroundStartup = true;

                // Background startup processing completed
            } catch (error) {
                console.error('Error in background startup processing:', error);
                // Reset flag on error so it can be retried
                this.hasRunBackgroundStartup = false;
            }
        }, 2000); // 2 second delay to ensure Obsidian is fully loaded
    }

    /**
     * Check for updates on startup in background
     */
    async checkForUpdatesOnStartup(): Promise<void> {
        // Run in background to avoid blocking startup
        setTimeout(async () => {
            try {
                const { settings } = this.config;
                const lastCheck = settings.settings.lastUpdateCheckDate;
                if (lastCheck) {
                    const lastCheckTime = new Date(lastCheck);
                    const now = new Date();
                    const daysDiff = (now.getTime() - lastCheckTime.getTime()) / (1000 * 60 * 60 * 24);
                    if (daysDiff < 1) {
                        return;
                    }
                }

                const updateManager = new UpdateManager(this.config.plugin);
                const hasUpdate = await updateManager.checkForUpdate();

                settings.settings.lastUpdateCheckDate = new Date().toISOString();

                if (hasUpdate) {
                    const availableVersion = await updateManager.getLatestVersion();

                    settings.settings.availableUpdateVersion = availableVersion;

                    new Notice(`Plugin update available: v${availableVersion}. Check settings to update.`, 8000);
                } else {
                    settings.settings.availableUpdateVersion = undefined;
                }

                await settings.saveSettings();

            } catch (error) {
                console.error('Failed to check for updates:', error);
            }
        }, 2000); // 2 second delay
    }

    async validateSearchFunctionality(): Promise<void> {
        try {
            const serviceManager = this.config.serviceManager;
            if (serviceManager) {
                const metadata = serviceManager.getAllServiceStatus();
                const serviceNames = Object.keys(metadata);

                const coreServices = ['workspaceService', 'memoryService', 'chatService'];
                const availableCore = coreServices.filter(service => serviceNames.includes(service));
            }
        } catch (error) {
        }
    }

    /**
     * Update settings tab with available services (non-blocking)
     */
    updateSettingsTabServices(): void {
        if (this.config.settingsTab) {
            const services: Record<string, any> = {};
            for (const serviceName of this.config.serviceManager.getReadyServices()) {
                services[serviceName] = this.config.serviceManager.getServiceIfReady(serviceName);
            }
            this.config.settingsTab.updateServices(services);
        }
    }

    /**
     * Update settings tab reference (used when settings tab is created)
     */
    setSettingsTab(settingsTab: SettingsView): void {
        this.config.settingsTab = settingsTab;
    }

    /**
     * Check if background startup processing has run
     */
    hasRunBackgroundStartupProcessing(): boolean {
        return this.hasRunBackgroundStartup;
    }

    /**
     * Reset background startup flag (useful for testing)
     */
    resetBackgroundStartupFlag(): void {
        this.hasRunBackgroundStartup = false;
    }
}
```

## core/commands/CommandDefinitions.ts

```typescript
/**
 * Command Definitions
 * Basic command definitions for plugin functionality
 */

export interface CommandContext {
  plugin: any;
  serviceManager: any;
  getService?: (name: any, timeoutMs?: any) => any;
  isInitialized?: () => boolean;
}

export const BASIC_COMMAND_DEFINITIONS = [
  {
    id: 'open-settings',
    name: 'Open Plugin Settings',
    callback: (context: CommandContext) => {
      context.plugin.app.setting.open();
      context.plugin.app.setting.openTabById(context.plugin.manifest.id);
    }
  }
];

export const MAINTENANCE_COMMAND_DEFINITIONS = BASIC_COMMAND_DEFINITIONS;
export const TROUBLESHOOT_COMMAND_DEFINITION = BASIC_COMMAND_DEFINITIONS[0];
```

## core/commands/MaintenanceCommandManager.ts

```typescript
/**
 * Maintenance Command Manager
 * Handles maintenance and troubleshooting commands
 */

import { Notice } from 'obsidian';
import { CommandContext } from './CommandDefinitions';
import type NexusPlugin from '../../main';

export class MaintenanceCommandManager {
  constructor(private context: CommandContext) {}

  /**
   * Execute maintenance command
   */
  async executeMaintenanceCommand(commandId: string): Promise<void> {
    // Basic maintenance operations
  }

  /**
   * Get available maintenance commands
   */
  getMaintenanceCommands(): string[] {
    return ['open-settings', 'run-diagnostics'];
  }

  /**
   * Register maintenance commands
   */
  registerMaintenanceCommands(): void {
    this.registerDiagnosticsCommand();
  }

  /**
   * Register troubleshoot command
   */
  registerTroubleshootCommand(): void {
  }

  /**
   * Register diagnostics command for testing service health
   */
  private registerDiagnosticsCommand(): void {
    this.context.plugin.addCommand({
      id: 'run-service-diagnostics',
      name: 'Run Service Diagnostics',
      callback: async () => {
        await this.runServiceDiagnostics();
      }
    });
  }

  /**
   * Run comprehensive service diagnostics
   */
  private async runServiceDiagnostics(): Promise<void> {
    new Notice('Running service diagnostics... Check console for results.');

    let passed = 0;
    let failed = 0;
    const results: string[] = [];

    // Check critical services
    const criticalServices = [
      'vaultOperations',
      'workspaceService',
      'memoryService',
      'sessionService',
      'llmService',
      'customPromptStorageService',
      'conversationService',
      'chatService'
    ];

    for (const serviceName of criticalServices) {
      try {
        if (!this.context.getService) {
          console.error(`âŒ ${serviceName}: getService not available`);
          results.push(`âŒ ${serviceName}: getService not available`);
          failed++;
          continue;
        }

        const service = await this.context.getService(serviceName, 5000);
        if (service) {
          results.push(`âœ… ${serviceName}`);
          passed++;
        } else {
          console.error(`âŒ ${serviceName}: Not initialized`);
          results.push(`âŒ ${serviceName}: Not initialized`);
          failed++;
        }
      } catch (error: any) {
        console.error(`âŒ ${serviceName}: Error -`, error.message);
        results.push(`âŒ ${serviceName}: ${error.message}`);
        failed++;
      }
    }

    // Check plugin.services getter
    const services = (this.context.plugin as NexusPlugin).services;
    const expectedServices = ['memoryService', 'workspaceService', 'sessionService', 'conversationService', 'customPromptStorageService'];

    for (const name of expectedServices) {
      if (services && services[name]) {
        results.push(`âœ… plugin.services.${name}`);
        passed++;
      } else {
        console.error(`âŒ plugin.services.${name}: Missing`);
        results.push(`âŒ plugin.services.${name}: Missing`);
        failed++;
      }
    }

    // Final report
    if (failed === 0) {
      new Notice(`âœ… All services healthy! (${passed} passed)`);
    } else {
      new Notice(`âš ï¸ ${failed} service(s) failed. Check console for details.`);
    }
  }
}
```

## core/index.ts

```typescript
/**
 * Core Components Index - Obsidian API-First Architecture
 * Location: src/core/index.ts
 * 
 * Central export point for all core architecture components that implement
 * the Obsidian API-first migration. This provides clean imports and ensures
 * consistent usage across the codebase.
 * 
 * Components provided:
 * - VaultOperations: Cross-platform file operations using Vault API
 * - ObsidianPathManager: Path management with security and normalization
 * - PluginDataManager: Type-safe settings and data persistence
 * - StructuredLogger: Configurable logging system
 * - ServiceContainer: Dependency injection container
 * 
 * Usage:
 * import { VaultOperations, StructuredLogger } from './core';
 */

// Core services
export { VaultOperations } from './VaultOperations';
export { ObsidianPathManager } from './ObsidianPathManager';
export { PluginDataManager, SettingsMigrationManager } from './PluginDataManager';
export { StructuredLogger, ContextLogger, LogLevel } from './StructuredLogger';
export { ServiceContainer } from './ServiceContainer';

// Type exports for external usage
export type { 
  BatchWriteOperation, 
  BatchWriteResult, 
  FileStats 
} from './VaultOperations';

export type { 
  PathValidationResult 
} from './ObsidianPathManager';

export type { 
  SettingsSchema, 
  SettingsMigration, 
  BackupData 
} from './PluginDataManager';

export type { 
  LogEntry, 
  LoggerConfig 
} from './StructuredLogger';

export type { 
  ServiceFactory, 
  ServiceRegistration, 
  ServiceMetadata 
} from './ServiceContainer';

/**
 * Utility function to create a complete service setup for a plugin
 * This provides a quick way to bootstrap the new architecture
 */
export async function createCoreServices(plugin: any) {
  // Import components directly to avoid circular dependency
  const { StructuredLogger } = await import('./StructuredLogger');
  const { ObsidianPathManager } = await import('./ObsidianPathManager');
  const { PluginDataManager } = await import('./PluginDataManager');
  const { VaultOperations } = await import('./VaultOperations');
  const { ServiceContainer } = await import('./ServiceContainer');
  
  // Create logger first
  const logger = new StructuredLogger(plugin);
  
  // Create path manager with manifest
  const pathManager = new ObsidianPathManager(plugin.app.vault, plugin.manifest);
  
  // Create data manager with defaults
  const dataManager = new PluginDataManager(plugin);
  await dataManager.load();
  
  // Create vault operations
  const vaultOperations = new VaultOperations(plugin.app.vault, pathManager, logger);
  
  // Create service container
  const container = new ServiceContainer();
  
  // Register core services
  container.register('logger', () => logger);
  container.register('pathManager', () => pathManager);
  container.register('dataManager', () => dataManager);
  container.register('vaultOperations', () => vaultOperations);
  
  return {
    logger,
    pathManager,
    dataManager,
    vaultOperations,
    container
  };
}

/**
 * Architecture validation utility
 * Helps ensure proper implementation of the new patterns
 */
export function validateArchitecture(plugin: any): {
  valid: boolean;
  issues: string[];
  recommendations: string[];
} {
  const issues: string[] = [];
  const recommendations: string[] = [];
  
  // Check if using new core components
  if (!plugin.logger || plugin.logger.constructor.name !== 'StructuredLogger') {
    issues.push('Plugin should use StructuredLogger instead of console.log');
    recommendations.push('Replace console.log statements with this.logger.info/debug/warn/error');
  }
  
  if (!plugin.pathManager || plugin.pathManager.constructor.name !== 'ObsidianPathManager') {
    issues.push('Plugin should use ObsidianPathManager for path operations');
    recommendations.push('Replace manual path construction with pathManager methods');
  }
  
  if (!plugin.vaultOperations || plugin.vaultOperations.constructor.name !== 'VaultOperations') {
    issues.push('Plugin should use VaultOperations instead of Node.js fs');
    recommendations.push('Replace require("fs") operations with vaultOperations methods');
  }
  
  if (!plugin.dataManager || plugin.dataManager.constructor.name !== 'PluginDataManager') {
    issues.push('Plugin should use PluginDataManager for settings');
    recommendations.push('Replace manual Plugin.loadData/saveData with dataManager');
  }
  
  // Check for anti-patterns
  const pluginCode = plugin.toString();
  
  if (pluginCode.includes('require("fs")') || pluginCode.includes('require(\'fs\')')) {
    issues.push('Node.js filesystem usage detected');
    recommendations.push('Use VaultOperations for cross-platform file operations');
  }
  
  if (pluginCode.includes('console.log') || pluginCode.includes('console.error')) {
    issues.push('Direct console logging detected');
    recommendations.push('Use StructuredLogger for proper log management');
  }
  
  if (pluginCode.includes('FileSystemAdapter')) {
    issues.push('Direct FileSystemAdapter usage detected');
    recommendations.push('Use ObsidianPathManager for cross-platform path handling');
  }
  
  return {
    valid: issues.length === 0,
    issues,
    recommendations
  };
}

/**
 * Migration helper to gradually transition from old to new architecture
 */
export class ArchitectureMigrationHelper {
  constructor(private plugin: any) {}
  
  /**
   * Phase 1: Replace console logging
   */
  async migrateLogging(): Promise<void> {
    if (!this.plugin.logger) {
      const { StructuredLogger } = await import('./StructuredLogger');
      this.plugin.logger = new StructuredLogger(this.plugin);
    }
  }
  
  /**
   * Phase 2: Replace path management
   */
  async migratePaths(): Promise<void> {
    if (!this.plugin.pathManager) {
      const { ObsidianPathManager } = await import('./ObsidianPathManager');
      this.plugin.pathManager = new ObsidianPathManager(
        this.plugin.app.vault,
        this.plugin.manifest
      );
    }
  }
  
  /**
   * Phase 3: Replace file operations
   */
  async migrateFileOperations(): Promise<void> {
    if (!this.plugin.vaultOperations && this.plugin.pathManager && this.plugin.logger) {
      const { VaultOperations } = await import('./VaultOperations');
      this.plugin.vaultOperations = new VaultOperations(
        this.plugin.app.vault,
        this.plugin.pathManager,
        this.plugin.logger
      );
    }
  }
  
  /**
   * Phase 4: Replace data management
   */
  async migrateDataManagement(defaults: any): Promise<void> {
    if (!this.plugin.dataManager) {
      const { PluginDataManager } = await import('./PluginDataManager');
      this.plugin.dataManager = new PluginDataManager(this.plugin);
      await this.plugin.dataManager.load();
    }
  }
  
  /**
   * Complete migration in phases
   */
  async performFullMigration(defaults: any): Promise<void> {
    await this.migrateLogging();
    await this.migratePaths();
    await this.migrateFileOperations();
    await this.migrateDataManagement(defaults);
  }
}
```

## core/ObsidianPathManager.ts

```typescript
/**
 * ObsidianPathManager - Path management using Obsidian's normalizePath and proper validation
 * Location: src/core/ObsidianPathManager.ts
 * 
 * This class replaces all manual path construction with Obsidian API-first patterns,
 * ensuring cross-platform compatibility and security through proper validation.
 * 
 * Key improvements over PathManager:
 * - Uses Obsidian's normalizePath function exclusively
 * - Security validation prevents path traversal
 * - Cross-platform path handling (mobile + desktop)
 * - Integration with Vault API for directory operations
 * 
 * Used by:
 * - VaultOperations for all path operations
 * - Plugin data directory management
 * - Configuration file path handling
 */

import { Vault, normalizePath, FileSystemAdapter, App } from 'obsidian';

export interface PathValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  normalizedPath: string;
}

/**
 * Path management using Obsidian's normalizePath and proper validation
 * Replaces all manual path construction
 */
export class ObsidianPathManager {
  private manifest: any;

  constructor(private vault: Vault, manifest?: any) {
    this.manifest = manifest;
  }

  /**
   * Core path operations using Obsidian API
   */
  normalizePath(path: string): string {
    // Use Obsidian's official normalizePath function
    return normalizePath(path);
  }

  /**
   * Validate path for security and compatibility
   */
  validatePath(path: string): PathValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Security validation - prevent path traversal
    if (path.includes('..') || path.includes('~')) {
      errors.push('Path traversal sequences are not allowed for security');
    }

    // Platform compatibility checks
    const invalidChars = /[<>:"|?*]/;
    if (invalidChars.test(path)) {
      errors.push('Path contains invalid characters for cross-platform compatibility');
    }

    // Ensure vault-relative (not absolute)
    if (path.startsWith('/') || /^[A-Za-z]:/.test(path)) {
      errors.push('Path should be relative to vault root, not absolute');
    }

    // Check for dangerous patterns
    if (path.includes('\\')) {
      warnings.push('Path contains backslashes, will be normalized to forward slashes');
    }

    // Path length limits for cross-platform compatibility
    if (path.length > 260) {
      warnings.push('Path length exceeds recommended limits for cross-platform compatibility');
    }

    const normalizedPath = this.normalizePath(path);

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      normalizedPath
    };
  }

  /**
   * Sanitize path component for filesystem safety
   */
  sanitizePath(path: string): string {
    return path
      .replace(/[<>:"|?*]/g, '_')  // Replace invalid filesystem chars
      .replace(/\\/g, '/')         // Normalize separators
      .replace(/\/+/g, '/')        // Remove duplicate separators
      .replace(/^\/|\/$/g, '')     // Remove leading/trailing separators
      .replace(/\.{2,}/g, '_')     // Replace path traversal sequences
      .substring(0, 255);          // Limit length for filesystem compatibility
  }

  /**
   * Plugin-specific path construction
   */
  getPluginDataPath(): string {
    if (!this.manifest?.id) {
      throw new Error('Plugin manifest ID not available for path construction');
    }
    return this.normalizePath(`${this.manifest.id}/data`);
  }

  /**
   * Get storage path for data files
   */
  getStoragePath(fileName: string): string {
    const safeName = this.sanitizePath(fileName);
    return this.normalizePath(`.obsidian/plugins/${this.manifest.id}/data/storage/${safeName}`);
  }

  /**
   * Get cache directory path
   */
  getCachePath(): string {
    return this.normalizePath(`${this.getPluginDataPath()}/cache`);
  }

  /**
   * Get logs directory path
   */
  getLogsPath(): string {
    return this.normalizePath(`${this.getPluginDataPath()}/logs`);
  }

  /**
   * Get backup directory path
   */
  getBackupPath(): string {
    return this.normalizePath(`${this.getPluginDataPath()}/backups`);
  }

  /**
   * Get JSON storage path
   */
  getDataStoragePath(): string {
    return this.normalizePath(`${this.getPluginDataPath()}/storage`);
  }

  /**
   * Safe path operations with validation
   */
  async ensureParentExists(filePath: string): Promise<void> {
    const parentPath = this.getParentPath(filePath);
    if (parentPath && !this.vault.getFolderByPath(parentPath)) {
      try {
        await this.vault.createFolder(parentPath);
      } catch (error) {
        // Ignore "Folder already exists" - can happen during startup before vault is fully indexed
        if (error instanceof Error && !error.message.includes('already exists')) {
          throw error;
        }
      }
    }
  }

  /**
   * Generate unique path to avoid conflicts
   */
  async generateUniquePath(basePath: string): Promise<string> {
    let uniquePath = basePath;
    let counter = 1;

    while (this.vault.getAbstractFileByPath(uniquePath)) {
      const extension = this.getExtension(basePath);
      const basename = this.getBasename(basePath);
      const parentPath = this.getParentPath(basePath);
      
      const newFileName = extension 
        ? `${basename} ${counter}.${extension}`
        : `${basename} ${counter}`;
      
      uniquePath = parentPath 
        ? this.joinPath(parentPath, newFileName)
        : newFileName;
      
      counter++;
    }

    return uniquePath;
  }

  /**
   * Join path segments safely
   */
  joinPath(...segments: string[]): string {
    return this.normalizePath(
      segments
        .filter(segment => segment && segment.length > 0)
        .join('/')
    );
  }

  /**
   * Get parent directory path
   */
  getParentPath(path: string): string {
    const normalized = this.normalizePath(path);
    const lastSlash = normalized.lastIndexOf('/');
    return lastSlash > 0 ? normalized.substring(0, lastSlash) : '';
  }

  /**
   * Get filename without directory
   */
  getFileName(path: string): string {
    const normalized = this.normalizePath(path);
    const lastSlash = normalized.lastIndexOf('/');
    return lastSlash >= 0 ? normalized.substring(lastSlash + 1) : normalized;
  }

  /**
   * Get basename (filename without extension)
   */
  getBasename(path: string): string {
    const fileName = this.getFileName(path);
    const lastDot = fileName.lastIndexOf('.');
    return lastDot > 0 ? fileName.substring(0, lastDot) : fileName;
  }

  /**
   * Get file extension
   */
  getExtension(path: string): string {
    const fileName = this.getFileName(path);
    const lastDot = fileName.lastIndexOf('.');
    return lastDot > 0 ? fileName.substring(lastDot + 1) : '';
  }

  /**
   * Check if path is absolute
   */
  isAbsolutePath(path: string): boolean {
    return /^[A-Za-z]:|^\//.test(path);
  }

  /**
   * Convert absolute path to vault-relative (cross-platform safe)
   */
  makeVaultRelative(absolutePath: string): string {
    // Try to get vault base path safely
    const vaultBasePath = this.getVaultBasePath();
    
    if (!vaultBasePath) {
      // Mobile or base path not available - extract plugin path pattern
      return this.extractPluginPathPattern(absolutePath);
    }

    try {
      const normalizedAbsolute = this.normalizePath(absolutePath);
      const normalizedBase = this.normalizePath(vaultBasePath);

      if (normalizedAbsolute.startsWith(normalizedBase)) {
        let relativePath = normalizedAbsolute.substring(normalizedBase.length);
        
        // Remove leading separator
        if (relativePath.startsWith('/')) {
          relativePath = relativePath.substring(1);
        }
        
        return relativePath || this.getPluginDataPath();
      }
      
      // Fallback to pattern extraction
      return this.extractPluginPathPattern(absolutePath);
    } catch (error) {
      // Ultimate fallback
      return this.getPluginDataPath();
    }
  }

  /**
   * Extract plugin path pattern from absolute path
   */
  private extractPluginPathPattern(path: string): string {
    const normalized = this.normalizePath(path);
    
    // Look for plugin directory pattern
    if (this.manifest?.id) {
      const pluginPattern = `/${this.manifest.id}/`;
      const pluginIndex = normalized.indexOf(pluginPattern);
      
      if (pluginIndex >= 0) {
        // Extract from plugin directory onwards
        const pluginStart = normalized.substring(0, pluginIndex + pluginPattern.length - 1);
        const remaining = normalized.substring(pluginIndex + pluginPattern.length);
        return this.normalizePath(`${this.manifest.id}/${remaining}`);
      }
    }
    
    // Look for .obsidian/plugins pattern
    const obsidianIndex = normalized.indexOf('.obsidian/plugins/');
    if (obsidianIndex >= 0) {
      return normalized.substring(obsidianIndex);
    }

    // Ultimate fallback
    return this.getPluginDataPath();
  }

  /**
   * Get vault base path safely (returns null on mobile)
   */
  private getVaultBasePath(): string | null {
    try {
      const adapter = this.vault.adapter;
      if (adapter instanceof FileSystemAdapter) {
        return adapter.getBasePath();
      }
      return null;
    } catch (error) {
      return null;
    }
  }

  /**
   * Safe path operation wrapper with validation
   */
  async safePathOperation<T>(
    path: string,
    operation: (validPath: string) => Promise<T>,
    operationName: string = 'unknown'
  ): Promise<T> {
    try {
      // Convert to relative if absolute
      const relativePath = this.isAbsolutePath(path) 
        ? this.makeVaultRelative(path) 
        : path;

      // Validate the path
      const validation = this.validatePath(relativePath);
      if (!validation.isValid) {
        throw new Error(`Path validation failed: ${validation.errors.join(', ')}`);
      }

      return await operation(validation.normalizedPath);

    } catch (error) {
      console.error(`[ObsidianPathManager] Safe operation '${operationName}' failed for path: ${path}`, error);
      throw error;
    }
  }

  /**
   * Batch validate paths
   */
  validatePaths(paths: string[]): Map<string, PathValidationResult> {
    const results = new Map<string, PathValidationResult>();
    
    for (const path of paths) {
      results.set(path, this.validatePath(path));
    }
    
    return results;
  }

  /**
   * Get path type (file or folder)
   */
  async getPathType(path: string): Promise<'file' | 'folder' | null> {
    try {
      const normalizedPath = this.normalizePath(path);
      const stat = await this.vault.adapter.stat(normalizedPath);
      return stat?.type as 'file' | 'folder' || null;
    } catch (error) {
      return null;
    }
  }

  /**
   * Check if path exists
   */
  async pathExists(path: string): Promise<boolean> {
    try {
      const normalizedPath = this.normalizePath(path);
      return await this.vault.adapter.exists(normalizedPath);
    } catch (error) {
      return false;
    }
  }
}
```

## core/PluginDataManager.ts

```typescript
/**
 * Plugin Data Manager
 * Handles simple plugin data storage operations using Obsidian's native data.json
 */

import { Plugin } from 'obsidian';

export class PluginDataManager {
  constructor(private plugin: Plugin) {}

  /**
   * Save data to plugin storage
   */
  async saveData(data: any): Promise<void> {
    await this.plugin.saveData(data);
  }

  /**
   * Load data from plugin storage
   */
  async loadData(): Promise<any> {
    return await this.plugin.loadData();
  }

  /**
   * Load data with defaults and migration support
   */
  async load(defaults: any = {}, migrateFn?: (data: any) => any): Promise<any> {
    try {
      let data = await this.plugin.loadData();
      if (!data) {
        data = defaults;
      }
      if (migrateFn) {
        data = migrateFn(data);
      }
      return data;
    } catch {
      return defaults;
    }
  }

  /**
   * Check if data exists
   */
  async hasData(): Promise<boolean> {
    try {
      const data = await this.plugin.loadData();
      return data !== null && data !== undefined;
    } catch {
      return false;
    }
  }
}

// Legacy compatibility exports
export class SettingsMigrationManager {
  static migrate(data: any): any {
    return data;
  }
}

export interface SettingsSchema {
  [key: string]: any;
}

export interface SettingsMigration {
  version: number;
  migrate: (data: any) => any;
}

export interface BackupData {
  version: string;
  timestamp: number;
  data: any;
}
```

## core/PluginLifecycleManager.ts

```typescript
/**
 * Location: /src/core/PluginLifecycleManager.ts
 *
 * Plugin Lifecycle Manager - Handles plugin initialization, startup, and shutdown logic
 *
 * This service extracts complex lifecycle management from the main plugin class,
 * coordinating service initialization, background tasks, and cleanup procedures.
 * Used by main.ts to manage the plugin's lifecycle phases in a structured way.
 */

import { Plugin, Notice, Platform, App, PluginManifest } from 'obsidian';
import { ServiceManager } from './ServiceManager';
import { Settings } from '../settings';
import { UpdateManager } from '../utils/UpdateManager';
import { ServiceRegistrar } from './services/ServiceRegistrar';
import { MaintenanceCommandManager } from './commands/MaintenanceCommandManager';
import { ChatUIManager } from './ui/ChatUIManager';
import { BackgroundProcessor } from './background/BackgroundProcessor';
import { SettingsTabManager } from './settings/SettingsTabManager';
import { EmbeddingManager } from '../services/embeddings/EmbeddingManager';
import type { ServiceCreationContext } from './services/ServiceDefinitions';
import type { HybridStorageAdapter } from '../database/adapters/HybridStorageAdapter';
import type { ChatTraceService } from '../services/chat/ChatTraceService';

// Type-only import to avoid bundling Node.js dependencies on mobile
type MCPConnectorType = import('../connector').MCPConnector;

// Interface for services with storage state management
interface StateManager {
    saveState(): Promise<void>;
}

// Extended Plugin interface with optional embeddingManager property
interface PluginWithEmbedding extends Plugin {
    embeddingManager?: EmbeddingManager;
}

export interface PluginLifecycleConfig {
    plugin: Plugin;
    app: App;
    serviceManager: ServiceManager;
    settings: Settings;
    connector?: MCPConnectorType; // Optional - undefined on mobile
    manifest: PluginManifest;
}

/**
 * Plugin Lifecycle Manager - coordinates plugin initialization and shutdown
 */
export class PluginLifecycleManager {
    private config: PluginLifecycleConfig;
    private isInitialized: boolean = false;
    private startTime: number = Date.now();
    private serviceRegistrar: ServiceRegistrar;
    private commandManager: MaintenanceCommandManager;
    private chatUIManager: ChatUIManager;
    private backgroundProcessor: BackgroundProcessor;
    private settingsTabManager: SettingsTabManager;
    private embeddingManager: EmbeddingManager | null = null;

    constructor(config: PluginLifecycleConfig) {
        this.config = config;

        // Create service registrar with proper context
        const serviceContext: ServiceCreationContext = {
            plugin: config.plugin,
            app: config.app,
            serviceManager: config.serviceManager,
            settings: config.settings,
            connector: config.connector,
            manifest: config.manifest
        };
        this.serviceRegistrar = new ServiceRegistrar(serviceContext);

        // Create command manager
        this.commandManager = new MaintenanceCommandManager({
            plugin: config.plugin,
            serviceManager: config.serviceManager,
            getService: (name, timeoutMs) => this.serviceRegistrar.getService(name, timeoutMs),
            isInitialized: () => this.isInitialized
        });

        // Create chat UI manager
        this.chatUIManager = new ChatUIManager({
            plugin: config.plugin,
            app: config.app,
            settings: config.settings,
            getService: (name, timeoutMs) => this.serviceRegistrar.getService(name, timeoutMs)
        });

        // Create background processor
        this.backgroundProcessor = new BackgroundProcessor({
            plugin: config.plugin,
            settings: config.settings,
            serviceManager: config.serviceManager,
            getService: (name, timeoutMs) => this.serviceRegistrar.getService(name, timeoutMs),
            waitForService: (name, timeoutMs) => this.serviceRegistrar.waitForService(name, timeoutMs),
            isInitialized: () => this.isInitialized
        });

        // Create settings tab manager
        this.settingsTabManager = new SettingsTabManager({
            plugin: config.plugin,
            app: config.app,
            settings: config.settings,
            serviceManager: config.serviceManager,
            connector: config.connector,
            lifecycleManager: this,
            backgroundProcessor: this.backgroundProcessor
        });
    }

    /**
     * Initialize plugin - called from onload()
     */
    async initialize(): Promise<void> {
        const startTime = Date.now();

        try {
            // PHASE 1: Foundation - Service container and settings already created by main.ts

            // PHASE 2: Register core services (no initialization yet)
            await this.serviceRegistrar.registerCoreServices();

            // PHASE 3: Initialize essential services only
            await this.serviceRegistrar.initializeEssentialServices();

            // Plugin is now "loaded" - defer full initialization to background
            // PHASE 4: Start background initialization after onload completes
            setTimeout(() => {
                this.startBackgroundInitialization().catch(error => {
                    console.error('[PluginLifecycleManager] Background initialization failed:', error);
                });
            }, 0);

        } catch (error) {
            console.error('[PluginLifecycleManager] Critical initialization failure:', error);
            this.enableFallbackMode();
        }
    }

    /**
     * Background initialization - runs after onload() completes
     */
    private async startBackgroundInitialization(): Promise<void> {
        const bgStartTime = Date.now();

        try {
            // Load settings first
            await this.config.settings.loadSettings();

            // Initialize data directories
            await this.serviceRegistrar.initializeDataDirectories();

            // Now initialize heavy services in background (non-blocking)
            setTimeout(async () => {
                try {
                    // Initialize core services in proper dependency order
                    await this.serviceRegistrar.initializeBusinessServices();

                    // Pre-initialize UI-critical services to avoid long loading times
                    await this.serviceRegistrar.preInitializeUICriticalServices();

                    // Validate search functionality
                    await this.backgroundProcessor.validateSearchFunctionality();

                    // Start MCP server AFTER services are ready (registers agents)
                    // Only on desktop - connector is undefined on mobile
                    if (this.config.connector) {
                        try {
                            await this.config.connector.start();
                        } catch (error) {
                        }
                    }

                    // Initialize ChatService AFTER agents are registered (so tools are available)
                    try {
                        await this.serviceRegistrar.initializeChatService();
                    } catch (error) {
                    }

	                    // Register chat UI components AFTER ChatService is initialized
	                    await this.chatUIManager.registerChatUI();

	                    // Initialize embedding system (desktop only) after 3-second delay
	                    if (!Platform.isMobile) {
	                        setTimeout(async () => {
	                            try {
	                                const storageAdapter = await this.serviceRegistrar.getService<HybridStorageAdapter>('hybridStorageAdapter');
	                                if (storageAdapter && typeof storageAdapter.waitForReady === 'function') {
	                                    const ready = await storageAdapter.waitForReady();
	                                    if (!ready) {
	                                        return;
	                                    }
	                                }

	                                if (storageAdapter && storageAdapter.cache) {
	                                    this.embeddingManager = new EmbeddingManager(
	                                        this.config.app,
	                                        this.config.plugin,
	                                        storageAdapter.cache
	                                    );
	                                    await this.embeddingManager.initialize();
	                                    // Expose on plugin for lazy access by agents
	                                    (this.config.plugin as PluginWithEmbedding).embeddingManager = this.embeddingManager;

	                                    // Wire embedding service into ChatTraceService so new traces get embedded
	                                    const embeddingService = this.embeddingManager.getService();
	                                    if (embeddingService) {
	                                        const chatTraceService = await this.serviceRegistrar.getService<ChatTraceService>('chatTraceService');
	                                        if (chatTraceService && typeof chatTraceService.setEmbeddingService === 'function') {
	                                            chatTraceService.setEmbeddingService(embeddingService);
	                                        }
	                                    }
	                                }
	                            } catch (error) {
	                            }
	                        }, 3000);
	                    }
                } catch (error) {
                    console.error('[PluginLifecycleManager] Background service initialization failed:', error);
                }
            }, 100);

            // Create settings tab
            await this.settingsTabManager.initializeSettingsTab();

            // Register all maintenance commands
            this.commandManager.registerMaintenanceCommands();

            // Check for updates
            this.backgroundProcessor.checkForUpdatesOnStartup();

            // Update settings tab with loaded services
            this.backgroundProcessor.updateSettingsTabServices();

            // Mark as fully initialized
            this.isInitialized = true;

            // Start background startup processing after everything is ready
            this.backgroundProcessor.startBackgroundStartupProcessing();

        } catch (error) {
            console.error('[PluginLifecycleManager] Background initialization failed:', error);
        }
    }

    /**
     * Enable fallback mode with minimal functionality
     */
    private enableFallbackMode(): void {
        try {
            this.commandManager.registerTroubleshootCommand();
        } catch (error) {
            console.error('[PluginLifecycleManager] Fallback mode setup failed:', error);
        }
    }

    /**
     * Get service helper method
     */
    private async getService<T>(name: string, timeoutMs: number = 10000): Promise<T | null> {
        if (!this.config.serviceManager) {
            return null;
        }

        // Try to get service (will initialize if needed)
        try {
            return await this.config.serviceManager.getService<T>(name);
        } catch (error) {
            return null;
        }
    }

    /**
     * Reload configuration for all services after settings change
     */
    reloadConfiguration(): void {
        // Configuration reloading handled by individual services
    }

    /**
     * Get initialization status
     */
    getInitializationStatus(): { isInitialized: boolean; startTime: number } {
        return {
            isInitialized: this.isInitialized,
            startTime: this.startTime
        };
    }

    /**
     * Shutdown and cleanup
     */
    async shutdown(): Promise<void> {
        try {
            // Shutdown embedding system first (before database closes)
            if (this.embeddingManager) {
                try {
                    await this.embeddingManager.shutdown();
                } catch (error) {
                }
            }

            // Save processed files state before cleanup
            const stateManager = this.config.serviceManager?.getServiceIfReady<StateManager>('stateManager');
            if (stateManager && typeof stateManager.saveState === 'function') {
                await stateManager.saveState();
            }

            // Close HybridStorageAdapter to properly shut down SQLite
            const storageAdapter = this.config.serviceManager?.getServiceIfReady<HybridStorageAdapter>('hybridStorageAdapter');
            if (storageAdapter && typeof storageAdapter.close === 'function') {
                try {
                    await storageAdapter.close();
                } catch (error) {
                }
            }

            // Cleanup settings tab accordions
            this.settingsTabManager.cleanup();

            // Cleanup service manager (handles all service cleanup)
            if (this.config.serviceManager) {
                await this.config.serviceManager.stop();
            }

            // Stop the MCP connector
            if (this.config.connector) {
                await this.config.connector.stop();
            }

        } catch (error) {
            console.error('[PluginLifecycleManager] Error during cleanup:', error);
        }
    }
}

```

## core/ServiceContainer.ts

```typescript
/**
 * ServiceContainer - Enhanced dependency injection container with lazy loading and factory support
 * Location: src/core/ServiceContainer.ts
 * 
 * This service replaces the complex service registries and initialization coordination
 * with a unified, predictable dependency injection pattern. It provides clean service
 * lifecycle management and proper dependency resolution with multiple registration patterns.
 * 
 * Key features:
 * - Simple factory-based service registration
 * - Lazy loading capabilities with deferred initialization
 * - IServiceFactory pattern support for advanced factories
 * - Singleton and transient service support
 * - Dependency injection with type safety
 * - Circular dependency detection
 * - Promise-based duplicate initialization prevention
 * - Clean cleanup and lifecycle management
 * 
 * Registration Types:
 * - register(): Traditional factory with dependency injection
 * - registerLazy(): Lazy-loaded services with deferred creation
 * - registerFactory(): IServiceFactory pattern with advanced dependency management
 * 
 * Used by:
 * - Enhanced Plugin main class for service coordination
 * - Service initialization and dependency resolution
 * - Lazy loading patterns from LazyServiceManager
 * - Factory patterns from ServiceDescriptors
 * - Clean service lifecycle management
 * - Service cleanup during plugin unload
 */

export type ServiceFactory<T> = (dependencies: Record<string, any>) => T | Promise<T>;
export type LazyFactory<T> = () => Promise<T>;

export interface ServiceRegistration<T> {
  factory: ServiceFactory<T>;
  singleton: boolean;
  dependencies?: string[];
}

export interface IServiceFactory<T> {
  create(dependencies: Map<string, any>): Promise<T>;
  getRequiredDependencies(): string[];
}

export interface IServiceContainer {
  register<T>(name: string, factory: ServiceFactory<T>, options?: { singleton?: boolean; dependencies?: string[] }): void;
  registerLazy<T>(name: string, factory: LazyFactory<T>): void;
  registerFactory<T>(name: string, factory: IServiceFactory<T>): void;
  get<T>(name: string): Promise<T>;
  getLazy<T>(name: string): Promise<T>;
  getIfReady<T>(name: string): T | null;
  has(name: string): boolean;
  isReady(name: string): boolean;
  resolveDependencies(name: string): Promise<void>;
  
  // Additional methods required by ServiceManager
  getServiceMetadata(name: string): ServiceMetadata | null;
  getRegisteredServices(): string[];
  clear(): void;
  getReadyServices(): string[];
  getStats(): { registered: number; ready: number; failed: number };
  validateDependencies(): { isValid: boolean; errors: string[] };
  preInitializeMany(names: string[]): Promise<void>;
  initializeInOrder(names: string[]): Promise<void>;
  exportDependencyGraph(): { nodes: string[], edges: Array<{from: string, to: string}> };
}

export interface ServiceMetadata {
  name: string;
  singleton: boolean;
  initialized: boolean;
  dependencies: string[];
  dependents: string[];
}

/**
 * Enhanced dependency injection container with lazy loading and factory support
 * Replaces complex service registries with unified service management
 */
export class ServiceContainer implements IServiceContainer {
  private services = new Map<string, any>();
  private factories = new Map<string, ServiceRegistration<any>>();
  private lazyFactories = new Map<string, LazyFactory<any>>();
  private serviceFactories = new Map<string, IServiceFactory<any>>();
  private initializationStack: string[] = [];
  private dependencyGraph = new Map<string, Set<string>>();
  private pendingPromises = new Map<string, Promise<any>>();

  /**
   * Register service factory with optional dependencies
   */
  register<T>(
    name: string, 
    factory: ServiceFactory<T>, 
    options: {
      singleton?: boolean;
      dependencies?: string[];
    } = {}
  ): void {
    const singleton = options.singleton !== false; // Default to singleton
    const dependencies = options.dependencies || [];

    this.factories.set(name, {
      factory,
      singleton,
      dependencies
    });

    // Build dependency graph
    this.dependencyGraph.set(name, new Set(dependencies));
  }

  /**
   * Register lazy-loaded service factory
   * Services registered with this method are created on-demand without explicit dependencies
   */
  registerLazy<T>(name: string, factory: LazyFactory<T>): void {
    this.lazyFactories.set(name, factory);
    // Lazy services have no explicit dependencies - they manage their own resolution
    this.dependencyGraph.set(name, new Set());
  }

  /**
   * Register service using IServiceFactory interface
   * Supports the factory pattern with explicit dependency management
   */
  registerFactory<T>(name: string, factory: IServiceFactory<T>): void {
    const dependencies = factory.getRequiredDependencies();
    this.serviceFactories.set(name, factory);
    // Build dependency graph from factory
    this.dependencyGraph.set(name, new Set(dependencies));
  }

  /**
   * Get service instance with dependency resolution
   * Supports regular factories, lazy factories, and IServiceFactory pattern
   */
  async get<T>(name: string): Promise<T> {
    // Check if already instantiated (for singletons)
    if (this.services.has(name)) {
      return this.services.get(name);
    }

    // Check if there's a pending promise to avoid duplicate initialization
    if (this.pendingPromises.has(name)) {
      return this.pendingPromises.get(name);
    }

    // Try different registration types in order of preference
    const registration = this.factories.get(name);
    const lazyFactory = this.lazyFactories.get(name);
    const serviceFactory = this.serviceFactories.get(name);

    if (!registration && !lazyFactory && !serviceFactory) {
      const availableServices = [
        ...Array.from(this.factories.keys()),
        ...Array.from(this.lazyFactories.keys()),
        ...Array.from(this.serviceFactories.keys())
      ];
      throw new Error(`Service '${name}' not found. Available services: ${availableServices.join(', ')}`);
    }

    // Check for circular dependencies
    if (this.initializationStack.includes(name)) {
      const cycle = [...this.initializationStack, name].join(' -> ');
      throw new Error(`Circular dependency detected: ${cycle}`);
    }

    // Create and store promise to avoid duplicate initialization
    const promise = this.createServiceInstance<T>(name, registration, lazyFactory, serviceFactory);
    this.pendingPromises.set(name, promise);

    try {
      const instance = await promise;
      this.pendingPromises.delete(name);
      return instance;
    } catch (error) {
      this.pendingPromises.delete(name);
      throw error;
    }
  }

  /**
   * Get service using lazy loading pattern
   * Equivalent to get() but explicitly for lazy-registered services
   */
  async getLazy<T>(name: string): Promise<T> {
    return this.get<T>(name);
  }

  /**
   * Internal method to create service instance based on registration type
   */
  private async createServiceInstance<T>(
    name: string,
    registration: ServiceRegistration<any> | undefined,
    lazyFactory: LazyFactory<any> | undefined,
    serviceFactory: IServiceFactory<any> | undefined
  ): Promise<T> {
    // Add to initialization stack
    this.initializationStack.push(name);

    try {
      let instance: T;

      if (lazyFactory) {
        // Handle lazy factory (no dependency injection)
        instance = await lazyFactory();
        // Lazy factories are always treated as singletons
        this.services.set(name, instance);
      } else if (serviceFactory) {
        // Handle IServiceFactory pattern
        const dependencies = serviceFactory.getRequiredDependencies();
        const resolvedDependencies = new Map<string, any>();
        
        // Resolve dependencies
        for (const depName of dependencies) {
          const dependency = await this.get(depName);
          resolvedDependencies.set(depName, dependency);
        }

        instance = await serviceFactory.create(resolvedDependencies);
        // ServiceFactory instances are always treated as singletons
        this.services.set(name, instance);
      } else if (registration) {
        // Handle regular factory pattern
        const resolvedDependencies: Record<string, any> = {};
        const dependencies = registration.dependencies || [];
        
        // Resolve dependencies
        for (const depName of dependencies) {
          const dependency = await this.get(depName);
          resolvedDependencies[depName] = dependency;
        }

        instance = await registration.factory(resolvedDependencies);

        // Store if singleton
        if (registration.singleton) {
          this.services.set(name, instance);
        }
      } else {
        throw new Error(`No valid factory found for service '${name}'`);
      }

      return instance;

    } catch (error) {
      console.error(`[ServiceContainer] âŒ Failed to create service '${name}':`, error);
      throw error;
    } finally {
      // Remove from initialization stack
      this.initializationStack.pop();
    }
  }

  /**
   * Get service if already instantiated (non-blocking)
   */
  getIfReady<T>(name: string): T | null {
    return this.services.get(name) || null;
  }

  /**
   * Check if service is registered (any type)
   */
  has(name: string): boolean {
    return this.factories.has(name) || this.lazyFactories.has(name) || this.serviceFactories.has(name);
  }

  /**
   * Resolve all dependencies for a service without instantiating the service itself
   * Useful for preparation phase of service initialization
   */
  async resolveDependencies(name: string): Promise<void> {
    const dependencies = this.dependencyGraph.get(name);
    if (!dependencies || dependencies.size === 0) {
      return; // No dependencies to resolve
    }

    // Pre-resolve all dependencies in parallel
    const dependencyPromises = Array.from(dependencies).map(depName => this.get(depName));
    await Promise.all(dependencyPromises);
  }

  /**
   * Check if service is instantiated
   */
  isReady(name: string): boolean {
    return this.services.has(name);
  }

  /**
   * Get all registered service names (all types)
   */
  getRegisteredServices(): string[] {
    return [
      ...Array.from(this.factories.keys()),
      ...Array.from(this.lazyFactories.keys()),
      ...Array.from(this.serviceFactories.keys())
    ];
  }

  /**
   * Get all instantiated service names
   */
  getReadyServices(): string[] {
    return Array.from(this.services.keys());
  }

  /**
   * Get service metadata (supports all service types)
   */
  getServiceMetadata(name: string): ServiceMetadata | null {
    const registration = this.factories.get(name);
    const lazyFactory = this.lazyFactories.get(name);
    const serviceFactory = this.serviceFactories.get(name);

    if (!registration && !lazyFactory && !serviceFactory) {
      return null;
    }

    // Find dependents (services that depend on this one)
    const dependents: string[] = [];
    for (const [serviceName, deps] of Array.from(this.dependencyGraph.entries())) {
      if (deps.has(name)) {
        dependents.push(serviceName);
      }
    }

    let singleton = true; // Default for lazy and service factory
    let dependencies: string[] = [];

    if (registration) {
      singleton = registration.singleton;
      dependencies = registration.dependencies || [];
    } else if (serviceFactory) {
      dependencies = serviceFactory.getRequiredDependencies();
    }
    // Lazy services have no explicit dependencies

    return {
      name,
      singleton,
      initialized: this.services.has(name),
      dependencies,
      dependents
    };
  }

  /**
   * Get all service metadata
   */
  getAllServiceMetadata(): Record<string, ServiceMetadata> {
    const metadata: Record<string, ServiceMetadata> = {};
    
    // Get metadata for all registered services (all types)
    for (const serviceName of this.getRegisteredServices()) {
      const meta = this.getServiceMetadata(serviceName);
      if (meta) {
        metadata[serviceName] = meta;
      }
    }

    return metadata;
  }

  async preInitialize(name: string): Promise<void> {
    try {
      await this.get(name);
    } catch (error) {
    }
  }

  /**
   * Pre-initialize multiple services in parallel
   */
  async preInitializeMany(names: string[]): Promise<void> {
    const promises = names.map(name => this.preInitialize(name));
    await Promise.allSettled(promises);
  }

  /**
   * Initialize services in dependency order
   */
  async initializeInOrder(names: string[]): Promise<void> {
    const sorted = this.topologicalSort(names);
    
    for (const name of sorted) {
      await this.get(name);
    }
  }

  /**
   * Validate dependency graph for cycles
   */
  validateDependencies(): { isValid: boolean; errors: string[] } {
    const cycles: string[] = [];
    const visited = new Set<string>();
    const recursionStack = new Set<string>();

    const detectCycle = (node: string, path: string[]): boolean => {
      if (recursionStack.has(node)) {
        const cycleStart = path.indexOf(node);
        const cycle = path.slice(cycleStart).join(' -> ') + ' -> ' + node;
        cycles.push(cycle);
        return true;
      }

      if (visited.has(node)) {
        return false;
      }

      visited.add(node);
      recursionStack.add(node);

      const dependencies = this.dependencyGraph.get(node) || new Set();
      for (const dep of Array.from(dependencies)) {
        if (detectCycle(dep, [...path, node])) {
          return true;
        }
      }

      recursionStack.delete(node);
      return false;
    };

    for (const service of Array.from(this.factories.keys())) {
      if (!visited.has(service)) {
        detectCycle(service, []);
      }
    }

    return {
      isValid: cycles.length === 0,
      errors: cycles
    };
  }

  /**
   * Topological sort for dependency order
   */
  private topologicalSort(services: string[]): string[] {
    const visited = new Set<string>();
    const result: string[] = [];

    const visit = (node: string) => {
      if (visited.has(node)) return;
      visited.add(node);

      const dependencies = this.dependencyGraph.get(node) || new Set();
      for (const dep of Array.from(dependencies)) {
        if (services.includes(dep)) {
          visit(dep);
        }
      }

      result.push(node);
    };

    for (const service of services) {
      visit(service);
    }

    return result;
  }

  /**
   * Replace a service instance (for testing or hot-swapping)
   */
  replace<T>(name: string, instance: T): void {
    if (!this.factories.has(name)) {
      throw new Error(`Cannot replace unregistered service '${name}'`);
    }

    this.services.set(name, instance);
  }

  /**
   * Remove a service (cleanup)
   */
  remove(name: string): void {
    const instance = this.services.get(name);
    
    // Call cleanup if available
    if (instance && typeof instance.cleanup === 'function') {
      try {
        instance.cleanup();
      } catch (error) {
        console.error(`[ServiceContainer] Service '${name}' cleanup failed:`, error);
      }
    }

    // Remove from all maps
    this.services.delete(name);
    this.factories.delete(name);
    this.lazyFactories.delete(name);
    this.serviceFactories.delete(name);
    this.dependencyGraph.delete(name);
    this.pendingPromises.delete(name);
  }

  /**
   * Clear all services with proper cleanup
   */
  clear(): void {
    // Get services in reverse dependency order for cleanup
    const allServices = Array.from(this.services.keys());
    const cleanupOrder = this.topologicalSort(allServices).reverse();

    // Cleanup services in dependency order
    for (const serviceName of cleanupOrder) {
      const service = this.services.get(serviceName);
      
      if (service && typeof service.cleanup === 'function') {
        try {
          service.cleanup();
        } catch (error) {
          console.error(`[ServiceContainer] âŒ Cleanup failed for service '${serviceName}':`, error);
        }
      }
    }
    
    // Clear all maps
    this.services.clear();
    this.factories.clear();
    this.lazyFactories.clear();
    this.serviceFactories.clear();
    this.dependencyGraph.clear();
    this.pendingPromises.clear();
    this.initializationStack = [];
  }

  /**
   * Get container statistics
   */
  getStats(): { registered: number; ready: number; failed: number } {
    let singletons = 0;
    let transients = 0;
    let totalDependencies = 0;

    // Count regular factory services
    for (const registration of Array.from(this.factories.values())) {
      if (registration.singleton) {
        singletons++;
      } else {
        transients++;
      }
      totalDependencies += (registration.dependencies || []).length;
    }

    // Lazy services and factory services are always singletons
    singletons += this.lazyFactories.size + this.serviceFactories.size;

    // Count dependencies from service factories
    for (const factory of Array.from(this.serviceFactories.values())) {
      totalDependencies += factory.getRequiredDependencies().length;
    }

    return {
      registered: this.factories.size + this.lazyFactories.size + this.serviceFactories.size,
      ready: this.services.size,
      failed: 0 // TODO: Track failed services if needed
    };
  }

  /**
   * Export dependency graph for visualization
   */
  exportDependencyGraph(): { nodes: string[]; edges: Array<{ from: string; to: string }> } {
    const nodes = this.getRegisteredServices();
    const edges: Array<{ from: string; to: string }> = [];

    for (const [service, dependencies] of Array.from(this.dependencyGraph.entries())) {
      for (const dep of Array.from(dependencies)) {
        edges.push({ from: service, to: dep });
      }
    }

    return { nodes, edges };
  }
}
```

## core/ServiceFactory.ts

```typescript
/**
 * Location: src/core/ServiceFactory.ts
 *
 * Service factory definitions for standardized dependency injection
 * This file provides factory functions for creating agents with proper constructor injection
 * managed by the ServiceManager/ServiceContainer architecture.
 *
 * Key principles:
 * - All dependencies provided via constructor parameters
 * - ServiceManager resolves dependencies before agent creation
 * - No setter injection or manual service lookups
 * - Clear dependency declarations for each agent
 * - Type-safe dependency resolution
 *
 * Used by: AgentRegistrationService, ServiceManager
 * Dependencies: ServiceManager, all agent implementations
 */

import { App, Plugin } from 'obsidian';
import type { ServiceManager } from './ServiceManager';
import {
    ContentManagerAgent,
    CommandManagerAgent,
    StorageManagerAgent,
    SearchManagerAgent,
    MemoryManagerAgent,
    PromptManagerAgent
} from '../agents';
import { LLMProviderManager } from '../services/llm/providers/ProviderManager';
import { AgentManager } from '../services/AgentManager';
import { UsageTracker } from '../services/UsageTracker';
import { MemoryService } from '../agents/memoryManager/services/MemoryService';
import { Settings } from '../settings';
import type NexusPlugin from '../main';

/**
 * Type guard to check if a plugin has settings property
 */
function hasSettings(plugin: Plugin): plugin is Plugin & { settings: Settings } {
    return 'settings' in plugin && plugin.settings !== undefined;
}

/**
 * Standardized agent factory interface
 */
export interface IAgentFactory<TAgent = any> {
    readonly name: string;
    readonly dependencies: string[];
    create(dependencies: Map<string, any>, app: App, plugin: Plugin): Promise<TAgent>;
}

/**
 * Base agent factory with common dependency resolution
 */
abstract class BaseAgentFactory<TAgent> implements IAgentFactory<TAgent> {
    constructor(
        public readonly name: string,
        public readonly dependencies: string[]
    ) {}

    abstract create(dependencies: Map<string, any>, app: App, plugin: Plugin): Promise<TAgent>;

    /**
     * Helper to safely get dependency from map
     */
    protected getDependency<T>(dependencies: Map<string, any>, name: string): T {
        const dependency = dependencies.get(name);
        if (!dependency) {
            throw new Error(`Required dependency '${name}' not found for agent '${this.name}'`);
        }
        return dependency;
    }

    /**
     * Helper to get optional dependency from map
     */
    protected getOptionalDependency<T>(dependencies: Map<string, any>, name: string): T | null {
        return dependencies.get(name) || null;
    }
}

/**
 * ContentManager agent factory with memory service dependencies
 */
export class ContentManagerAgentFactory extends BaseAgentFactory<ContentManagerAgent> {
    constructor() {
        super('contentManager', ['memoryService', 'workspaceService']); // Optional dependencies
    }

    async create(dependencies: Map<string, any>, app: App, plugin: Plugin): Promise<ContentManagerAgent> {
        const memoryService = this.getOptionalDependency<MemoryService>(dependencies, 'memoryService');
        const workspaceService = this.getOptionalDependency<any>(dependencies, 'workspaceService');
        // ContentManagerAgent accepts NexusPlugin which extends Plugin
        const nexusPlugin = plugin as unknown as NexusPlugin;
        return new ContentManagerAgent(app, nexusPlugin, memoryService, workspaceService);
    }
}

/**
 * CommandManager agent factory - no external dependencies
 */
export class CommandManagerAgentFactory extends BaseAgentFactory<CommandManagerAgent> {
    constructor() {
        super('commandManager', []);
    }

    async create(dependencies: Map<string, any>, app: App, plugin: Plugin): Promise<CommandManagerAgent> {
        return new CommandManagerAgent(app);
    }
}

/**
 * StorageManager agent factory - no external dependencies
 */
export class StorageManagerAgentFactory extends BaseAgentFactory<StorageManagerAgent> {
    constructor() {
        super('storageManager', []); // No external dependencies
    }

    async create(dependencies: Map<string, any>, app: App, plugin: Plugin): Promise<StorageManagerAgent> {
        return new StorageManagerAgent(app);
    }
}

/**
 * SearchManager agent factory with memory service dependencies
 */
export class SearchManagerAgentFactory extends BaseAgentFactory<SearchManagerAgent> {
    constructor() {
        super('searchManager', ['memoryService', 'workspaceService']); // Optional dependencies
    }

    async create(dependencies: Map<string, any>, app: App, plugin: Plugin): Promise<SearchManagerAgent> {
        // Get settings from plugin using type guard
        const pluginSettings = hasSettings(plugin) ? plugin.settings.settings : undefined;
        const enableSearchModes = false; // Currently disabled
        const memoryService = this.getOptionalDependency<MemoryService>(dependencies, 'memoryService');
        const workspaceService = this.getOptionalDependency<any>(dependencies, 'workspaceService');

        const agent = new SearchManagerAgent(app, enableSearchModes, memoryService, workspaceService);

        // Apply memory settings if available
        const memorySettings = pluginSettings?.memory;
        if (memorySettings) {
            agent.updateSettings(memorySettings);
        }

        return agent;
    }
}

/**
 * MemoryManager agent factory with memory service dependencies
 */
export class MemoryManagerAgentFactory extends BaseAgentFactory<MemoryManagerAgent> {
    constructor() {
        super('memoryManager', ['memoryService', 'workspaceService']); // Dependencies
    }

    async create(dependencies: Map<string, any>, app: App, plugin: Plugin): Promise<MemoryManagerAgent> {
        const memoryService = this.getDependency<MemoryService>(dependencies, 'memoryService');
        const workspaceService = this.getDependency<any>(dependencies, 'workspaceService');
        return new MemoryManagerAgent(app, plugin, memoryService, workspaceService);
    }
}

/**
 * PromptManager agent factory with LLM provider dependencies
 */
export class PromptManagerAgentFactory extends BaseAgentFactory<PromptManagerAgent> {
    constructor() {
        super('promptManager', [
            'llmProviderManager',
            'agentManager',
            'usageTracker'
        ]);
    }

    async create(dependencies: Map<string, any>, app: App, plugin: Plugin): Promise<PromptManagerAgent> {
        // Get required dependencies
        const providerManager = this.getDependency<LLMProviderManager>(dependencies, 'llmProviderManager');
        const parentAgentManager = this.getDependency<AgentManager>(dependencies, 'agentManager');
        const usageTracker = this.getDependency<UsageTracker>(dependencies, 'usageTracker');

        // Get plugin settings using type guard
        if (!hasSettings(plugin)) {
            throw new Error('Plugin settings required for PromptManagerAgent');
        }

        // Create agent with all dependencies injected via constructor
        return new PromptManagerAgent(
            plugin.settings,
            providerManager,
            parentAgentManager,
            usageTracker,
            app.vault
        );
    }
}

/**
 * Registry of all agent factories
 */
export class AgentFactoryRegistry {
    private factories = new Map<string, IAgentFactory>();

    constructor() {
        // Register all agent factories
        this.registerFactory(new ContentManagerAgentFactory());
        this.registerFactory(new CommandManagerAgentFactory());
        this.registerFactory(new StorageManagerAgentFactory());
        this.registerFactory(new SearchManagerAgentFactory());
        this.registerFactory(new MemoryManagerAgentFactory());
        this.registerFactory(new PromptManagerAgentFactory());
    }

    private registerFactory(factory: IAgentFactory): void {
        this.factories.set(factory.name, factory);
    }

    getFactory(name: string): IAgentFactory | null {
        return this.factories.get(name) || null;
    }

    getAllFactories(): Map<string, IAgentFactory> {
        return new Map(this.factories);
    }

    /**
     * Get all dependencies for a specific agent
     */
    getDependencies(agentName: string): string[] {
        const factory = this.factories.get(agentName);
        return factory ? factory.dependencies : [];
    }

    /**
     * Get dependency graph for all agents
     */
    getDependencyGraph(): Map<string, string[]> {
        const graph = new Map<string, string[]>();

        for (const [name, factory] of this.factories) {
            graph.set(name, factory.dependencies);
        }

        return graph;
    }
}
```

## core/ServiceManager.ts

```typescript
/**
 * Location: src/core/ServiceManager.ts
 * 
 * ServiceManager - Unified service management facade that consolidates all service management capabilities
 * 
 * This facade unifies 4 competing service management systems into a single, clean interface:
 * - ServiceContainer (enhanced DI container with lifecycle management)
 * - LazyServiceManager (stage-based loading with coordination)
 * - SimpleServiceManager (3-tier architecture with immediate/fast/background)
 * - Lazy-initialization system (descriptor-based configuration)
 * 
 * Key features:
 * - Unified registration interface supporting all existing patterns
 * - Stage-based initialization (immediate, fast, background, on-demand)
 * - Dependency injection with circular dependency detection
 * - Lifecycle management with proper cleanup
 * - Service descriptors for configuration-driven service definitions
 * - Backward compatibility with all existing systems
 * - Type-safe generics throughout
 * 
 * Used by:
 * - Main plugin class for unified service coordination
 * - All service consumers through single interface
 * - Settings components for service management UI
 * - Agents and modes for service dependencies
 */

import { App, Plugin } from 'obsidian';
import { ServiceContainer, IServiceContainer, ServiceFactory, LazyFactory, IServiceFactory } from './ServiceContainer';
// All service management now handled through ServiceContainer - no external dependencies needed

// Core interfaces for unified service management
export interface IServiceDescriptor<T = any> {
    name: string;
    dependencies?: string[];
    stage?: ServiceStage;
    singleton?: boolean;
    create(): Promise<T> | T;
}

export interface IServiceManager {
    // Registration methods - unified interface
    registerService<T>(descriptor: IServiceDescriptor<T>): Promise<void>;
    registerFactory<T>(name: string, factory: ServiceFactory<T>, options?: ServiceRegistrationOptions): void;
    registerLazy<T>(name: string, factory: LazyFactory<T>): void;
    registerServiceFactory<T>(name: string, factory: IServiceFactory<T>): void;
    
    // Service retrieval - unified interface
    getService<T>(name: string): Promise<T>;
    getServiceIfReady<T>(name: string): T | null;
    getServiceSync<T>(name: string): T | null; // For immediate services only
    
    // Lifecycle management
    initializeServices(): Promise<void>;
    initializeStage(stage: ServiceStage): Promise<void>;
    
    // Service status and introspection
    isServiceReady(name: string): boolean;
    isStageReady(stage: ServiceStage): boolean;
    getServiceStatus(name: string): ServiceStatus;
    getAllServiceStatus(): Record<string, ServiceStatus>;
    
    // Lifecycle operations
    start(): Promise<void>;
    stop(): Promise<void>;
    cleanup(): Promise<void>;
}

export interface ServiceRegistrationOptions {
    singleton?: boolean;
    dependencies?: string[];
    stage?: ServiceStage;
    timeout?: number;
}

export enum ServiceStage {
    IMMEDIATE = 'immediate',       // < 100ms - essential for plugin loading
    FAST = 'fast',                // ~300ms - important for UX
    BACKGROUND = 'background',    // ~2-5s - full functionality  
    ON_DEMAND = 'on_demand'       // Only when needed
}

export interface ServiceStatus {
    name: string;
    stage: ServiceStage;
    ready: boolean;
    initialized: boolean;
    loading: boolean;
    error?: Error;
    dependencies: string[];
    dependents: string[];
    registrationTime?: number;
    initializationTime?: number;
}

/**
 * ServiceManager - Unified facade for all service management operations
 * 
 * Architecture:
 * - Uses ServiceContainer as the core DI engine
 * - Integrates ServiceLifecycleManager for advanced lifecycle coordination
 * - Supports all existing registration patterns
 * - Provides unified interface for service consumers
 * - Maintains backward compatibility with all existing systems
 */
export class ServiceManager implements IServiceManager {
    private container: IServiceContainer;
    private serviceStages = new Map<string, ServiceStage>();
    private isStarted = false;
    private isInitializing = false;
    private initializationPromise: Promise<void> | null = null;
    
    constructor(
        private app: App,
        private plugin: Plugin
    ) {
        // Initialize core components
        this.container = new ServiceContainer();
    }

    /**
     * Register service using unified descriptor interface
     * Supports all existing registration patterns through a single interface
     */
    async registerService<T>(descriptor: IServiceDescriptor<T>): Promise<void> {
        const stage = descriptor.stage || ServiceStage.BACKGROUND;
        const singleton = descriptor.singleton !== false; // Default to singleton
        
        // Store stage information
        this.serviceStages.set(descriptor.name, stage);
        
        // Register with ServiceContainer using factory pattern
        this.container.register<T>(
            descriptor.name,
            async (dependencies: Record<string, any>) => {
                // Resolve dependencies if needed
                if (descriptor.dependencies && descriptor.dependencies.length > 0) {
                    const resolvedDeps: Record<string, any> = {};
                    for (const depName of descriptor.dependencies) {
                        resolvedDeps[depName] = await this.getService(depName);
                    }
                    
                    // Create service instance
                    const result = descriptor.create();
                    return result instanceof Promise ? await result : result;
                }
                
                const result = descriptor.create();
                return result instanceof Promise ? await result : result;
            },
            {
                singleton,
                dependencies: descriptor.dependencies || []
            }
        );
        
        // Service registered with ServiceContainer - no legacy compatibility needed
    }

    /**
     * Register service using traditional factory pattern
     */
    registerFactory<T>(name: string, factory: ServiceFactory<T>, options?: ServiceRegistrationOptions): void {
        const stage = options?.stage || ServiceStage.BACKGROUND;
        this.serviceStages.set(name, stage);
        
        this.container.register<T>(name, factory, {
            singleton: options?.singleton,
            dependencies: options?.dependencies
        });
    }

    /**
     * Register lazy-loaded service
     */
    registerLazy<T>(name: string, factory: LazyFactory<T>): void {
        this.serviceStages.set(name, ServiceStage.ON_DEMAND);
        this.container.registerLazy<T>(name, factory);
    }

    /**
     * Register service using IServiceFactory interface
     */
    registerServiceFactory<T>(name: string, factory: IServiceFactory<T>): void {
        this.serviceStages.set(name, ServiceStage.BACKGROUND);
        this.container.registerFactory<T>(name, factory);
    }

    /**
     * Get service instance - unified retrieval method
     */
    async getService<T>(name: string): Promise<T> {
        try {
            return await this.container.get<T>(name);
        } catch (error) {
            console.error(`[ServiceManager] Failed to get service '${name}':`, error);
            throw error;
        }
    }

    /**
     * Get service if already initialized (non-blocking)
     */
    getServiceIfReady<T>(name: string): T | null {
        return this.container.getIfReady<T>(name);
    }

    getServiceSync<T>(name: string): T | null {
        const stage = this.serviceStages.get(name);
        if (stage !== ServiceStage.IMMEDIATE) {
            return null;
        }

        return this.container.getIfReady<T>(name);
    }

    async initializeServices(): Promise<void> {
        if (this.initializationPromise) {
            return this.initializationPromise;
        }

        if (this.isInitializing) {
            return;
        }
        
        this.isInitializing = true;
        
        this.initializationPromise = this.performInitialization();
        
        try {
            await this.initializationPromise;
        } finally {
            this.isInitializing = false;
            this.initializationPromise = null;
        }
    }

    private async performInitialization(): Promise<void> {
        try {
            await this.initializeStage(ServiceStage.IMMEDIATE);
            await this.initializeStage(ServiceStage.FAST);

            setTimeout(() => {
                this.initializeStage(ServiceStage.BACKGROUND).catch(error => {
                    console.error('[ServiceManager] Background service initialization failed:', error);
                });
            }, 0);

        } catch (error) {
            console.error('[ServiceManager] Service initialization failed:', error);
            throw error;
        }
    }

    /**
     * Initialize all services in a specific stage
     */
    async initializeStage(stage: ServiceStage): Promise<void> {
        const serviceNames = this.getServicesByStage(stage);
        if (serviceNames.length === 0) {
            return;
        }

        const stageStartTime = Date.now();
        // Initializing services for stage
        
        // Initialize services in parallel within stage, but respect dependencies
        const initPromises = serviceNames.map(async (serviceName) => {
            try {
                await this.getService(serviceName);
                // Service initialized successfully
            } catch (error) {
                console.error(`[ServiceManager] âœ— Failed to initialize ${serviceName}:`, error);
                throw error;
            }
        });
        
        await Promise.all(initPromises);
        
        const stageDuration = Date.now() - stageStartTime;
        // Stage initialization completed
    }

    /**
     * Check if service is ready
     */
    isServiceReady(name: string): boolean {
        return this.container.isReady(name);
    }

    /**
     * Check if all services in a stage are ready
     */
    isStageReady(stage: ServiceStage): boolean {
        const serviceNames = this.getServicesByStage(stage);
        return serviceNames.every(name => this.container.isReady(name));
    }

    /**
     * Get detailed service status
     */
    getServiceStatus(name: string): ServiceStatus {
        const containerMeta = this.container.getServiceMetadata(name);
        const stage = this.serviceStages.get(name) || ServiceStage.BACKGROUND;
        
        return {
            name,
            stage,
            ready: this.container.isReady(name),
            initialized: containerMeta?.initialized || false,
            loading: false, // TODO: Track loading state
            dependencies: containerMeta?.dependencies || [],
            dependents: containerMeta?.dependents || []
        };
    }

    /**
     * Get status of all services
     */
    getAllServiceStatus(): Record<string, ServiceStatus> {
        const status: Record<string, ServiceStatus> = {};
        
        for (const serviceName of this.container.getRegisteredServices()) {
            status[serviceName] = this.getServiceStatus(serviceName);
        }
        
        return status;
    }

    /**
     * Start the service manager
     */
    async start(): Promise<void> {
        if (this.isStarted) {
            return;
        }
        
        this.isStarted = true;
        // Service manager starting
        
        // Initialize services
        await this.initializeServices();
    }

    /**
     * Stop the service manager
     */
    async stop(): Promise<void> {
        if (!this.isStarted) {
            return;
        }
        
        // Service manager stopping
        
        // Stop services in reverse dependency order
        await this.cleanup();
        
        this.isStarted = false;
    }

    /**
     * Cleanup all services
     */
    async cleanup(): Promise<void> {
        try {
            // Container handles cleanup in proper dependency order
            this.container.clear();
            
            // Clear stage mappings
            this.serviceStages.clear();
            
            // Service cleanup completed
            
        } catch (error) {
            console.error('[ServiceManager] Cleanup error:', error);
            throw error;
        }
    }

    // Helper methods

    /**
     * Get services by stage
     */
    private getServicesByStage(stage: ServiceStage): string[] {
        const services: string[] = [];
        
        this.serviceStages.forEach((serviceStage, serviceName) => {
            if (serviceStage === stage) {
                services.push(serviceName);
            }
        });
        
        return services;
    }

    // Legacy stage mapping removed - all stage management now through ServiceStage enum

    // Compatibility methods for existing consumers

    /**
     * Compatibility method for LazyServiceManager interface
     */
    async get<T>(name: string): Promise<T> {
        return this.getService<T>(name);
    }

    /**
     * Compatibility method for SimpleServiceManager interface
     */
    getIfReady<T>(name: string): T | null {
        return this.getServiceIfReady<T>(name);
    }

    /**
     * Compatibility method for getting all initialized services
     */
    getAllInitialized(): Record<string, any> {
        const services: Record<string, any> = {};
        
        for (const serviceName of this.container.getReadyServices()) {
            const service = this.container.getIfReady(serviceName);
            if (service) {
                services[serviceName] = service;
            }
        }
        
        return services;
    }

    /**
     * Get container statistics
     */
    getStats() {
        return this.container.getStats();
    }

    /**
     * Get ready service names
     */
    getReadyServices(): string[] {
        return this.container.getReadyServices();
    }

    /**
     * Get registered service names
     */
    getRegisteredServices(): string[] {
        return this.container.getRegisteredServices();
    }

    /**
     * Validate dependency graph
     */
    validateDependencies(): { valid: boolean; cycles: string[] } {
        const result = this.container.validateDependencies();
        return {
            valid: result.isValid,
            cycles: result.errors
        };
    }

    /**
     * Pre-initialize services for better performance
     */
    async preInitializeServices(serviceNames: string[]): Promise<void> {
        await this.container.preInitializeMany(serviceNames);
    }

    /**
     * Initialize services in dependency order
     */
    async initializeInOrder(serviceNames: string[]): Promise<void> {
        await this.container.initializeInOrder(serviceNames);
    }

    /**
     * Export dependency graph for visualization
     */
    exportDependencyGraph(): { nodes: string[]; edges: Array<{ from: string; to: string }> } {
        return this.container.exportDependencyGraph();
    }
}
```

## core/services/ServiceDefinitions.ts

```typescript
/**
 * Location: /src/core/services/ServiceDefinitions.ts
 *
 * Service Definitions - Centralized service registration configuration
 *
 * This module defines all services in a data-driven way, making it easy to add
 * new services without modifying the core PluginLifecycleManager.
 *
 * Simplified architecture for JSON-based storage
 */

import type { Plugin } from 'obsidian';
import { Events } from 'obsidian';
import type { ServiceManager } from '../ServiceManager';
import type { Settings } from '../../settings';
import type { IStorageAdapter } from '../../database/interfaces/IStorageAdapter';
import type { DirectToolExecutor } from '../../services/chat/DirectToolExecutor';
import type { AgentRegistrationService } from '../../services/agent/AgentRegistrationService';
import type { SessionContextManager } from '../../services/SessionContextManager';

export interface ServiceDefinition {
    name: string;
    dependencies?: string[];
    create: (context: ServiceCreationContext) => Promise<any>;
}

export interface ServiceCreationContext {
    plugin: Plugin;
    app: any;
    settings: Settings;
    serviceManager: ServiceManager;
    connector: any; // MCPConnector
    manifest: any;
}

/**
 * Core service definitions in dependency order
 * Note: Events are handled via Obsidian's built-in Events API (plugin.on/trigger)
 */
export const CORE_SERVICE_DEFINITIONS: ServiceDefinition[] = [
    // VaultOperations - centralized vault operations using Obsidian API
    {
        name: 'vaultOperations',
        create: async (context) => {
            const { VaultOperations } = await import('../VaultOperations');
            const { ObsidianPathManager } = await import('../ObsidianPathManager');
            const { StructuredLogger } = await import('../StructuredLogger');

            const pathManager = new ObsidianPathManager(context.app.vault);
            const logger = new StructuredLogger(context.plugin);
            return new VaultOperations(context.app.vault, pathManager, logger);
        }
    },

    // Note: ProcessedFilesStateManager and SimpleMemoryService removed in simplify-search-architecture
    // State management is now handled by simplified JSON-based storage

    // Workspace service (centralized storage service)
    {
        name: 'workspaceService',
        dependencies: ['hybridStorageAdapter', 'vaultOperations'],
        create: async (context) => {
            const { WorkspaceService } = await import('../../services/WorkspaceService');
            const { FileSystemService } = await import('../../services/storage/FileSystemService');
            const { IndexManager } = await import('../../services/storage/IndexManager');
            const { VaultOperations } = await import('../VaultOperations');

            const vaultOperations = await context.serviceManager.getService('vaultOperations') as InstanceType<typeof VaultOperations>;
            const fileSystem = new FileSystemService(context.plugin, vaultOperations);
            const indexManager = new IndexManager(fileSystem);

            // Get storage adapter if available (may be null if initialization failed)
            const storageAdapter = await context.serviceManager.getService<IStorageAdapter | null>('hybridStorageAdapter');

            return new WorkspaceService(context.plugin, fileSystem, indexManager, storageAdapter || undefined);
        }
    },

    // Default workspace manager (ensures default workspace exists)
    {
        name: 'defaultWorkspaceManager',
        dependencies: ['workspaceService'],
        create: async (context) => {
            const { DefaultWorkspaceManager } = await import('../../services/workspace/DefaultWorkspaceManager');
            const { WorkspaceService } = await import('../../services/WorkspaceService');
            const workspaceService = await context.serviceManager.getService('workspaceService') as InstanceType<typeof WorkspaceService>;

            const manager = new DefaultWorkspaceManager(context.app, workspaceService);
            await manager.initialize();
            return manager;
        }
    },

    // Memory service (agent-specific, delegates to WorkspaceService or SQLite via storageAdapter)
    {
        name: 'memoryService',
        dependencies: ['workspaceService', 'hybridStorageAdapter'],
        create: async (context) => {
            const { MemoryService } = await import('../../agents/memoryManager/services/MemoryService');
            const WorkspaceService = (await import('../../services/WorkspaceService')).WorkspaceService;
            const workspaceService = await context.serviceManager.getService('workspaceService') as InstanceType<typeof WorkspaceService>;

            // Get storage adapter if available (may be null if initialization failed)
            const storageAdapter = await context.serviceManager.getService<IStorageAdapter | null>('hybridStorageAdapter');

            return new MemoryService(context.plugin, workspaceService, storageAdapter || undefined);
        }
    },

    // Cache manager for performance
    {
        name: 'cacheManager',
        dependencies: ['workspaceService', 'memoryService'],
        create: async (context) => {
            const { CacheManager } = await import('../../database/services/cache/CacheManager');
            const { WorkspaceService } = await import('../../services/WorkspaceService');
            const { MemoryService } = await import('../../agents/memoryManager/services/MemoryService');

            const workspaceService = await context.serviceManager.getService<InstanceType<typeof WorkspaceService>>('workspaceService');
            const memoryService = await context.serviceManager.getService<InstanceType<typeof MemoryService>>('memoryService');

            const cacheManager = new CacheManager(
                context.plugin.app,
                workspaceService,
                memoryService,
                {
                    enableEntityCache: true,
                    enableFileIndex: true,
                    enablePrefetch: true
                }
            );

            await cacheManager.initialize();
            return cacheManager;
        }
    },

    // Session service for session persistence
    {
        name: 'sessionService',
        dependencies: ['memoryService'],
        create: async (context) => {
            const { SessionService } = await import('../../services/session/SessionService');
            type IMemoryService = import('../../services/session/SessionService').IMemoryService;
            const memoryService = await context.serviceManager.getService('memoryService') as IMemoryService;

            const service = new SessionService(memoryService);
            return service;
        }
    },

    // Session context manager
    {
        name: 'sessionContextManager',
        dependencies: ['workspaceService', 'memoryService', 'sessionService'],
        create: async (context) => {
            const { SessionContextManager } = await import('../../services/SessionContextManager');

            const workspaceService = await context.serviceManager.getService('workspaceService');
            const memoryService = await context.serviceManager.getService('memoryService');
            const sessionService = await context.serviceManager.getService('sessionService');

            const manager = new SessionContextManager();
            manager.setSessionService(sessionService);
            return manager;
        }
    },

    // Tool call trace service for capturing tool executions
    {
        name: 'toolCallTraceService',
        dependencies: ['memoryService', 'sessionContextManager', 'workspaceService'],
        create: async (context) => {
            const { ToolCallTraceService } = await import('../../services/trace/ToolCallTraceService');
            const { MemoryService } = await import('../../agents/memoryManager/services/MemoryService');
            const { SessionContextManager } = await import('../../services/SessionContextManager');
            const { WorkspaceService } = await import('../../services/WorkspaceService');

            const memoryService = await context.serviceManager.getService('memoryService') as InstanceType<typeof MemoryService>;
            const sessionContextManager = await context.serviceManager.getService('sessionContextManager') as InstanceType<typeof SessionContextManager>;
            const workspaceService = await context.serviceManager.getService('workspaceService') as InstanceType<typeof WorkspaceService>;

            return new ToolCallTraceService(
                memoryService,
                sessionContextManager,
                workspaceService,
                context.plugin
            );
        }
    },

    // LLM services for chat functionality
    // Note: Tool execution is now handled by DirectToolExecutor, not mcpConnector
    {
        name: 'llmService',
        dependencies: ['vaultOperations', 'directToolExecutor'],
        create: async (context) => {
            const { LLMService } = await import('../../services/llm/core/LLMService');
            const { VaultOperations } = await import('../../core/VaultOperations');

            const llmProviders = context.settings.settings.llmProviders;
            if (!llmProviders || typeof llmProviders !== 'object' || !('providers' in llmProviders)) {
                throw new Error('Invalid LLM provider settings');
            }

            // Create LLMService without mcpConnector (tool execution handled separately)
            const llmService = new LLMService(llmProviders, context.app.vault);

            // Inject VaultOperations for file reading
            const vaultOperations = await context.serviceManager.getService('vaultOperations') as InstanceType<typeof VaultOperations>;
            if (vaultOperations) {
                llmService.setVaultOperations(vaultOperations);
            }

            // Inject DirectToolExecutor for tool execution (works on ALL platforms)
            const directToolExecutor = await context.serviceManager.getService<DirectToolExecutor>('directToolExecutor');
            if (directToolExecutor) {
                llmService.setToolExecutor(directToolExecutor);
            }

            return llmService;
        }
    },

    // Custom prompt storage service for AgentManager
    {
        name: 'customPromptStorageService',
        create: async (context) => {
            const { CustomPromptStorageService } = await import('../../agents/promptManager/services/CustomPromptStorageService');
            return new CustomPromptStorageService(context.settings);
        }
    },

    // Agent manager for custom AI agents (registry only - no dependencies needed)
    {
        name: 'agentManager',
        dependencies: [],
        create: async (context) => {
            const { AgentManager } = await import('../../services/AgentManager');

            return new AgentManager(
                context.plugin.app,
                context.plugin,
                new Events() // Placeholder Events instance for unused parameter
            );
        }
    },

    // Hybrid storage adapter (SQLite + JSONL) - deferred initialization for fast startup
    {
        name: 'hybridStorageAdapter',
        create: async (context) => {
            try {
                const { HybridStorageAdapter } = await import('../../database/adapters/HybridStorageAdapter');

                const adapter = new HybridStorageAdapter({
                    app: context.app,
                    basePath: '.nexus',
                    autoSync: true,
                    cacheTTL: 60000, // 1 minute query cache
                    cacheMaxSize: 500
                });

                // Start initialization in background (non-blocking)
                // ChatView will show loading indicator until ready
                adapter.initialize(false);
                return adapter;
            } catch {
                // HybridStorageAdapter creation failed - graceful fallback to legacy storage
                return null;
            }
        }
    },

    // Conversation service for chat storage
    {
        name: 'conversationService',
        dependencies: ['hybridStorageAdapter', 'vaultOperations'],
        create: async (context) => {
            const { ConversationService } = await import('../../services/ConversationService');
            const { FileSystemService } = await import('../../services/storage/FileSystemService');
            const { IndexManager } = await import('../../services/storage/IndexManager');
            const { VaultOperations } = await import('../VaultOperations');

            const vaultOperations = await context.serviceManager.getService('vaultOperations') as InstanceType<typeof VaultOperations>;
            const fileSystem = new FileSystemService(context.plugin, vaultOperations);
            const indexManager = new IndexManager(fileSystem);

            // Get storage adapter if available (may be null if initialization failed)
            const storageAdapter = await context.serviceManager.getService<IStorageAdapter | null>('hybridStorageAdapter');

            return new ConversationService(context.plugin, fileSystem, indexManager, storageAdapter || undefined);
        }
    },

    // Agent registration service - independent of MCP, works on ALL platforms
    // This initializes agents without requiring the MCP connector
    {
        name: 'agentRegistrationService',
        dependencies: ['memoryService', 'workspaceService', 'agentManager'],
        create: async (context) => {
            const { AgentRegistrationService } = await import('../../services/agent/AgentRegistrationService');
            const { AgentManager } = await import('../../services/AgentManager');
            // Plugin type augmentation - NexusPlugin extends Plugin with events property
            const plugin = context.plugin as Plugin & { events?: Events };

            // Get the AgentManager service instance (not create a new one)
            const agentManager = await context.serviceManager.getService('agentManager') as InstanceType<typeof AgentManager>;

            // Create agent registration service with the shared AgentManager
            const agentService = new AgentRegistrationService(
                context.app,
                plugin,
                plugin.events || new Events(),
                context.serviceManager,
                undefined, // customPromptStorage - optional
                agentManager // pass the shared AgentManager
            );

            // Initialize all agents
            await agentService.initializeAllAgents();

            return agentService;
        }
    },

    // Direct tool executor - enables tool execution on ALL platforms (desktop + mobile)
    // Bypasses MCP protocol for native chat, uses agents directly
    {
        name: 'directToolExecutor',
        dependencies: ['agentRegistrationService', 'sessionContextManager'],
        create: async (context) => {
            const { DirectToolExecutor } = await import('../../services/chat/DirectToolExecutor');

            const agentService = await context.serviceManager.getService<AgentRegistrationService>('agentRegistrationService');
            const sessionContextManager = context.serviceManager.getServiceIfReady<SessionContextManager>('sessionContextManager') ?? undefined;

            // Wrap agentService to match AgentProvider interface
            const agentProvider = {
                getAllAgents: () => agentService.getAllAgents(),
                getAgent: (name: string) => agentService.getAgent(name),
                hasAgent: (name: string) => agentService.getAgent(name) !== null,
                agentSupportsMode: () => true // Let execution fail if tool not supported
            };

            const executor = new DirectToolExecutor({
                agentProvider,
                sessionContextManager
            });

            return executor;
        }
    },

    // Chat trace service for creating memory traces from conversations
    {
        name: 'chatTraceService',
        dependencies: ['workspaceService'],
        create: async (context) => {
            const { ChatTraceService } = await import('../../services/chat/ChatTraceService');
            const { WorkspaceService } = await import('../../services/WorkspaceService');

            const workspaceService = await context.serviceManager.getService('workspaceService') as InstanceType<typeof WorkspaceService>;

            return new ChatTraceService({
                workspaceService
            });
        }
    },

    // Chat service with direct agent integration
    // Uses DirectToolExecutor for tool execution and ChatTraceService for memory traces
    {
        name: 'chatService',
        dependencies: ['conversationService', 'llmService', 'directToolExecutor', 'chatTraceService'],
        create: async (context) => {
            const { ChatService } = await import('../../services/chat/ChatService');
            const { ChatTraceService } = await import('../../services/chat/ChatTraceService');

            const conversationService = await context.serviceManager.getService('conversationService');
            const llmService = await context.serviceManager.getService('llmService');
            const directToolExecutor = await context.serviceManager.getService('directToolExecutor');
            const chatTraceService = await context.serviceManager.getService('chatTraceService') as InstanceType<typeof ChatTraceService> | null;

            const chatService = new ChatService(
                {
                    conversationService,
                    llmService,
                    vaultName: context.app.vault.getName(),
                    mcpConnector: context.connector, // Keep for backward compatibility, but not used for tool execution
                    chatTraceService: chatTraceService || undefined
                },
                {
                    maxToolIterations: 10,
                    toolTimeout: 30000,
                    enableToolChaining: true
                }
            );

            // Set up DirectToolExecutor for tool execution (works on ALL platforms)
            chatService.setDirectToolExecutor(directToolExecutor as DirectToolExecutor);

            return chatService;
        }
    }
];

/**
 * Interface for additional service factories with enhanced dependency injection
 */
export interface AdditionalServiceFactory {
    name: string;
    dependencies: string[];
    factory: (deps: Record<string, any>) => Promise<any>;
}

/**
 * Additional services for UI and maintenance functionality
 */
export const ADDITIONAL_SERVICE_FACTORIES: AdditionalServiceFactory[] = [
    // Note: ChatDatabaseService removed in simplify-search-architecture
    // Chat data now stored in simplified JSON format
];

/**
 * Services that require special initialization
 */
export const SPECIALIZED_SERVICES = [
    'cacheManager',           // Requires dependency injection
    'sessionContextManager',  // Requires settings configuration
    'chatService'             // Requires MCP client initialization
];
```

## core/services/ServiceRegistrar.ts

```typescript
/**
 * Location: /src/core/services/ServiceRegistrar.ts
 *
 * Service Registrar - Handles service registration and additional service factories
 *
 * This service extracts the complex service registration logic from PluginLifecycleManager,
 * making it data-driven and easily extensible for new services.
 */

import type { ServiceManager } from '../ServiceManager';
import { FileSystemService } from '../../services/storage/FileSystemService';
import { IndexManager } from '../../services/storage/IndexManager';
import { DataMigrationService } from '../../services/migration/DataMigrationService';
import { TraceSchemaMigrationService } from '../../services/migration/TraceSchemaMigrationService';
import { normalizePath } from 'obsidian';
import { CORE_SERVICE_DEFINITIONS, ADDITIONAL_SERVICE_FACTORIES } from './ServiceDefinitions';
import type { ServiceCreationContext, AdditionalServiceFactory } from './ServiceDefinitions';
import type { VaultOperations } from '../VaultOperations';
import type { ChatService } from '../../services/chat/ChatService';

export class ServiceRegistrar {
    private context: ServiceCreationContext;

    constructor(context: ServiceCreationContext) {
        this.context = context;
    }

    /**
     * Register all core services with the ServiceManager
     */
    async registerCoreServices(): Promise<void> {
        for (const serviceDef of CORE_SERVICE_DEFINITIONS) {
            await this.context.serviceManager.registerService({
                name: serviceDef.name,
                dependencies: serviceDef.dependencies,
                create: () => serviceDef.create(this.context)
            });
        }
    }

    /**
     * Register additional services needed by UI components using factory pattern
     */
    registerAdditionalServices(): void {
        const { serviceManager, plugin, settings, app } = this.context;

        // Early return if no additional service factories defined
        if (!ADDITIONAL_SERVICE_FACTORIES || ADDITIONAL_SERVICE_FACTORIES.length === 0) {
            return;
        }

        // Type guard to ensure service factory has required properties
        const isValidServiceFactory = (factory: unknown): factory is AdditionalServiceFactory => {
            if (factory === null || typeof factory !== 'object') {
                return false;
            }

            // At this point we know factory is a non-null object
            const obj = factory as Record<string, unknown>;

            return (
                'name' in obj &&
                'dependencies' in obj &&
                'factory' in obj &&
                typeof obj.name === 'string' &&
                Array.isArray(obj.dependencies) &&
                typeof obj.factory === 'function'
            );
        };

        for (const serviceFactory of ADDITIONAL_SERVICE_FACTORIES) {
            if (!isValidServiceFactory(serviceFactory)) {
                continue;
            }

            serviceManager.registerFactory(
                serviceFactory.name,
                async (deps) => {
                    // Create enhanced dependency context
                    const enhancedDeps = {
                        ...deps,
                        plugin,
                        app,
                        memorySettings: settings.settings.memory || {}
                    };
                    return serviceFactory.factory(enhancedDeps);
                },
                { dependencies: serviceFactory.dependencies }
            );
        }
    }

    /**
     * Get default memory settings
     */
    static getDefaultMemorySettings(dataDir: string) {
        return {};
    }

    /**
     * Initialize data directories and run migration if needed
     */
    async initializeDataDirectories(): Promise<void> {
        try {
            const { app, plugin, settings, manifest, serviceManager } = this.context;

            // Get vaultOperations service with proper typing
            const vaultOperations = await serviceManager.getService<VaultOperations>('vaultOperations');

            // Initialize storage services
            const fileSystem = new FileSystemService(plugin, vaultOperations);
            const indexManager = new IndexManager(fileSystem);

            // Check migration status BEFORE creating directories
            const migrationService = new DataMigrationService(plugin, fileSystem, indexManager);
            const status = await migrationService.checkMigrationStatus();

            if (status.isRequired) {
                // Migrate from legacy ChromaDB data
                const result = await migrationService.performMigration();

                if (result.success) {
                    // Migration completed successfully
                } else {
                    console.error('[ServiceRegistrar] Migration failed:', result.errors);
                }
            } else if (!status.migrationComplete) {
                // No legacy data and directories don't exist - initialize fresh structure
                await migrationService.initializeFreshDirectories();
            }

            // Ensure all conversations have metadata field (idempotent)
            try {
                const metadataResult = await migrationService.ensureConversationMetadata();
                if (metadataResult.errors.length > 0) {
                    console.error('[ServiceRegistrar] Metadata migration errors:', metadataResult.errors);
                }
            } catch (error) {
                console.error('[ServiceRegistrar] Metadata migration failed:', error);
            }

            // Normalize memory trace schema across all workspaces (idempotent)
            try {
                const traceMigrationService = new TraceSchemaMigrationService(plugin, fileSystem, vaultOperations);
                await traceMigrationService.migrateIfNeeded();
            } catch (error) {
                console.error('[ServiceRegistrar] Trace schema migration failed:', error);
            }

            // Legacy data directory handling (can be removed after migration)
            const pluginDir = `.obsidian/plugins/${manifest.id}`;
            const dataDir = `${pluginDir}/data`;
            const storageDir = `${dataDir}/storage`;

            try {
                await vaultOperations.ensureDirectory(dataDir);
                await vaultOperations.ensureDirectory(storageDir);
            } catch (error) {
                // Directories may already exist
            }

            // Update settings with correct path
            if (!settings.settings.memory) {
                settings.settings.memory = ServiceRegistrar.getDefaultMemorySettings(storageDir);
            }

            // Save settings in background
            settings.saveSettings().catch(error => {
            });

        } catch (error) {
            console.error('[ServiceRegistrar] Failed to initialize data directories:', error);
            // Don't throw - plugin should function without directories for now
        }
    }

    /**
     * Initialize essential services that must be ready immediately
     * Includes the full chain needed for tool call tracing:
     * workspaceService -> memoryService -> sessionService -> sessionContextManager
     */
    async initializeEssentialServices(): Promise<void> {
        try {
            await this.context.serviceManager.getService('workspaceService');
            await this.context.serviceManager.getService('memoryService');
            await this.context.serviceManager.getService('cacheManager');
            await this.context.serviceManager.getService('sessionService');
            await this.context.serviceManager.getService('sessionContextManager');
        } catch (error) {
            console.error('[ServiceRegistrar] Essential service initialization failed:', error);
            throw error;
        }
    }

    /**
     * Initialize business services with proper dependency resolution
     * Note: ChatService initialization is deferred to initializeChatService()
     */
    async initializeBusinessServices(): Promise<void> {
        try {
            // Core services already initialized in essential services:
            // - workspaceService, memoryService, sessionService, sessionContextManager

            await this.context.serviceManager.getService('defaultWorkspaceManager'); // Initialize default workspace
            await this.context.serviceManager.getService('agentManager');
            await this.context.serviceManager.getService('llmService');
            await this.context.serviceManager.getService('toolCallTraceService'); // Initialize trace service
            await this.context.serviceManager.getService('conversationService');

            // ChatService initialization deferred - will be called after agents are registered
        } catch (error) {
            console.error('[ServiceRegistrar] Business service initialization failed:', error);
            throw error;
        }
    }

    /**
     * Initialize ChatService AFTER agents are registered in connector
     * This ensures tools are available when ChatService initializes
     */
    async initializeChatService(): Promise<void> {
        try {
            const chatService = await this.context.serviceManager.getService<ChatService>('chatService');

            // Type guard to ensure chatService has initialize method
            if (chatService && 'initialize' in chatService && typeof chatService.initialize === 'function') {
                await chatService.initialize();
            }
        } catch (error) {
            console.error('[ServiceRegistrar] ChatService initialization failed:', error);
            throw error;
        }
    }

    /**
     * Pre-initialize UI-critical services to avoid Memory Management loading delays
     */
    async preInitializeUICriticalServices(): Promise<void> {
        if (!this.context.serviceManager) return;

        try {
            // Register additional services if not already registered
            this.registerAdditionalServices();

        } catch (error) {
            console.error('[ServiceRegistrar] UI-critical services pre-initialization failed:', error);
        }
    }

    /**
     * Get service helper method with timeout
     */
    async getService<T>(name: string, timeoutMs: number = 10000): Promise<T | null> {
        if (!this.context.serviceManager) {
            return null;
        }
        
        try {
            return await this.context.serviceManager.getService<T>(name);
        } catch (error) {
            return null;
        }
    }

    /**
     * Wait for a service to be ready with retry logic
     */
    async waitForService<T>(serviceName: string, timeoutMs: number = 30000): Promise<T | null> {
        const startTime = Date.now();
        const retryInterval = 1000; // Check every 1 second
        
        while (Date.now() - startTime < timeoutMs) {
            try {
                const service = await this.getService<T>(serviceName, 2000);
                if (service) {
                    return service;
                }
            } catch (error) {
                // Service not ready yet, continue waiting
            }
            
            // Wait before retrying
            await new Promise(resolve => setTimeout(resolve, retryInterval));
        }

        return null;
    }
}

```

## core/settings/SettingsTabManager.ts

```typescript
/**
 * Location: /src/core/settings/SettingsTabManager.ts
 * 
 * Settings Tab Manager - Handles settings tab creation and management
 * 
 * This service extracts settings tab management from PluginLifecycleManager,
 * providing focused settings tab lifecycle management.
 */

import type { App, Plugin } from 'obsidian';
import type { Settings } from '../../settings';
// Use new SettingsView (tab-based UI) instead of old SettingsTab (accordion-based)
import { SettingsView } from '../../settings/SettingsView';
import type { BackgroundProcessor } from '../background/BackgroundProcessor';
import type { ServiceManager } from '../ServiceManager';

// Type-only import to avoid bundling Node.js dependencies on mobile
type MCPConnectorType = import('../../connector').MCPConnector;

// Extended interface for PluginLifecycleManager with optional methods
interface LifecycleManager {
    [key: string]: any;
}

export interface SettingsTabManagerConfig {
    plugin: Plugin;
    app: App;
    settings: Settings;
    serviceManager: ServiceManager;
    connector?: MCPConnectorType; // Optional - undefined on mobile
    lifecycleManager: LifecycleManager; // Reference to PluginLifecycleManager for ChatView activation
    backgroundProcessor?: BackgroundProcessor;
}

export class SettingsTabManager {
    private config: SettingsTabManagerConfig;
    private settingsTab?: SettingsView;

    constructor(config: SettingsTabManagerConfig) {
        this.config = config;
    }

    /**
     * Initialize settings tab asynchronously
     */
    async initializeSettingsTab(): Promise<void> {
        try {
            // Get agent references - may not be available yet
            const searchManager = this.config.connector?.getSearchManager();
            const memoryManager = this.config.connector?.getMemoryManager();
            
            // Get services from container
            const services: Record<string, any> = {};
            for (const serviceName of this.config.serviceManager.getReadyServices()) {
                services[serviceName] = this.config.serviceManager.getServiceIfReady(serviceName);
            }
            
            // Create settings tab with current state (using new tab-based SettingsView)
            this.settingsTab = new SettingsView(
                this.config.app,
                this.config.plugin,
                this.config.settings,
                services, // Pass current services (may be empty initially)
                searchManager || undefined,
                memoryManager || undefined,
                this.config.serviceManager, // Pass service manager for compatibility
                this.config.lifecycleManager // Pass lifecycle manager for ChatView activation
            );
            this.config.plugin.addSettingTab(this.settingsTab);
            
            // Pass settings tab to background processor for service updates
            if (this.config.backgroundProcessor) {
                this.config.backgroundProcessor.setSettingsTab(this.settingsTab);
            }
            
        } catch (error) {
            console.error('[SettingsTabManager] Settings tab initialization failed:', error);
            // Plugin should still function without settings tab
        }
    }

    /**
     * Set background processor reference (used for dependency injection)
     */
    setBackgroundProcessor(backgroundProcessor: BackgroundProcessor): void {
        this.config.backgroundProcessor = backgroundProcessor;
        
        // Pass settings tab if already created
        if (this.settingsTab && backgroundProcessor) {
            backgroundProcessor.setSettingsTab(this.settingsTab);
        }
    }

    /**
     * Get the settings tab instance
     */
    getSettingsTab(): SettingsView | undefined {
        return this.settingsTab;
    }

    /**
     * Check if settings tab is initialized
     */
    isInitialized(): boolean {
        return !!this.settingsTab;
    }

    /**
     * Cleanup settings tab (called during shutdown)
     */
    cleanup(): void {
        if (this.settingsTab && 'cleanup' in this.settingsTab && typeof this.settingsTab.cleanup === 'function') {
            this.settingsTab.cleanup();
        }
    }
}
```

## core/StructuredLogger.ts

```typescript
/**
 * StructuredLogger - Structured logging system replacing console.log proliferation
 * Location: src/core/StructuredLogger.ts
 * 
 * This service replaces the 1,286+ console.log statements throughout the codebase
 * with a proper logging system that respects debug modes, provides structured output,
 * and includes log management features.
 * 
 * Key features:
 * - Configurable log levels and debug mode
 * - Structured log entries with metadata
 * - Context-specific loggers for modules
 * - Log buffering and export functionality
 * - Performance timing utilities
 * - Cross-platform compatibility
 * 
 * Used by:
 * - All services to replace console.log statements
 * - Debug and troubleshooting operations
 * - Performance monitoring
 * - Error tracking and reporting
 */

import { Platform, Plugin } from 'obsidian';

export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

/**
 * Extended Performance interface for Chrome's memory API
 * Chrome-specific extension not available in all browsers
 */
interface PerformanceMemory {
  usedJSHeapSize: number;
  totalJSHeapSize: number;
  jsHeapSizeLimit: number;
}

interface PerformanceWithMemory extends Performance {
  memory: PerformanceMemory;
}

/**
 * Type guard to check if performance.memory is available
 * This is a Chrome-specific feature not available in all environments
 */
function hasMemoryAPI(perf: Performance): perf is PerformanceWithMemory {
  return 'memory' in perf &&
         perf.memory !== undefined &&
         perf.memory !== null &&
         typeof perf.memory === 'object' &&
         'usedJSHeapSize' in perf.memory;
}

export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  data?: any;
  context?: string;
  plugin: string;
  performance?: {
    duration?: number;
    memory?: number;
  };
}

export interface LoggerConfig {
  debugMode: boolean;
  level: LogLevel;
  maxBufferSize: number;
  enablePerformanceLogging: boolean;
  enableExport: boolean;
}

/**
 * Context-specific logger for modules/services
 */
export class ContextLogger {
  constructor(
    private logger: StructuredLogger,
    private context: string
  ) {}

  debug(message: string, data?: any): void {
    this.logger.debug(message, data, this.context);
  }

  info(message: string, data?: any): void {
    this.logger.info(message, data, this.context);
  }

  warn(message: string, data?: any): void {
    this.logger.warn(message, data, this.context);
  }

  error(message: string, error?: Error): void {
    this.logger.error(message, error, this.context);
  }

  time(label: string): void {
    this.logger.time(`${this.context}:${label}`);
  }

  timeEnd(label: string): void {
    this.logger.timeEnd(`${this.context}:${label}`);
  }
}

/**
 * Structured logging system replacing console.log proliferation
 * Configurable levels and proper error handling
 */
export class StructuredLogger {
  private config: LoggerConfig;
  private logBuffer: LogEntry[] = [];
  private timers = new Map<string, number>();
  private contextLoggers = new Map<string, ContextLogger>();

  constructor(private plugin: Plugin) {
    this.config = {
      debugMode: false,
      level: LogLevel.INFO,
      maxBufferSize: 1000,
      enablePerformanceLogging: false,
      enableExport: true
    };
    
    this.loadLogSettings();
  }

  private async loadLogSettings(): Promise<void> {
    try {
      const settings = await this.plugin.loadData();
      const loggingSettings = settings?.logging;

      if (loggingSettings) {
        this.config = {
          debugMode: loggingSettings.debugMode || false,
          level: loggingSettings.level || LogLevel.INFO,
          maxBufferSize: loggingSettings.maxBufferSize || 1000,
          enablePerformanceLogging: loggingSettings.enablePerformanceLogging || false,
          enableExport: loggingSettings.enableExport !== false
        };
      }
    } catch (error) {
    }
  }

  /**
   * Update logging configuration
   */
  async updateConfig(newConfig: Partial<LoggerConfig>): Promise<void> {
    this.config = { ...this.config, ...newConfig };
    
    try {
      const settings = await this.plugin.loadData() || {};
      settings.logging = this.config;
      await this.plugin.saveData(settings);
    } catch (error) {
      console.error('[StructuredLogger] Failed to save log configuration:', error);
    }
  }

  /**
   * Debug level logging
   */
  debug(message: string, data?: any, context?: string): void {
    if (this.config.debugMode && this.shouldLog(LogLevel.DEBUG)) {
      this.log(LogLevel.DEBUG, message, data, context);
    }
  }

  /**
   * Info level logging
   */
  info(message: string, data?: any, context?: string): void {
    if (this.shouldLog(LogLevel.INFO)) {
      this.log(LogLevel.INFO, message, data, context);
    }
  }

  /**
   * Warning level logging
   */
  warn(message: string, data?: any, context?: string): void {
    if (this.shouldLog(LogLevel.WARN)) {
      this.log(LogLevel.WARN, message, data, context);
    }
  }

  /**
   * Error level logging
   */
  error(message: string, error?: Error, context?: string): void {
    if (this.shouldLog(LogLevel.ERROR)) {
      // Extract error information
      const errorData = error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : undefined;
      
      this.log(LogLevel.ERROR, message, errorData, context);
    }
  }

  /**
   * Performance timing start
   */
  time(label: string): void {
    if (this.config.enablePerformanceLogging || this.config.debugMode) {
      this.timers.set(label, performance.now());
    }
  }

  /**
   * Performance timing end
   */
  timeEnd(label: string): void {
    if (this.config.enablePerformanceLogging || this.config.debugMode) {
      const startTime = this.timers.get(label);
      if (startTime !== undefined) {
        const duration = performance.now() - startTime;
        this.timers.delete(label);
        
        this.debug(`Performance: ${label} completed`, {
          duration: `${duration.toFixed(2)}ms`,
          label
        }, 'Performance');
      }
    }
  }

  /**
   * Create context-specific logger
   */
  createContextLogger(context: string): ContextLogger {
    if (!this.contextLoggers.has(context)) {
      this.contextLoggers.set(context, new ContextLogger(this, context));
    }
    return this.contextLoggers.get(context)!;
  }

  /**
   * Log performance metrics
   */
  logPerformance(operation: string, duration: number, context?: string): void {
    if (this.config.enablePerformanceLogging) {
      this.info(`Performance: ${operation}`, {
        duration: `${duration.toFixed(2)}ms`,
        operation
      }, context || 'Performance');
    }
  }

  /**
   * Log memory usage
   */
  logMemoryUsage(context?: string): void {
    if (this.config.enablePerformanceLogging && hasMemoryAPI(performance)) {
      const memInfo = performance.memory;
      this.debug('Memory usage', {
        used: `${(memInfo.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB`,
        total: `${(memInfo.totalJSHeapSize / 1024 / 1024).toFixed(2)} MB`,
        limit: `${(memInfo.jsHeapSizeLimit / 1024 / 1024).toFixed(2)} MB`
      }, context || 'Memory');
    }
  }

  private log(level: LogLevel, message: string, data?: any, context?: string): void {
    const timestamp = new Date().toISOString();
    const logEntry: LogEntry = {
      timestamp,
      level,
      message,
      data,
      context,
      plugin: this.plugin.manifest.id
    };

    if (this.config.enablePerformanceLogging && hasMemoryAPI(performance)) {
      const memInfo = performance.memory;
      logEntry.performance = {
        memory: memInfo.usedJSHeapSize
      };
    }

    this.addToBuffer(logEntry);

    const formattedMessage = this.formatMessage(logEntry);

    if (level === LogLevel.ERROR) {
      console.error(formattedMessage, data || '');
    }
  }

  /**
   * Check if should log at level
   */
  private shouldLog(level: LogLevel): boolean {
    return level >= this.config.level;
  }

  /**
   * Format log message for console output
   */
  private formatMessage(entry: LogEntry): string {
    const levelStr = LogLevel[entry.level];
    const contextStr = entry.context ? ` [${entry.context}]` : '';
    const timestamp = new Date(entry.timestamp).toLocaleTimeString();
    
    return `[${entry.plugin}]${contextStr} ${levelStr}: ${entry.message} (${timestamp})`;
  }

  /**
   * Add entry to buffer with size management
   */
  private addToBuffer(entry: LogEntry): void {
    this.logBuffer.push(entry);
    
    if (this.logBuffer.length > this.config.maxBufferSize) {
      // Remove oldest entries
      const excess = this.logBuffer.length - this.config.maxBufferSize;
      this.logBuffer.splice(0, excess);
    }
  }

  /**
   * Export logs for debugging
   */
  async exportLogs(): Promise<string> {
    if (!this.config.enableExport) {
      throw new Error('Log export is disabled');
    }

    const exportData = {
      plugin: this.plugin.manifest.id,
      version: this.plugin.manifest.version,
      exported: new Date().toISOString(),
      config: this.config,
      platform: Platform.isMobile ? 'mobile' : 'desktop',
      logCount: this.logBuffer.length,
      logs: this.logBuffer
    };
    
    return JSON.stringify(exportData, null, 2);
  }

  /**
   * Get log statistics
   */
  getLogStats(): {
    totalEntries: number;
    byLevel: Record<string, number>;
    byContext: Record<string, number>;
    bufferSize: number;
    oldestEntry?: string;
    newestEntry?: string;
  } {
    const byLevel: Record<string, number> = {};
    const byContext: Record<string, number> = {};

    for (const entry of this.logBuffer) {
      const levelStr = LogLevel[entry.level];
      byLevel[levelStr] = (byLevel[levelStr] || 0) + 1;
      
      const context = entry.context || 'Unknown';
      byContext[context] = (byContext[context] || 0) + 1;
    }

    return {
      totalEntries: this.logBuffer.length,
      byLevel,
      byContext,
      bufferSize: this.config.maxBufferSize,
      oldestEntry: this.logBuffer[0]?.timestamp,
      newestEntry: this.logBuffer[this.logBuffer.length - 1]?.timestamp
    };
  }

  clearBuffer(): void {
    const clearedCount = this.logBuffer.length;
    this.logBuffer = [];
    this.info(`Log buffer cleared (${clearedCount} entries removed)`, undefined, 'Logger');
  }

  /**
   * Search logs by criteria
   */
  searchLogs(criteria: {
    level?: LogLevel;
    context?: string;
    message?: string;
    since?: Date;
    until?: Date;
  }): LogEntry[] {
    return this.logBuffer.filter(entry => {
      if (criteria.level !== undefined && entry.level !== criteria.level) {
        return false;
      }
      
      if (criteria.context && entry.context !== criteria.context) {
        return false;
      }
      
      if (criteria.message && !entry.message.toLowerCase().includes(criteria.message.toLowerCase())) {
        return false;
      }
      
      const entryTime = new Date(entry.timestamp);
      if (criteria.since && entryTime < criteria.since) {
        return false;
      }
      
      if (criteria.until && entryTime > criteria.until) {
        return false;
      }
      
      return true;
    });
  }

  /**
   * Enable or disable debug mode
   */
  async setDebugMode(enabled: boolean): Promise<void> {
    await this.updateConfig({ debugMode: enabled });
    this.info(`Debug mode ${enabled ? 'enabled' : 'disabled'}`, undefined, 'Logger');
  }

  /**
   * Set log level
   */
  async setLogLevel(level: LogLevel): Promise<void> {
    await this.updateConfig({ level });
    this.info(`Log level set to ${LogLevel[level]}`, undefined, 'Logger');
  }

  /**
   * Get current configuration
   */
  getConfig(): Readonly<LoggerConfig> {
    return { ...this.config };
  }

  /**
   * Clean up resources
   */
  cleanup(): void {
    // Clear all timers
    this.timers.clear();
    
    // Clear context loggers
    this.contextLoggers.clear();
    
    // Optionally preserve buffer for post-cleanup analysis
    if (this.config.debugMode) {
      this.info('StructuredLogger cleanup completed', {
        bufferedEntries: this.logBuffer.length
      }, 'Logger');
    }
  }
}
```

## core/ui/ChatUIManager.ts

```typescript
/**
 * Location: /src/core/ui/ChatUIManager.ts
 * 
 * Chat UI Manager - Handles ChatView registration, activation, and management
 * 
 * This service extracts ChatView-specific logic from PluginLifecycleManager,
 * providing a focused interface for chat UI operations.
 */

import { Notice } from 'obsidian';
import type { Plugin } from 'obsidian';
import type { Settings } from '../../settings';

export interface ChatUIManagerConfig {
    plugin: Plugin;
    app: any;
    settings: Settings;
    getService: <T>(name: string, timeoutMs?: number) => Promise<T | null>;
}

export class ChatUIManager {
    private config: ChatUIManagerConfig;
    private chatUIRegistered: boolean = false;

    constructor(config: ChatUIManagerConfig) {
        this.config = config;
    }

    /**
     * Register chat UI components
     */
    async registerChatUI(): Promise<void> {
        try {
            const { plugin, app } = this.config;

            // Skip if already registered
            if (this.chatUIRegistered) {
                return;
            }
            
            // Get ChatService
            const chatService = await this.config.getService<any>('chatService', 5000);
            if (!chatService) {
                return;
            }
            
            // Import ChatView
            const { ChatView, CHAT_VIEW_TYPE } = await import('../../ui/chat/ChatView');
            
            // Register ChatView with Obsidian
            plugin.registerView(
                CHAT_VIEW_TYPE,
                (leaf) => new ChatView(leaf, chatService)
            );
            
            // Add ribbon icon for chat
            plugin.addRibbonIcon('message-square', 'Nexus Chat', () => {
                this.activateChatView();
            });
            
            // Add command to open chat
            plugin.addCommand({
                id: 'open-chat',
                name: 'Open Nexus Chat',
                callback: () => {
                    this.activateChatView();
                }
            });


            // Mark as registered
            this.chatUIRegistered = true;

        } catch (error) {
            console.error('Failed to register chat UI:', error);
        }
    }

    /**
     * Activate chat view in sidebar
     */
    async activateChatView(): Promise<void> {
        const { app } = this.config;

        const { CHAT_VIEW_TYPE } = await import('../../ui/chat/ChatView');
        
        // Check if chat view already exists
        const existingLeaf = app.workspace.getLeavesOfType(CHAT_VIEW_TYPE)[0];
        if (existingLeaf) {
            app.workspace.revealLeaf(existingLeaf);
            return;
        }
        
        // Create new chat view in right sidebar
        const leaf = app.workspace.getRightLeaf(false);
        await leaf.setViewState({
            type: CHAT_VIEW_TYPE,
            active: true
        });
        
        app.workspace.revealLeaf(leaf);
    }

    /**
     * Check if chat UI is registered
     */
    isChatUIRegistered(): boolean {
        return this.chatUIRegistered;
    }

    /**
     * Reset registration state (useful for testing or reinitialization)
     */
    resetRegistrationState(): void {
        this.chatUIRegistered = false;
    }
}
```

## core/VaultOperations.ts

```typescript
/**
 * VaultOperations - Centralized Vault operations using official Obsidian API
 * Location: src/core/VaultOperations.ts
 * 
 * This service replaces all Node.js filesystem operations with Obsidian Vault API calls,
 * ensuring cross-platform compatibility (mobile + desktop) and proper integration
 * with Obsidian's caching and file management systems.
 * 
 * Used by:
 * - All services that need file/directory operations
 * - ChromaDB persistence operations
 * - Plugin data management
 * - Configuration file handling
 */

import { Vault, TFile, TFolder, normalizePath } from 'obsidian';
import { ObsidianPathManager } from './ObsidianPathManager';
import { StructuredLogger } from './StructuredLogger';

export interface BatchWriteOperation {
  path: string;
  content: string;
}

export interface BatchWriteResult {
  success: string[];
  failed: string[];
}

export interface FileStats {
  size: number;
  mtime: number;
  ctime: number;
  type: 'file' | 'folder';
}

/**
 * Centralized Vault operations using official Obsidian API
 * Replaces all Node.js filesystem operations
 */
export class VaultOperations {
  private fileCache = new Map<string, { content: string; mtime: number }>();

  constructor(
    private vault: Vault,
    private pathManager: ObsidianPathManager,
    private logger: StructuredLogger
  ) {}

  /**
   * Get file by path with proper error handling
   */
  async getFile(path: string): Promise<TFile | null> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      const file = this.vault.getFileByPath(normalizedPath);
      return file;
    } catch (error) {
      this.logger.warn(`Failed to get file: ${path}`, error);
      return null;
    }
  }

  /**
   * Get folder by path with proper error handling
   */
  async getFolder(path: string): Promise<TFolder | null> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      const folder = this.vault.getFolderByPath(normalizedPath);
      return folder;
    } catch (error) {
      this.logger.warn(`Failed to get folder: ${path}`, error);
      return null;
    }
  }

  /**
   * Check if file exists
   */
  async fileExists(path: string): Promise<boolean> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      return await this.vault.adapter.exists(normalizedPath);
    } catch (error) {
      this.logger.debug(`File existence check failed: ${path}`, error);
      return false;
    }
  }

  /**
   * Check if folder exists
   */
  async folderExists(path: string): Promise<boolean> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      const stat = await this.vault.adapter.stat(normalizedPath);
      return stat?.type === 'folder';
    } catch (error) {
      this.logger.debug(`Folder existence check failed: ${path}`, error);
      return false;
    }
  }

  /**
   * Check if path is hidden (starts with . in any segment)
   */
  private isHiddenPath(path: string): boolean {
    return path.split('/').some(segment => segment.startsWith('.'));
  }

  /**
   * Read file content with caching support
   * Uses adapter.read() for hidden files since Obsidian doesn't index them
   */
  async readFile(path: string, useCache: boolean = true): Promise<string | null> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);

      // For hidden files, use adapter directly (Obsidian doesn't index hidden files)
      if (this.isHiddenPath(normalizedPath)) {
        const exists = await this.vault.adapter.exists(normalizedPath);
        if (!exists) {
          this.logger.warn(`File not found: ${normalizedPath}`);
          return null;
        }
        const content = await this.vault.adapter.read(normalizedPath);
        this.logger.debug(`Successfully read hidden file: ${normalizedPath}`);
        return content;
      }

      if (useCache) {
        const file = await this.getFile(normalizedPath);
        if (file) {
          const cached = this.fileCache.get(normalizedPath);
          if (cached && cached.mtime === file.stat.mtime) {
            this.logger.debug(`Cache hit for file: ${normalizedPath}`);
            return cached.content;
          }
        }
      }

      const file = await this.getFile(normalizedPath);
      if (!file) {
        this.logger.warn(`File not found: ${normalizedPath}`);
        return null;
      }

      const content = await this.vault.cachedRead(file);

      if (useCache) {
        this.fileCache.set(normalizedPath, {
          content,
          mtime: file.stat.mtime
        });
      }

      this.logger.debug(`Successfully read file: ${normalizedPath}`);
      return content;
    } catch (error) {
      this.logger.error(`Failed to read file ${path}`, error instanceof Error ? error : new Error(String(error)));
      return null;
    }
  }

  /**
   * Write file content with automatic directory creation
   * Uses adapter.write() for hidden files since Obsidian doesn't index them
   */
  async writeFile(path: string, content: string): Promise<boolean> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);

      // For hidden files, use adapter directly (Obsidian doesn't index hidden files)
      if (this.isHiddenPath(normalizedPath)) {
        // Ensure parent directory exists using adapter
        const parentPath = this.pathManager.getParentPath(normalizedPath);
        if (parentPath) {
          const parentExists = await this.vault.adapter.exists(parentPath);
          if (!parentExists) {
            await this.vault.adapter.mkdir(parentPath);
          }
        }
        await this.vault.adapter.write(normalizedPath, content);
        this.logger.debug(`Successfully wrote hidden file: ${normalizedPath}`);
        return true;
      }

      await this.pathManager.ensureParentExists(normalizedPath);

      const existingFile = await this.getFile(normalizedPath);
      if (existingFile) {
        await this.vault.modify(existingFile, content);
      } else {
        await this.vault.create(normalizedPath, content);
      }

      // Invalidate cache
      this.fileCache.delete(normalizedPath);

      this.logger.debug(`Successfully wrote file: ${normalizedPath}`);
      return true;
    } catch (error) {
      this.logger.error(`Failed to write file ${path}`, error instanceof Error ? error : new Error(String(error)));
      return false;
    }
  }

  /**
   * Create directory if it doesn't exist
   * Uses adapter.mkdir() for hidden directories since Obsidian doesn't index them
   */
  async ensureDirectory(path: string): Promise<boolean> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);

      // For hidden directories, use adapter directly
      if (this.isHiddenPath(normalizedPath)) {
        const exists = await this.vault.adapter.exists(normalizedPath);
        if (!exists) {
          await this.vault.adapter.mkdir(normalizedPath);
          this.logger.debug(`Created hidden directory: ${normalizedPath}`);
        }
        return true;
      }

      const existingFolder = await this.getFolder(normalizedPath);

      if (!existingFolder) {
        try {
          await this.vault.createFolder(normalizedPath);
          this.logger.debug(`Created directory: ${normalizedPath}`);
        } catch (createError) {
          // Ignore "Folder already exists" - can happen during startup before vault is fully indexed
          if (createError instanceof Error && !createError.message.includes('already exists')) {
            throw createError;
          }
        }
      }

      return true;
    } catch (error) {
      this.logger.error(`Failed to create directory ${path}`, error instanceof Error ? error : new Error(String(error)));
      return false;
    }
  }

  /**
   * Delete file
   */
  async deleteFile(path: string): Promise<boolean> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      const file = await this.getFile(normalizedPath);
      
      if (file) {
        await this.vault.delete(file);
        this.fileCache.delete(normalizedPath);
        this.logger.debug(`Deleted file: ${normalizedPath}`);
        return true;
      }
      
      this.logger.warn(`File not found for deletion: ${normalizedPath}`);
      return false;
    } catch (error) {
      this.logger.error(`Failed to delete file ${path}`, error instanceof Error ? error : new Error(String(error)));
      return false;
    }
  }

  /**
   * Delete folder
   */
  async deleteFolder(path: string): Promise<boolean> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      const folder = await this.getFolder(normalizedPath);
      
      if (folder) {
        await this.vault.delete(folder);
        this.logger.debug(`Deleted folder: ${normalizedPath}`);
        return true;
      }
      
      this.logger.warn(`Folder not found for deletion: ${normalizedPath}`);
      return false;
    } catch (error) {
      this.logger.error(`Failed to delete folder ${path}`, error instanceof Error ? error : new Error(String(error)));
      return false;
    }
  }

  /**
   * Get file/folder statistics
   */
  async getStats(path: string): Promise<FileStats | null> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      const stat = await this.vault.adapter.stat(normalizedPath);
      
      if (stat) {
        return {
          size: stat.size || 0,
          mtime: stat.mtime || 0,
          ctime: stat.ctime || 0,
          type: stat.type as 'file' | 'folder'
        };
      }
      
      return null;
    } catch (error) {
      this.logger.debug(`Failed to get stats for ${path}`, error);
      return null;
    }
  }

  /**
   * List directory contents
   */
  async listDirectory(path: string): Promise<{ files: string[]; folders: string[] }> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      const listing = await this.vault.adapter.list(normalizedPath);
      
      return {
        files: listing.files,
        folders: listing.folders
      };
    } catch (error) {
      this.logger.error(`Failed to list directory ${path}`, error instanceof Error ? error : new Error(String(error)));
      return { files: [], folders: [] };
    }
  }

  /**
   * Calculate directory size recursively
   */
  async calculateDirectorySize(path: string): Promise<number> {
    try {
      const normalizedPath = this.pathManager.normalizePath(path);
      let totalSize = 0;
      
      const listing = await this.vault.adapter.list(normalizedPath);
      
      // Calculate size of files
      for (const filePath of listing.files) {
        const stat = await this.getStats(filePath);
        if (stat) {
          totalSize += stat.size;
        }
      }
      
      // Recursively calculate size of subdirectories
      for (const folderPath of listing.folders) {
        totalSize += await this.calculateDirectorySize(folderPath);
      }
      
      return totalSize;
    } catch (error) {
      this.logger.error(`Failed to calculate directory size for ${path}`, error instanceof Error ? error : new Error(String(error)));
      return 0;
    }
  }

  /**
   * Batch read operations
   */
  async batchRead(paths: string[]): Promise<Map<string, string | null>> {
    const results = new Map<string, string | null>();
    
    // Process in parallel for better performance
    const promises = paths.map(async (path) => {
      const content = await this.readFile(path);
      results.set(path, content);
    });
    
    await Promise.all(promises);
    return results;
  }

  /**
   * Batch write operations
   */
  async batchWrite(operations: BatchWriteOperation[]): Promise<BatchWriteResult> {
    const success: string[] = [];
    const failed: string[] = [];
    
    // Process in sequence to avoid race conditions
    for (const operation of operations) {
      const result = await this.writeFile(operation.path, operation.content);
      if (result) {
        success.push(operation.path);
      } else {
        failed.push(operation.path);
      }
    }
    
    return { success, failed };
  }

  /**
   * Copy file
   */
  async copyFile(sourcePath: string, targetPath: string): Promise<boolean> {
    try {
      const content = await this.readFile(sourcePath, false);
      if (content === null) {
        this.logger.error(`Source file not found: ${sourcePath}`);
        return false;
      }
      
      return await this.writeFile(targetPath, content);
    } catch (error) {
      this.logger.error(`Failed to copy file from ${sourcePath} to ${targetPath}`, error instanceof Error ? error : new Error(String(error)));
      return false;
    }
  }

  /**
   * Move/rename file
   */
  async moveFile(sourcePath: string, targetPath: string): Promise<boolean> {
    try {
      const normalizedSource = this.pathManager.normalizePath(sourcePath);
      const normalizedTarget = this.pathManager.normalizePath(targetPath);
      
      const sourceFile = await this.getFile(normalizedSource);
      if (!sourceFile) {
        this.logger.error(`Source file not found: ${sourcePath}`);
        return false;
      }
      
      await this.vault.rename(sourceFile, normalizedTarget);
      this.fileCache.delete(normalizedSource);
      
      this.logger.debug(`Moved file from ${sourcePath} to ${targetPath}`);
      return true;
    } catch (error) {
      this.logger.error(`Failed to move file from ${sourcePath} to ${targetPath}`, error instanceof Error ? error : new Error(String(error)));
      return false;
    }
  }

  /**
   * Clear file cache
   */
  clearCache(): void {
    this.fileCache.clear();
    this.logger.debug('File cache cleared');
  }

  /**
   * Get cache statistics
   */
  getCacheStats(): { size: number; entries: number } {
    const entries = this.fileCache.size;
    let size = 0;
    
    for (const cached of this.fileCache.values()) {
      size += cached.content.length;
    }
    
    return { size, entries };
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    this.clearCache();
    this.logger.debug('VaultOperations cleaned up');
  }
}
```

## database/adapters/HybridStorageAdapter.ts

```typescript
/**
 * Location: src/database/adapters/HybridStorageAdapter.ts
 *
 * Hybrid Storage Adapter - Thin Facade Following SOLID Principles
 *
 * This adapter coordinates JSONL (source of truth) + SQLite (cache) by:
 * 1. Owning infrastructure (JSONLWriter, SQLiteCache, SyncCoordinator, QueryCache)
 * 2. Delegating all entity operations to focused repositories
 * 3. Managing lifecycle (initialize, close, sync)
 *
 * SOLID Compliance:
 * - S: Only orchestration/lifecycle, no business logic
 * - O: Extensible through new repositories
 * - L: Implements IStorageAdapter
 * - I: Clean interface segregation
 * - D: Depends on repository abstractions
 *
 * Related Files:
 * - src/database/repositories/* - Entity repositories
 * - src/database/services/* - Business services
 * - src/database/interfaces/IStorageAdapter.ts - Interface definition
 */

import { App } from 'obsidian';
import { IStorageAdapter, QueryOptions, ImportOptions } from '../interfaces/IStorageAdapter';
import { JSONLWriter } from '../storage/JSONLWriter';
import { SQLiteCacheManager } from '../storage/SQLiteCacheManager';
import { SyncCoordinator } from '../sync/SyncCoordinator';
import { QueryCache } from '../optimizations/QueryCache';
import { PaginatedResult, PaginationParams } from '../../types/pagination/PaginationTypes';
import {
  WorkspaceMetadata,
  SessionMetadata,
  StateMetadata,
  StateData,
  ConversationMetadata,
  MessageData,
  MemoryTraceData,
  ExportFilter,
  ExportData,
  SyncResult
} from '../../types/storage/HybridStorageTypes';
import { RepositoryDependencies } from '../repositories/base/BaseRepository';
import { LegacyMigrator } from '../migration/LegacyMigrator';

// Import all repositories
import { WorkspaceRepository } from '../repositories/WorkspaceRepository';
import { SessionRepository } from '../repositories/SessionRepository';
import { StateRepository } from '../repositories/StateRepository';
import { TraceRepository } from '../repositories/TraceRepository';
import { ConversationRepository } from '../repositories/ConversationRepository';
import { MessageRepository } from '../repositories/MessageRepository';
// Import services
import { ExportService } from '../services/ExportService';

/**
 * Configuration options for HybridStorageAdapter
 */
export interface HybridStorageAdapterOptions {
  /** Obsidian app instance */
  app: App;
  /** Base path for storage (default: '.nexus') */
  basePath?: string;
  /** Auto-sync on initialization (default: true) */
  autoSync?: boolean;
  /** Query cache TTL in ms (default: 60000) */
  cacheTTL?: number;
  /** Query cache max size (default: 500) */
  cacheMaxSize?: number;
}

/**
 * Hybrid Storage Adapter
 *
 * Thin facade that composes repositories and handles lifecycle.
 * Reduced from 1,696 lines to ~350 lines by delegating to repositories.
 */
export class HybridStorageAdapter implements IStorageAdapter {
  private app: App;
  private basePath: string;
  private initialized = false;
  private syncInterval?: NodeJS.Timeout;

  // Deferred initialization support
  private initPromise: Promise<void> | null = null;
  private initResolve: (() => void) | null = null;
  private initError: Error | null = null;

  // Infrastructure (owned by adapter)
  private jsonlWriter: JSONLWriter;
  private sqliteCache: SQLiteCacheManager;
  private syncCoordinator: SyncCoordinator;
  private queryCache: QueryCache;

  // Repositories (composed)
  private workspaceRepo!: WorkspaceRepository;
  private sessionRepo!: SessionRepository;
  private stateRepo!: StateRepository;
  private traceRepo!: TraceRepository;
  private conversationRepo!: ConversationRepository;
  private messageRepo!: MessageRepository;

  // Services
  private exportService!: ExportService;

  constructor(options: HybridStorageAdapterOptions) {
    this.app = options.app;
    this.basePath = options.basePath ?? '.nexus';

    // Initialize infrastructure
    this.jsonlWriter = new JSONLWriter({
      app: this.app,
      basePath: this.basePath
    });

    this.sqliteCache = new SQLiteCacheManager({
      app: this.app,
      dbPath: `${this.basePath}/cache.db`
    });

    this.syncCoordinator = new SyncCoordinator(
      this.jsonlWriter,
      this.sqliteCache
    );

    this.queryCache = new QueryCache({
      defaultTTL: options.cacheTTL ?? 60000,
      maxSize: options.cacheMaxSize ?? 500
    });

    // Create repository dependencies
    const deps: RepositoryDependencies = {
      jsonlWriter: this.jsonlWriter,
      sqliteCache: this.sqliteCache,
      queryCache: this.queryCache
    };

    // Initialize all repositories
    this.workspaceRepo = new WorkspaceRepository(deps);
    this.sessionRepo = new SessionRepository(deps);
    this.stateRepo = new StateRepository(deps);
    this.traceRepo = new TraceRepository(deps);
    this.conversationRepo = new ConversationRepository(deps);
    this.messageRepo = new MessageRepository(deps);

    // Initialize services
    this.exportService = new ExportService({
      app: this.app,
      conversationRepo: this.conversationRepo,
      messageRepo: this.messageRepo,
      workspaceRepo: this.workspaceRepo,
      sessionRepo: this.sessionRepo,
      stateRepo: this.stateRepo,
      traceRepo: this.traceRepo
    });
  }

  // ============================================================================
  // Lifecycle Management
  // ============================================================================

  /**
   * Initialize the storage adapter.
   * By default, starts initialization in background and returns immediately.
   * Use waitForReady() to wait for completion if needed.
   *
   * @param blocking - If true, waits for initialization to complete before returning
   */
  async initialize(blocking = false): Promise<void> {
    if (this.initialized) {
      return;
    }

    // If already initializing, optionally wait for it
    if (this.initPromise) {
      if (blocking) {
        await this.initPromise;
      }
      return;
    }

    // Create the promise that will resolve when initialization completes
    this.initPromise = new Promise<void>((resolve) => {
      this.initResolve = resolve;
    });

    // Start initialization in background
    this.performInitialization().catch(error => {
      this.initError = error;
      console.error('[HybridStorageAdapter] Background initialization failed:', error);
    });

    // If blocking mode, wait for completion
    if (blocking) {
      await this.initPromise;
      if (this.initError) {
        throw this.initError;
      }
    }
  }

  /**
   * Perform the actual initialization work
   */
  private async performInitialization(): Promise<void> {
    const startTime = Date.now();

    try {
      // 1. Initialize SQLite cache
      await this.sqliteCache.initialize();

      // 2. Ensure JSONL directories exist
      await this.jsonlWriter.ensureDirectory('workspaces');
      await this.jsonlWriter.ensureDirectory('conversations');

      const migrator = new LegacyMigrator(this.app);
      const migrationNeeded = await migrator.isMigrationNeeded();

      if (migrationNeeded) {
        await migrator.migrate();
      }

      // 4. Perform initial sync (rebuild cache from JSONL)
      const syncState = await this.sqliteCache.getSyncState(this.jsonlWriter.getDeviceId());
      if (!syncState || migrationNeeded) {
        try {
          await this.syncCoordinator.fullRebuild();
        } catch (rebuildError) {
          console.error('[HybridStorageAdapter] Full rebuild failed:', rebuildError);
          // Continue anyway - partial data is better than no data
        }
      } else {
        try {
          await this.syncCoordinator.sync();
        } catch (syncError) {
          console.error('[HybridStorageAdapter] Incremental sync failed:', syncError);
        }
      }

      this.initialized = true;

      // Resolve the ready promise
      if (this.initResolve) {
        this.initResolve();
      }

    } catch (error) {
      console.error('[HybridStorageAdapter] Initialization failed:', error);
      this.initError = error as Error;
      if (this.initResolve) {
        this.initResolve(); // Resolve even on error so waiters don't hang
      }
      throw error;
    }
  }

  /**
   * Check if the adapter is ready for use
   */
  isReady(): boolean {
    return this.initialized && !this.initError;
  }

  /**
   * Wait for initialization to complete
   * @returns true if initialization succeeded, false if it failed
   */
  async waitForReady(): Promise<boolean> {
    if (this.initialized) {
      return !this.initError;
    }
    if (this.initPromise) {
      await this.initPromise;
    }
    return this.initialized && !this.initError;
  }

  /**
   * Get initialization error if any
   */
  getInitError(): Error | null {
    return this.initError;
  }

  /**
   * Get the underlying SQLite cache manager
   * Used by EmbeddingManager for vector storage
   */
  get cache(): SQLiteCacheManager {
    return this.sqliteCache;
  }

  async close(): Promise<void> {
    if (!this.initialized) {
      return;
    }

    try {
      // Stop sync timer
      if (this.syncInterval) {
        clearInterval(this.syncInterval);
        this.syncInterval = undefined;
      }

      // Clear query cache
      this.queryCache.clear();

      // Close SQLite
      await this.sqliteCache.close();

      this.initialized = false;

    } catch (error) {
      console.error('[HybridStorageAdapter] Error during close:', error);
      throw error;
    }
  }

  async sync(): Promise<SyncResult> {
    try {
      const result = await this.syncCoordinator.sync();

      // Invalidate all query cache on sync
      this.queryCache.clear();

      return result;

    } catch (error) {
      console.error('[HybridStorageAdapter] Sync failed:', error);
      throw error;
    }
  }

  // ============================================================================
  // Workspace Operations - Delegate to WorkspaceRepository
  // ============================================================================

  getWorkspace = async (id: string): Promise<WorkspaceMetadata | null> => {
    await this.ensureInitialized();
    return this.workspaceRepo.getById(id);
  };

  getWorkspaces = async (options?: QueryOptions): Promise<PaginatedResult<WorkspaceMetadata>> => {
    await this.ensureInitialized();
    return this.workspaceRepo.getWorkspaces(options);
  };

  createWorkspace = async (workspace: Omit<WorkspaceMetadata, 'id'> & { id?: string }): Promise<string> => {
    await this.ensureInitialized();
    return this.workspaceRepo.create(workspace);
  };

  updateWorkspace = async (id: string, updates: Partial<WorkspaceMetadata>): Promise<void> => {
    await this.ensureInitialized();
    return this.workspaceRepo.update(id, updates);
  };

  deleteWorkspace = async (id: string): Promise<void> => {
    await this.ensureInitialized();
    return this.workspaceRepo.delete(id);
  };

  searchWorkspaces = async (query: string): Promise<WorkspaceMetadata[]> => {
    await this.ensureInitialized();
    return this.workspaceRepo.search(query);
  };

  // ============================================================================
  // Session Operations - Delegate to SessionRepository
  // ============================================================================

  getSession = async (id: string): Promise<SessionMetadata | null> => {
    await this.ensureInitialized();
    return this.sessionRepo.getById(id);
  };

  getSessions = async (workspaceId: string, options?: PaginationParams): Promise<PaginatedResult<SessionMetadata>> => {
    await this.ensureInitialized();
    return this.sessionRepo.getByWorkspaceId(workspaceId, options);
  };

  createSession = async (workspaceId: string, session: Omit<SessionMetadata, 'id' | 'workspaceId'>): Promise<string> => {
    await this.ensureInitialized();
    return this.sessionRepo.create({ ...session, workspaceId });
  };

  updateSession = async (workspaceId: string, sessionId: string, updates: Partial<SessionMetadata>): Promise<void> => {
    await this.ensureInitialized();
    // Extract fields that are valid for UpdateSessionData (includes required workspaceId)
    const { name, description, endTime, isActive } = updates;
    return this.sessionRepo.update(sessionId, { name, description, endTime, isActive, workspaceId });
  };

  deleteSession = async (sessionId: string): Promise<void> => {
    await this.ensureInitialized();
    return this.sessionRepo.delete(sessionId);
  };

  // ============================================================================
  // State Operations - Delegate to StateRepository
  // ============================================================================

  getState = async (id: string): Promise<StateData | null> => {
    await this.ensureInitialized();
    return this.stateRepo.getStateData(id);
  };

  getStates = async (
    workspaceId: string,
    sessionId?: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<StateMetadata>> => {
    await this.ensureInitialized();
    return this.stateRepo.getStates(workspaceId, sessionId, options);
  };

  saveState = async (
    workspaceId: string,
    sessionId: string,
    state: Omit<StateData, 'id' | 'workspaceId' | 'sessionId'>
  ): Promise<string> => {
    await this.ensureInitialized();
    return this.stateRepo.saveState(workspaceId, sessionId, state);
  };

  deleteState = async (id: string): Promise<void> => {
    await this.ensureInitialized();
    return this.stateRepo.delete(id);
  };

  countStates = async (workspaceId: string, sessionId?: string): Promise<number> => {
    await this.ensureInitialized();
    return this.stateRepo.countStates(workspaceId, sessionId);
  };

  // ============================================================================
  // Trace Operations - Delegate to TraceRepository
  // ============================================================================

  getTraces = async (
    workspaceId: string,
    sessionId?: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<MemoryTraceData>> => {
    await this.ensureInitialized();
    return this.traceRepo.getTraces(workspaceId, sessionId, options);
  };

  addTrace = async (
    workspaceId: string,
    sessionId: string,
    trace: Omit<MemoryTraceData, 'id' | 'workspaceId' | 'sessionId'>
  ): Promise<string> => {
    await this.ensureInitialized();
    return this.traceRepo.addTrace(workspaceId, sessionId, trace);
  };

  searchTraces = async (
    workspaceId: string,
    query: string,
    sessionId?: string
  ): Promise<MemoryTraceData[]> => {
    await this.ensureInitialized();
    // Repository returns paginated, but interface expects array
    const result = await this.traceRepo.searchTraces(workspaceId, query, sessionId);
    return result.items;
  };

  // ============================================================================
  // Conversation Operations - Delegate to ConversationRepository
  // ============================================================================

  getConversation = async (id: string): Promise<ConversationMetadata | null> => {
    await this.ensureInitialized();
    return this.conversationRepo.getById(id);
  };

  getConversations = async (options?: QueryOptions): Promise<PaginatedResult<ConversationMetadata>> => {
    await this.ensureInitialized();
    return this.conversationRepo.getConversations(options);
  };

  createConversation = async (params: Omit<ConversationMetadata, 'id' | 'messageCount'>): Promise<string> => {
    await this.ensureInitialized();
    return this.conversationRepo.create(params);
  };

  updateConversation = async (id: string, updates: Partial<ConversationMetadata>): Promise<void> => {
    await this.ensureInitialized();
    return this.conversationRepo.update(id, updates);
  };

  deleteConversation = async (id: string): Promise<void> => {
    await this.ensureInitialized();

    // Cascade delete: find and delete any child branch conversations
    const branches = await this.conversationRepo.getConversations({
      pageSize: 100,
      includeBranches: true
    });

    for (const branch of branches.items) {
      if (branch.metadata?.parentConversationId === id) {
        // Recursively delete child branches (they may have their own branches)
        await this.deleteConversation(branch.id);
      }
    }

    // Now delete the conversation itself
    return this.conversationRepo.delete(id);
  };

  searchConversations = async (query: string): Promise<ConversationMetadata[]> => {
    await this.ensureInitialized();
    return this.conversationRepo.search(query);
  };

  // ============================================================================
  // Message Operations - Delegate to MessageRepository
  // ============================================================================

  getMessages = async (
    conversationId: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<MessageData>> => {
    await this.ensureInitialized();
    return this.messageRepo.getMessages(conversationId, options);
  };

  addMessage = async (
    conversationId: string,
    message: Omit<MessageData, 'id' | 'conversationId' | 'sequenceNumber'> & { id?: string }
  ): Promise<string> => {
    await this.ensureInitialized();
    return this.messageRepo.addMessage(conversationId, message);
  };

  updateMessage = async (
    _conversationId: string,
    messageId: string,
    updates: Partial<MessageData>
  ): Promise<void> => {
    await this.ensureInitialized();
    return this.messageRepo.update(messageId, updates);
  };

  deleteMessage = async (conversationId: string, messageId: string): Promise<void> => {
    await this.ensureInitialized();

    // Cascade delete: find and delete any branch conversations tied to this message
    const branches = await this.conversationRepo.getConversations({
      pageSize: 100,
      includeBranches: true
    });

    for (const branch of branches.items) {
      if (branch.metadata?.parentMessageId === messageId) {
        await this.deleteConversation(branch.id);
      }
    }

    // Now delete the message itself
    return this.messageRepo.deleteMessage(conversationId, messageId);
  };

  // ============================================================================
  // Export/Import Operations - Delegate to ExportService
  // ============================================================================

  exportConversationsForFineTuning = async (filter?: ExportFilter): Promise<string> => {
    await this.ensureInitialized();
    return this.exportService.exportForFineTuning(filter);
  };

  exportAllData = async (): Promise<ExportData> => {
    await this.ensureInitialized();
    return this.exportService.exportAllData();
  };

  async importData(_data: ExportData, _options?: ImportOptions): Promise<void> {
    await this.ensureInitialized();
    // TODO: Implement importData in ExportService
    throw new Error('importData not yet implemented');
  }

  // ============================================================================
  // Utilities
  // ============================================================================

  /**
   * Ensure the adapter is initialized before use.
   * If initialization is in progress, waits for it to complete.
   */
  private async ensureInitialized(): Promise<void> {
    if (this.initialized) {
      return;
    }

    // If initialization is in progress, wait for it
    if (this.initPromise) {
      await this.initPromise;
      if (this.initError) {
        throw this.initError;
      }
      if (!this.initialized) {
        throw new Error('HybridStorageAdapter initialization failed.');
      }
      return;
    }

    throw new Error('HybridStorageAdapter not initialized. Call initialize() first.');
  }
}

```

## database/adapters/index.ts

```typescript
/**
 * Location: src/database/adapters/index.ts
 *
 * Storage Adapter Exports
 *
 * Provides the main storage adapter implementation for the hybrid JSONL + SQLite
 * storage architecture.
 */

export { HybridStorageAdapter } from './HybridStorageAdapter';
export type { HybridStorageAdapterOptions } from './HybridStorageAdapter';

```

## database/interfaces/index.ts

```typescript
/**
 * Location: src/database/interfaces/index.ts
 *
 * Database Interfaces - Central export point
 *
 * Exports all database interface types for easy importing.
 */

export * from './StorageEvents';
export * from './IStorageBackend';
export * from './IStorageAdapter';

```

## database/interfaces/IStorageAdapter.ts

```typescript
/**
 * Storage Adapter Interface
 *
 * Location: src/database/interfaces/IStorageAdapter.ts
 * Purpose: Main storage interface that the application uses for all data operations
 * Used by: Services throughout the application for data persistence and retrieval
 *
 * This is the primary interface for data access in the hybrid storage system.
 * It abstracts away the complexity of:
 * - JSONL event sourcing (source of truth)
 * - SQLite caching (fast queries and pagination)
 * - Multi-device synchronization
 *
 * The hybrid approach provides:
 * - Sync-friendly: JSONL files work with Obsidian Sync
 * - Fast queries: SQLite cache enables efficient searching and pagination
 * - Conflict resolution: Event sourcing provides clear merge semantics
 * - Portability: JSONL files are human-readable and easy to migrate
 *
 * Relationships:
 * - Implemented by: HybridStorageAdapter
 * - Uses: IStorageBackend for SQLite operations
 * - Uses: JSONLWriter/JSONLReader for event sourcing
 */

import { PaginatedResult, PaginationParams } from '../../types/pagination/PaginationTypes';
import {
  WorkspaceMetadata,
  SessionMetadata,
  StateMetadata,
  StateData,
  ConversationMetadata,
  MessageData,
  MemoryTraceData,
  ExportFilter,
  ExportData,
  SyncResult
} from '../../types/storage/HybridStorageTypes';
/**
 * Extended query options for flexible data retrieval
 */
export interface QueryOptions extends PaginationParams {
  /** Field to sort by */
  sortBy?: string;

  /** Sort direction */
  sortOrder?: 'asc' | 'desc';

  /** Filters to apply (key-value pairs) */
  filter?: Record<string, any>;

  /** Full-text search query */
  search?: string;

  /** Include branch conversations (default: false - branches are hidden from list) */
  includeBranches?: boolean;
}

/**
 * Main storage adapter interface
 *
 * This is the primary interface that all application code should use
 * for data persistence and retrieval. It provides a clean, high-level
 * API that hides the complexity of the hybrid storage architecture.
 */
export interface IStorageAdapter {
  // ============================================================================
  // Lifecycle Management
  // ============================================================================

  /**
   * Initialize the storage adapter
   *
   * This should:
   * 1. Initialize the SQLite backend
   * 2. Load sync state from disk
   * 3. Perform initial sync if needed
   * 4. Set up file watchers for JSONL files
   *
   * @throws {Error} If initialization fails
   */
  initialize(): Promise<void>;

  /**
   * Close the storage adapter and release resources
   *
   * This should:
   * 1. Save sync state
   * 2. Close the SQLite backend
   * 3. Stop file watchers
   */
  close(): Promise<void>;

  /**
   * Synchronize SQLite cache with JSONL source of truth
   *
   * This should:
   * 1. Read new events from JSONL files
   * 2. Apply events to SQLite cache
   * 3. Update sync state
   * 4. Handle any conflicts or errors
   *
   * @returns Sync result with statistics and errors
   */
  sync(): Promise<SyncResult>;

  // ============================================================================
  // Workspace Operations
  // ============================================================================

  /**
   * Get a single workspace by ID
   *
   * @param id - Workspace ID
   * @returns Workspace metadata, or null if not found
   */
  getWorkspace(id: string): Promise<WorkspaceMetadata | null>;

  /**
   * Get all workspaces with pagination and filtering
   *
   * @param options - Query options (pagination, sorting, filtering)
   * @returns Paginated list of workspaces
   */
  getWorkspaces(options?: QueryOptions): Promise<PaginatedResult<WorkspaceMetadata>>;

  /**
   * Create a new workspace
   *
   * This should:
   * 1. Use provided ID or generate a new workspace ID
   * 2. Write create event to JSONL
   * 3. Update SQLite cache
   *
   * @param workspace - Workspace metadata (id optional - will be generated if not provided)
   * @returns ID of the created workspace
   */
  createWorkspace(workspace: Omit<WorkspaceMetadata, 'id'> & { id?: string }): Promise<string>;

  /**
   * Update an existing workspace
   *
   * This should:
   * 1. Write update event to JSONL
   * 2. Update SQLite cache
   *
   * @param id - Workspace ID
   * @param updates - Partial workspace metadata to update
   */
  updateWorkspace(id: string, updates: Partial<WorkspaceMetadata>): Promise<void>;

  /**
   * Delete a workspace
   *
   * This should:
   * 1. Write delete event to JSONL
   * 2. Remove from SQLite cache
   * 3. Cascade delete sessions, states, and traces
   *
   * @param id - Workspace ID
   */
  deleteWorkspace(id: string): Promise<void>;

  /**
   * Search workspaces by name or description
   *
   * @param query - Search query
   * @returns Array of matching workspaces
   */
  searchWorkspaces(query: string): Promise<WorkspaceMetadata[]>;

  // ============================================================================
  // Session Operations
  // ============================================================================

  /**
   * Get sessions for a workspace
   *
   * @param workspaceId - Workspace ID
   * @param options - Pagination options
   * @returns Paginated list of sessions
   */
  getSessions(
    workspaceId: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<SessionMetadata>>;

  /**
   * Get a single session by ID
   *
   * @param id - Session ID
   * @returns Session metadata, or null if not found
   */
  getSession(id: string): Promise<SessionMetadata | null>;

  /**
   * Create a new session
   *
   * @param workspaceId - Parent workspace ID
   * @param session - Session metadata (without id)
   * @returns ID of the created session
   */
  createSession(
    workspaceId: string,
    session: Omit<SessionMetadata, 'id' | 'workspaceId'>
  ): Promise<string>;

  /**
   * Update an existing session
   *
   * @param workspaceId - Parent workspace ID
   * @param sessionId - Session ID
   * @param updates - Partial session metadata to update
   */
  updateSession(
    workspaceId: string,
    sessionId: string,
    updates: Partial<SessionMetadata>
  ): Promise<void>;

  /**
   * Delete a session
   *
   * @param sessionId - Session ID
   */
  deleteSession(sessionId: string): Promise<void>;

  // ============================================================================
  // State Operations
  // ============================================================================

  /**
   * Get states for a workspace or session
   *
   * @param workspaceId - Workspace ID
   * @param sessionId - Optional session ID to filter by
   * @param options - Pagination options
   * @returns Paginated list of state metadata
   */
  getStates(
    workspaceId: string,
    sessionId?: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<StateMetadata>>;

  /**
   * Get a single state by ID (includes full content)
   *
   * @param id - State ID
   * @returns Full state data, or null if not found
   */
  getState(id: string): Promise<StateData | null>;

  /**
   * Save a new state or update existing
   *
   * @param workspaceId - Parent workspace ID
   * @param sessionId - Parent session ID
   * @param state - State data (with or without id)
   */
  saveState(
    workspaceId: string,
    sessionId: string,
    state: Omit<StateData, 'id' | 'workspaceId' | 'sessionId'>
  ): Promise<string>;

  /**
   * Delete a state
   *
   * @param id - State ID
   */
  deleteState(id: string): Promise<void>;

  /**
   * Count states for a workspace or session
   *
   * @param workspaceId - Workspace ID
   * @param sessionId - Optional session ID to filter by
   * @returns Number of states
   */
  countStates(workspaceId: string, sessionId?: string): Promise<number>;

  // ============================================================================
  // Memory Trace Operations
  // ============================================================================

  /**
   * Get memory traces for a workspace or session
   *
   * @param workspaceId - Workspace ID
   * @param sessionId - Optional session ID to filter by
   * @param options - Pagination options
   * @returns Paginated list of memory traces
   */
  getTraces(
    workspaceId: string,
    sessionId?: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<MemoryTraceData>>;

  /**
   * Add a new memory trace
   *
   * @param workspaceId - Parent workspace ID
   * @param sessionId - Parent session ID
   * @param trace - Trace data (without id)
   */
  addTrace(
    workspaceId: string,
    sessionId: string,
    trace: Omit<MemoryTraceData, 'id' | 'workspaceId' | 'sessionId'>
  ): Promise<string>;

  /**
   * Search memory traces by content
   *
   * @param workspaceId - Workspace ID to search within
   * @param query - Search query
   * @param sessionId - Optional session ID to filter by
   * @returns Array of matching traces
   */
  searchTraces(
    workspaceId: string,
    query: string,
    sessionId?: string
  ): Promise<MemoryTraceData[]>;

  // ============================================================================
  // Conversation Operations
  // ============================================================================

  /**
   * Get a single conversation by ID
   *
   * @param id - Conversation ID
   * @returns Conversation metadata, or null if not found
   */
  getConversation(id: string): Promise<ConversationMetadata | null>;

  /**
   * Get all conversations with pagination and filtering
   *
   * @param options - Query options (pagination, sorting, filtering)
   * @returns Paginated list of conversations
   */
  getConversations(options?: QueryOptions): Promise<PaginatedResult<ConversationMetadata>>;

  /**
   * Create a new conversation
   *
   * @param params - Conversation metadata (without id)
   * @returns ID of the created conversation
   */
  createConversation(params: Omit<ConversationMetadata, 'id' | 'messageCount'>): Promise<string>;

  /**
   * Update an existing conversation
   *
   * @param id - Conversation ID
   * @param updates - Partial conversation metadata to update
   */
  updateConversation(id: string, updates: Partial<ConversationMetadata>): Promise<void>;

  /**
   * Delete a conversation and all its messages
   *
   * @param id - Conversation ID
   */
  deleteConversation(id: string): Promise<void>;

  /**
   * Search conversations by title or content
   *
   * @param query - Search query
   * @returns Array of matching conversations
   */
  searchConversations(query: string): Promise<ConversationMetadata[]>;

  // ============================================================================
  // Message Operations
  // ============================================================================

  /**
   * Get messages for a conversation
   *
   * @param conversationId - Conversation ID
   * @param options - Pagination options
   * @returns Paginated list of messages (ordered by sequence number)
   */
  getMessages(
    conversationId: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<MessageData>>;

  /**
   * Add a new message to a conversation
   *
   * @param conversationId - Parent conversation ID
   * @param message - Message data (without id, conversationId, sequenceNumber)
   */
  addMessage(
    conversationId: string,
    message: Omit<MessageData, 'id' | 'conversationId' | 'sequenceNumber'> & { id?: string }
  ): Promise<string>;

  /**
   * Update an existing message
   *
   * @param conversationId - Parent conversation ID
   * @param messageId - Message ID
   * @param updates - Partial message data to update
   */
  updateMessage(
    conversationId: string,
    messageId: string,
    updates: Partial<MessageData>
  ): Promise<void>;

  /**
   * Delete a message
   *
   * @param conversationId - Parent conversation ID
   * @param messageId - Message ID
   */
  deleteMessage(conversationId: string, messageId: string): Promise<void>;

  // ============================================================================
  // Export Operations
  // ============================================================================

  /**
   * Export conversations in OpenAI fine-tuning format
   *
   * This creates a JSONL file where each line is a complete conversation
   * in the format expected by OpenAI's fine-tuning API:
   * {"messages": [{"role": "system", "content": "..."}, ...]}
   *
   * @param filter - Optional filter for which conversations to export
   * @returns Path to the exported JSONL file
   */
  exportConversationsForFineTuning(filter?: ExportFilter): Promise<string>;

  /**
   * Export all data for backup or migration
   *
   * @returns Complete export data structure
   */
  exportAllData(): Promise<ExportData>;

  /**
   * Import data from an export
   *
   * @param data - Export data to import
   * @param options - Import options (merge vs replace)
   */
  importData(data: ExportData, options?: ImportOptions): Promise<void>;

  // ============================================================================
  // Repository Access (for advanced operations)
  // ============================================================================

}

/**
 * Import options for data import operations
 */
export interface ImportOptions {
  /** Whether to merge with existing data or replace */
  mode: 'merge' | 'replace';

  /** Whether to skip conflicts (keep existing) or overwrite */
  conflictResolution: 'skip' | 'overwrite';

  /** Optional workspace mapping for imported data */
  workspaceMapping?: Record<string, string>;
}

```

## database/interfaces/IStorageBackend.ts

```typescript
/**
 * Storage Backend Interface
 *
 * Location: src/database/interfaces/IStorageBackend.ts
 * Purpose: Pluggable storage backend interface for different database implementations
 * Used by: HybridStorageAdapter to interact with SQLite, in-memory, or other backends
 *
 * This interface abstracts away the specific database implementation, allowing
 * for different backends:
 * - SQLite (better-sqlite3) for production
 * - sql.js (WASM SQLite) for browser/mobile
 * - In-memory for testing
 *
 * Relationships:
 * - Implemented by: SQLiteBackend, SqlJsBackend, InMemoryBackend
 * - Used by: HybridStorageAdapter
 */

/**
 * Result of a database write operation
 */
export interface RunResult {
  /** Number of rows affected by the operation */
  changes: number;

  /** Row ID of the last inserted row (for INSERT operations) */
  lastInsertRowid: number;
}

/**
 * Pluggable storage backend interface
 *
 * Provides a common interface for different database implementations.
 */
export interface IStorageBackend {
  // ============================================================================
  // Lifecycle Management
  // ============================================================================

  /**
   * Initialize the database connection and schema
   *
   * This should:
   * 1. Open/create the database file (or memory database)
   * 2. Run schema migrations if needed
   * 3. Set up any necessary indexes
   * 4. Configure database settings (WAL mode, foreign keys, etc.)
   *
   * @throws {Error} If initialization fails
   */
  initialize(): Promise<void>;

  /**
   * Close the database connection
   *
   * This should:
   * 1. Flush any pending writes
   * 2. Close the database connection
   * 3. Release any resources
   *
   * @throws {Error} If closing fails
   */
  close(): Promise<void>;

  /**
   * Check if the database is currently open and ready
   */
  isOpen(): boolean;

  // ============================================================================
  // Query Operations
  // ============================================================================

  /**
   * Execute a SELECT query and return all matching rows
   *
   * @template T - The expected shape of the result rows
   * @param sql - SQL query string with optional placeholders (?)
   * @param params - Optional parameters to bind to placeholders
   * @returns Array of result rows (empty array if no matches)
   *
   * @example
   * const users = await backend.query<User>(
   *   'SELECT * FROM users WHERE age > ?',
   *   [18]
   * );
   */
  query<T = any>(sql: string, params?: any[]): Promise<T[]>;

  /**
   * Execute a SELECT query and return the first matching row
   *
   * @template T - The expected shape of the result row
   * @param sql - SQL query string with optional placeholders (?)
   * @param params - Optional parameters to bind to placeholders
   * @returns First matching row, or null if no matches
   *
   * @example
   * const user = await backend.queryOne<User>(
   *   'SELECT * FROM users WHERE id = ?',
   *   [userId]
   * );
   */
  queryOne<T = any>(sql: string, params?: any[]): Promise<T | null>;

  /**
   * Execute an INSERT, UPDATE, or DELETE query
   *
   * @param sql - SQL query string with optional placeholders (?)
   * @param params - Optional parameters to bind to placeholders
   * @returns Result with number of changes and last insert rowid
   *
   * @example
   * const result = await backend.run(
   *   'INSERT INTO users (name, age) VALUES (?, ?)',
   *   ['Alice', 30]
   * );
   * console.log('Inserted user with ID:', result.lastInsertRowid);
   */
  run(sql: string, params?: any[]): Promise<RunResult>;

  // ============================================================================
  // Transaction Support
  // ============================================================================

  /**
   * Begin a new transaction
   *
   * All subsequent operations will be part of this transaction until
   * commit() or rollback() is called.
   *
   * @throws {Error} If a transaction is already active
   */
  beginTransaction(): Promise<void>;

  /**
   * Commit the current transaction
   *
   * Makes all changes since beginTransaction() permanent.
   *
   * @throws {Error} If no transaction is active
   */
  commit(): Promise<void>;

  /**
   * Rollback the current transaction
   *
   * Discards all changes since beginTransaction().
   *
   * @throws {Error} If no transaction is active
   */
  rollback(): Promise<void>;

  /**
   * Execute a function within a transaction
   *
   * Automatically handles begin, commit, and rollback.
   * If the function throws an error, the transaction is rolled back.
   *
   * @template T - Return type of the function
   * @param fn - Function to execute within transaction
   * @returns Result of the function
   *
   * @example
   * await backend.transaction(async () => {
   *   await backend.run('INSERT INTO users ...');
   *   await backend.run('INSERT INTO profiles ...');
   * });
   */
  transaction<T>(fn: () => Promise<T>): Promise<T>;

  // ============================================================================
  // Schema Management
  // ============================================================================

  /**
   * Execute raw SQL statements (for schema creation, migrations, etc.)
   *
   * This can execute multiple statements separated by semicolons.
   * Use this for CREATE TABLE, ALTER TABLE, CREATE INDEX, etc.
   *
   * WARNING: This does not use parameterized queries. Never use user input here.
   *
   * @param sql - SQL statements to execute
   *
   * @example
   * await backend.exec(`
   *   CREATE TABLE IF NOT EXISTS users (
   *     id INTEGER PRIMARY KEY,
   *     name TEXT NOT NULL
   *   );
   *   CREATE INDEX IF NOT EXISTS idx_users_name ON users(name);
   * `);
   */
  exec(sql: string): Promise<void>;

  // ============================================================================
  // Persistence (for in-memory and sql.js backends)
  // ============================================================================

  /**
   * Save database to disk
   *
   * For file-based backends (better-sqlite3), this is a no-op.
   * For in-memory backends (sql.js), this exports the database to a file.
   *
   * @throws {Error} If save fails
   */
  save(): Promise<void>;

  /**
   * Load database from disk
   *
   * For file-based backends (better-sqlite3), this is handled in initialize().
   * For in-memory backends (sql.js), this imports the database from a file.
   *
   * @throws {Error} If load fails
   */
  load?(): Promise<void>;

  // ============================================================================
  // Utilities
  // ============================================================================

  /**
   * Get the path to the database file (if applicable)
   *
   * @returns Database file path, or null for in-memory databases
   */
  getDatabasePath(): string | null;

  /**
   * Vacuum the database to reclaim space
   *
   * This rebuilds the database file, removing deleted data and
   * defragmenting the file.
   */
  vacuum(): Promise<void>;

  /**
   * Get database statistics
   *
   * @returns Object with database statistics (size, table counts, etc.)
   */
  getStats(): Promise<DatabaseStats>;
}

/**
 * Database statistics
 */
export interface DatabaseStats {
  /** Database file size in bytes (0 for in-memory) */
  fileSize: number;

  /** Number of tables */
  tableCount: number;

  /** Total number of rows across all tables */
  totalRows: number;

  /** Map of table name to row count */
  tableCounts: Record<string, number>;

  /** Whether the database is using WAL mode */
  walMode: boolean;
}

```

## database/interfaces/StorageEvents.ts

```typescript
/**
 * Location: src/database/interfaces/StorageEvents.ts
 *
 * Storage Event Type Definitions
 *
 * This file defines the event types for the hybrid storage system's append-only JSONL files.
 * Each event represents an immutable operation with deviceId and timestamp for sync safety.
 *
 * Design Principles:
 * - All events extend BaseStorageEvent with id, type, deviceId, timestamp
 * - Events are append-only and never modified after creation
 * - DeviceId tracks which device created the event (for conflict-free sync)
 * - Conversations use OpenAI fine-tuning format for compatibility
 *
 * Related Files:
 * - src/database/storage/JSONLWriter.ts - JSONL file operations
 * - src/database/types/workspace/WorkspaceTypes.ts - Workspace data structures
 * - src/database/types/session/SessionTypes.ts - Session data structures
 * - src/types/chat/ChatTypes.ts - Conversation message structures
 */

// ============================================================================
// Base Event Interface
// ============================================================================

/**
 * Base storage event with common fields for all event types
 */
export interface BaseStorageEvent {
  /**
   * Unique event identifier (UUID v4)
   */
  id: string;

  /**
   * Event type discriminator
   */
  type: string;

  /**
   * Device ID that created this event (for sync conflict resolution)
   */
  deviceId: string;

  /**
   * Unix timestamp (milliseconds) when event was created
   */
  timestamp: number;
}

// ============================================================================
// Workspace Events
// ============================================================================

/**
 * Event: Workspace created
 *
 * Records the creation of a new workspace with initial metadata.
 */
export interface WorkspaceCreatedEvent extends BaseStorageEvent {
  type: 'workspace_created';
  data: {
    /** Unique workspace identifier */
    id: string;
    /** Display name */
    name: string;
    /** Optional description */
    description?: string;
    /** Root folder path in vault */
    rootFolder: string;
    /** Creation timestamp */
    created: number;
    /** Whether this workspace is active (defaults to true) */
    isActive?: boolean;
    /** Optional dedicated agent ID */
    dedicatedAgentId?: string;
    /** JSON-serialized workspace context */
    contextJson?: string;
  };
}

/**
 * Event: Workspace updated
 *
 * Records updates to workspace metadata. Only changed fields are included.
 */
export interface WorkspaceUpdatedEvent extends BaseStorageEvent {
  type: 'workspace_updated';
  /** Target workspace ID */
  workspaceId: string;
  /** Partial update data (only changed fields) */
  data: Partial<{
    name: string;
    description: string;
    rootFolder: string;
    lastAccessed: number;
    isActive: boolean;
    dedicatedAgentId: string;
    contextJson: string;
  }>;
}

/**
 * Event: Workspace deleted
 *
 * Marks a workspace as deleted (soft delete).
 */
export interface WorkspaceDeletedEvent extends BaseStorageEvent {
  type: 'workspace_deleted';
  /** Target workspace ID */
  workspaceId: string;
}

// ============================================================================
// Session Events
// ============================================================================

/**
 * Event: Session created
 *
 * Records the creation of a new session within a workspace.
 */
export interface SessionCreatedEvent extends BaseStorageEvent {
  type: 'session_created';
  /** Parent workspace ID */
  workspaceId: string;
  data: {
    /** Unique session identifier */
    id: string;
    /** Session name */
    name: string;
    /** Optional description */
    description?: string;
    /** Session start timestamp */
    startTime: number;
  };
}

/**
 * Event: Session updated
 *
 * Records updates to session metadata.
 */
export interface SessionUpdatedEvent extends BaseStorageEvent {
  type: 'session_updated';
  /** Parent workspace ID */
  workspaceId: string;
  /** Target session ID */
  sessionId: string;
  /** Partial update data (only changed fields) */
  data: Partial<{
    name: string;
    description: string;
    endTime: number;
    isActive: boolean;
  }>;
}

// ============================================================================
// State Events
// ============================================================================

/**
 * Event: State saved
 *
 * Records a saved state snapshot for workspace/session restoration.
 */
export interface StateSavedEvent extends BaseStorageEvent {
  type: 'state_saved';
  /** Parent workspace ID */
  workspaceId: string;
  /** Parent session ID */
  sessionId: string;
  data: {
    /** Unique state identifier */
    id: string;
    /** State name */
    name: string;
    /** Optional description */
    description?: string;
    /** Creation timestamp */
    created: number;
    /** JSON-serialized state context */
    stateJson: string;
    /** Optional tags for categorization */
    tags?: string[];
  };
}

/**
 * Event: State deleted
 *
 * Marks a state as deleted (soft delete).
 */
export interface StateDeletedEvent extends BaseStorageEvent {
  type: 'state_deleted';
  /** Parent workspace ID */
  workspaceId: string;
  /** Parent session ID */
  sessionId: string;
  /** Target state ID */
  stateId: string;
}

// ============================================================================
// Trace Events
// ============================================================================

/**
 * Event: Trace added
 *
 * Records a memory trace for workspace activity tracking.
 */
export interface TraceAddedEvent extends BaseStorageEvent {
  type: 'trace_added';
  /** Parent workspace ID */
  workspaceId: string;
  /** Parent session ID */
  sessionId: string;
  data: {
    /** Unique trace identifier */
    id: string;
    /** Trace content */
    content: string;
    /** Optional trace type categorization */
    traceType?: string;
    /** JSON-serialized metadata */
    metadataJson?: string;
  };
}

// ============================================================================
// Conversation Events (OpenAI Format)
// ============================================================================

/**
 * Event: Conversation metadata
 *
 * Special event type that records conversation metadata.
 * Stored as first line in conversation JSONL file.
 */
export interface ConversationCreatedEvent extends BaseStorageEvent {
  type: 'metadata';
  data: {
    /** Unique conversation identifier */
    id: string;
    /** Conversation title */
    title: string;
    /** Creation timestamp */
    created: number;
    /** Vault name */
    vault: string;
    /** Optional conversation settings */
    settings?: any;
  };
}

/**
 * Event: Conversation updated
 *
 * Records updates to conversation metadata.
 */
export interface ConversationUpdatedEvent extends BaseStorageEvent {
  type: 'conversation_updated';
  /** Target conversation ID */
  conversationId: string;
  /** Partial update data (only changed fields) */
  data: Partial<{
    title: string;
    updated: number;
    settings: any;
  }>;
}

/**
 * Alternative message data for branching support
 */
export interface AlternativeMessageEvent {
  /** Unique identifier for this alternative */
  id: string;
  /** Alternative content */
  content: string | null;
  /** Timestamp when alternative was created */
  timestamp: number;
  /** Tool calls made in this alternative */
  tool_calls?: Array<{
    id: string;
    type: 'function';
    function: { name: string; arguments: string };
  }>;
  /** Reasoning/thinking content for this alternative */
  reasoning?: string;
  /** Message lifecycle state */
  state?: string;
}

/**
 * Event: Message added/updated
 *
 * Records a chat message in OpenAI fine-tuning format.
 * This format is compatible with OpenAI's JSONL training data.
 */
export interface MessageEvent extends BaseStorageEvent {
  type: 'message';
  /** Parent conversation ID */
  conversationId: string;
  data: {
    /** Unique message identifier */
    id: string;
    /** Message role */
    role: 'system' | 'user' | 'assistant' | 'tool';
    /** Message content (null for tool calls) */
    content: string | null;
    /** Tool calls (OpenAI format with extended properties for tool bubble reconstruction) */
    tool_calls?: Array<{
      id: string;
      type: 'function' | string;
      function: { name: string; arguments: string };
      // Extended properties for tool bubbles reconstruction after reload
      name?: string;
      parameters?: Record<string, unknown>;
      result?: unknown;
      success?: boolean;
      error?: string;
      executionTime?: number;
    }>;
    /** Tool call ID (for tool role messages) */
    tool_call_id?: string;
    /** Message lifecycle state */
    state?: string;
    /** Reasoning/thinking content (for extended thinking models) */
    reasoning?: string;
    /** Sequence number for ordering */
    sequenceNumber: number;
    /** Alternative responses for branching */
    alternatives?: AlternativeMessageEvent[];
    /** Which alternative is active: 0 = original, 1+ = alternative index + 1 */
    activeAlternativeIndex?: number;
  };
}

/**
 * Event: Message updated
 *
 * Records updates to existing message (e.g., streaming completion, state changes).
 */
export interface MessageUpdatedEvent extends BaseStorageEvent {
  type: 'message_updated';
  /** Parent conversation ID */
  conversationId: string;
  /** Target message ID */
  messageId: string;
  /** Partial update data (only changed fields) */
  data: Partial<{
    content: string;
    state: string;
    reasoning: string;
    tool_calls: Array<{
      id: string;
      type: 'function' | string;
      function: { name: string; arguments: string };
      // Extended properties for tool bubbles reconstruction
      name?: string;
      parameters?: Record<string, unknown>;
      result?: unknown;
      success?: boolean;
      error?: string;
    }>;
    tool_call_id: string;
    /** Alternative responses for branching */
    alternatives: AlternativeMessageEvent[];
    /** Which alternative is active: 0 = original, 1+ = alternative index + 1 */
    activeAlternativeIndex: number;
  }>;
}

// ============================================================================
// Branch Events (Append-Only for Conflict-Free Sync)
// ============================================================================

/**
 * Event: Branch created on a message
 *
 * Branches are stored separately from messages to enable append-only writes.
 * This eliminates race conditions when multiple devices create branches concurrently.
 */
export interface BranchCreatedEvent extends BaseStorageEvent {
  type: 'branch_created';
  /** Parent conversation ID */
  conversationId: string;
  /** Message ID this branch is attached to */
  parentMessageId: string;
  data: {
    /** Unique branch identifier */
    id: string;
    /** Branch type */
    type: 'human' | 'subagent';
    /** Whether LLM context includes parent conversation */
    inheritContext: boolean;
    /** Type-specific metadata (JSON stringified for subagent) */
    metadataJson?: string;
  };
}

/**
 * Event: Message added to a branch
 *
 * Branch messages are separate from main conversation messages.
 * Append-only: each message is a new event line, no conflicts.
 */
export interface BranchMessageEvent extends BaseStorageEvent {
  type: 'branch_message';
  /** Parent conversation ID */
  conversationId: string;
  /** Branch ID this message belongs to */
  branchId: string;
  data: {
    /** Unique message identifier */
    id: string;
    /** Message role */
    role: 'system' | 'user' | 'assistant' | 'tool';
    /** Message content (null for tool calls) */
    content: string | null;
    /** Tool calls (OpenAI format) */
    tool_calls?: Array<{
      id: string;
      type: 'function' | string;
      function: { name: string; arguments: string };
      // Extended properties for tool bubbles
      name?: string;
      parameters?: Record<string, unknown>;
      result?: unknown;
      success?: boolean;
      error?: string;
    }>;
    /** Tool call ID (for tool role messages) */
    tool_call_id?: string;
    /** Message lifecycle state */
    state?: string;
    /** Reasoning/thinking content */
    reasoning?: string;
    /** Sequence number for ordering within branch */
    sequenceNumber: number;
  };
}

/**
 * Event: Branch message updated (streaming completion, state changes)
 */
export interface BranchMessageUpdatedEvent extends BaseStorageEvent {
  type: 'branch_message_updated';
  /** Parent conversation ID */
  conversationId: string;
  /** Branch ID */
  branchId: string;
  /** Target message ID */
  messageId: string;
  /** Partial update data */
  data: Partial<{
    content: string;
    state: string;
    reasoning: string;
    tool_calls: Array<{
      id: string;
      type: 'function' | string;
      function: { name: string; arguments: string };
      result?: unknown;
      success?: boolean;
      error?: string;
    }>;
    tool_call_id: string;
  }>;
}

/**
 * Event: Branch state/metadata updated
 *
 * Used for subagent state transitions: running â†’ complete, cancelled, etc.
 */
export interface BranchUpdatedEvent extends BaseStorageEvent {
  type: 'branch_updated';
  /** Parent conversation ID */
  conversationId: string;
  /** Target branch ID */
  branchId: string;
  /** Partial update data */
  data: Partial<{
    /** Updated metadata (JSON stringified) */
    metadataJson: string;
    /** Updated timestamp */
    updated: number;
  }>;
}

// ============================================================================
// Union Types and Type Guards
// ============================================================================

/**
 * Union of all workspace-related events
 */
export type WorkspaceEvent =
  | WorkspaceCreatedEvent
  | WorkspaceUpdatedEvent
  | WorkspaceDeletedEvent
  | SessionCreatedEvent
  | SessionUpdatedEvent
  | StateSavedEvent
  | StateDeletedEvent
  | TraceAddedEvent;

/**
 * Union of all conversation-related events
 */
export type ConversationEvent =
  | ConversationCreatedEvent
  | ConversationUpdatedEvent
  | MessageEvent
  | MessageUpdatedEvent
  | BranchCreatedEvent
  | BranchMessageEvent
  | BranchMessageUpdatedEvent
  | BranchUpdatedEvent;

/**
 * Union of all storage events
 */
export type StorageEvent = WorkspaceEvent | ConversationEvent;

/**
 * Type guard: Check if event is workspace-related
 */
export function isWorkspaceEvent(event: StorageEvent): event is WorkspaceEvent {
  return [
    'workspace_created',
    'workspace_updated',
    'workspace_deleted',
    'session_created',
    'session_updated',
    'state_saved',
    'state_deleted',
    'trace_added',
  ].includes(event.type);
}

/**
 * Type guard: Check if event is conversation-related
 */
export function isConversationEvent(event: StorageEvent): event is ConversationEvent {
  return [
    'metadata',
    'conversation_updated',
    'message',
    'message_updated',
    'branch_created',
    'branch_message',
    'branch_message_updated',
    'branch_updated',
  ].includes(event.type);
}

/**
 * Type guard: Check if event is a creation event
 */
export function isCreationEvent(event: StorageEvent): boolean {
  return [
    'workspace_created',
    'session_created',
    'state_saved',
    'trace_added',
    'metadata',
    'message',
    'branch_created',
    'branch_message',
  ].includes(event.type);
}

/**
 * Type guard: Check if event is an update event
 */
export function isUpdateEvent(event: StorageEvent): boolean {
  return [
    'workspace_updated',
    'session_updated',
    'conversation_updated',
    'message_updated',
    'branch_message_updated',
    'branch_updated',
  ].includes(event.type);
}

/**
 * Type guard: Check if event is a deletion event
 */
export function isDeletionEvent(event: StorageEvent): boolean {
  return [
    'workspace_deleted',
    'state_deleted',
  ].includes(event.type);
}

```

## database/migration/BaseMigrator.ts

```typescript
/**
 * Location: src/database/migration/BaseMigrator.ts
 *
 * Abstract base class for file migrators.
 * Provides DRY implementation of file iteration, status tracking, and error handling.
 *
 * Subclasses implement:
 * - category: 'workspaces' or 'conversations'
 * - listFiles(): Get files to migrate
 * - migrateFile(): Migrate a single file
 * - createEmptyResult(): Create initial result object
 */

import { App } from 'obsidian';
import { JSONLWriter } from '../storage/JSONLWriter';
import { LegacyFileScanner } from './LegacyFileScanner';
import { MigrationStatusTracker } from './MigrationStatusTracker';
import { MigrationCategory } from './types';

/**
 * Base interface for migration results - all results must have errors array
 */
export interface BaseMigrationResult {
  errors: string[];
}

/**
 * Abstract base class for migrators
 */
export abstract class BaseMigrator<TResult extends BaseMigrationResult> {
  protected app: App;
  protected jsonlWriter: JSONLWriter;
  protected fileScanner: LegacyFileScanner;
  protected statusTracker: MigrationStatusTracker;

  /** Category of files this migrator handles */
  protected abstract readonly category: MigrationCategory;

  constructor(
    app: App,
    jsonlWriter: JSONLWriter,
    fileScanner: LegacyFileScanner,
    statusTracker: MigrationStatusTracker
  ) {
    this.app = app;
    this.jsonlWriter = jsonlWriter;
    this.fileScanner = fileScanner;
    this.statusTracker = statusTracker;
  }

  /**
   * Migrate all files in this category.
   * Handles file iteration, status tracking, and error collection.
   */
  async migrate(): Promise<TResult> {
    const result = this.createEmptyResult();

    try {
      const files = await this.listFiles();

      for (const filePath of files) {
        // Skip if already migrated (duplicate prevention)
        if (await this.statusTracker.isFileMigrated(this.category, filePath)) {
          continue;
        }

        try {
          await this.migrateFile(filePath, result);
          await this.statusTracker.markFileMigrated(this.category, filePath);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          result.errors.push(`Failed to migrate ${filePath}: ${message}`);
          console.error(`[${this.constructor.name}] Error migrating ${filePath}:`, error);
        }
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      result.errors.push(`Failed to list ${this.category} files: ${message}`);
      console.error(`[${this.constructor.name}] Error listing files:`, error);
    }

    return result;
  }

  /**
   * Get list of files to migrate
   */
  protected abstract listFiles(): Promise<string[]>;

  /**
   * Migrate a single file. Updates result with migration counts.
   */
  protected abstract migrateFile(filePath: string, result: TResult): Promise<void>;

  /**
   * Create an empty result object
   */
  protected abstract createEmptyResult(): TResult;
}

```

## database/migration/ConversationMigrator.ts

```typescript
/**
 * Location: src/database/migration/ConversationMigrator.ts
 *
 * Migrates conversation data from legacy JSON to JSONL format.
 * Handles conversations and messages in OpenAI fine-tuning format.
 *
 * Extends BaseMigrator for DRY file iteration and status tracking.
 * Uses batched writes for performance (single file operation per conversation).
 */

import { App } from 'obsidian';
import { JSONLWriter } from '../storage/JSONLWriter';
import { IndividualConversation } from '../../types/storage/StorageTypes';
import { ConversationCreatedEvent, MessageEvent, ConversationEvent } from '../interfaces/StorageEvents';
import { LegacyFileScanner } from './LegacyFileScanner';
import { MigrationStatusTracker } from './MigrationStatusTracker';
import { BaseMigrator } from './BaseMigrator';
import { ConversationMigrationResult, MigrationCategory } from './types';

export class ConversationMigrator extends BaseMigrator<ConversationMigrationResult> {
  protected readonly category: MigrationCategory = 'conversations';

  constructor(
    app: App,
    jsonlWriter: JSONLWriter,
    fileScanner: LegacyFileScanner,
    statusTracker: MigrationStatusTracker
  ) {
    super(app, jsonlWriter, fileScanner, statusTracker);
  }

  protected async listFiles(): Promise<string[]> {
    return this.fileScanner.listLegacyConversationFilePaths();
  }

  protected createEmptyResult(): ConversationMigrationResult {
    return {
      conversations: 0,
      messages: 0,
      errors: [],
    };
  }

  /**
   * Migrate a single conversation file using batched writes for performance
   */
  protected async migrateFile(
    filePath: string,
    result: ConversationMigrationResult
  ): Promise<void> {
    // Read legacy conversation JSON via adapter
    const content = await this.app.vault.adapter.read(filePath);
    const conversation: IndividualConversation = JSON.parse(content);

    // Collect all events for this conversation
    const events: Array<Omit<ConversationEvent, 'id' | 'deviceId' | 'timestamp'>> = [];

    // Conversation metadata event (first line in JSONL)
    events.push({
      type: 'metadata',
      data: {
        id: conversation.id,
        title: conversation.title,
        created: conversation.created,
        vault: conversation.vault_name,
        settings: conversation.metadata?.chatSettings,
      },
    } as Omit<ConversationCreatedEvent, 'id' | 'deviceId' | 'timestamp'>);
    result.conversations++;

    // Collect message events
    if (conversation.messages && conversation.messages.length > 0) {
      // Sort messages by timestamp to ensure correct order
      const sortedMessages = [...conversation.messages].sort(
        (a, b) => a.timestamp - b.timestamp
      );

      for (let i = 0; i < sortedMessages.length; i++) {
        const message = sortedMessages[i];
        events.push({
          type: 'message',
          conversationId: conversation.id,
          data: {
            id: message.id,
            role: message.role,
            content: message.content,
            state: message.state,
            sequenceNumber: i,
            tool_calls: message.toolCalls?.map((tc) => ({
              id: tc.id,
              type: 'function' as const,
              function: {
                name: tc.function?.name || tc.name || '',
                arguments: tc.function?.arguments || JSON.stringify(tc.parameters || {}),
              },
            })),
            // Branching support - migrate alternatives from legacy JSON
            alternatives: message.alternatives?.map((alt) => ({
              id: alt.id,
              content: alt.content,
              timestamp: alt.timestamp,
              tool_calls: alt.toolCalls?.map((tc) => ({
                id: tc.id,
                type: 'function' as const,
                function: {
                  name: tc.function?.name || tc.name || '',
                  arguments: tc.function?.arguments || JSON.stringify(tc.parameters || {}),
                },
              })),
              reasoning: alt.reasoning,
              state: alt.state || 'complete',
            })),
            activeAlternativeIndex: message.activeAlternativeIndex ?? 0,
          },
        } as Omit<MessageEvent, 'id' | 'deviceId' | 'timestamp'>);
        result.messages++;
      }
    }

    // Write all events in a single operation
    const jsonlPath = `conversations/conv_${conversation.id}.jsonl`;
    await this.jsonlWriter.appendEvents(jsonlPath, events);
  }
}

```

## database/migration/index.ts

```typescript
/**
 * Location: src/database/migration/index.ts
 *
 * Migration Module Exports
 *
 * Central export point for the legacy JSON to JSONL/SQLite migration system.
 */

// Main orchestrator
export { LegacyMigrator } from './LegacyMigrator';

// Base class for migrators (DRY)
export { BaseMigrator } from './BaseMigrator';
export type { BaseMigrationResult } from './BaseMigrator';

// Specialized migrators
export { WorkspaceMigrator } from './WorkspaceMigrator';
export { ConversationMigrator } from './ConversationMigrator';

// Support classes
export { LegacyFileScanner } from './LegacyFileScanner';
export { MigrationStatusTracker } from './MigrationStatusTracker';
export { LegacyArchiver } from './LegacyArchiver';
export type { ArchiveResult } from './LegacyArchiver';

// Types
export type {
  MigrationStatus,
  MigrationResult,
  MigrationStats,
  MigrationCategory,
  WorkspaceMigrationResult,
  ConversationMigrationResult,
} from './types';

```

## database/migration/LegacyArchiver.ts

```typescript
/**
 * Location: src/database/migration/LegacyArchiver.ts
 *
 * Archives legacy JSON folders after successful migration.
 * Renames .workspaces â†’ .workspaces-archived
 * Renames .conversations â†’ .conversations-archived
 */

import { App } from 'obsidian';

export interface ArchiveResult {
  archived: string[];
  errors: string[];
}

export class LegacyArchiver {
  private app: App;
  private legacyWorkspacesPath = '.workspaces';
  private legacyConversationsPath = '.conversations';
  private archivedWorkspacesPath = '.workspaces-archived';
  private archivedConversationsPath = '.conversations-archived';

  constructor(app: App) {
    this.app = app;
  }

  /**
   * Archive legacy folders by renaming them with -archived suffix
   */
  async archiveLegacyFolders(): Promise<ArchiveResult> {
    const result: ArchiveResult = {
      archived: [],
      errors: [],
    };

    // Archive workspaces folder
    await this.archiveFolder(
      this.legacyWorkspacesPath,
      this.archivedWorkspacesPath,
      result
    );

    // Archive conversations folder
    await this.archiveFolder(
      this.legacyConversationsPath,
      this.archivedConversationsPath,
      result
    );

    return result;
  }

  /**
   * Archive a single folder
   */
  private async archiveFolder(
    sourcePath: string,
    destPath: string,
    result: ArchiveResult
  ): Promise<void> {
    try {
      // Check if source folder exists
      const sourceExists = await this.app.vault.adapter.exists(sourcePath);
      if (!sourceExists) {
        return; // Nothing to archive
      }

      // Check if destination already exists
      const destExists = await this.app.vault.adapter.exists(destPath);
      if (destExists) {
        return; // Already archived
      }

      // Rename folder
      await this.app.vault.adapter.rename(sourcePath, destPath);
      result.archived.push(sourcePath);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      result.errors.push(`Failed to archive ${sourcePath}: ${message}`);
      console.error(`[LegacyArchiver] Error archiving ${sourcePath}:`, error);
    }
  }

  /**
   * Check if legacy folders have been archived
   */
  async isArchived(): Promise<boolean> {
    // Check if original folders don't exist and archived folders do
    const workspacesExists = await this.app.vault.adapter.exists(this.legacyWorkspacesPath);
    const conversationsExists = await this.app.vault.adapter.exists(this.legacyConversationsPath);

    // If either original folder exists, not fully archived
    if (workspacesExists || conversationsExists) {
      return false;
    }

    // Check if at least one archived folder exists (indicates archive was done)
    const archivedWorkspacesExists = await this.app.vault.adapter.exists(this.archivedWorkspacesPath);
    const archivedConversationsExists = await this.app.vault.adapter.exists(this.archivedConversationsPath);

    return archivedWorkspacesExists || archivedConversationsExists;
  }

  /**
   * Check if legacy folders exist (migration source)
   */
  async hasLegacyFolders(): Promise<boolean> {
    const workspacesExists = await this.app.vault.adapter.exists(this.legacyWorkspacesPath);
    const conversationsExists = await this.app.vault.adapter.exists(this.legacyConversationsPath);
    return workspacesExists || conversationsExists;
  }

  /**
   * Check if archive folders exist (indicates previous migration completed archiving)
   */
  async archiveFoldersExist(): Promise<boolean> {
    const archivedWorkspacesExists = await this.app.vault.adapter.exists(this.archivedWorkspacesPath);
    const archivedConversationsExists = await this.app.vault.adapter.exists(this.archivedConversationsPath);
    return archivedWorkspacesExists || archivedConversationsExists;
  }
}

```

## database/migration/LegacyFileScanner.ts

```typescript
/**
 * Location: src/database/migration/LegacyFileScanner.ts
 *
 * Scans for legacy JSON files in .workspaces and .conversations folders.
 * Uses vault.adapter for hidden folder support.
 */

import { App } from 'obsidian';

export class LegacyFileScanner {
  private app: App;
  private legacyWorkspacesPath = '.workspaces';
  private legacyConversationsPath = '.conversations';

  constructor(app: App) {
    this.app = app;
  }

  /**
   * Check if legacy workspaces folder exists and has data
   */
  async hasLegacyWorkspaces(): Promise<boolean> {
    try {
      const exists = await this.app.vault.adapter.exists(this.legacyWorkspacesPath);
      if (!exists) return false;

      const listing = await this.app.vault.adapter.list(this.legacyWorkspacesPath);
      const jsonFiles = listing.files.filter(f => f.endsWith('.json') && !f.endsWith('index.json'));
      return jsonFiles.length > 0;
    } catch (error) {
      return false;
    }
  }

  /**
   * Check if legacy conversations folder exists and has data
   */
  async hasLegacyConversations(): Promise<boolean> {
    try {
      const exists = await this.app.vault.adapter.exists(this.legacyConversationsPath);
      if (!exists) return false;

      const listing = await this.app.vault.adapter.list(this.legacyConversationsPath);
      const jsonFiles = listing.files.filter(f => f.endsWith('.json') && !f.endsWith('index.json'));
      return jsonFiles.length > 0;
    } catch (error) {
      return false;
    }
  }

  /**
   * List all workspace JSON file paths in legacy folder
   */
  async listLegacyWorkspaceFilePaths(): Promise<string[]> {
    try {
      const exists = await this.app.vault.adapter.exists(this.legacyWorkspacesPath);
      if (!exists) {
        return [];
      }

      const listing = await this.app.vault.adapter.list(this.legacyWorkspacesPath);
      return listing.files.filter(f => {
        // Must be .json file
        if (!f.endsWith('.json')) return false;
        // Skip index and schema files
        const filename = f.split('/').pop() || '';
        if (filename === 'index.json') return false;
        if (filename.startsWith('.')) return false;
        if (filename.includes('schema')) return false;
        return true;
      });
    } catch (error) {
      console.error('[LegacyFileScanner] Error listing workspace files:', error);
      return [];
    }
  }

  /**
   * List all conversation JSON file paths in legacy folder
   */
  async listLegacyConversationFilePaths(): Promise<string[]> {
    try {
      const exists = await this.app.vault.adapter.exists(this.legacyConversationsPath);
      if (!exists) {
        return [];
      }

      const listing = await this.app.vault.adapter.list(this.legacyConversationsPath);
      return listing.files.filter(f => f.endsWith('.json') && !f.endsWith('index.json'));
    } catch (error) {
      console.error('[LegacyFileScanner] Error listing conversation files:', error);
      return [];
    }
  }

  /**
   * Read file content via adapter (works for hidden files)
   */
  async readFile(path: string): Promise<string | null> {
    try {
      return await this.app.vault.adapter.read(path);
    } catch (error) {
      console.error(`[LegacyFileScanner] Error reading file ${path}:`, error);
      return null;
    }
  }
}

```

## database/migration/LegacyMigrator.ts

```typescript
/**
 * Location: src/database/migration/LegacyMigrator.ts
 *
 * Legacy JSON to JSONL/SQLite Migration Orchestrator
 *
 * Thin orchestrator that delegates to specialized migrators:
 * - LegacyFileScanner: Scans for legacy JSON files
 * - MigrationStatusTracker: Tracks migration progress and per-file status
 * - WorkspaceMigrator: Migrates workspace/session/state/trace data
 * - ConversationMigrator: Migrates conversation/message data
 * - LegacyArchiver: Archives legacy folders after migration
 *
 * Design Principles:
 * - Single Responsibility: Orchestration only, no direct migration logic
 * - Open/Closed: Add new migrators without modifying this class
 * - Dependency Injection: All dependencies passed to constructor
 *
 * Duplicate Prevention:
 * - Per-file tracking in migration-status.json
 * - Files already in migratedFiles list are always skipped
 * - Safe to run multiple times or after version bumps
 */

import { App } from 'obsidian';
import { JSONLWriter } from '../storage/JSONLWriter';
import { LegacyFileScanner } from './LegacyFileScanner';
import { MigrationStatusTracker } from './MigrationStatusTracker';
import { WorkspaceMigrator } from './WorkspaceMigrator';
import { ConversationMigrator } from './ConversationMigrator';
import { LegacyArchiver } from './LegacyArchiver';
import { MigrationResult, MigrationStats, MigrationStatus } from './types';

// Re-export types for backward compatibility
export type { MigrationStatus, MigrationResult } from './types';

/**
 * Legacy data migrator for JSON to JSONL/SQLite transition
 *
 * Usage:
 * ```typescript
 * const migrator = new LegacyMigrator(app);
 * const result = await migrator.migrate();
 *
 * if (result.needed) {
 *   console.log(`Migration completed: ${result.message}`);
 * }
 * ```
 */
export class LegacyMigrator {
  private app: App;
  private jsonlWriter: JSONLWriter;
  private fileScanner: LegacyFileScanner;
  private statusTracker: MigrationStatusTracker;
  private workspaceMigrator: WorkspaceMigrator;
  private conversationMigrator: ConversationMigrator;
  private archiver: LegacyArchiver;

  // Current migration version - increment to force re-migration
  // 1.0.0 - Initial migration
  // 1.1.0 - Fixed message migration detection
  // 1.2.0 - Fixed JSONLWriter.appendEvent() for hidden folders
  // 1.3.0 - Added per-file tracking and legacy archival
  private readonly MIGRATION_VERSION = '1.3.0';

  constructor(app: App) {
    this.app = app;
    this.jsonlWriter = new JSONLWriter({ app, basePath: '.nexus' });
    this.fileScanner = new LegacyFileScanner(app);
    this.statusTracker = new MigrationStatusTracker(app);
    this.archiver = new LegacyArchiver(app);

    // Pass statusTracker to migrators for per-file tracking
    this.workspaceMigrator = new WorkspaceMigrator(
      app,
      this.jsonlWriter,
      this.fileScanner,
      this.statusTracker
    );
    this.conversationMigrator = new ConversationMigrator(
      app,
      this.jsonlWriter,
      this.fileScanner,
      this.statusTracker
    );
  }

  /**
   * Check if migration is needed
   */
  async isMigrationNeeded(): Promise<boolean> {
    try {
      // Check if legacy folders have been archived (status file flag)
      const isArchivedFlag = await this.statusTracker.isLegacyArchived();
      if (isArchivedFlag) {
        return false;
      }

      // Also check if archive folders exist (in case status file is incomplete)
      const archiveFoldersExist = await this.archiver.archiveFoldersExist();
      if (archiveFoldersExist) {
        // Archive folders exist but flag not set - set it now and skip migration
        await this.statusTracker.markLegacyArchived();
        return false;
      }

      // Check if legacy folders exist
      const hasLegacy = await this.archiver.hasLegacyFolders();
      if (!hasLegacy) {
        return false;
      }

      const hasUnmigratedWorkspaces = await this.hasUnmigratedFiles('workspaces');
      const hasUnmigratedConversations = await this.hasUnmigratedFiles('conversations');

      return hasUnmigratedWorkspaces || hasUnmigratedConversations;
    } catch (error) {
      console.error('[LegacyMigrator] Error checking migration status:', error);
      return false;
    }
  }

  /**
   * Check if there are unmigrated files in a category
   */
  private async hasUnmigratedFiles(category: 'workspaces' | 'conversations'): Promise<boolean> {
    const migratedFiles = await this.statusTracker.getMigratedFiles();
    const migratedSet = new Set(migratedFiles[category]);

    const allFiles = category === 'workspaces'
      ? await this.fileScanner.listLegacyWorkspaceFilePaths()
      : await this.fileScanner.listLegacyConversationFilePaths();

    return allFiles.some(file => !migratedSet.has(file));
  }

  /**
   * Perform the migration from legacy JSON to JSONL/SQLite
   */
  async migrate(): Promise<MigrationResult> {
    const startTime = Date.now();
    const errors: string[] = [];
    const stats: MigrationStats = {
      workspacesMigrated: 0,
      sessionsMigrated: 0,
      statesMigrated: 0,
      tracesMigrated: 0,
      conversationsMigrated: 0,
      messagesMigrated: 0,
    };

    try {
      // Check if migration is needed
      const needed = await this.isMigrationNeeded();
      if (!needed) {
        return this.createResult(false, true, stats, [], startTime,
          'Migration not needed - already completed or no legacy data found');
      }

      // Ensure directory structure exists
      await this.ensureDirectories();

      // Record migration start
      await this.statusTracker.save({
        completed: false,
        startedAt: startTime,
        version: this.MIGRATION_VERSION,
        deviceId: this.jsonlWriter.getDeviceId(),
      });

      // Migrate workspaces
      const workspaceResult = await this.migrateWorkspacesSafely(errors);
      stats.workspacesMigrated = workspaceResult.workspaces;
      stats.sessionsMigrated = workspaceResult.sessions;
      stats.statesMigrated = workspaceResult.states;
      stats.tracesMigrated = workspaceResult.traces;

      // Migrate conversations
      const conversationResult = await this.migrateConversationsSafely(errors);
      stats.conversationsMigrated = conversationResult.conversations;
      stats.messagesMigrated = conversationResult.messages;

      // Archive legacy folders after successful migration
      const archiveResult = await this.archiver.archiveLegacyFolders();
      if (archiveResult.errors.length > 0) {
        errors.push(...archiveResult.errors);
      }

      // Record migration completion
      // Mark as archived if we archived anything, OR if archive folders already exist
      // (meaning a previous migration already archived them)
      const wasArchived = archiveResult.archived.length > 0 ||
        await this.archiver.archiveFoldersExist();
      await this.recordCompletion(startTime, stats, errors, wasArchived);

      const duration = Date.now() - startTime;
      const success = errors.length === 0;

      return this.createResult(true, success, stats, errors, startTime,
        success
          ? `Successfully migrated ${stats.workspacesMigrated} workspaces and ${stats.conversationsMigrated} conversations`
          : `Migration completed with ${errors.length} errors`);

    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      errors.push(`Migration failed: ${message}`);
      console.error('[LegacyMigrator] Fatal migration error:', error);

      return this.createResult(true, false, stats, errors, startTime, `Migration failed: ${message}`);
    }
  }

  // ============================================================================
  // Private Helper Methods
  // ============================================================================

  private async ensureDirectories(): Promise<void> {
    await this.jsonlWriter.ensureDirectory();
    await this.jsonlWriter.ensureDirectory('workspaces');
    await this.jsonlWriter.ensureDirectory('conversations');
  }

  private async migrateWorkspacesSafely(errors: string[]): Promise<{
    workspaces: number;
    sessions: number;
    states: number;
    traces: number;
  }> {
    try {
      const result = await this.workspaceMigrator.migrate();
      errors.push(...result.errors);
      return result;
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      errors.push(`Workspace migration failed: ${message}`);
      console.error('[LegacyMigrator] Workspace migration error:', error);
      return { workspaces: 0, sessions: 0, states: 0, traces: 0 };
    }
  }

  private async migrateConversationsSafely(errors: string[]): Promise<{
    conversations: number;
    messages: number;
  }> {
    try {
      const result = await this.conversationMigrator.migrate();
      errors.push(...result.errors);
      return result;
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      errors.push(`Conversation migration failed: ${message}`);
      console.error('[LegacyMigrator] Conversation migration error:', error);
      return { conversations: 0, messages: 0 };
    }
  }

  private async recordCompletion(
    startTime: number,
    stats: MigrationStats,
    errors: string[],
    archived: boolean
  ): Promise<void> {
    // Preserve existing migratedFiles when recording completion
    const existingMigratedFiles = await this.statusTracker.getMigratedFiles();

    await this.statusTracker.save({
      completed: true,
      startedAt: startTime,
      completedAt: Date.now(),
      version: this.MIGRATION_VERSION,
      stats: { ...stats, errors },
      deviceId: this.jsonlWriter.getDeviceId(),
      errors,
      legacyArchived: archived,
      migratedFiles: existingMigratedFiles,
    });
  }

  private createResult(
    needed: boolean,
    success: boolean,
    stats: MigrationStats,
    errors: string[],
    startTime: number,
    message: string
  ): MigrationResult {
    return {
      needed,
      success,
      stats,
      errors,
      duration: Date.now() - startTime,
      message,
    };
  }
}

```

## database/migration/MigrationStatusTracker.ts

```typescript
/**
 * Location: src/database/migration/MigrationStatusTracker.ts
 *
 * Tracks migration status and progress.
 * Stores status in .nexus/migration-status.json
 */

import { App } from 'obsidian';
import { MigrationStatus, MigrationCategory } from './types';

export class MigrationStatusTracker {
  private app: App;
  private statusPath = '.nexus/migration-status.json';

  constructor(app: App) {
    this.app = app;
  }

  /**
   * Load migration status from file
   */
  async load(): Promise<MigrationStatus | null> {
    try {
      // Use adapter directly for consistency with save()
      const exists = await this.app.vault.adapter.exists(this.statusPath);
      if (!exists) {
        return null;
      }

      const content = await this.app.vault.adapter.read(this.statusPath);
      const status = JSON.parse(content);
      return status;
    } catch (error) {
      console.error('[MigrationStatusTracker] Failed to load status:', error);
      return null;
    }
  }

  /**
   * Save migration status to file
   */
  async save(status: MigrationStatus): Promise<void> {
    try {
      const content = JSON.stringify(status, null, 2);

      // Ensure .nexus directory exists
      const dirPath = '.nexus';
      const dirExists = await this.app.vault.adapter.exists(dirPath);
      if (!dirExists) {
        await this.app.vault.adapter.mkdir(dirPath);
      }

      // Write status file (create or update)
      await this.app.vault.adapter.write(this.statusPath, content);
    } catch (error) {
      console.error('[MigrationStatusTracker] Failed to save migration status:', error);
      throw error;
    }
  }

  /**
   * Check if migration is complete for given version
   */
  async isCompleteForVersion(version: string): Promise<boolean> {
    const status = await this.load();
    return status?.completed === true && status.version === version;
  }

  /**
   * Check if a specific file has been migrated
   */
  async isFileMigrated(category: MigrationCategory, filePath: string): Promise<boolean> {
    const status = await this.load();
    if (!status?.migratedFiles) {
      return false;
    }
    return status.migratedFiles[category]?.includes(filePath) ?? false;
  }

  /**
   * Mark a file as migrated
   */
  async markFileMigrated(category: MigrationCategory, filePath: string): Promise<void> {
    let status = await this.load();

    // Initialize status if needed
    if (!status) {
      status = {
        completed: false,
        version: '',
        migratedFiles: { workspaces: [], conversations: [] },
      };
    }

    // Initialize migratedFiles if needed
    if (!status.migratedFiles) {
      status.migratedFiles = { workspaces: [], conversations: [] };
    }

    // Add file if not already present
    if (!status.migratedFiles[category].includes(filePath)) {
      status.migratedFiles[category].push(filePath);
      await this.save(status);
    }
  }

  /**
   * Get all migrated files
   */
  async getMigratedFiles(): Promise<{ workspaces: string[]; conversations: string[] }> {
    const status = await this.load();
    return status?.migratedFiles ?? { workspaces: [], conversations: [] };
  }

  /**
   * Check if legacy folders have been archived
   */
  async isLegacyArchived(): Promise<boolean> {
    const status = await this.load();
    return status?.legacyArchived === true;
  }

  /**
   * Mark legacy folders as archived
   */
  async markLegacyArchived(): Promise<void> {
    let status = await this.load();

    if (!status) {
      status = {
        completed: false,
        version: '',
        legacyArchived: true,
      };
    } else {
      status.legacyArchived = true;
    }

    await this.save(status);
  }
}

```

## database/migration/types.ts

```typescript
/**
 * Location: src/database/migration/types.ts
 *
 * Shared types for the migration system.
 */

/**
 * Migration status tracking
 */
export interface MigrationStatus {
  /** Whether migration has been completed */
  completed: boolean;

  /** Timestamp when migration started */
  startedAt?: number;

  /** Timestamp when migration completed */
  completedAt?: number;

  /** Version of migration logic */
  version: string;

  /** Migration statistics */
  stats?: {
    workspacesMigrated: number;
    sessionsMigrated: number;
    statesMigrated: number;
    tracesMigrated: number;
    conversationsMigrated: number;
    messagesMigrated: number;
    errors: string[];
  };

  /** Device that performed the migration */
  deviceId?: string;

  /** Any errors encountered during migration */
  errors?: string[];

  /** Per-file tracking to prevent duplicates on version bumps */
  migratedFiles?: {
    workspaces: string[];
    conversations: string[];
  };

  /** Whether legacy folders have been archived */
  legacyArchived?: boolean;
}

/** Category of migration files */
export type MigrationCategory = 'workspaces' | 'conversations';

/**
 * Migration result returned to caller
 */
export interface MigrationResult {
  /** Whether migration was needed */
  needed: boolean;

  /** Whether migration completed successfully */
  success: boolean;

  /** Migration statistics */
  stats: MigrationStats;

  /** Any errors encountered */
  errors: string[];

  /** Duration of migration in milliseconds */
  duration: number;

  /** Human-readable message */
  message: string;
}

/**
 * Migration statistics
 */
export interface MigrationStats {
  workspacesMigrated: number;
  sessionsMigrated: number;
  statesMigrated: number;
  tracesMigrated: number;
  conversationsMigrated: number;
  messagesMigrated: number;
}

/**
 * Workspace migration result
 */
export interface WorkspaceMigrationResult {
  workspaces: number;
  sessions: number;
  states: number;
  traces: number;
  errors: string[];
}

/**
 * Conversation migration result
 */
export interface ConversationMigrationResult {
  conversations: number;
  messages: number;
  errors: string[];
}

```

## database/migration/WorkspaceMigrator.ts

```typescript
/**
 * Location: src/database/migration/WorkspaceMigrator.ts
 *
 * Migrates workspace data from legacy JSON to JSONL format.
 * Handles workspaces, sessions, states, and traces.
 *
 * Extends BaseMigrator for DRY file iteration and status tracking.
 * Uses batched writes for performance (single file operation per workspace).
 */

import { App } from 'obsidian';
import { JSONLWriter } from '../storage/JSONLWriter';
import {
  IndividualWorkspace,
  SessionData,
  MemoryTrace,
  StateData,
} from '../../types/storage/StorageTypes';
import {
  WorkspaceCreatedEvent,
  SessionCreatedEvent,
  StateSavedEvent,
  TraceAddedEvent,
  WorkspaceEvent,
} from '../interfaces/StorageEvents';
import { LegacyFileScanner } from './LegacyFileScanner';
import { MigrationStatusTracker } from './MigrationStatusTracker';
import { BaseMigrator } from './BaseMigrator';
import { WorkspaceMigrationResult, MigrationCategory } from './types';

export class WorkspaceMigrator extends BaseMigrator<WorkspaceMigrationResult> {
  protected readonly category: MigrationCategory = 'workspaces';

  constructor(
    app: App,
    jsonlWriter: JSONLWriter,
    fileScanner: LegacyFileScanner,
    statusTracker: MigrationStatusTracker
  ) {
    super(app, jsonlWriter, fileScanner, statusTracker);
  }

  protected async listFiles(): Promise<string[]> {
    return this.fileScanner.listLegacyWorkspaceFilePaths();
  }

  protected createEmptyResult(): WorkspaceMigrationResult {
    return {
      workspaces: 0,
      sessions: 0,
      states: 0,
      traces: 0,
      errors: [],
    };
  }

  /**
   * Migrate a single workspace file using batched writes for performance
   */
  protected async migrateFile(
    filePath: string,
    result: WorkspaceMigrationResult
  ): Promise<void> {
    // Read legacy workspace JSON via adapter
    const content = await this.app.vault.adapter.read(filePath);
    let workspace: IndividualWorkspace;

    try {
      workspace = JSON.parse(content);
    } catch (parseError) {
      console.error(`[WorkspaceMigrator] Failed to parse workspace JSON: ${filePath}`, parseError);
      return;
    }

    if (!workspace.id || !workspace.name) {
      return;
    }

    // Collect all events for this workspace
    const events: Array<Omit<WorkspaceEvent, 'id' | 'deviceId' | 'timestamp'>> = [];

    // Workspace created event
    events.push({
      type: 'workspace_created',
      data: {
        id: workspace.id,
        name: workspace.name,
        description: workspace.description,
        rootFolder: workspace.rootFolder,
        created: workspace.created,
        // Default to true if not specified (workspaces should be active by default)
        isActive: workspace.isActive !== undefined ? workspace.isActive : true,
        contextJson: workspace.context ? JSON.stringify(workspace.context) : undefined,
      },
    } as Omit<WorkspaceCreatedEvent, 'id' | 'deviceId' | 'timestamp'>);
    result.workspaces++;

    // Collect session, state, and trace events
    if (workspace.sessions) {
      const sessionEntries = Object.entries(workspace.sessions);
      for (const [sessionId, sessionData] of sessionEntries) {
        this.collectSessionEvents(workspace.id, sessionId, sessionData, events, result);
      }
    }

    // Write all events in a single operation
    const jsonlPath = `workspaces/ws_${workspace.id}.jsonl`;
    await this.jsonlWriter.appendEvents(jsonlPath, events);
  }

  /**
   * Collect events for a session (synchronous - no I/O)
   */
  private collectSessionEvents(
    workspaceId: string,
    sessionId: string,
    sessionData: SessionData,
    events: Array<Omit<WorkspaceEvent, 'id' | 'deviceId' | 'timestamp'>>,
    result: WorkspaceMigrationResult
  ): void {
    // Session created event
    events.push({
      type: 'session_created',
      workspaceId,
      data: {
        id: sessionId,
        name: sessionData.name || `Session ${sessionId}`,
        description: sessionData.description,
        startTime: sessionData.startTime,
      },
    } as Omit<SessionCreatedEvent, 'id' | 'deviceId' | 'timestamp'>);
    result.sessions++;

    // Collect states
    if (sessionData.states) {
      const stateEntries = Object.entries(sessionData.states);
      for (const [stateId, stateData] of stateEntries) {
        events.push({
          type: 'state_saved',
          workspaceId,
          sessionId,
          data: {
            id: stateId,
            name: stateData.name,
            created: stateData.created,
            stateJson: JSON.stringify(stateData.state),
          },
        } as Omit<StateSavedEvent, 'id' | 'deviceId' | 'timestamp'>);
        result.states++;
      }
    }

    // Collect traces
    if (sessionData.memoryTraces) {
      const traceEntries = Object.entries(sessionData.memoryTraces);
      for (const [traceId, traceData] of traceEntries) {
        events.push({
          type: 'trace_added',
          workspaceId,
          sessionId,
          data: {
            id: traceId,
            content: traceData.content,
            traceType: traceData.type,
            metadataJson: traceData.metadata ? JSON.stringify(traceData.metadata) : undefined,
          },
        } as Omit<TraceAddedEvent, 'id' | 'deviceId' | 'timestamp'>);
        result.traces++;
      }
    }
  }
}

```

## database/optimizations/BatchOperations.ts

```typescript
/**
 * Location: /src/database/optimizations/BatchOperations.ts
 *
 * Batch processing utilities with progress tracking and error handling.
 * Optimizes large dataset operations by processing in configurable chunks.
 *
 * Patterns inspired by agentic-flow AgentDB batch processing strategies.
 *
 * Related Files:
 * - /src/database/sync/SyncCoordinator.ts - Uses batch processing for event application
 * - /src/database/storage/JSONLWriter.ts - Batch writes to JSONL files
 * - /src/database/storage/SQLiteCacheManager.ts - Batch cache updates
 */

/**
 * Options for batch processing operations
 */
export interface BatchOptions<T> {
  /** Number of items to process per batch */
  batchSize: number;
  /** Callback for progress updates */
  onProgress?: (completed: number, total: number, currentBatch: number) => void;
  /** Callback when a batch completes */
  onBatchComplete?: (batchNumber: number, batchResults: any[]) => void;
  /** Whether to stop on first error */
  stopOnError?: boolean;
  /** Delay between batches in ms (for rate limiting) */
  delayBetweenBatches?: number;
}

/**
 * Result of a batch operation
 */
export interface BatchResult<R> {
  success: boolean;
  totalProcessed: number;
  totalFailed: number;
  results: R[];
  errors: Array<{ index: number; item: any; error: Error }>;
  duration: number;
}

/**
 * Batch processing utilities for optimizing large dataset operations.
 *
 * Features:
 * - Configurable batch sizes
 * - Progress tracking callbacks
 * - Error handling with continue/stop options
 * - Rate limiting between batches
 * - Parallel execution with concurrency control
 *
 * @example Sequential batch processing
 * ```typescript
 * const result = await BatchOperations.executeBatch(
 *   items,
 *   async (item) => processItem(item),
 *   {
 *     batchSize: 100,
 *     onProgress: (completed, total) => console.log(`${completed}/${total}`),
 *     stopOnError: false
 *   }
 * );
 * ```
 *
 * @example Parallel batch processing
 * ```typescript
 * const result = await BatchOperations.executeParallel(
 *   items,
 *   async (item) => processItem(item),
 *   5 // max 5 concurrent operations
 * );
 * ```
 */
export class BatchOperations {
  /**
   * Execute an operation on items in batches with progress tracking.
   *
   * Processes items sequentially in batches, allowing for:
   * - Progress monitoring
   * - Per-batch completion callbacks
   * - Rate limiting between batches
   * - Graceful error handling
   *
   * @param items - Array of items to process
   * @param operation - Async function to execute on each item
   * @param options - Batch processing options
   * @returns Result object with success status, results, and errors
   */
  static async executeBatch<T, R>(
    items: T[],
    operation: (item: T, index: number) => Promise<R>,
    options: BatchOptions<T>
  ): Promise<BatchResult<R>> {
    const startTime = Date.now();
    const {
      batchSize,
      onProgress,
      onBatchComplete,
      stopOnError = false,
      delayBetweenBatches = 0
    } = options;

    const results: R[] = [];
    const errors: Array<{ index: number; item: T; error: Error }> = [];
    let totalProcessed = 0;
    let totalFailed = 0;

    const totalBatches = Math.ceil(items.length / batchSize);

    // Process each batch sequentially
    for (let batchNum = 0; batchNum < totalBatches; batchNum++) {
      const start = batchNum * batchSize;
      const end = Math.min(start + batchSize, items.length);
      const batch = items.slice(start, end);
      const batchResults: R[] = [];

      // Process items in current batch
      for (let i = 0; i < batch.length; i++) {
        const globalIndex = start + i;
        try {
          const result = await operation(batch[i], globalIndex);
          results.push(result);
          batchResults.push(result);
          totalProcessed++;
        } catch (error) {
          totalFailed++;
          errors.push({
            index: globalIndex,
            item: batch[i],
            error: error instanceof Error ? error : new Error(String(error))
          });

          // Stop immediately if stopOnError is true
          if (stopOnError) {
            return {
              success: false,
              totalProcessed,
              totalFailed,
              results,
              errors,
              duration: Date.now() - startTime
            };
          }
        }
      }

      // Progress callback
      if (onProgress) {
        onProgress(totalProcessed + totalFailed, items.length, batchNum + 1);
      }

      // Batch complete callback
      if (onBatchComplete) {
        onBatchComplete(batchNum + 1, batchResults);
      }

      if (delayBetweenBatches > 0 && batchNum < totalBatches - 1) {
        await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
      }
    }

    return {
      success: errors.length === 0,
      totalProcessed,
      totalFailed,
      results,
      errors,
      duration: Date.now() - startTime
    };
  }

  /**
   * Execute multiple operations in parallel with concurrency limit.
   *
   * Processes items in parallel chunks, respecting a maximum concurrency limit.
   * Useful for I/O-bound operations where parallel execution provides benefits.
   *
   * @param items - Array of items to process
   * @param operation - Async function to execute on each item
   * @param concurrency - Maximum number of concurrent operations (default: 5)
   * @returns Result object with success status, results, and errors
   */
  static async executeParallel<T, R>(
    items: T[],
    operation: (item: T, index: number) => Promise<R>,
    concurrency: number = 5
  ): Promise<BatchResult<R>> {
    const startTime = Date.now();
    const results: R[] = new Array(items.length);
    const errors: Array<{ index: number; item: T; error: Error }> = [];
    let totalProcessed = 0;
    let totalFailed = 0;

    // Process in chunks of concurrency size
    for (let i = 0; i < items.length; i += concurrency) {
      const chunk = items.slice(i, i + concurrency);
      const chunkPromises = chunk.map(async (item, chunkIndex) => {
        const globalIndex = i + chunkIndex;
        try {
          results[globalIndex] = await operation(item, globalIndex);
          totalProcessed++;
        } catch (error) {
          totalFailed++;
          errors.push({
            index: globalIndex,
            item,
            error: error instanceof Error ? error : new Error(String(error))
          });
        }
      });

      // Wait for all operations in this chunk to complete
      await Promise.all(chunkPromises);
    }

    return {
      success: errors.length === 0,
      totalProcessed,
      totalFailed,
      results: results.filter(r => r !== undefined),
      errors,
      duration: Date.now() - startTime
    };
  }

  /**
   * Execute operations with retry logic for failed items.
   *
   * Attempts to process all items, then retries failed items up to maxRetries times.
   * Useful for operations that may fail due to transient errors.
   *
   * @param items - Array of items to process
   * @param operation - Async function to execute on each item
   * @param options - Batch processing options
   * @param maxRetries - Maximum number of retry attempts (default: 3)
   * @returns Result object with success status, results, and errors
   */
  static async executeBatchWithRetry<T, R>(
    items: T[],
    operation: (item: T, index: number) => Promise<R>,
    options: BatchOptions<T>,
    maxRetries: number = 3
  ): Promise<BatchResult<R>> {
    let result = await this.executeBatch(items, operation, options);
    let retryCount = 0;

    // Retry failed items
    while (result.errors.length > 0 && retryCount < maxRetries) {
      retryCount++;
      const failedItems = result.errors.map(e => e.item);
      const failedIndices = result.errors.map(e => e.index);

      // Clear previous errors
      result.errors = [];

      // Retry failed items
      const retryResult = await this.executeBatch(
        failedItems,
        operation,
        { ...options, stopOnError: false }
      );

      // Merge results
      retryResult.results.forEach((res, idx) => {
        const originalIndex = failedIndices[idx];
        result.results[originalIndex] = res;
        result.totalProcessed++;
        result.totalFailed--;
      });

      // Keep track of still-failed items
      result.errors = retryResult.errors.map((err, idx) => ({
        ...err,
        index: failedIndices[idx]
      }));
    }

    result.success = result.errors.length === 0;
    return result;
  }

  /**
   * Process items in batches with a transform function.
   *
   * Useful for data transformation pipelines where you want to process
   * large datasets in memory-efficient batches.
   *
   * @param items - Array of items to transform
   * @param transform - Transform function for each item
   * @param batchSize - Size of each batch
   * @returns Array of transformed results
   */
  static async transformBatch<T, R>(
    items: T[],
    transform: (item: T) => Promise<R>,
    batchSize: number = 100
  ): Promise<R[]> {
    const result = await this.executeBatch(
      items,
      (item) => transform(item),
      { batchSize, stopOnError: false }
    );
    return result.results;
  }

  /**
   * Split an array into batches of specified size.
   *
   * Utility function for manual batch processing.
   *
   * @param items - Array to split
   * @param batchSize - Size of each batch
   * @returns Array of batches
   */
  static splitIntoBatches<T>(items: T[], batchSize: number): T[][] {
    const batches: T[][] = [];
    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }
    return batches;
  }
}

```

## database/optimizations/index.ts

```typescript
/**
 * Location: /src/database/optimizations/index.ts
 *
 * Database optimization utilities for hybrid storage system.
 *
 * This module provides performance optimization utilities for the hybrid
 * JSONL + SQLite storage architecture:
 *
 * - BatchOperations: Process large datasets in chunks with progress tracking
 * - QueryCache: Cache expensive queries with TTL and pattern-based invalidation
 *
 * Related Files:
 * - /src/database/sync/SyncCoordinator.ts - Sync coordination (separate export)
 * - /src/database/storage/JSONLWriter.ts - JSONL event log
 * - /src/database/storage/SQLiteCacheManager.ts - SQLite cache
 */

// Export batch operations
export { BatchOperations } from './BatchOperations';
export type { BatchOptions, BatchResult } from './BatchOperations';

// Export query cache
export { QueryCache } from './QueryCache';
export type { CacheEntry, CacheStats } from './QueryCache';

```

## database/optimizations/QueryCache.ts

```typescript
/**
 * Location: /src/database/optimizations/QueryCache.ts
 *
 * Query cache with TTL and pattern-based invalidation.
 * Optimizes expensive read operations by caching results with configurable lifetimes.
 *
 * Design Principles:
 * - Time-based expiration (TTL) for cache freshness
 * - Pattern-based invalidation for bulk updates
 * - Type-specific invalidation for targeted cache clearing
 * - LRU-style eviction when hitting max size
 * - Cache statistics for monitoring and optimization
 *
 * Related Files:
 * - /src/database/storage/SQLiteCacheManager.ts - Uses query cache for read operations
 * - /src/database/sync/SyncCoordinator.ts - Invalidates cache after sync
 * - /src/database/services/cache/CacheManager.ts - Existing cache infrastructure
 */

/**
 * Internal cache entry structure
 */
export interface CacheEntry<T> {
  /** Cached query result */
  result: T;
  /** Timestamp when entry expires (Unix ms) */
  expires: number;
  /** Timestamp when entry was created (Unix ms) */
  createdAt: number;
}

/**
 * Cache performance statistics
 */
export interface CacheStats {
  /** Number of cache hits */
  hits: number;
  /** Number of cache misses */
  misses: number;
  /** Current cache size */
  size: number;
  /** Creation timestamp of oldest entry (null if empty) */
  oldestEntry: number | null;
}

/**
 * Query cache with TTL-based expiration and pattern-based invalidation.
 *
 * Provides automatic caching for expensive queries with configurable lifetimes.
 * Supports bulk invalidation via patterns or entity types.
 *
 * Features:
 * - Automatic TTL-based expiration
 * - LRU eviction when reaching max size
 * - Pattern-based invalidation (regex)
 * - Type-specific invalidation (workspace, session, etc.)
 * - Hit/miss statistics for monitoring
 * - Cleanup of expired entries
 *
 * @example Basic usage
 * ```typescript
 * const cache = new QueryCache({ defaultTTL: 60000 }); // 1 minute default
 *
 * // Cache a query result
 * const result = await cache.cachedQuery(
 *   'workspace:get:abc123',
 *   async () => db.getWorkspace('abc123'),
 *   30000 // 30 second TTL
 * );
 * ```
 *
 * @example Pattern invalidation
 * ```typescript
 * // Invalidate all workspace queries
 * cache.invalidate('^workspace:');
 *
 * // Invalidate specific workspace
 * cache.invalidate('workspace:.*:abc123');
 * ```
 */
export class QueryCache {
  private cache = new Map<string, CacheEntry<any>>();
  private hits = 0;
  private misses = 0;
  private maxSize: number;
  private defaultTTL: number;

  /**
   * Create a new query cache
   *
   * @param options.maxSize - Maximum number of entries (default: 1000)
   * @param options.defaultTTL - Default TTL in milliseconds (default: 60000)
   */
  constructor(options: { maxSize?: number; defaultTTL?: number } = {}) {
    this.maxSize = options.maxSize ?? 1000;
    this.defaultTTL = options.defaultTTL ?? 60000; // 1 minute default
  }

  /**
   * Get or compute a cached value.
   *
   * If the key exists and hasn't expired, returns cached value.
   * Otherwise executes queryFn and caches the result.
   *
   * @param key - Cache key (should be unique per query)
   * @param queryFn - Function to execute on cache miss
   * @param ttlMs - Optional TTL override (uses defaultTTL if not specified)
   * @returns Cached or newly computed result
   */
  async cachedQuery<T>(
    key: string,
    queryFn: () => Promise<T>,
    ttlMs?: number
  ): Promise<T> {
    const ttl = ttlMs ?? this.defaultTTL;
    const now = Date.now();

    // Check cache
    const cached = this.cache.get(key);
    if (cached && cached.expires > now) {
      this.hits++;
      return cached.result as T;
    }

    // Cache miss - execute query
    this.misses++;
    const result = await queryFn();

    // Store in cache
    this.set(key, result, ttl);

    return result;
  }

  /**
   * Set a cache entry directly.
   *
   * Useful for proactive caching or updating cache after mutations.
   *
   * @param key - Cache key
   * @param result - Value to cache
   * @param ttlMs - Optional TTL override
   */
  set<T>(key: string, result: T, ttlMs?: number): void {
    const ttl = ttlMs ?? this.defaultTTL;
    const now = Date.now();

    // Evict if at max size
    if (this.cache.size >= this.maxSize) {
      this.evictOldest();
    }

    this.cache.set(key, {
      result,
      expires: now + ttl,
      createdAt: now
    });
  }

  /**
   * Get a cache entry without computing.
   *
   * Returns undefined if key doesn't exist or entry has expired.
   *
   * @param key - Cache key
   * @returns Cached value or undefined
   */
  get<T>(key: string): T | undefined {
    const now = Date.now();
    const cached = this.cache.get(key);

    if (cached && cached.expires > now) {
      this.hits++;
      return cached.result as T;
    }

    if (cached) {
      // Expired - remove it
      this.cache.delete(key);
    }

    this.misses++;
    return undefined;
  }

  /**
   * Invalidate cache entries matching a pattern.
   *
   * Supports both string patterns (with * wildcards) and RegExp.
   *
   * @param pattern - Pattern to match (string with * wildcards or RegExp)
   * @returns Number of entries invalidated
   *
   * @example
   * ```typescript
   * // Invalidate all workspace queries
   * cache.invalidate('workspace:*');
   *
   * // Invalidate specific workspace
   * cache.invalidate(/workspace:get:abc123/);
   * ```
   */
  invalidate(pattern: string | RegExp): number {
    let invalidated = 0;
    const regex = typeof pattern === 'string'
      ? new RegExp(pattern.replace(/\*/g, '.*'))
      : pattern;

    for (const key of this.cache.keys()) {
      if (regex.test(key)) {
        this.cache.delete(key);
        invalidated++;
      }
    }

    return invalidated;
  }

  /**
   * Invalidate a specific cache key.
   *
   * @param key - Cache key to invalidate
   * @returns True if key was found and removed
   */
  invalidateKey(key: string): boolean {
    return this.cache.delete(key);
  }

  /**
   * Invalidate all entries for a specific entity type.
   *
   * Convenience method for type-specific invalidation.
   *
   * @param type - Entity type to invalidate
   * @returns Number of entries invalidated
   *
   * @example
   * ```typescript
   * // Invalidate all workspace queries
   * cache.invalidateByType('workspace');
   *
   * // Invalidate all conversation queries
   * cache.invalidateByType('conversation');
   * ```
   */
  invalidateByType(type: 'workspace' | 'session' | 'state' | 'conversation' | 'message'): number {
    return this.invalidate(`^${type}:`);
  }

  /**
   * Invalidate all entries for a specific entity ID.
   *
   * @param type - Entity type
   * @param id - Entity ID
   * @returns Number of entries invalidated
   *
   * @example
   * ```typescript
   * // Invalidate all queries for workspace abc123
   * cache.invalidateById('workspace', 'abc123');
   * ```
   */
  invalidateById(
    type: 'workspace' | 'session' | 'state' | 'conversation' | 'message',
    id: string
  ): number {
    return this.invalidate(`^${type}:.*:${id}`);
  }

  /**
   * Clear entire cache.
   *
   * Removes all entries and resets statistics.
   */
  clear(): void {
    this.cache.clear();
    this.hits = 0;
    this.misses = 0;
  }

  /**
   * Remove expired entries.
   *
   * Performs garbage collection on expired cache entries.
   * Should be called periodically to prevent memory leaks.
   *
   * @returns Number of entries removed
   */
  cleanup(): number {
    const now = Date.now();
    let removed = 0;

    for (const [key, entry] of this.cache.entries()) {
      if (entry.expires <= now) {
        this.cache.delete(key);
        removed++;
      }
    }

    return removed;
  }

  /**
   * Evict oldest entry (LRU-style).
   *
   * Internal method called when cache reaches max size.
   */
  private evictOldest(): void {
    let oldestKey: string | null = null;
    let oldestTime = Infinity;

    for (const [key, entry] of this.cache.entries()) {
      if (entry.createdAt < oldestTime) {
        oldestTime = entry.createdAt;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }

  /**
   * Get cache statistics.
   *
   * @returns Cache performance metrics
   */
  getStats(): CacheStats {
    let oldestEntry: number | null = null;

    for (const entry of this.cache.values()) {
      if (oldestEntry === null || entry.createdAt < oldestEntry) {
        oldestEntry = entry.createdAt;
      }
    }

    return {
      hits: this.hits,
      misses: this.misses,
      size: this.cache.size,
      oldestEntry
    };
  }

  /**
   * Get hit rate percentage.
   *
   * @returns Hit rate as percentage (0-100)
   */
  getHitRate(): number {
    const total = this.hits + this.misses;
    return total > 0 ? (this.hits / total) * 100 : 0;
  }

  // ============================================================================
  // Static Helper Methods for Cache Key Generation
  // ============================================================================

  /**
   * Generate cache key for workspace queries.
   *
   * @param id - Workspace ID (omit for list queries)
   * @param queryType - Type of query (default: 'get')
   * @returns Formatted cache key
   *
   * @example
   * ```typescript
   * QueryCache.workspaceKey('abc123', 'get'); // 'workspace:get:abc123'
   * QueryCache.workspaceKey(undefined, 'list'); // 'workspace:list:all'
   * ```
   */
  static workspaceKey(id?: string, queryType: string = 'get'): string {
    return id ? `workspace:${queryType}:${id}` : `workspace:${queryType}:all`;
  }

  /**
   * Generate cache key for session queries.
   *
   * @param workspaceId - Parent workspace ID
   * @param sessionId - Session ID (omit for list queries)
   * @param queryType - Type of query (default: 'get')
   * @returns Formatted cache key
   */
  static sessionKey(workspaceId: string, sessionId?: string, queryType: string = 'get'): string {
    return sessionId
      ? `session:${queryType}:${workspaceId}:${sessionId}`
      : `session:${queryType}:${workspaceId}:all`;
  }

  /**
   * Generate cache key for state queries.
   *
   * @param workspaceId - Parent workspace ID
   * @param sessionId - Parent session ID (omit for list queries)
   * @param queryType - Type of query (default: 'get')
   * @returns Formatted cache key
   */
  static stateKey(workspaceId: string, sessionId?: string, queryType: string = 'get'): string {
    return sessionId
      ? `state:${queryType}:${workspaceId}:${sessionId}`
      : `state:${queryType}:${workspaceId}:all`;
  }

  /**
   * Generate cache key for conversation queries.
   *
   * @param id - Conversation ID (omit for list queries)
   * @param queryType - Type of query (default: 'get')
   * @returns Formatted cache key
   */
  static conversationKey(id?: string, queryType: string = 'get'): string {
    return id ? `conversation:${queryType}:${id}` : `conversation:${queryType}:all`;
  }

  /**
   * Generate cache key for message queries.
   *
   * @param conversationId - Parent conversation ID
   * @param queryType - Type of query (default: 'get')
   * @returns Formatted cache key
   */
  static messageKey(conversationId: string, queryType: string = 'get'): string {
    return `message:${queryType}:${conversationId}`;
  }

  /**
   * Generate cache key for search queries.
   *
   * @param searchType - Type of search (e.g., 'content', 'metadata')
   * @param searchQuery - Search query string (hashed for consistent keys)
   * @returns Formatted cache key
   */
  static searchKey(searchType: string, searchQuery: string): string {
    // Simple hash for query string (not cryptographic, just for cache key)
    const hash = searchQuery.split('').reduce((acc, char) => {
      return ((acc << 5) - acc) + char.charCodeAt(0);
    }, 0);
    return `search:${searchType}:${Math.abs(hash)}`;
  }
}

```

## database/repositories/base/BaseRepository.ts

```typescript
/**
 * Location: src/database/repositories/base/BaseRepository.ts
 *
 * Base Repository Implementation
 *
 * Provides shared functionality for all entity repositories including:
 * - JSONL event writing
 * - SQLite cache operations
 * - Query cache management
 * - ID generation
 * - Pagination helpers
 *
 * Design Principles:
 * - DRY: Common logic in base class, entity-specific in subclasses
 * - Template Method: Abstract methods for entity-specific operations
 * - Dependency Injection: All dependencies passed via constructor
 *
 * Related Files:
 * - src/database/repositories/interfaces/IRepository.ts - Base interface
 * - src/database/storage/SQLiteCacheManager.ts - SQLite operations
 * - src/database/storage/JSONLWriter.ts - JSONL operations
 */

import { v4 as uuidv4 } from '../../../utils/uuid';
import { IRepository } from '../interfaces/IRepository';
import { PaginatedResult, PaginationParams } from '../../../types/pagination/PaginationTypes';
import { SQLiteCacheManager } from '../../storage/SQLiteCacheManager';
import { JSONLWriter } from '../../storage/JSONLWriter';
import { QueryCache } from '../../optimizations/QueryCache';
import { BaseStorageEvent } from '../../interfaces/StorageEvents';

/**
 * Valid entity types for type-specific cache invalidation
 * Must match the types supported by QueryCache.invalidateByType/invalidateById
 */
export type CacheableEntityType = 'workspace' | 'session' | 'state' | 'conversation' | 'message';

/**
 * Dependencies required by all repositories
 */
export interface RepositoryDependencies {
  /** SQLite cache manager for fast queries */
  sqliteCache: SQLiteCacheManager;

  /** JSONL writer for event sourcing */
  jsonlWriter: JSONLWriter;

  /** Query cache for optimization */
  queryCache: QueryCache;
}

/**
 * Base repository with shared functionality
 *
 * @template T - The entity type this repository manages
 */
export abstract class BaseRepository<T> implements IRepository<T> {
  protected readonly sqliteCache: SQLiteCacheManager;
  protected readonly jsonlWriter: JSONLWriter;
  protected readonly queryCache: QueryCache;

  /**
   * SQLite table name (must be overridden by subclasses)
   */
  protected abstract readonly tableName: string;

  /**
   * Entity type identifier for logging and cache keys
   */
  protected abstract readonly entityType: string;

  /**
   * JSONL file path generator (must be overridden by subclasses)
   * @param id - Entity or workspace ID
   * @returns Relative path to JSONL file
   */
  protected abstract jsonlPath(id: string): string;

  constructor(deps: RepositoryDependencies) {
    this.sqliteCache = deps.sqliteCache;
    this.jsonlWriter = deps.jsonlWriter;
    this.queryCache = deps.queryCache;
  }

  // ============================================================================
  // Abstract Methods (Must be implemented by subclasses)
  // ============================================================================

  /**
   * Convert SQLite row to entity instance
   * @param row - Raw SQLite row data
   * @returns Typed entity instance
   */
  protected abstract rowToEntity(row: any): T;

  /**
   * Get entity by ID (subclasses implement with entity-specific logic)
   */
  abstract getById(id: string): Promise<T | null>;

  /**
   * Get all entities with pagination
   */
  abstract getAll(options?: PaginationParams): Promise<PaginatedResult<T>>;

  /**
   * Create a new entity
   */
  abstract create(data: any): Promise<string>;

  /**
   * Update an existing entity
   */
  abstract update(id: string, data: any): Promise<void>;

  /**
   * Delete an entity
   */
  abstract delete(id: string): Promise<void>;

  /**
   * Count entities
   */
  abstract count(criteria?: Record<string, any>): Promise<number>;

  // ============================================================================
  // Shared Helper Methods
  // ============================================================================

  /**
   * Generate a new UUID for entity IDs
   */
  protected generateId(): string {
    return uuidv4();
  }

  /**
   * Write an event to JSONL file
   *
   * @param path - Relative path to JSONL file
   * @param eventData - Event data (without id, deviceId, timestamp)
   * @returns Complete event with metadata
   */
  protected async writeEvent<E extends BaseStorageEvent>(
    path: string,
    eventData: Omit<E, 'id' | 'deviceId' | 'timestamp'>
  ): Promise<E> {
    try {
      const event = await this.jsonlWriter.appendEvent<E>(path, eventData);
      return event;
    } catch (error) {
      console.error(`[${this.entityType}Repository] Failed to write event:`, error);
      throw error;
    }
  }

  /**
   * Paginated query helper with automatic caching
   *
   * @param baseQuery - SQL query without LIMIT/OFFSET
   * @param countQuery - SQL query to count total items
   * @param options - Pagination options
   * @param params - Query parameters
   * @returns Paginated result
   */
  protected async queryPaginated<R>(
    baseQuery: string,
    countQuery: string,
    options: PaginationParams = {},
    params: any[] = []
  ): Promise<PaginatedResult<R>> {
    const page = options.page ?? 0;
    const pageSize = Math.min(options.pageSize ?? 25, 200);
    const offset = page * pageSize;

    // Get total count
    const countResult = await this.sqliteCache.queryOne<{ count: number }>(countQuery, params);
    const totalItems = countResult?.count ?? 0;
    const totalPages = Math.ceil(totalItems / pageSize);

    // Get paginated results
    const paginatedQuery = `${baseQuery} LIMIT ? OFFSET ?`;
    const items = await this.sqliteCache.query<R>(paginatedQuery, [...params, pageSize, offset]);

    return {
      items,
      page,
      pageSize,
      totalItems,
      totalPages,
      hasNextPage: page < totalPages - 1,
      hasPreviousPage: page > 0
    };
  }

  /**
   * Get cached value or execute query function
   *
   * @param cacheKey - Cache key
   * @param queryFn - Function to execute on cache miss
   * @param ttlMs - Optional TTL override
   * @returns Cached or freshly queried result
   */
  protected async getCachedOrFetch<R>(
    cacheKey: string,
    queryFn: () => Promise<R>,
    ttlMs?: number
  ): Promise<R> {
    return this.queryCache.cachedQuery(cacheKey, queryFn, ttlMs);
  }

  /**
   * Check if entity type is cacheable (supports type-specific invalidation)
   *
   * @param type - Entity type to check
   * @returns True if type supports QueryCache.invalidateByType/invalidateById
   */
  private isCacheableEntityType(type: string): type is CacheableEntityType {
    return ['workspace', 'session', 'state', 'conversation', 'message'].includes(type);
  }

  /**
   * Invalidate cache for this entity type
   *
   * @param id - Optional specific entity ID to invalidate
   */
  protected invalidateCache(id?: string): void {
    if (this.isCacheableEntityType(this.entityType)) {
      // Use type-specific invalidation for supported entity types
      if (id) {
        this.queryCache.invalidateById(this.entityType, id);
      } else {
        this.queryCache.invalidateByType(this.entityType);
      }
    } else {
      // Use pattern-based invalidation for other entity types
      if (id) {
        this.queryCache.invalidate(`^${this.entityType}:.*:${id}`);
      } else {
        this.queryCache.invalidate(`^${this.entityType}:`);
      }
    }
  }

  /**
   * Execute multiple operations in a transaction
   *
   * @param fn - Function to execute within transaction
   * @returns Result of the function
   */
  protected async transaction<R>(fn: () => Promise<R>): Promise<R> {
    return this.sqliteCache.transaction(fn);
  }

  /**
   * Log repository operation (disabled by default - enable for debugging)
   *
   * @param operation - Operation name
   * @param details - Optional details
   */
  protected log(_operation: string, _details?: any): void {
  }

  /**
   * Log repository error
   *
   * @param operation - Operation name
   * @param error - Error object
   */
  protected logError(operation: string, error: any): void {
    console.error(`[${this.entityType}Repository] ${operation} failed:`, error);
  }
}

```

## database/repositories/base/index.ts

```typescript
/**
 * Location: src/database/repositories/base/index.ts
 *
 * Base Repository Infrastructure Exports
 */

export { BaseRepository } from './BaseRepository';
export type { RepositoryDependencies } from './BaseRepository';

```

## database/repositories/ConversationRepository.ts

```typescript
/**
 * Location: src/database/repositories/ConversationRepository.ts
 *
 * Conversation Repository
 *
 * Manages conversation entity persistence using hybrid JSONL + SQLite storage.
 * Each conversation has its own JSONL file containing metadata and messages.
 *
 * Storage Strategy:
 * - JSONL: conversations/conv_{id}.jsonl (source of truth)
 * - SQLite: conversations table (cache for fast queries)
 * - FTS: Full-text search on title
 *
 * Related Files:
 * - src/database/repositories/interfaces/IConversationRepository.ts - Interface
 * - src/database/repositories/base/BaseRepository.ts - Base class
 * - src/types/storage/HybridStorageTypes.ts - Data types
 */

import { BaseRepository, RepositoryDependencies } from './base/BaseRepository';
import { IConversationRepository, CreateConversationData, UpdateConversationData } from './interfaces/IConversationRepository';
import { ConversationMetadata } from '../../types/storage/HybridStorageTypes';
import { ConversationCreatedEvent, ConversationUpdatedEvent } from '../interfaces/StorageEvents';
import { PaginatedResult, PaginationParams } from '../../types/pagination/PaginationTypes';
import { QueryOptions } from '../interfaces/IStorageAdapter';

/**
 * Conversation repository implementation
 *
 * Stores conversation metadata in SQLite for fast queries.
 * Each conversation has its own JSONL file for messages and events.
 */
export class ConversationRepository
  extends BaseRepository<ConversationMetadata>
  implements IConversationRepository {

  protected readonly tableName = 'conversations';
  protected readonly entityType = 'conversation';

  protected jsonlPath(id: string): string {
    return `conversations/conv_${id}.jsonl`;
  }

  constructor(deps: RepositoryDependencies) {
    super(deps);
  }

  // ============================================================================
  // Abstract method implementations
  // ============================================================================

  protected rowToEntity(row: any): ConversationMetadata {
    return this.rowToConversation(row);
  }

  async getAll(options?: PaginationParams): Promise<PaginatedResult<ConversationMetadata>> {
    return this.getConversations(options);
  }

  // ============================================================================
  // Read Operations
  // ============================================================================

  /**
   * Get a conversation by ID
   */
  async getById(id: string): Promise<ConversationMetadata | null> {
    return this.getCachedOrFetch(
      `${this.entityType}:${id}`,
      async () => {
        const row = await this.sqliteCache.queryOne<any>(
          `SELECT * FROM ${this.tableName} WHERE id = ?`,
          [id]
        );
        return row ? this.rowToConversation(row) : null;
      }
    );
  }

  /**
   * Get all conversations with pagination and filtering
   */
  async getConversations(options?: QueryOptions): Promise<PaginatedResult<ConversationMetadata>> {
    const page = options?.page ?? 0;
    const pageSize = Math.min(options?.pageSize ?? 25, 200);
    const sortBy = options?.sortBy ?? 'updated';
    const sortOrder = options?.sortOrder ?? 'desc';
    const includeBranches = options?.includeBranches ?? false;

    // Build WHERE clause
    const filters: string[] = [];
    const params: any[] = [];

    // Exclude branches by default (branches have parentConversationId in metadata)
    if (!includeBranches) {
      filters.push(`(metadataJson IS NULL OR metadataJson NOT LIKE '%"parentConversationId"%')`);
    }

    if (options?.filter) {
      if (options.filter.vaultName) {
        filters.push('vaultName = ?');
        params.push(options.filter.vaultName);
      }
      // Note: workspaceId filter not supported - column not in schema
    }

    const whereClause = filters.length > 0 ? `WHERE ${filters.join(' AND ')}` : '';

    // Count total
    const countResult = await this.sqliteCache.queryOne<{ count: number }>(
      `SELECT COUNT(*) as count FROM ${this.tableName} ${whereClause}`,
      params
    );
    const totalItems = countResult?.count ?? 0;

    // Get data
    const rows = await this.sqliteCache.query<any>(
      `SELECT * FROM ${this.tableName} ${whereClause}
       ORDER BY ${sortBy} ${sortOrder}
       LIMIT ? OFFSET ?`,
      [...params, pageSize, page * pageSize]
    );

    return {
      items: rows.map((r: any) => this.rowToConversation(r)),
      page,
      pageSize,
      totalItems,
      totalPages: Math.ceil(totalItems / pageSize),
      hasNextPage: (page + 1) * pageSize < totalItems,
      hasPreviousPage: page > 0
    };
  }

  /**
   * Search conversations by title using FTS
   */
  async search(query: string): Promise<ConversationMetadata[]> {
    const rows = await this.sqliteCache.searchConversations(query);
    return rows.map((r: any) => this.rowToConversation(r));
  }

  /**
   * Count conversations matching filter
   */
  async count(filter?: Record<string, any>): Promise<number> {
    let whereClause = '';
    const params: any[] = [];

    if (filter) {
      const filters: string[] = [];
      if (filter.vaultName) {
        filters.push('vaultName = ?');
        params.push(filter.vaultName);
      }
      if (filters.length > 0) {
        whereClause = `WHERE ${filters.join(' AND ')}`;
      }
    }

    const result = await this.sqliteCache.queryOne<{ count: number }>(
      `SELECT COUNT(*) as count FROM ${this.tableName} ${whereClause}`,
      params
    );
    return result?.count ?? 0;
  }

  // ============================================================================
  // Write Operations
  // ============================================================================

  /**
   * Create a new conversation
   */
  async create(data: CreateConversationData): Promise<string> {
    const id = this.generateId();
    const now = Date.now();

    try {
      // 1. Write metadata event to JSONL (includes settings for branch metadata, etc.)
      const eventData: Omit<ConversationCreatedEvent, 'id' | 'deviceId' | 'timestamp'> = {
        type: 'metadata',
        data: {
          id,
          title: data.title,
          created: data.created ?? now,
          vault: data.vaultName,
          settings: data.metadata  // Store arbitrary metadata (parentConversationId, branchType, etc.)
        }
      };
      await this.writeEvent<ConversationCreatedEvent>(
        this.jsonlPath(id),
        eventData
      );

      // 2. Update SQLite cache
      await this.sqliteCache.run(
        `INSERT INTO ${this.tableName} (id, title, created, updated, vaultName, messageCount, metadataJson)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          id,
          data.title,
          data.created ?? now,
          data.updated ?? now,
          data.vaultName,
          0,
          data.metadata ? JSON.stringify(data.metadata) : null
        ]
      );

      // 3. Invalidate cache
      this.invalidateCache();

      return id;

    } catch (error) {
      console.error('[ConversationRepository] Failed to create conversation:', error);
      throw error;
    }
  }

  /**
   * Update an existing conversation
   */
  async update(id: string, data: UpdateConversationData): Promise<void> {
    try {
      // 1. Write update event to JSONL
      const eventData: Omit<ConversationUpdatedEvent, 'id' | 'deviceId' | 'timestamp'> = {
        type: 'conversation_updated',
        conversationId: id,
        data: {
          title: data.title,
          updated: data.updated ?? Date.now(),
          settings: data.metadata
        }
      };
      await this.writeEvent<ConversationUpdatedEvent>(
        this.jsonlPath(id),
        eventData
      );

      // 2. Update SQLite cache
      const setClauses: string[] = [];
      const params: any[] = [];

      if (data.title !== undefined) {
        setClauses.push('title = ?');
        params.push(data.title);
      }
      // Note: workspaceId and sessionId are not in SQLite schema
      // They are stored in metadataJson if needed
      if (data.metadata !== undefined) {
        setClauses.push('metadataJson = ?');
        params.push(data.metadata ? JSON.stringify(data.metadata) : null);
      }

      // Always update timestamp
      setClauses.push('updated = ?');
      params.push(data.updated ?? Date.now());

      params.push(id);

      await this.sqliteCache.run(
        `UPDATE ${this.tableName} SET ${setClauses.join(', ')} WHERE id = ?`,
        params
      );

      // 3. Invalidate cache
      this.invalidateCache(id);

    } catch (error) {
      console.error('[ConversationRepository] Failed to update conversation:', error);
      throw error;
    }
  }

  /**
   * Delete a conversation
   */
  async delete(id: string): Promise<void> {
    try {
      // No specific delete event - just remove from SQLite
      // Messages are cascaded via foreign key constraint
      await this.sqliteCache.run(`DELETE FROM ${this.tableName} WHERE id = ?`, [id]);

      // Invalidate cache
      this.invalidateCache();

    } catch (error) {
      console.error('[ConversationRepository] Failed to delete conversation:', error);
      throw error;
    }
  }

  /**
   * Increment message count for a conversation
   */
  async incrementMessageCount(id: string): Promise<void> {
    try {
      await this.sqliteCache.run(
        `UPDATE ${this.tableName} SET messageCount = messageCount + 1, updated = ? WHERE id = ?`,
        [Date.now(), id]
      );

      this.invalidateCache(id);

    } catch (error) {
      console.error('[ConversationRepository] Failed to increment message count:', error);
      throw error;
    }
  }

  /**
   * Touch a conversation (update timestamp)
   */
  async touch(id: string, timestamp?: number): Promise<void> {
    try {
      await this.sqliteCache.run(
        `UPDATE ${this.tableName} SET updated = ? WHERE id = ?`,
        [timestamp ?? Date.now(), id]
      );

      this.invalidateCache(id);

    } catch (error) {
      console.error('[ConversationRepository] Failed to touch conversation:', error);
      throw error;
    }
  }

  // ============================================================================
  // Helper Methods
  // ============================================================================

  /**
   * Convert SQLite row to ConversationMetadata
   */
  private rowToConversation(row: any): ConversationMetadata {
    const metadata = row.metadataJson ? JSON.parse(row.metadataJson) : undefined;
    return {
      id: row.id,
      title: row.title,
      created: row.created,
      updated: row.updated,
      vaultName: row.vaultName,
      messageCount: row.messageCount,
      // workspaceId and sessionId stored in metadata if needed
      workspaceId: metadata?.workspaceId,
      sessionId: metadata?.sessionId,
      metadata
    };
  }
}

```

## database/repositories/index.ts

```typescript
/**
 * Location: src/database/repositories/index.ts
 *
 * Repository Module Exports
 *
 * Central export point for all repository classes and interfaces.
 * Simplifies imports throughout the application.
 *
 * Usage:
 * ```typescript
 * import {
 *   WorkspaceRepository,
 *   SessionRepository,
 *   IWorkspaceRepository
 * } from '@/database/repositories';
 * ```
 */

// Base repository and dependencies
export { BaseRepository } from './base/BaseRepository';
export type { RepositoryDependencies } from './base/BaseRepository';

// Repository interfaces
export type { IRepository } from './interfaces/IRepository';
export type {
  IWorkspaceRepository,
  CreateWorkspaceData,
  UpdateWorkspaceData
} from './interfaces/IWorkspaceRepository';
export type {
  ISessionRepository,
  CreateSessionData,
  UpdateSessionData
} from './interfaces/ISessionRepository';
export type {
  IStateRepository,
  SaveStateData
} from './interfaces/IStateRepository';
export type {
  ITraceRepository,
  AddTraceData
} from './interfaces/ITraceRepository';

// Repository implementations
export { WorkspaceRepository } from './WorkspaceRepository';
export { SessionRepository } from './SessionRepository';
export { StateRepository } from './StateRepository';
export { TraceRepository } from './TraceRepository';

```

## database/repositories/interfaces/IConversationRepository.ts

```typescript
/**
 * Location: src/database/repositories/interfaces/IConversationRepository.ts
 *
 * Conversation Repository Interface
 *
 * Defines the contract for conversation persistence operations.
 * Follows Interface Segregation Principle - only conversation-specific methods.
 *
 * Related Files:
 * - src/database/repositories/ConversationRepository.ts - Implementation
 * - src/types/storage/HybridStorageTypes.ts - Data types
 */

import { PaginatedResult, PaginationParams } from '../../../types/pagination/PaginationTypes';
import { ConversationMetadata } from '../../../types/storage/HybridStorageTypes';
import { QueryOptions } from '../../interfaces/IStorageAdapter';

/**
 * Data for creating a new conversation
 */
export interface CreateConversationData extends Omit<ConversationMetadata, 'id' | 'messageCount'> {
  // All fields from ConversationMetadata except id and messageCount
}

/**
 * Data for updating an existing conversation
 */
export interface UpdateConversationData extends Partial<ConversationMetadata> {
  // Partial updates allowed for all fields
}

/**
 * Conversation repository interface
 */
export interface IConversationRepository {
  /**
   * Get a conversation by ID
   */
  getById(id: string): Promise<ConversationMetadata | null>;

  /**
   * Get all conversations with pagination and filtering
   */
  getConversations(options?: QueryOptions): Promise<PaginatedResult<ConversationMetadata>>;

  /**
   * Create a new conversation
   */
  create(data: CreateConversationData): Promise<string>;

  /**
   * Update an existing conversation
   */
  update(id: string, data: UpdateConversationData): Promise<void>;

  /**
   * Delete a conversation
   */
  delete(id: string): Promise<void>;

  /**
   * Search conversations by title
   */
  search(query: string): Promise<ConversationMetadata[]>;

  /**
   * Increment message count for a conversation
   */
  incrementMessageCount(id: string): Promise<void>;

  /**
   * Touch a conversation (update timestamp)
   */
  touch(id: string, timestamp?: number): Promise<void>;

  /**
   * Count conversations matching filter
   */
  count(filter?: Record<string, any>): Promise<number>;
}

```

## database/repositories/interfaces/IMessageRepository.ts

```typescript
/**
 * Location: src/database/repositories/interfaces/IMessageRepository.ts
 *
 * Message Repository Interface
 *
 * Defines the contract for message persistence operations.
 * Messages are stored in conversation JSONL files in OpenAI format.
 *
 * Related Files:
 * - src/database/repositories/MessageRepository.ts - Implementation
 * - src/types/storage/HybridStorageTypes.ts - Data types
 */

import { PaginatedResult, PaginationParams } from '../../../types/pagination/PaginationTypes';
import { MessageData, AlternativeMessage } from '../../../types/storage/HybridStorageTypes';

/**
 * Data for creating a new message
 */
export interface CreateMessageData extends Omit<MessageData, 'id' | 'conversationId' | 'sequenceNumber'> {
  /**
   * Optional custom message ID (used for streaming placeholders so UI/storage IDs stay in sync)
   */
  id?: string;
}

/**
 * Data for updating an existing message
 * Only content, state, reasoning, tool call data, and alternatives can be updated
 */
export interface UpdateMessageData {
  content?: string | null;
  state?: 'draft' | 'streaming' | 'complete' | 'aborted' | 'invalid';
  reasoning?: string;
  toolCalls?: MessageData['toolCalls'];
  toolCallId?: string | null;
  /** Alternative responses for branching */
  alternatives?: AlternativeMessage[];
  /** Which alternative is active: 0 = original, 1+ = alternative index + 1 */
  activeAlternativeIndex?: number;
}

/**
 * Message repository interface
 */
export interface IMessageRepository {
  /**
   * Get messages for a conversation (paginated, ordered by sequence number)
   */
  getMessages(conversationId: string, options?: PaginationParams): Promise<PaginatedResult<MessageData>>;

  /**
   * Add a new message to a conversation
   * Sequence number is auto-incremented
   */
  addMessage(conversationId: string, data: CreateMessageData): Promise<string>;

  /**
   * Update an existing message
   * Only content, state, and reasoning can be updated
   */
  update(messageId: string, data: UpdateMessageData): Promise<void>;

  /**
   * Delete a message from a conversation
   */
  deleteMessage(conversationId: string, messageId: string): Promise<void>;

  /**
   * Get the next sequence number for a conversation
   */
  getNextSequenceNumber(conversationId: string): Promise<number>;

  /**
   * Count messages in a conversation
   */
  countMessages(conversationId: string): Promise<number>;
}

```

## database/repositories/interfaces/index.ts

```typescript
/**
 * Location: src/database/repositories/interfaces/index.ts
 *
 * Repository Interfaces Exports
 *
 * Central export point for all repository interfaces. This provides a single
 * import location for services that depend on repository abstractions.
 *
 * Design Principles:
 * - Dependency Inversion: Services depend on interfaces, not implementations
 * - Single Responsibility: Each interface defines one entity's contract
 * - Interface Segregation: Minimal, focused interfaces
 *
 * Related Files:
 * - src/database/repositories/index.ts - Repository implementations export
 * - src/services/*.ts - Services that use these interfaces
 */

// Base repository interfaces
export type { IRepository } from './IRepository';

// Workspace-related repository interfaces
export type { IWorkspaceRepository } from './IWorkspaceRepository';
export type { CreateWorkspaceData } from './IWorkspaceRepository';
export type { UpdateWorkspaceData } from './IWorkspaceRepository';

export type { ISessionRepository } from './ISessionRepository';
export type { CreateSessionData } from './ISessionRepository';
export type { UpdateSessionData } from './ISessionRepository';

export type { IStateRepository } from './IStateRepository';
export type { SaveStateData } from './IStateRepository';

export type { ITraceRepository } from './ITraceRepository';
export type { AddTraceData } from './ITraceRepository';

// Conversation-related repository interfaces
export type { IConversationRepository } from './IConversationRepository';
export type { CreateConversationData } from './IConversationRepository';
export type { UpdateConversationData } from './IConversationRepository';

export type { IMessageRepository } from './IMessageRepository';
export type { CreateMessageData } from './IMessageRepository';
export type { UpdateMessageData } from './IMessageRepository';

```

## database/repositories/interfaces/IRepository.ts

```typescript
/**
 * Location: src/database/repositories/interfaces/IRepository.ts
 *
 * Base Repository Interface
 *
 * Defines the standard CRUD operations that all repositories must implement.
 * This interface ensures consistency across all entity repositories.
 *
 * Design Principles:
 * - Generic type T for the entity being managed
 * - Standard CRUD operations (Create, Read, Update, Delete)
 * - Pagination support for list operations
 * - Count operations for statistics
 *
 * Related Files:
 * - src/database/repositories/base/BaseRepository.ts - Base implementation
 * - src/database/repositories/interfaces/I*Repository.ts - Entity-specific interfaces
 */

import { PaginatedResult, PaginationParams } from '../../../types/pagination/PaginationTypes';

/**
 * Base repository interface for CRUD operations
 *
 * @template T - The entity type this repository manages
 */
export interface IRepository<T> {
  /**
   * Get a single entity by ID
   *
   * @param id - Entity ID
   * @returns Entity instance or null if not found
   */
  getById(id: string): Promise<T | null>;

  /**
   * Get all entities with optional pagination
   *
   * @param options - Pagination options
   * @returns Paginated list of entities
   */
  getAll(options?: PaginationParams): Promise<PaginatedResult<T>>;

  /**
   * Create a new entity
   *
   * @param data - Entity data
   * @returns ID of the created entity
   */
  create(data: any): Promise<string>;

  /**
   * Update an existing entity
   *
   * @param id - Entity ID
   * @param data - Partial entity data to update
   */
  update(id: string, data: any): Promise<void>;

  /**
   * Delete an entity
   *
   * @param id - Entity ID
   */
  delete(id: string): Promise<void>;

  /**
   * Count entities with optional criteria
   *
   * @param criteria - Optional filter criteria
   * @returns Number of entities matching criteria
   */
  count(criteria?: Record<string, any>): Promise<number>;
}

```

## database/repositories/interfaces/ISessionRepository.ts

```typescript
/**
 * Location: src/database/repositories/interfaces/ISessionRepository.ts
 *
 * Session Repository Interface
 *
 * Defines session-specific operations for managing work sessions within workspaces.
 * Sessions represent periods of focused work and contain states and traces.
 *
 * Related Files:
 * - src/database/repositories/SessionRepository.ts - Implementation
 * - src/types/storage/HybridStorageTypes.ts - SessionMetadata type
 */

import { IRepository } from './IRepository';
import { SessionMetadata } from '../../../types/storage/HybridStorageTypes';
import { PaginatedResult, PaginationParams } from '../../../types/pagination/PaginationTypes';

/**
 * Data required to create a new session
 */
export interface CreateSessionData {
  name: string;
  description?: string;
  startTime?: number;
  isActive?: boolean;
}

/**
 * Data for updating an existing session
 */
export interface UpdateSessionData {
  name?: string;
  description?: string;
  endTime?: number;
  isActive?: boolean;
}

/**
 * Session repository interface
 */
export interface ISessionRepository extends IRepository<SessionMetadata> {
  /**
   * Get all sessions for a workspace
   *
   * @param workspaceId - Parent workspace ID
   * @param options - Pagination options
   * @returns Paginated list of sessions
   */
  getByWorkspaceId(
    workspaceId: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<SessionMetadata>>;

  /**
   * Get the currently active session for a workspace
   *
   * @param workspaceId - Parent workspace ID
   * @returns Active session or null if none active
   */
  getActiveSession(workspaceId: string): Promise<SessionMetadata | null>;

  /**
   * End a session by setting its endTime and marking it inactive
   *
   * @param id - Session ID
   */
  endSession(id: string): Promise<void>;

  /**
   * Count sessions for a workspace
   *
   * @param workspaceId - Parent workspace ID
   * @returns Number of sessions
   */
  countByWorkspace(workspaceId: string): Promise<number>;
}

```

## database/repositories/interfaces/IStateRepository.ts

```typescript
/**
 * Location: src/database/repositories/interfaces/IStateRepository.ts
 *
 * State Repository Interface
 *
 * Defines state-specific operations for managing workspace state snapshots.
 * States are named snapshots that can be resumed later to continue work.
 *
 * Related Files:
 * - src/database/repositories/StateRepository.ts - Implementation
 * - src/types/storage/HybridStorageTypes.ts - StateMetadata, StateData types
 */

import { IRepository } from './IRepository';
import { StateMetadata, StateData } from '../../../types/storage/HybridStorageTypes';
import { PaginatedResult, PaginationParams } from '../../../types/pagination/PaginationTypes';

/**
 * Data required to create/save a state
 */
export interface SaveStateData {
  name: string;
  description?: string;
  created?: number;
  content: any;
  tags?: string[];
}

/**
 * State repository interface
 */
export interface IStateRepository extends IRepository<StateMetadata> {
  /**
   * Get states for a workspace or session
   *
   * @param workspaceId - Parent workspace ID
   * @param sessionId - Optional session ID to filter by
   * @param options - Pagination options
   * @returns Paginated list of state metadata
   */
  getStates(
    workspaceId: string,
    sessionId?: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<StateMetadata>>;

  /**
   * Get full state data including content
   *
   * @param id - State ID
   * @returns Full state data or null if not found
   */
  getStateData(id: string): Promise<StateData | null>;

  /**
   * Save a new state (includes full content)
   *
   * @param workspaceId - Parent workspace ID
   * @param sessionId - Parent session ID
   * @param data - State data
   * @returns ID of the created state
   */
  saveState(
    workspaceId: string,
    sessionId: string,
    data: SaveStateData
  ): Promise<string>;

  /**
   * Count states for a workspace or session
   *
   * @param workspaceId - Parent workspace ID
   * @param sessionId - Optional session ID to filter by
   * @returns Number of states
   */
  countStates(workspaceId: string, sessionId?: string): Promise<number>;

  /**
   * Get states by tag
   *
   * @param tag - Tag to search for
   * @param options - Pagination options
   * @returns Paginated list of states with the tag
   */
  getByTag(tag: string, options?: PaginationParams): Promise<PaginatedResult<StateMetadata>>;
}

```

## database/repositories/interfaces/ITraceRepository.ts

```typescript
/**
 * Location: src/database/repositories/interfaces/ITraceRepository.ts
 *
 * Trace Repository Interface
 *
 * Defines trace-specific operations for managing memory traces.
 * Traces record significant events and context during work sessions.
 *
 * Related Files:
 * - src/database/repositories/TraceRepository.ts - Implementation
 * - src/types/storage/HybridStorageTypes.ts - MemoryTraceData type
 */

import { IRepository } from './IRepository';
import { MemoryTraceData } from '../../../types/storage/HybridStorageTypes';
import { PaginatedResult, PaginationParams } from '../../../types/pagination/PaginationTypes';

/**
 * Data required to add a trace
 */
export interface AddTraceData {
  content: string;
  type?: string;
  metadata?: Record<string, any>;
  timestamp?: number;
}

/**
 * Trace repository interface
 */
export interface ITraceRepository extends IRepository<MemoryTraceData> {
  /**
   * Get traces for a workspace or session
   *
   * @param workspaceId - Parent workspace ID
   * @param sessionId - Optional session ID to filter by
   * @param options - Pagination options
   * @returns Paginated list of traces
   */
  getTraces(
    workspaceId: string,
    sessionId?: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<MemoryTraceData>>;

  /**
   * Add a new trace
   *
   * @param workspaceId - Parent workspace ID
   * @param sessionId - Parent session ID
   * @param data - Trace data
   * @returns ID of the created trace
   */
  addTrace(
    workspaceId: string,
    sessionId: string,
    data: AddTraceData
  ): Promise<string>;

  /**
   * Search traces by content
   *
   * @param workspaceId - Workspace ID to search within
   * @param query - Search query
   * @param sessionId - Optional session ID to filter by
   * @param options - Pagination options
   * @returns Paginated list of matching traces
   */
  searchTraces(
    workspaceId: string,
    query: string,
    sessionId?: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<MemoryTraceData>>;

  /**
   * Get traces by type
   *
   * @param workspaceId - Parent workspace ID
   * @param type - Trace type
   * @param options - Pagination options
   * @returns Paginated list of traces of that type
   */
  getByType(
    workspaceId: string,
    type: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<MemoryTraceData>>;

  /**
   * Count traces for a workspace or session
   *
   * @param workspaceId - Parent workspace ID
   * @param sessionId - Optional session ID to filter by
   * @returns Number of traces
   */
  countTraces(workspaceId: string, sessionId?: string): Promise<number>;
}

```

## database/repositories/interfaces/IWorkspaceRepository.ts

```typescript
/**
 * Location: src/database/repositories/interfaces/IWorkspaceRepository.ts
 *
 * Workspace Repository Interface
 *
 * Defines workspace-specific operations beyond basic CRUD.
 * Workspaces organize sessions, states, and traces into logical boundaries.
 *
 * Related Files:
 * - src/database/repositories/WorkspaceRepository.ts - Implementation
 * - src/types/storage/HybridStorageTypes.ts - WorkspaceMetadata type
 */

import { IRepository } from './IRepository';
import { WorkspaceMetadata, WorkspaceContext } from '../../../types/storage/HybridStorageTypes';
import { PaginatedResult } from '../../../types/pagination/PaginationTypes';
import { QueryOptions } from '../../interfaces/IStorageAdapter';

/**
 * Data required to create a new workspace
 */
export interface CreateWorkspaceData {
  /** Optional custom ID (e.g., 'default' for the default workspace) */
  id?: string;
  name: string;
  description?: string;
  rootFolder: string;
  created?: number;
  isActive?: boolean;
  dedicatedAgentId?: string;
  /** Workspace context (purpose, workflows, keyFiles, etc.) */
  context?: WorkspaceContext;
}

/**
 * Data for updating an existing workspace
 */
export interface UpdateWorkspaceData {
  name?: string;
  description?: string;
  rootFolder?: string;
  lastAccessed?: number;
  isActive?: boolean;
  dedicatedAgentId?: string;
  /** Workspace context (purpose, workflows, keyFiles, etc.) */
  context?: WorkspaceContext;
}

/**
 * Workspace repository interface
 */
export interface IWorkspaceRepository extends IRepository<WorkspaceMetadata> {
  /**
   * Get all workspaces with optional filtering and sorting
   *
   * @param options - Query options (pagination, sorting, filtering)
   * @returns Paginated list of workspaces
   */
  getWorkspaces(options?: QueryOptions): Promise<PaginatedResult<WorkspaceMetadata>>;

  /**
   * Get a workspace by name
   *
   * @param name - Workspace name
   * @returns Workspace metadata or null if not found
   */
  getByName(name: string): Promise<WorkspaceMetadata | null>;

  /**
   * Update the last accessed timestamp for a workspace
   *
   * @param id - Workspace ID
   */
  updateLastAccessed(id: string): Promise<void>;

  /**
   * Search workspaces by name or description
   *
   * @param query - Search query
   * @returns Array of matching workspaces
   */
  search(query: string): Promise<WorkspaceMetadata[]>;
}

```

## database/repositories/MessageRepository.ts

```typescript
/**
 * Location: src/database/repositories/MessageRepository.ts
 *
 * Message Repository
 *
 * Manages message persistence in conversation JSONL files.
 * Messages are stored in OpenAI fine-tuning format with auto-incrementing sequence numbers.
 *
 * Storage Strategy:
 * - JSONL: conversations/conv_{conversationId}.jsonl (source of truth)
 * - SQLite: messages table (cache for fast queries and pagination)
 * - Ordering: By sequenceNumber (auto-incremented)
 *
 * Related Files:
 * - src/database/repositories/interfaces/IMessageRepository.ts - Interface
 * - src/database/repositories/base/BaseRepository.ts - Base class
 * - src/types/storage/HybridStorageTypes.ts - Data types
 */

import { BaseRepository, RepositoryDependencies } from './base/BaseRepository';
import { IMessageRepository, CreateMessageData, UpdateMessageData } from './interfaces/IMessageRepository';
import { MessageData, AlternativeMessage } from '../../types/storage/HybridStorageTypes';
import { MessageEvent, MessageUpdatedEvent, AlternativeMessageEvent } from '../interfaces/StorageEvents';
import { PaginatedResult, PaginationParams } from '../../types/pagination/PaginationTypes';

/**
 * Message repository implementation
 *
 * Messages are appended to conversation JSONL files in OpenAI format.
 * Each message has an auto-incrementing sequence number for ordering.
 */
export class MessageRepository
  extends BaseRepository<MessageData>
  implements IMessageRepository {

  protected readonly tableName = 'messages';
  protected readonly entityType = 'message';

  protected jsonlPath(conversationId: string): string {
    return `conversations/conv_${conversationId}.jsonl`;
  }

  constructor(deps: RepositoryDependencies) {
    super(deps);
  }

  // ============================================================================
  // Abstract method implementations
  // ============================================================================

  protected rowToEntity(row: any): MessageData {
    return this.rowToMessage(row);
  }

  async getById(id: string): Promise<MessageData | null> {
    const row = await this.sqliteCache.queryOne<any>(
      `SELECT * FROM ${this.tableName} WHERE id = ?`,
      [id]
    );
    return row ? this.rowToMessage(row) : null;
  }

  async getAll(options?: PaginationParams): Promise<PaginatedResult<MessageData>> {
    // Messages don't have a global getAll - they are per conversation
    // Return empty result - use getMessages instead
    return {
      items: [],
      page: 0,
      pageSize: options?.pageSize ?? 50,
      totalItems: 0,
      totalPages: 0,
      hasNextPage: false,
      hasPreviousPage: false
    };
  }

  async create(data: any): Promise<string> {
    // Use addMessage with conversationId
    throw new Error('Use addMessage(conversationId, data) instead');
  }

  async delete(id: string): Promise<void> {
    await this.sqliteCache.run(`DELETE FROM ${this.tableName} WHERE id = ?`, [id]);
    this.invalidateCache();
  }

  async count(criteria?: Record<string, any>): Promise<number> {
    if (criteria?.conversationId) {
      return this.countMessages(criteria.conversationId);
    }
    const result = await this.sqliteCache.queryOne<{ count: number }>(
      `SELECT COUNT(*) as count FROM ${this.tableName}`,
      []
    );
    return result?.count ?? 0;
  }

  // ============================================================================
  // Read Operations
  // ============================================================================

  /**
   * Get messages for a conversation (paginated, ordered by sequence number)
   */
  async getMessages(
    conversationId: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<MessageData>> {
    const page = options?.page ?? 0;
    const pageSize = Math.min(options?.pageSize ?? 50, 200);

    // Count total
    const countResult = await this.sqliteCache.queryOne<{ count: number }>(
      `SELECT COUNT(*) as count FROM ${this.tableName} WHERE conversationId = ?`,
      [conversationId]
    );
    const totalItems = countResult?.count ?? 0;

    // Get data (ordered by sequence number)
    const rows = await this.sqliteCache.query<any>(
      `SELECT * FROM ${this.tableName} WHERE conversationId = ?
       ORDER BY sequenceNumber ASC
       LIMIT ? OFFSET ?`,
      [conversationId, pageSize, page * pageSize]
    );

    return {
      items: rows.map((r: any) => this.rowToMessage(r)),
      page,
      pageSize,
      totalItems,
      totalPages: Math.ceil(totalItems / pageSize),
      hasNextPage: (page + 1) * pageSize < totalItems,
      hasPreviousPage: page > 0
    };
  }

  /**
   * Count messages in a conversation
   */
  async countMessages(conversationId: string): Promise<number> {
    const result = await this.sqliteCache.queryOne<{ count: number }>(
      `SELECT COUNT(*) as count FROM ${this.tableName} WHERE conversationId = ?`,
      [conversationId]
    );
    return result?.count ?? 0;
  }

  /**
   * Get the next sequence number for a conversation
   */
  async getNextSequenceNumber(conversationId: string): Promise<number> {
    const result = await this.sqliteCache.queryOne<{ maxSeq: number }>(
      `SELECT MAX(sequenceNumber) as maxSeq FROM ${this.tableName} WHERE conversationId = ?`,
      [conversationId]
    );
    return (result?.maxSeq ?? -1) + 1;
  }

  // ============================================================================
  // Write Operations
  // ============================================================================

  /**
   * Add a new message to a conversation
   * Sequence number is auto-incremented
   */
  async addMessage(conversationId: string, data: CreateMessageData): Promise<string> {
    const id = data.id || this.generateId();

    try {
      // Get next sequence number
      const sequenceNumber = await this.getNextSequenceNumber(conversationId);

      // 1. Write message event to conversation JSONL
      await this.writeEvent<MessageEvent>(
        this.jsonlPath(conversationId),
        {
          type: 'message',
          conversationId,
          data: {
            id,
            role: data.role,
            content: data.content,
            tool_calls: data.toolCalls?.map(tc => ({
              id: tc.id,
              type: tc.type || 'function',
              function: tc.function,
              // Persist extras so tool bubbles can be reconstructed after reload
              name: tc.name,
              parameters: tc.parameters,
              result: tc.result,
              success: tc.success,
              error: tc.error,
              executionTime: tc.executionTime
            })),
            tool_call_id: data.toolCallId,
            state: data.state,
            sequenceNumber,
            // Branching support
            alternatives: this.convertAlternativesToEvent(data.alternatives),
            activeAlternativeIndex: data.activeAlternativeIndex ?? 0
          }
        }
      );

      // 2. Update SQLite cache
      await this.sqliteCache.run(
        `INSERT INTO ${this.tableName}
         (id, conversationId, role, content, timestamp, state, toolCallsJson, toolCallId, sequenceNumber, reasoningContent, alternativesJson, activeAlternativeIndex)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          id,
          conversationId,
          data.role,
          data.content,
          data.timestamp,
          data.state ?? 'complete',
          data.toolCalls ? JSON.stringify(data.toolCalls) : null,
          data.toolCallId ?? null,
          sequenceNumber,
          data.reasoning ?? null,
          data.alternatives ? JSON.stringify(data.alternatives) : null,
          data.activeAlternativeIndex ?? 0
        ]
      );

      // 3. Invalidate cache
      this.invalidateCache();

      return id;

    } catch (error) {
      console.error('[MessageRepository] Failed to add message:', error);
      throw error;
    }
  }

  /**
   * Update an existing message
   * Only content, state, reasoning, and tool call data can be updated
   */
  async update(messageId: string, data: UpdateMessageData): Promise<void> {
    try {
      // Get message to find conversation ID
      const message = await this.sqliteCache.queryOne<any>(
        `SELECT conversationId FROM ${this.tableName} WHERE id = ?`,
        [messageId]
      );

      if (!message) {
        throw new Error(`Message ${messageId} not found`);
      }

      // 1. Write update event to JSONL
      await this.writeEvent<MessageUpdatedEvent>(
        this.jsonlPath(message.conversationId),
        {
          type: 'message_updated',
          conversationId: message.conversationId,
          messageId,
          data: {
            content: data.content ?? undefined,
            state: data.state,
            reasoning: data.reasoning,
            // Persist full tool call data including results so tool bubbles can be reconstructed
            tool_calls: data.toolCalls?.map(tc => ({
              id: tc.id,
              type: tc.type || 'function',
              function: tc.function,
              name: tc.name,
              parameters: tc.parameters,
              result: tc.result,
              success: tc.success,
              error: tc.error
            })),
            tool_call_id: data.toolCallId ?? undefined,
            // Branching support
            alternatives: this.convertAlternativesToEvent(data.alternatives),
            activeAlternativeIndex: data.activeAlternativeIndex
          }
        }
      );

      // 2. Update SQLite cache
      const setClauses: string[] = [];
      const params: any[] = [];

      if (data.content !== undefined) {
        setClauses.push('content = ?');
        params.push(data.content);
      }
      if (data.state !== undefined) {
        setClauses.push('state = ?');
        params.push(data.state);
      }
      if (data.reasoning !== undefined) {
        setClauses.push('reasoningContent = ?');
        params.push(data.reasoning);
      }
      if (data.toolCalls !== undefined) {
        setClauses.push('toolCallsJson = ?');
        params.push(data.toolCalls ? JSON.stringify(data.toolCalls) : null);
      }
      if (data.toolCallId !== undefined) {
        setClauses.push('toolCallId = ?');
        params.push(data.toolCallId);
      }
      if (data.alternatives !== undefined) {
        setClauses.push('alternativesJson = ?');
        params.push(data.alternatives ? JSON.stringify(data.alternatives) : null);
      }
      if (data.activeAlternativeIndex !== undefined) {
        setClauses.push('activeAlternativeIndex = ?');
        params.push(data.activeAlternativeIndex);
      }

      if (setClauses.length > 0) {
        params.push(messageId);
        await this.sqliteCache.run(
          `UPDATE ${this.tableName} SET ${setClauses.join(', ')} WHERE id = ?`,
          params
        );
      }

      // 3. Invalidate cache
      this.invalidateCache();

    } catch (error) {
      console.error('[MessageRepository] Failed to update message:', error);
      throw error;
    }
  }

  /**
   * Delete a message from a conversation
   */
  async deleteMessage(conversationId: string, messageId: string): Promise<void> {
    try {
      // No specific delete event - just remove from SQLite
      await this.sqliteCache.run(`DELETE FROM ${this.tableName} WHERE id = ?`, [messageId]);

      // Invalidate cache
      this.invalidateCache();

    } catch (error) {
      console.error('[MessageRepository] Failed to delete message:', error);
      throw error;
    }
  }

  // ============================================================================
  // Helper Methods
  // ============================================================================

  /**
   * Convert SQLite row to MessageData
   */
  private rowToMessage(row: any): MessageData {
    return {
      id: row.id,
      conversationId: row.conversationId,
      role: row.role,
      content: row.content,
      timestamp: row.timestamp,
      state: row.state ?? 'complete',
      sequenceNumber: row.sequenceNumber,
      toolCalls: row.toolCallsJson ? JSON.parse(row.toolCallsJson) : undefined,
      toolCallId: row.toolCallId ?? undefined,
      reasoning: row.reasoningContent ?? undefined,
      metadata: row.metadataJson ? JSON.parse(row.metadataJson) : undefined,
      alternatives: row.alternativesJson ? JSON.parse(row.alternativesJson) : undefined,
      activeAlternativeIndex: row.activeAlternativeIndex ?? 0
    };
  }

  /**
   * Convert AlternativeMessage[] to AlternativeMessageEvent[] for JSONL storage
   */
  private convertAlternativesToEvent(alternatives?: AlternativeMessage[]): AlternativeMessageEvent[] | undefined {
    if (!alternatives || alternatives.length === 0) {
      return undefined;
    }
    return alternatives.map(alt => ({
      id: alt.id,
      content: alt.content,
      timestamp: alt.timestamp,
      tool_calls: alt.toolCalls?.map(tc => ({
        id: tc.id,
        type: 'function' as const,
        function: tc.function
      })),
      reasoning: alt.reasoning,
      state: alt.state
    }));
  }
}

```

## database/repositories/SessionRepository.ts

```typescript
/**
 * Location: src/database/repositories/SessionRepository.ts
 *
 * Session Repository Implementation
 *
 * Manages session entities within workspaces.
 * Session events are written to the workspace's JSONL file.
 *
 * Design Principles:
 * - Sessions belong to workspaces (parent-child relationship)
 * - Events go to workspace JSONL file: workspaces/ws_[workspaceId].jsonl
 * - SQLite provides fast queries with workspace filtering
 * - Active session tracking for workspace context
 *
 * Related Files:
 * - src/database/repositories/base/BaseRepository.ts - Base functionality
 * - src/database/repositories/interfaces/ISessionRepository.ts - Interface
 * - src/types/storage/HybridStorageTypes.ts - SessionMetadata type
 */

import { BaseRepository, RepositoryDependencies } from './base/BaseRepository';
import {
  ISessionRepository,
  CreateSessionData,
  UpdateSessionData
} from './interfaces/ISessionRepository';
import { SessionMetadata } from '../../types/storage/HybridStorageTypes';
import {
  SessionCreatedEvent,
  SessionUpdatedEvent
} from '../interfaces/StorageEvents';
import { PaginatedResult, PaginationParams } from '../../types/pagination/PaginationTypes';
import { QueryCache } from '../optimizations/QueryCache';

/**
 * Repository for session entities
 *
 * Handles CRUD operations for sessions within workspaces.
 * Events are written to the workspace's JSONL file.
 */
export class SessionRepository
  extends BaseRepository<SessionMetadata>
  implements ISessionRepository {

  protected readonly tableName = 'sessions';
  protected readonly entityType = 'session';
  // Sessions write to workspace JSONL file
  protected readonly jsonlPath = (workspaceId: string) => `workspaces/ws_${workspaceId}.jsonl`;

  constructor(deps: RepositoryDependencies) {
    super(deps);
  }

  // ============================================================================
  // IRepository Implementation
  // ============================================================================

  async getById(id: string): Promise<SessionMetadata | null> {
    // First get the session to find its workspaceId
    const row = await this.sqliteCache.queryOne<any>(
      'SELECT * FROM sessions WHERE id = ?',
      [id]
    );
    return row ? this.rowToEntity(row) : null;
  }

  async getAll(options?: PaginationParams): Promise<PaginatedResult<SessionMetadata>> {
    const baseQuery = 'SELECT * FROM sessions ORDER BY startTime DESC';
    const countQuery = 'SELECT COUNT(*) as count FROM sessions';
    const result = await this.queryPaginated<any>(baseQuery, countQuery, options);
    return {
      items: result.items.map(row => this.rowToEntity(row)),
      page: result.page,
      pageSize: result.pageSize,
      totalItems: result.totalItems,
      totalPages: result.totalPages,
      hasNextPage: result.hasNextPage,
      hasPreviousPage: result.hasPreviousPage
    };
  }

  async create(data: CreateSessionData & { workspaceId: string }): Promise<string> {
    const id = this.generateId();
    const now = Date.now();

    try {
      await this.transaction(async () => {
        // 1. Write event to workspace JSONL
        await this.writeEvent<SessionCreatedEvent>(
          this.jsonlPath(data.workspaceId),
          {
            type: 'session_created',
            workspaceId: data.workspaceId,
            data: {
              id,
              name: data.name,
              description: data.description,
              startTime: data.startTime ?? now
            }
          }
        );

        // 2. Update SQLite cache
        await this.sqliteCache.run(
          `INSERT INTO sessions (id, workspaceId, name, description, startTime, isActive)
           VALUES (?, ?, ?, ?, ?, ?)`,
          [
            id,
            data.workspaceId,
            data.name,
            data.description ?? null,
            data.startTime ?? now,
            data.isActive ? 1 : 0
          ]
        );
      });

      // 3. Invalidate cache
      this.invalidateCache();
      this.log('create', { id, workspaceId: data.workspaceId, name: data.name });

      return id;
    } catch (error) {
      this.logError('create', error);
      throw error;
    }
  }

  async update(id: string, data: UpdateSessionData & { workspaceId: string }): Promise<void> {
    try {
      await this.transaction(async () => {
        // 1. Write event to workspace JSONL
        await this.writeEvent<SessionUpdatedEvent>(
          this.jsonlPath(data.workspaceId),
          {
            type: 'session_updated',
            workspaceId: data.workspaceId,
            sessionId: id,
            data: {
              name: data.name,
              description: data.description,
              endTime: data.endTime,
              isActive: data.isActive
            }
          }
        );

        // 2. Update SQLite cache
        const setClauses: string[] = [];
        const params: any[] = [];

        if (data.name !== undefined) {
          setClauses.push('name = ?');
          params.push(data.name);
        }
        if (data.description !== undefined) {
          setClauses.push('description = ?');
          params.push(data.description);
        }
        if (data.endTime !== undefined) {
          setClauses.push('endTime = ?');
          params.push(data.endTime);
        }
        if (data.isActive !== undefined) {
          setClauses.push('isActive = ?');
          params.push(data.isActive ? 1 : 0);
        }

        if (setClauses.length > 0) {
          params.push(id);
          await this.sqliteCache.run(
            `UPDATE sessions SET ${setClauses.join(', ')} WHERE id = ?`,
            params
          );
        }
      });

      // 3. Invalidate cache
      this.invalidateCache(id);
      this.log('update', { id });
    } catch (error) {
      this.logError('update', error);
      throw error;
    }
  }

  async delete(id: string): Promise<void> {
    try {
      await this.transaction(async () => {
        // Get workspace ID first
        const session = await this.getById(id);
        if (!session) {
          throw new Error(`Session not found: ${id}`);
        }

        // Delete from SQLite (cascades to states and traces)
        await this.sqliteCache.run('DELETE FROM sessions WHERE id = ?', [id]);
      });

      // Invalidate cache
      this.invalidateCache();
      this.log('delete', { id });
    } catch (error) {
      this.logError('delete', error);
      throw error;
    }
  }

  async count(criteria?: Record<string, any>): Promise<number> {
    let sql = 'SELECT COUNT(*) as count FROM sessions';
    const params: any[] = [];

    if (criteria) {
      const conditions: string[] = [];
      if (criteria.workspaceId) {
        conditions.push('workspaceId = ?');
        params.push(criteria.workspaceId);
      }
      if (criteria.isActive !== undefined) {
        conditions.push('isActive = ?');
        params.push(criteria.isActive ? 1 : 0);
      }
      if (conditions.length > 0) {
        sql += ` WHERE ${conditions.join(' AND ')}`;
      }
    }

    const result = await this.sqliteCache.queryOne<{ count: number }>(sql, params);
    return result?.count ?? 0;
  }

  // ============================================================================
  // ISessionRepository Specific Methods
  // ============================================================================

  async getByWorkspaceId(
    workspaceId: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<SessionMetadata>> {
    const baseQuery = 'SELECT * FROM sessions WHERE workspaceId = ? ORDER BY startTime DESC';
    const countQuery = 'SELECT COUNT(*) as count FROM sessions WHERE workspaceId = ?';
    const result = await this.queryPaginated<any>(baseQuery, countQuery, options, [workspaceId]);
    return {
      items: result.items.map(row => this.rowToEntity(row)),
      page: result.page,
      pageSize: result.pageSize,
      totalItems: result.totalItems,
      totalPages: result.totalPages,
      hasNextPage: result.hasNextPage,
      hasPreviousPage: result.hasPreviousPage
    };
  }

  async getActiveSession(workspaceId: string): Promise<SessionMetadata | null> {
    const row = await this.sqliteCache.queryOne<any>(
      'SELECT * FROM sessions WHERE workspaceId = ? AND isActive = 1 ORDER BY startTime DESC LIMIT 1',
      [workspaceId]
    );
    return row ? this.rowToEntity(row) : null;
  }

  async endSession(id: string): Promise<void> {
    const session = await this.getById(id);
    if (!session) {
      throw new Error(`Session not found: ${id}`);
    }

    await this.update(id, {
      workspaceId: session.workspaceId,
      endTime: Date.now(),
      isActive: false
    });
  }

  async countByWorkspace(workspaceId: string): Promise<number> {
    return this.count({ workspaceId });
  }

  // ============================================================================
  // Protected Methods
  // ============================================================================

  protected rowToEntity(row: any): SessionMetadata {
    return {
      id: row.id,
      workspaceId: row.workspaceId,
      name: row.name,
      description: row.description ?? undefined,
      startTime: row.startTime,
      endTime: row.endTime ?? undefined,
      isActive: row.isActive === 1
    };
  }
}

```

## database/repositories/StateRepository.ts

```typescript
/**
 * Location: src/database/repositories/StateRepository.ts
 *
 * State Repository Implementation
 *
 * Manages workspace state snapshots within sessions.
 * State events are written to the workspace's JSONL file.
 *
 * Design Principles:
 * - States are named snapshots for resuming work
 * - Full content stored in JSONL, metadata in SQLite
 * - Events go to workspace JSONL file
 * - Tag-based organization for easy categorization
 *
 * Related Files:
 * - src/database/repositories/base/BaseRepository.ts - Base functionality
 * - src/database/repositories/interfaces/IStateRepository.ts - Interface
 * - src/types/storage/HybridStorageTypes.ts - StateMetadata, StateData types
 */

import { BaseRepository, RepositoryDependencies } from './base/BaseRepository';
import {
  IStateRepository,
  SaveStateData
} from './interfaces/IStateRepository';
import { StateMetadata, StateData } from '../../types/storage/HybridStorageTypes';
import {
  StateSavedEvent,
  StateDeletedEvent
} from '../interfaces/StorageEvents';
import { PaginatedResult, PaginationParams } from '../../types/pagination/PaginationTypes';
import { QueryCache } from '../optimizations/QueryCache';

/**
 * Repository for state entities
 *
 * Handles state snapshot operations with full content in JSONL.
 * Metadata cached in SQLite for fast queries.
 */
export class StateRepository
  extends BaseRepository<StateMetadata>
  implements IStateRepository {

  protected readonly tableName = 'states';
  protected readonly entityType = 'state';
  // States write to workspace JSONL file
  protected readonly jsonlPath = (workspaceId: string) => `workspaces/ws_${workspaceId}.jsonl`;

  // In-memory cache for full state data (since content not in SQLite)
  private stateContentCache: Map<string, StateData> = new Map();

  constructor(deps: RepositoryDependencies) {
    super(deps);
  }

  // ============================================================================
  // IRepository Implementation
  // ============================================================================

  async getById(id: string): Promise<StateMetadata | null> {
    const row = await this.sqliteCache.queryOne<any>(
      'SELECT * FROM states WHERE id = ?',
      [id]
    );
    return row ? this.rowToEntity(row) : null;
  }

  async getAll(options?: PaginationParams): Promise<PaginatedResult<StateMetadata>> {
    const baseQuery = 'SELECT * FROM states ORDER BY created DESC';
    const countQuery = 'SELECT COUNT(*) as count FROM states';
    const result = await this.queryPaginated<any>(baseQuery, countQuery, options);
    return {
      items: result.items.map(row => this.rowToEntity(row)),
      page: result.page,
      pageSize: result.pageSize,
      totalItems: result.totalItems,
      totalPages: result.totalPages,
      hasNextPage: result.hasNextPage,
      hasPreviousPage: result.hasPreviousPage
    };
  }

  async create(data: SaveStateData & { workspaceId: string; sessionId: string }): Promise<string> {
    return this.saveState(data.workspaceId, data.sessionId, data);
  }

  async update(id: string, data: any): Promise<void> {
    // States are immutable snapshots - no updates allowed
    throw new Error('States are immutable. Create a new state instead.');
  }

  async delete(id: string): Promise<void> {
    try {
      await this.transaction(async () => {
        // Get state metadata to find workspace/session
        const state = await this.getById(id);
        if (!state) {
          throw new Error(`State not found: ${id}`);
        }

        // 1. Write delete event to workspace JSONL
        await this.writeEvent<StateDeletedEvent>(
          this.jsonlPath(state.workspaceId),
          {
            type: 'state_deleted',
            workspaceId: state.workspaceId,
            sessionId: state.sessionId,
            stateId: id
          }
        );

        // 2. Delete from SQLite
        await this.sqliteCache.run('DELETE FROM states WHERE id = ?', [id]);

        // 3. Clear from content cache
        this.stateContentCache.delete(id);
      });

      // Invalidate cache
      this.invalidateCache();
      this.log('delete', { id });
    } catch (error) {
      this.logError('delete', error);
      throw error;
    }
  }

  async count(criteria?: Record<string, any>): Promise<number> {
    let sql = 'SELECT COUNT(*) as count FROM states';
    const params: any[] = [];

    if (criteria) {
      const conditions: string[] = [];
      if (criteria.workspaceId) {
        conditions.push('workspaceId = ?');
        params.push(criteria.workspaceId);
      }
      if (criteria.sessionId) {
        conditions.push('sessionId = ?');
        params.push(criteria.sessionId);
      }
      if (conditions.length > 0) {
        sql += ` WHERE ${conditions.join(' AND ')}`;
      }
    }

    const result = await this.sqliteCache.queryOne<{ count: number }>(sql, params);
    return result?.count ?? 0;
  }

  // ============================================================================
  // IStateRepository Specific Methods
  // ============================================================================

  async getStates(
    workspaceId: string,
    sessionId?: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<StateMetadata>> {
    let baseQuery = 'SELECT * FROM states WHERE workspaceId = ?';
    let countQuery = 'SELECT COUNT(*) as count FROM states WHERE workspaceId = ?';
    const params: any[] = [workspaceId];

    if (sessionId) {
      baseQuery += ' AND sessionId = ?';
      countQuery += ' AND sessionId = ?';
      params.push(sessionId);
    }

    baseQuery += ' ORDER BY created DESC';

    const result = await this.queryPaginated<any>(baseQuery, countQuery, options, params);
    return {
      items: result.items.map(row => this.rowToEntity(row)),
      page: result.page,
      pageSize: result.pageSize,
      totalItems: result.totalItems,
      totalPages: result.totalPages,
      hasNextPage: result.hasNextPage,
      hasPreviousPage: result.hasPreviousPage
    };
  }

  async getStateData(id: string): Promise<StateData | null> {
    // Check content cache first
    if (this.stateContentCache.has(id)) {
      return this.stateContentCache.get(id) || null;
    }

    // Get metadata from SQLite
    const metadata = await this.getById(id);
    if (!metadata) {
      return null;
    }

    // Read full state from JSONL file
    try {
      const events = await this.jsonlWriter.readEvents<StateSavedEvent>(
        this.jsonlPath(metadata.workspaceId)
      );

      // Find the state saved event for this ID
      const stateEvent = events.find(
        e => e.type === 'state_saved' && e.data.id === id
      );

      if (!stateEvent) {
        this.logError('getStateData', `State event not found in JSONL: ${id}`);
        return null;
      }

      const content = JSON.parse(stateEvent.data.stateJson);

      const stateData: StateData = {
        ...metadata,
        content
      };

      // Cache for future requests
      this.stateContentCache.set(id, stateData);

      return stateData;
    } catch (error) {
      this.logError('getStateData', error);
      return null;
    }
  }

  async saveState(
    workspaceId: string,
    sessionId: string,
    data: SaveStateData
  ): Promise<string> {
    const id = this.generateId();
    const now = Date.now();

    try {
      await this.transaction(async () => {
        // 1. Write event to workspace JSONL with full content
        await this.writeEvent<StateSavedEvent>(
          this.jsonlPath(workspaceId),
          {
            type: 'state_saved',
            workspaceId,
            sessionId,
            data: {
              id,
              name: data.name,
              description: data.description,
              created: data.created ?? now,
              stateJson: JSON.stringify(data.content),
              tags: data.tags
            }
          }
        );

        // 2. Update SQLite cache (metadata only, no content)
        await this.sqliteCache.run(
          `INSERT INTO states (id, workspaceId, sessionId, name, description, created, tagsJson)
           VALUES (?, ?, ?, ?, ?, ?, ?)`,
          [
            id,
            workspaceId,
            sessionId,
            data.name,
            data.description ?? null,
            data.created ?? now,
            data.tags ? JSON.stringify(data.tags) : null
          ]
        );

        // 3. Cache full state data
        this.stateContentCache.set(id, {
          id,
          workspaceId,
          sessionId,
          name: data.name,
          description: data.description,
          created: data.created ?? now,
          tags: data.tags,
          content: data.content
        });
      });

      // Invalidate query cache
      this.invalidateCache();
      this.log('saveState', { id, workspaceId, sessionId, name: data.name });

      return id;
    } catch (error) {
      this.logError('saveState', error);
      throw error;
    }
  }

  async countStates(workspaceId: string, sessionId?: string): Promise<number> {
    return this.count({ workspaceId, sessionId });
  }

  async getByTag(tag: string, options?: PaginationParams): Promise<PaginatedResult<StateMetadata>> {
    // SQLite JSON query for tags array
    const baseQuery = `SELECT * FROM states WHERE tagsJson LIKE ? ORDER BY created DESC`;
    const countQuery = `SELECT COUNT(*) as count FROM states WHERE tagsJson LIKE ?`;
    const params = [`%"${tag}"%`];

    const result = await this.queryPaginated<any>(baseQuery, countQuery, options, params);
    return {
      items: result.items.map(row => this.rowToEntity(row)),
      page: result.page,
      pageSize: result.pageSize,
      totalItems: result.totalItems,
      totalPages: result.totalPages,
      hasNextPage: result.hasNextPage,
      hasPreviousPage: result.hasPreviousPage
    };
  }

  // ============================================================================
  // Protected Methods
  // ============================================================================

  protected rowToEntity(row: any): StateMetadata {
    return {
      id: row.id,
      sessionId: row.sessionId,
      workspaceId: row.workspaceId,
      name: row.name,
      description: row.description ?? undefined,
      created: row.created,
      tags: row.tagsJson ? JSON.parse(row.tagsJson) : undefined
    };
  }
}

```

## database/repositories/TraceRepository.ts

```typescript
/**
 * Location: src/database/repositories/TraceRepository.ts
 *
 * Trace Repository Implementation
 *
 * Manages memory traces for workspace activity tracking.
 * Trace events are written to the workspace's JSONL file.
 *
 * Design Principles:
 * - Traces record significant events and context during sessions
 * - Full-text search enabled via SQLite FTS
 * - Events go to workspace JSONL file
 * - Type-based categorization for filtering
 *
 * Related Files:
 * - src/database/repositories/base/BaseRepository.ts - Base functionality
 * - src/database/repositories/interfaces/ITraceRepository.ts - Interface
 * - src/types/storage/HybridStorageTypes.ts - MemoryTraceData type
 */

import { BaseRepository, RepositoryDependencies } from './base/BaseRepository';
import {
  ITraceRepository,
  AddTraceData
} from './interfaces/ITraceRepository';
import { MemoryTraceData } from '../../types/storage/HybridStorageTypes';
import { TraceAddedEvent } from '../interfaces/StorageEvents';
import { PaginatedResult, PaginationParams } from '../../types/pagination/PaginationTypes';
import { QueryCache } from '../optimizations/QueryCache';

/**
 * Repository for memory trace entities
 *
 * Handles trace operations with full-text search support.
 * Traces provide searchable history of workspace activity.
 */
export class TraceRepository
  extends BaseRepository<MemoryTraceData>
  implements ITraceRepository {

  protected readonly tableName = 'memory_traces';
  protected readonly entityType = 'trace';
  // Traces write to workspace JSONL file
  protected readonly jsonlPath = (workspaceId: string) => `workspaces/ws_${workspaceId}.jsonl`;

  constructor(deps: RepositoryDependencies) {
    super(deps);
  }

  // ============================================================================
  // IRepository Implementation
  // ============================================================================

  async getById(id: string): Promise<MemoryTraceData | null> {
    const row = await this.sqliteCache.queryOne<any>(
      'SELECT * FROM memory_traces WHERE id = ?',
      [id]
    );
    return row ? this.rowToEntity(row) : null;
  }

  async getAll(options?: PaginationParams): Promise<PaginatedResult<MemoryTraceData>> {
    const baseQuery = 'SELECT * FROM memory_traces ORDER BY timestamp DESC';
    const countQuery = 'SELECT COUNT(*) as count FROM memory_traces';
    const result = await this.queryPaginated<any>(baseQuery, countQuery, options);
    return {
      items: result.items.map(row => this.rowToEntity(row)),
      page: result.page,
      pageSize: result.pageSize,
      totalItems: result.totalItems,
      totalPages: result.totalPages,
      hasNextPage: result.hasNextPage,
      hasPreviousPage: result.hasPreviousPage
    };
  }

  async create(data: AddTraceData & { workspaceId: string; sessionId: string }): Promise<string> {
    return this.addTrace(data.workspaceId, data.sessionId, data);
  }

  async update(id: string, data: any): Promise<void> {
    // Traces are immutable records - no updates allowed
    throw new Error('Traces are immutable. Create a new trace instead.');
  }

  async delete(id: string): Promise<void> {
    try {
      await this.transaction(async () => {
        // Delete from SQLite only (keep in JSONL for audit trail)
        await this.sqliteCache.run('DELETE FROM memory_traces WHERE id = ?', [id]);
      });

      // Invalidate cache
      this.invalidateCache();
      this.log('delete', { id });
    } catch (error) {
      this.logError('delete', error);
      throw error;
    }
  }

  async count(criteria?: Record<string, any>): Promise<number> {
    let sql = 'SELECT COUNT(*) as count FROM memory_traces';
    const params: any[] = [];

    if (criteria) {
      const conditions: string[] = [];
      if (criteria.workspaceId) {
        conditions.push('workspaceId = ?');
        params.push(criteria.workspaceId);
      }
      if (criteria.sessionId) {
        conditions.push('sessionId = ?');
        params.push(criteria.sessionId);
      }
      if (criteria.type) {
        conditions.push('type = ?');
        params.push(criteria.type);
      }
      if (conditions.length > 0) {
        sql += ` WHERE ${conditions.join(' AND ')}`;
      }
    }

    const result = await this.sqliteCache.queryOne<{ count: number }>(sql, params);
    return result?.count ?? 0;
  }

  // ============================================================================
  // ITraceRepository Specific Methods
  // ============================================================================

  async getTraces(
    workspaceId: string,
    sessionId?: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<MemoryTraceData>> {
    let baseQuery = 'SELECT * FROM memory_traces WHERE workspaceId = ?';
    let countQuery = 'SELECT COUNT(*) as count FROM memory_traces WHERE workspaceId = ?';
    const params: any[] = [workspaceId];

    if (sessionId) {
      baseQuery += ' AND sessionId = ?';
      countQuery += ' AND sessionId = ?';
      params.push(sessionId);
    }

    baseQuery += ' ORDER BY timestamp DESC';

    const result = await this.queryPaginated<any>(baseQuery, countQuery, options, params);
    return {
      items: result.items.map(row => this.rowToEntity(row)),
      page: result.page,
      pageSize: result.pageSize,
      totalItems: result.totalItems,
      totalPages: result.totalPages,
      hasNextPage: result.hasNextPage,
      hasPreviousPage: result.hasPreviousPage
    };
  }

  async addTrace(
    workspaceId: string,
    sessionId: string,
    data: AddTraceData
  ): Promise<string> {
    const id = this.generateId();
    const now = Date.now();

    try {
      await this.transaction(async () => {
        // 1. Write event to workspace JSONL
        await this.writeEvent<TraceAddedEvent>(
          this.jsonlPath(workspaceId),
          {
            type: 'trace_added',
            workspaceId,
            sessionId,
            data: {
              id,
              content: data.content,
              traceType: data.type,
              metadataJson: data.metadata ? JSON.stringify(data.metadata) : undefined
            }
          }
        );

        // 2. Update SQLite cache
        await this.sqliteCache.run(
          `INSERT INTO memory_traces (id, workspaceId, sessionId, timestamp, type, content, metadataJson)
           VALUES (?, ?, ?, ?, ?, ?, ?)`,
          [
            id,
            workspaceId,
            sessionId,
            data.timestamp ?? now,
            data.type ?? null,
            data.content,
            data.metadata ? JSON.stringify(data.metadata) : null
          ]
        );
      });

      // Invalidate cache
      this.invalidateCache();
      this.log('addTrace', { id, workspaceId, sessionId });

      return id;
    } catch (error) {
      this.logError('addTrace', error);
      throw error;
    }
  }

  async searchTraces(
    workspaceId: string,
    query: string,
    sessionId?: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<MemoryTraceData>> {
    try {
      // Use SQLite FTS for search
      let baseQuery = `
        SELECT mt.* FROM memory_traces mt
        WHERE mt.workspaceId = ?
        AND mt.content LIKE ?
      `;
      let countQuery = `
        SELECT COUNT(*) as count FROM memory_traces mt
        WHERE mt.workspaceId = ?
        AND mt.content LIKE ?
      `;
      const params: any[] = [workspaceId, `%${query}%`];

      if (sessionId) {
        baseQuery += ' AND mt.sessionId = ?';
        countQuery += ' AND mt.sessionId = ?';
        params.push(sessionId);
      }

      baseQuery += ' ORDER BY mt.timestamp DESC';

      const result = await this.queryPaginated<any>(baseQuery, countQuery, options, params);
      return {
        items: result.items.map(row => this.rowToEntity(row)),
        page: result.page,
        pageSize: result.pageSize,
        totalItems: result.totalItems,
        totalPages: result.totalPages,
        hasNextPage: result.hasNextPage,
        hasPreviousPage: result.hasPreviousPage
      };
    } catch (error) {
      this.logError('searchTraces', error);
      throw error;
    }
  }

  async getByType(
    workspaceId: string,
    type: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<MemoryTraceData>> {
    const baseQuery = `
      SELECT * FROM memory_traces
      WHERE workspaceId = ? AND type = ?
      ORDER BY timestamp DESC
    `;
    const countQuery = `
      SELECT COUNT(*) as count FROM memory_traces
      WHERE workspaceId = ? AND type = ?
    `;
    const params = [workspaceId, type];

    const result = await this.queryPaginated<any>(baseQuery, countQuery, options, params);
    return {
      items: result.items.map(row => this.rowToEntity(row)),
      page: result.page,
      pageSize: result.pageSize,
      totalItems: result.totalItems,
      totalPages: result.totalPages,
      hasNextPage: result.hasNextPage,
      hasPreviousPage: result.hasPreviousPage
    };
  }

  async countTraces(workspaceId: string, sessionId?: string): Promise<number> {
    return this.count({ workspaceId, sessionId });
  }

  // ============================================================================
  // Protected Methods
  // ============================================================================

  protected rowToEntity(row: any): MemoryTraceData {
    return {
      id: row.id,
      sessionId: row.sessionId,
      workspaceId: row.workspaceId,
      timestamp: row.timestamp,
      type: row.type ?? undefined,
      content: row.content,
      metadata: row.metadataJson ? JSON.parse(row.metadataJson) : undefined
    };
  }
}

```

## database/repositories/WorkspaceRepository.ts

```typescript
/**
 * Location: src/database/repositories/WorkspaceRepository.ts
 *
 * Workspace Repository Implementation
 *
 * Manages workspace entities with JSONL persistence and SQLite caching.
 * Each workspace has its own JSONL file: .nexus/workspaces/ws_[id].jsonl
 *
 * Design Principles:
 * - Single Responsibility: Only handles workspace CRUD operations
 * - Hybrid Storage: JSONL source of truth + SQLite cache for queries
 * - Cache Invalidation: Automatic cache clearing after mutations
 * - Event Sourcing: All changes recorded as immutable events
 *
 * Related Files:
 * - src/database/repositories/base/BaseRepository.ts - Base functionality
 * - src/database/repositories/interfaces/IWorkspaceRepository.ts - Interface
 * - src/types/storage/HybridStorageTypes.ts - WorkspaceMetadata type
 */

import { BaseRepository, RepositoryDependencies } from './base/BaseRepository';
import {
  IWorkspaceRepository,
  CreateWorkspaceData,
  UpdateWorkspaceData
} from './interfaces/IWorkspaceRepository';
import { WorkspaceMetadata } from '../../types/storage/HybridStorageTypes';
import {
  WorkspaceCreatedEvent,
  WorkspaceUpdatedEvent,
  WorkspaceDeletedEvent
} from '../interfaces/StorageEvents';
import { PaginatedResult, PaginationParams } from '../../types/pagination/PaginationTypes';
import { QueryOptions } from '../interfaces/IStorageAdapter';
import { QueryCache } from '../optimizations/QueryCache';

/**
 * Repository for workspace entities
 *
 * Handles CRUD operations with JSONL persistence and SQLite caching.
 * Each workspace gets its own JSONL file for all related events.
 */
export class WorkspaceRepository
  extends BaseRepository<WorkspaceMetadata>
  implements IWorkspaceRepository {

  protected readonly tableName = 'workspaces';
  protected readonly entityType = 'workspace';
  protected readonly jsonlPath = (id: string) => `workspaces/ws_${id}.jsonl`;

  constructor(deps: RepositoryDependencies) {
    super(deps);
  }

  // ============================================================================
  // IRepository Implementation
  // ============================================================================

  async getById(id: string): Promise<WorkspaceMetadata | null> {
    return this.getCachedOrFetch(
      QueryCache.workspaceKey(id),
      async () => {
        const row = await this.sqliteCache.queryOne<any>(
          'SELECT * FROM workspaces WHERE id = ?',
          [id]
        );
        return row ? this.rowToEntity(row) : null;
      }
    );
  }

  async getAll(options?: PaginationParams): Promise<PaginatedResult<WorkspaceMetadata>> {
    return this.getWorkspaces(options);
  }

  async create(data: CreateWorkspaceData): Promise<string> {
    // Use provided ID or generate a new one
    const id = data.id || this.generateId();
    const now = Date.now();
    const contextJson = data.context ? JSON.stringify(data.context) : undefined;

    try {
      await this.transaction(async () => {
        // 1. Write event to JSONL
        await this.writeEvent<WorkspaceCreatedEvent>(
          this.jsonlPath(id),
          {
            type: 'workspace_created',
            data: {
              id,
              name: data.name,
              description: data.description,
              rootFolder: data.rootFolder,
              created: data.created ?? now,
              dedicatedAgentId: data.dedicatedAgentId,
              contextJson
            }
          }
        );

        // 2. Update SQLite cache
        await this.sqliteCache.run(
          `INSERT INTO workspaces (id, name, description, rootFolder, created, lastAccessed, isActive, dedicatedAgentId, contextJson)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            id,
            data.name,
            data.description ?? null,
            data.rootFolder,
            data.created ?? now,
            now,
            // Default to 1 (active) if not specified
            data.isActive !== undefined ? (data.isActive ? 1 : 0) : 1,
            data.dedicatedAgentId ?? null,
            contextJson ?? null  // SQLite needs null, not undefined
          ]
        );
      });

      // 3. Invalidate cache
      this.invalidateCache();
      this.log('create', { id, name: data.name });

      return id;
    } catch (error) {
      this.logError('create', error);
      throw error;
    }
  }

  async update(id: string, data: UpdateWorkspaceData): Promise<void> {
    try {
      await this.transaction(async () => {
        // 1. Write event to JSONL
        const eventData: Partial<{ name: string; description: string; rootFolder: string; lastAccessed: number; isActive: boolean; dedicatedAgentId: string; contextJson: string }> = {
          lastAccessed: data.lastAccessed ?? Date.now()
        };
        if (data.name !== undefined) eventData.name = data.name;
        if (data.description !== undefined) eventData.description = data.description;
        if (data.rootFolder !== undefined) eventData.rootFolder = data.rootFolder;
        if (data.isActive !== undefined) eventData.isActive = data.isActive;
        if (data.dedicatedAgentId !== undefined) eventData.dedicatedAgentId = data.dedicatedAgentId;
        if (data.context !== undefined) eventData.contextJson = JSON.stringify(data.context);

        await this.writeEvent<WorkspaceUpdatedEvent>(
          this.jsonlPath(id),
          {
            type: 'workspace_updated',
            workspaceId: id,
            data: eventData
          }
        );

        // 2. Update SQLite cache
        const setClauses: string[] = [];
        const params: any[] = [];

        if (data.name !== undefined) {
          setClauses.push('name = ?');
          params.push(data.name);
        }
        if (data.description !== undefined) {
          setClauses.push('description = ?');
          params.push(data.description);
        }
        if (data.rootFolder !== undefined) {
          setClauses.push('rootFolder = ?');
          params.push(data.rootFolder);
        }
        if (data.isActive !== undefined) {
          setClauses.push('isActive = ?');
          params.push(data.isActive ? 1 : 0);
        }
        if (data.dedicatedAgentId !== undefined) {
          setClauses.push('dedicatedAgentId = ?');
          params.push(data.dedicatedAgentId);
        }
        if (data.context !== undefined) {
          setClauses.push('contextJson = ?');
          params.push(JSON.stringify(data.context));
        }

        setClauses.push('lastAccessed = ?');
        params.push(data.lastAccessed ?? Date.now());
        params.push(id);

        if (setClauses.length > 0) {
          await this.sqliteCache.run(
            `UPDATE workspaces SET ${setClauses.join(', ')} WHERE id = ?`,
            params
          );
        }
      });

      // 3. Invalidate cache
      this.invalidateCache(id);
      this.log('update', { id });
    } catch (error) {
      this.logError('update', error);
      throw error;
    }
  }

  async delete(id: string): Promise<void> {
    try {
      await this.transaction(async () => {
        // 1. Write event to JSONL
        await this.writeEvent<WorkspaceDeletedEvent>(
          this.jsonlPath(id),
          {
            type: 'workspace_deleted',
            workspaceId: id
          }
        );

        // 2. Delete from SQLite (cascades to sessions, states, traces)
        await this.sqliteCache.run('DELETE FROM workspaces WHERE id = ?', [id]);
      });

      // 3. Invalidate cache
      this.invalidateCache();
      this.log('delete', { id });
    } catch (error) {
      this.logError('delete', error);
      throw error;
    }
  }

  async count(criteria?: Record<string, any>): Promise<number> {
    let sql = 'SELECT COUNT(*) as count FROM workspaces';
    const params: any[] = [];

    if (criteria) {
      const conditions: string[] = [];
      if (criteria.isActive !== undefined) {
        conditions.push('isActive = ?');
        params.push(criteria.isActive ? 1 : 0);
      }
      if (conditions.length > 0) {
        sql += ` WHERE ${conditions.join(' AND ')}`;
      }
    }

    const result = await this.sqliteCache.queryOne<{ count: number }>(sql, params);
    return result?.count ?? 0;
  }

  // ============================================================================
  // IWorkspaceRepository Specific Methods
  // ============================================================================

  async getWorkspaces(options?: QueryOptions): Promise<PaginatedResult<WorkspaceMetadata>> {
    const sortBy = options?.sortBy ?? 'lastAccessed';
    const sortOrder = options?.sortOrder ?? 'desc';

    let whereClause = '';
    const params: any[] = [];

    if (options?.filter) {
      const filters: string[] = [];
      if (options.filter.isActive !== undefined) {
        filters.push('isActive = ?');
        params.push(options.filter.isActive ? 1 : 0);
      }
      if (filters.length > 0) {
        whereClause = `WHERE ${filters.join(' AND ')}`;
      }
    }

    const baseQuery = `SELECT * FROM workspaces ${whereClause} ORDER BY ${sortBy} ${sortOrder}`;
    const countQuery = `SELECT COUNT(*) as count FROM workspaces ${whereClause}`;

    const result = await this.queryPaginated<any>(baseQuery, countQuery, options, params);
    return {
      items: result.items.map(row => this.rowToEntity(row)),
      page: result.page,
      pageSize: result.pageSize,
      totalItems: result.totalItems,
      totalPages: result.totalPages,
      hasNextPage: result.hasNextPage,
      hasPreviousPage: result.hasPreviousPage
    };
  }

  async getByName(name: string): Promise<WorkspaceMetadata | null> {
    const row = await this.sqliteCache.queryOne<any>(
      'SELECT * FROM workspaces WHERE name = ?',
      [name]
    );
    return row ? this.rowToEntity(row) : null;
  }

  async updateLastAccessed(id: string): Promise<void> {
    const now = Date.now();

    try {
      await this.transaction(async () => {
        await this.writeEvent<WorkspaceUpdatedEvent>(
          this.jsonlPath(id),
          {
            type: 'workspace_updated',
            workspaceId: id,
            data: { lastAccessed: now }
          }
        );

        await this.sqliteCache.run(
          'UPDATE workspaces SET lastAccessed = ? WHERE id = ?',
          [now, id]
        );
      });

      this.invalidateCache(id);
    } catch (error) {
      this.logError('updateLastAccessed', error);
      throw error;
    }
  }

  async search(query: string): Promise<WorkspaceMetadata[]> {
    const rows = await this.sqliteCache.searchWorkspaces(query);
    return rows.map(row => this.rowToEntity(row));
  }

  // ============================================================================
  // Protected Methods
  // ============================================================================

  protected rowToEntity(row: any): WorkspaceMetadata {
    let context = undefined;
    if (row.contextJson) {
      try {
        context = JSON.parse(row.contextJson);
      } catch (e) {
      }
    }

    return {
      id: row.id,
      name: row.name,
      description: row.description ?? undefined,
      rootFolder: row.rootFolder,
      created: row.created,
      lastAccessed: row.lastAccessed,
      isActive: row.isActive === 1,
      dedicatedAgentId: row.dedicatedAgentId ?? undefined,
      context
    };
  }
}

```

## database/schema/schema.ts

```typescript
/**
 * SQLite Schema for Hybrid Storage System
 * Location: src/database/schema/schema.ts
 * Purpose: Complete database schema with indexes and FTS
 * Current Version: 5
 *
 * IMPORTANT: When updating the schema:
 * 1. Update SCHEMA_SQL below for new installs
 * 2. Add a migration in SchemaMigrator.ts for existing databases
 * 3. Update CURRENT_SCHEMA_VERSION in SchemaMigrator.ts
 *
 * NOTE: Uses camelCase column names to match TypeScript/JavaScript conventions.
 */

export const SCHEMA_SQL = `
-- Schema version tracking
CREATE TABLE IF NOT EXISTS schema_version (
  version INTEGER PRIMARY KEY,
  appliedAt INTEGER NOT NULL
);

-- ==================== WORKSPACES ====================

CREATE TABLE IF NOT EXISTS workspaces (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  rootFolder TEXT NOT NULL,
  created INTEGER NOT NULL,
  lastAccessed INTEGER NOT NULL,
  isActive INTEGER DEFAULT 1,
  contextJson TEXT,
  dedicatedAgentId TEXT,
  UNIQUE(name)
);

CREATE INDEX IF NOT EXISTS idx_workspaces_name ON workspaces(name);
CREATE INDEX IF NOT EXISTS idx_workspaces_folder ON workspaces(rootFolder);
CREATE INDEX IF NOT EXISTS idx_workspaces_active ON workspaces(isActive);
CREATE INDEX IF NOT EXISTS idx_workspaces_accessed ON workspaces(lastAccessed);

-- ==================== SESSIONS ====================

CREATE TABLE IF NOT EXISTS sessions (
  id TEXT PRIMARY KEY,
  workspaceId TEXT NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  startTime INTEGER,
  endTime INTEGER,
  isActive INTEGER DEFAULT 0,
  FOREIGN KEY(workspaceId) REFERENCES workspaces(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_sessions_workspace ON sessions(workspaceId);
CREATE INDEX IF NOT EXISTS idx_sessions_active ON sessions(isActive);
CREATE INDEX IF NOT EXISTS idx_sessions_start ON sessions(startTime);

-- ==================== STATES ====================

CREATE TABLE IF NOT EXISTS states (
  id TEXT PRIMARY KEY,
  sessionId TEXT NOT NULL,
  workspaceId TEXT NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  created INTEGER NOT NULL,
  stateJson TEXT,
  tagsJson TEXT,
  FOREIGN KEY(sessionId) REFERENCES sessions(id) ON DELETE CASCADE,
  FOREIGN KEY(workspaceId) REFERENCES workspaces(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_states_session ON states(sessionId);
CREATE INDEX IF NOT EXISTS idx_states_workspace ON states(workspaceId);
CREATE INDEX IF NOT EXISTS idx_states_created ON states(created);

-- ==================== MEMORY TRACES ====================

CREATE TABLE IF NOT EXISTS memory_traces (
  id TEXT PRIMARY KEY,
  sessionId TEXT NOT NULL,
  workspaceId TEXT NOT NULL,
  timestamp INTEGER NOT NULL,
  type TEXT,
  content TEXT,
  metadataJson TEXT,
  FOREIGN KEY(sessionId) REFERENCES sessions(id) ON DELETE CASCADE,
  FOREIGN KEY(workspaceId) REFERENCES workspaces(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_traces_session ON memory_traces(sessionId);
CREATE INDEX IF NOT EXISTS idx_traces_workspace ON memory_traces(workspaceId);
CREATE INDEX IF NOT EXISTS idx_traces_timestamp ON memory_traces(timestamp);
CREATE INDEX IF NOT EXISTS idx_traces_type ON memory_traces(type);

-- ==================== CONVERSATIONS ====================

CREATE TABLE IF NOT EXISTS conversations (
  id TEXT PRIMARY KEY,
  title TEXT NOT NULL,
  created INTEGER NOT NULL,
  updated INTEGER NOT NULL,
  vaultName TEXT NOT NULL,
  messageCount INTEGER DEFAULT 0,
  metadataJson TEXT
);

CREATE INDEX IF NOT EXISTS idx_conversations_vault ON conversations(vaultName);
CREATE INDEX IF NOT EXISTS idx_conversations_updated ON conversations(updated);
CREATE INDEX IF NOT EXISTS idx_conversations_created ON conversations(created);

-- ==================== MESSAGES ====================

CREATE TABLE IF NOT EXISTS messages (
  id TEXT PRIMARY KEY,
  conversationId TEXT NOT NULL,
  role TEXT NOT NULL,
  content TEXT,
  timestamp INTEGER NOT NULL,
  state TEXT,
  toolCallsJson TEXT,
  toolCallId TEXT,
  reasoningContent TEXT,
  sequenceNumber INTEGER NOT NULL,
  alternativesJson TEXT,
  activeAlternativeIndex INTEGER DEFAULT 0,
  FOREIGN KEY(conversationId) REFERENCES conversations(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_messages_conversation ON messages(conversationId);
CREATE INDEX IF NOT EXISTS idx_messages_sequence ON messages(conversationId, sequenceNumber);
CREATE INDEX IF NOT EXISTS idx_messages_timestamp ON messages(timestamp);
CREATE INDEX IF NOT EXISTS idx_messages_role ON messages(role);

-- ==================== FULL-TEXT SEARCH (FTS5) ====================
-- Using FTS5 for full-text search capabilities

CREATE VIRTUAL TABLE IF NOT EXISTS workspace_fts USING fts5(
  id,
  name,
  description,
  content='workspaces',
  content_rowid='rowid'
);

CREATE TRIGGER IF NOT EXISTS workspace_fts_insert AFTER INSERT ON workspaces BEGIN
  INSERT INTO workspace_fts(rowid, id, name, description)
  VALUES (new.rowid, new.id, new.name, new.description);
END;

CREATE TRIGGER IF NOT EXISTS workspace_fts_delete AFTER DELETE ON workspaces BEGIN
  INSERT INTO workspace_fts(workspace_fts, rowid, id, name, description)
  VALUES ('delete', old.rowid, old.id, old.name, old.description);
END;

CREATE TRIGGER IF NOT EXISTS workspace_fts_update AFTER UPDATE ON workspaces BEGIN
  INSERT INTO workspace_fts(workspace_fts, rowid, id, name, description)
  VALUES ('delete', old.rowid, old.id, old.name, old.description);
  INSERT INTO workspace_fts(rowid, id, name, description)
  VALUES (new.rowid, new.id, new.name, new.description);
END;

CREATE VIRTUAL TABLE IF NOT EXISTS conversation_fts USING fts5(
  id,
  title,
  content='conversations',
  content_rowid='rowid'
);

CREATE TRIGGER IF NOT EXISTS conversation_fts_insert AFTER INSERT ON conversations BEGIN
  INSERT INTO conversation_fts(rowid, id, title)
  VALUES (new.rowid, new.id, new.title);
END;

CREATE TRIGGER IF NOT EXISTS conversation_fts_delete AFTER DELETE ON conversations BEGIN
  INSERT INTO conversation_fts(conversation_fts, rowid, id, title)
  VALUES ('delete', old.rowid, old.id, old.title);
END;

CREATE TRIGGER IF NOT EXISTS conversation_fts_update AFTER UPDATE ON conversations BEGIN
  INSERT INTO conversation_fts(conversation_fts, rowid, id, title)
  VALUES ('delete', old.rowid, old.id, old.title);
  INSERT INTO conversation_fts(rowid, id, title)
  VALUES (new.rowid, new.id, new.title);
END;

CREATE VIRTUAL TABLE IF NOT EXISTS message_fts USING fts5(
  id,
  conversationId,
  content,
  reasoningContent,
  content='messages',
  content_rowid='rowid'
);

CREATE TRIGGER IF NOT EXISTS message_fts_insert AFTER INSERT ON messages BEGIN
  INSERT INTO message_fts(rowid, id, conversationId, content, reasoningContent)
  VALUES (new.rowid, new.id, new.conversationId, new.content, new.reasoningContent);
END;

CREATE TRIGGER IF NOT EXISTS message_fts_delete AFTER DELETE ON messages BEGIN
  INSERT INTO message_fts(message_fts, rowid, id, conversationId, content, reasoningContent)
  VALUES ('delete', old.rowid, old.id, old.conversationId, old.content, old.reasoningContent);
END;

CREATE TRIGGER IF NOT EXISTS message_fts_update AFTER UPDATE ON messages BEGIN
  INSERT INTO message_fts(message_fts, rowid, id, conversationId, content, reasoningContent)
  VALUES ('delete', old.rowid, old.id, old.conversationId, old.content, old.reasoningContent);
  INSERT INTO message_fts(rowid, id, conversationId, content, reasoningContent)
  VALUES (new.rowid, new.id, new.conversationId, new.content, new.reasoningContent);
END;

-- ==================== SYNC STATE ====================

CREATE TABLE IF NOT EXISTS sync_state (
  deviceId TEXT PRIMARY KEY,
  lastEventTimestamp INTEGER NOT NULL,
  syncedFilesJson TEXT
);

CREATE TABLE IF NOT EXISTS applied_events (
  eventId TEXT PRIMARY KEY,
  appliedAt INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_applied_events_time ON applied_events(appliedAt);

-- ==================== NOTE EMBEDDINGS ====================

-- Vector storage (vec0 virtual table)
CREATE VIRTUAL TABLE IF NOT EXISTS note_embeddings USING vec0(
  embedding float[384]
);

-- Metadata linked to vec0 by rowid
CREATE TABLE IF NOT EXISTS embedding_metadata (
  rowid INTEGER PRIMARY KEY,
  notePath TEXT NOT NULL UNIQUE,
  model TEXT NOT NULL,
  contentHash TEXT NOT NULL,
  created INTEGER NOT NULL,
  updated INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_embedding_meta_path ON embedding_metadata(notePath);
CREATE INDEX IF NOT EXISTS idx_embedding_meta_hash ON embedding_metadata(contentHash);

-- ==================== TRACE EMBEDDINGS ====================

-- Vector storage for memory traces
CREATE VIRTUAL TABLE IF NOT EXISTS trace_embeddings USING vec0(
  embedding float[384]
);

-- Metadata linked to vec0 by rowid
CREATE TABLE IF NOT EXISTS trace_embedding_metadata (
  rowid INTEGER PRIMARY KEY,
  traceId TEXT NOT NULL UNIQUE,
  workspaceId TEXT NOT NULL,
  sessionId TEXT,
  model TEXT NOT NULL,
  contentHash TEXT NOT NULL,
  created INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_trace_embed_id ON trace_embedding_metadata(traceId);
CREATE INDEX IF NOT EXISTS idx_trace_embed_workspace ON trace_embedding_metadata(workspaceId);
CREATE INDEX IF NOT EXISTS idx_trace_embed_session ON trace_embedding_metadata(sessionId);

-- ==================== INITIALIZATION ====================

INSERT OR IGNORE INTO schema_version VALUES (5, strftime('%s', 'now') * 1000);
`;

```

## database/schema/SchemaMigrator.ts

```typescript
/**
 * Schema Migrator for SQLite Database
 * Location: src/database/schema/SchemaMigrator.ts
 *
 * Purpose: Handle incremental schema migrations without data loss.
 * Each migration is idempotent and can be safely re-run.
 *
 * ============================================================================
 * HOW TO ADD A NEW SCHEMA MIGRATION
 * ============================================================================
 *
 * When you need to modify the database schema (add columns, tables, indexes):
 *
 * STEP 1: Update CURRENT_SCHEMA_VERSION
 *   - Increment the version number (e.g., 3 -> 4)
 *
 * STEP 2: Add a new migration to the MIGRATIONS array
 *   - Add an entry with the new version number
 *   - Include a description of what the migration does
 *   - Add the SQL statements needed
 *
 *   Example:
 *   ```
 *   {
 *     version: 4,
 *     description: 'Add tags column to conversations table',
 *     sql: [
 *       'ALTER TABLE conversations ADD COLUMN tagsJson TEXT',
 *     ]
 *   }
 *   ```
 *
 * STEP 3: Update SCHEMA_SQL in schema.ts
 *   - Add the same columns/tables to the main schema
 *   - This ensures new installs get the complete schema
 *
 * IMPORTANT RULES:
 *   - NEVER modify existing migrations - only add new ones
 *   - Migrations must be idempotent (the migrator checks if columns exist)
 *   - Use ALTER TABLE ADD COLUMN for new columns (preserves existing data)
 *   - Use CREATE TABLE IF NOT EXISTS for new tables
 *   - Use CREATE INDEX IF NOT EXISTS for new indexes
 *   - Test on a vault with existing data before releasing
 *
 * SUPPORTED OPERATIONS:
 *   - Adding columns: ALTER TABLE x ADD COLUMN y TYPE
 *   - Adding tables: CREATE TABLE IF NOT EXISTS x (...)
 *   - Adding indexes: CREATE INDEX IF NOT EXISTS x ON y(z)
 *   - Adding triggers: CREATE TRIGGER IF NOT EXISTS x ...
 *
 * NOT SUPPORTED (requires manual data migration):
 *   - Removing columns (SQLite doesn't support DROP COLUMN easily)
 *   - Renaming columns
 *   - Changing column types
 *
 * ============================================================================
 */

/**
 * Minimal interface for SQLite database operations needed by SchemaMigrator.
 * Works with both sql.js and @dao-xyz/sqlite3-vec WASM databases.
 */
export interface MigratableDatabase {
  /** Execute SQL and return results */
  exec(sql: string): { values: any[][] }[];
  /** Run a statement (INSERT/UPDATE/DELETE) */
  run(sql: string, params?: any[]): void;
}

// Alias for backward compatibility
type Database = MigratableDatabase;

export const CURRENT_SCHEMA_VERSION = 5;

export interface Migration {
  version: number;
  description: string;
  /** SQL statements to run. Each is executed separately. */
  sql: string[];
}

/**
 * Migration definitions - add new migrations here when schema changes.
 *
 * IMPORTANT:
 * - Never modify existing migrations
 * - Always add new migrations with incrementing version numbers
 * - Migrations must be idempotent (safe to run multiple times)
 * - Use "IF NOT EXISTS" for new tables/indexes
 * - For columns, check if column exists before adding
 */
export const MIGRATIONS: Migration[] = [
  // Version 1 -> 2: Initial schema (handled by fresh install)
  // No migration needed - v1 and v2 had same structure

  // Version 2 -> 3: Add message alternatives/branching support
  {
    version: 3,
    description: 'Add alternativesJson and activeAlternativeIndex to messages table for branching support',
    sql: [
      // SQLite doesn't have IF NOT EXISTS for columns, so we use a workaround
      // The migrator will check column existence before running these
      `ALTER TABLE messages ADD COLUMN alternativesJson TEXT`,
      `ALTER TABLE messages ADD COLUMN activeAlternativeIndex INTEGER DEFAULT 0`,
    ]
  },

  // Version 3 -> 4: Added branches tables (intermediate version, now superseded by v5)
  // NOTE: This was only in schema.ts for fresh installs, never migrated.
  // Skipped in migration since v5 removes these tables anyway.

  // Version 4 -> 5: Remove branches tables (unified model: branches ARE conversations)
  // In the unified model, branches are stored as regular conversations with:
  //   - metadata.parentConversationId: parent conversation
  //   - metadata.parentMessageId: message branch is attached to
  //   - metadata.branchType: 'alternative' | 'subagent'
  {
    version: 5,
    description: 'Remove branches and branch_messages tables - unified model stores branches as conversations with parent metadata',
    sql: [
      // Drop tables if they exist (v4 fresh installs have them, v3 upgrades don't)
      'DROP TABLE IF EXISTS branch_messages',
      'DROP TABLE IF EXISTS branches',
    ]
  },

  // ========================================================================
  // ADD NEW MIGRATIONS BELOW THIS LINE
  // ========================================================================
];

/**
 * SchemaMigrator handles database schema upgrades
 */
export class SchemaMigrator {
  private db: Database;

  constructor(db: Database) {
    this.db = db;
  }

  /**
   * Get the current schema version from the database
   * Returns 0 if schema_version table doesn't exist (very old DB)
   * Returns 1 if table exists but is empty (pre-versioning DB)
   */
  getCurrentVersion(): number {
    try {
      // Check if schema_version table exists
      const tableCheck = this.db.exec(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='schema_version'"
      );

      if (tableCheck.length === 0 || tableCheck[0].values.length === 0) {
        // No schema_version table - this is a very old database or fresh
        // Check if messages table exists to differentiate
        const messagesCheck = this.db.exec(
          "SELECT name FROM sqlite_master WHERE type='table' AND name='messages'"
        );

        if (messagesCheck.length === 0 || messagesCheck[0].values.length === 0) {
          // No messages table = fresh database, return 0
          return 0;
        }

        // Has messages but no schema_version = v1 database
        return 1;
      }

      // Get max version from schema_version table
      const result = this.db.exec('SELECT MAX(version) as version FROM schema_version');

      if (result.length === 0 || result[0].values.length === 0 || result[0].values[0][0] === null) {
        // Table exists but empty - treat as v1
        return 1;
      }

      return result[0].values[0][0] as number;
    } catch (error) {
      console.error('[SchemaMigrator] Error getting current version:', error);
      return 0;
    }
  }

  /**
   * Check if a column exists in a table
   */
  private columnExists(tableName: string, columnName: string): boolean {
    try {
      const result = this.db.exec(`PRAGMA table_info(${tableName})`);

      if (result.length === 0) return false;

      // PRAGMA table_info returns: cid, name, type, notnull, dflt_value, pk
      // Column name is at index 1
      const columns = result[0].values.map(row => row[1] as string);
      return columns.includes(columnName);
    } catch (error) {
      console.error(`[SchemaMigrator] Error checking column ${tableName}.${columnName}:`, error);
      return false;
    }
  }

  /**
   * Run all pending migrations
   * Returns migration result including whether a rebuild is needed
   *
   * NOTE: When migrations are applied, the SQLite cache should be rebuilt from JSONL
   * because the existing data doesn't have the new columns populated correctly.
   */
  async migrate(): Promise<{
    applied: number;
    fromVersion: number;
    toVersion: number;
    needsRebuild: boolean;  // True if migrations were applied and data should be rebuilt from JSONL
  }> {
    const currentVersion = this.getCurrentVersion();
    const targetVersion = CURRENT_SCHEMA_VERSION;

    if (currentVersion >= targetVersion) {
      return { applied: 0, fromVersion: currentVersion, toVersion: currentVersion, needsRebuild: false };
    }

    // Ensure schema_version table exists
    this.ensureSchemaVersionTable();

    // Get migrations to apply (versions > currentVersion)
    const pendingMigrations = MIGRATIONS.filter(m => m.version > currentVersion);

    if (pendingMigrations.length === 0) {
      this.setVersion(targetVersion);
      return { applied: 0, fromVersion: currentVersion, toVersion: targetVersion, needsRebuild: false };
    }

    let appliedCount = 0;

    for (const migration of pendingMigrations) {
      try {
        for (const sql of migration.sql) {
          const alterMatch = sql.match(/ALTER TABLE (\w+) ADD COLUMN (\w+)/i);

          if (alterMatch) {
            const [, tableName, columnName] = alterMatch;

            if (this.columnExists(tableName, columnName)) {
              continue;
            }
          }

          this.db.run(sql);
        }

        this.setVersion(migration.version);
        appliedCount++;
      } catch (error) {
        console.error(`[SchemaMigrator] Migration v${migration.version} failed:`, error);
        throw error;
      }
    }

    return {
      applied: appliedCount,
      fromVersion: currentVersion,
      toVersion: targetVersion,
      needsRebuild: false
    };
  }

  /**
   * Ensure schema_version table exists
   */
  private ensureSchemaVersionTable(): void {
    this.db.run(`
      CREATE TABLE IF NOT EXISTS schema_version (
        version INTEGER PRIMARY KEY,
        appliedAt INTEGER NOT NULL
      )
    `);
  }

  /**
   * Set the current schema version
   */
  private setVersion(version: number): void {
    this.db.run(
      'INSERT OR REPLACE INTO schema_version (version, appliedAt) VALUES (?, ?)',
      [version, Date.now()]
    );
  }
}

```

## database/services/cache/CacheEvictionPolicy.ts

```typescript
/**
 * Location: src/database/services/cache/CacheEvictionPolicy.ts
 *
 * Purpose: Cache eviction policy for memory management
 * Extracted from ContentCache.ts to follow Single Responsibility Principle
 *
 * Used by: ContentCache for enforcing memory limits
 * Dependencies: CacheStrategy
 */

import { CachedEntry } from './strategies/CacheStrategy';

export interface EvictionEntry {
  key: string;
  entry: CachedEntry;
  type: string;
}

/**
 * Manages cache eviction when memory limits are exceeded
 */
export class CacheEvictionPolicy {
  /**
   * Enforce memory limits by evicting least recently used entries
   *
   * @param cacheGroups - Map of cache types to their strategies
   * @param currentMemoryMB - Current memory usage in MB
   * @param maxMemoryMB - Maximum allowed memory in MB
   * @param onEvict - Callback when entry is evicted
   * @returns Number of entries evicted
   */
  static enforceLimits(
    cacheGroups: Map<string, Map<string, CachedEntry>>,
    currentMemoryMB: number,
    maxMemoryMB: number,
    onEvict?: (key: string, type: string, sizeMB: number) => void
  ): { evictedCount: number; freedMemoryMB: number } {
    if (currentMemoryMB <= maxMemoryMB) {
      return { evictedCount: 0, freedMemoryMB: 0 };
    }

    // Collect all entries with their keys and types
    const allEntries: EvictionEntry[] = [];

    for (const [type, cacheMap] of cacheGroups.entries()) {
      for (const [key, entry] of cacheMap.entries()) {
        allEntries.push({ key, entry, type });
      }
    }

    // Sort by last access time (oldest first) - LRU policy
    allEntries.sort((a, b) => a.entry.lastAccess - b.entry.lastAccess);

    // Remove entries until under memory limit
    let evictedCount = 0;
    let freedMemoryMB = 0;
    const targetMemoryMB = maxMemoryMB * 0.8; // Target 80% of limit

    for (const { key, entry, type } of allEntries) {
      if ((currentMemoryMB - freedMemoryMB) <= targetMemoryMB) {
        break; // Stop when under 80% of limit
      }

      const cacheMap = cacheGroups.get(type);
      if (cacheMap) {
        cacheMap.delete(key);
        const entrySizeMB = entry.size / (1024 * 1024);
        freedMemoryMB += entrySizeMB;
        evictedCount++;

        if (onEvict) {
          onEvict(key, type, entrySizeMB);
        }
      }
    }

    return { evictedCount, freedMemoryMB };
  }

  /**
   * Get eviction candidates (entries that would be evicted next)
   */
  static getEvictionCandidates(
    cacheGroups: Map<string, Map<string, CachedEntry>>,
    count: number = 10
  ): EvictionEntry[] {
    const allEntries: EvictionEntry[] = [];

    for (const [type, cacheMap] of cacheGroups.entries()) {
      for (const [key, entry] of cacheMap.entries()) {
        allEntries.push({ key, entry, type });
      }
    }

    // Sort by last access time (oldest first)
    allEntries.sort((a, b) => a.entry.lastAccess - b.entry.lastAccess);

    return allEntries.slice(0, count);
  }

  /**
   * Calculate priority score for cache entry
   * Higher score = higher priority (less likely to be evicted)
   */
  static calculatePriority(entry: CachedEntry): number {
    const recencyScore = (Date.now() - entry.lastAccess) / (1000 * 60 * 60); // Hours since last access
    const frequencyScore = entry.accessCount;
    const ageScore = (Date.now() - entry.timestamp) / (1000 * 60 * 60 * 24); // Days since creation

    // Weighted priority: recent access and frequency are more important than age
    return (frequencyScore * 0.5) + (1 / (recencyScore + 1) * 0.4) + (1 / (ageScore + 1) * 0.1);
  }
}

```

## database/services/cache/CacheManager.ts

```typescript
import { Vault, App, EventRef, TFile } from 'obsidian';
import { EntityCache } from './EntityCache';
import { VaultFileIndex } from './VaultFileIndex';
import { WorkspaceService } from '../../../services/WorkspaceService';
import { MemoryService } from '../../../agents/memoryManager/services/MemoryService';
import { PrefetchManager } from './PrefetchManager';

export interface CacheManagerOptions {
    enableEntityCache?: boolean;
    enableFileIndex?: boolean;
    enablePrefetch?: boolean;
    entityCacheTTL?: number;
    maxCacheSize?: number;
}

export class CacheManager {
    private vault: Vault;
    private entityCache: EntityCache | null = null;
    private vaultFileIndex: VaultFileIndex | null = null;
    private prefetchManager: PrefetchManager | null = null;
    private isInitialized = false;
    private vaultEventRefs: EventRef[] = [];
    private entityCacheEventRefs: EventRef[] = [];

    constructor(
        private app: App,
        private workspaceService: WorkspaceService,
        private memoryService: MemoryService,
        private options: CacheManagerOptions = {}
    ) {
        this.vault = app.vault;
        // Default options
        this.options.enableEntityCache = options.enableEntityCache ?? true;
        this.options.enableFileIndex = options.enableFileIndex ?? true;
        this.options.enablePrefetch = options.enablePrefetch ?? true;
    }

    async initialize(): Promise<void> {
        if (this.isInitialized) {
            return;
        }

        // Initialize EntityCache
        if (this.options.enableEntityCache) {
            this.entityCache = new EntityCache(
                this.vault,
                this.workspaceService,
                this.memoryService,
                {
                    ttl: this.options.entityCacheTTL,
                    maxSize: this.options.maxCacheSize
                }
            );
        }

        // Initialize VaultFileIndex
        if (this.options.enableFileIndex) {
            this.vaultFileIndex = new VaultFileIndex(this.vault, this.app);
            await this.vaultFileIndex.initialize();

            // Set up file event listeners
            this.setupFileEventListeners();
        }

        // Initialize PrefetchManager
        if (this.options.enablePrefetch && this.entityCache) {
            this.prefetchManager = new PrefetchManager(
                this,
                this.workspaceService,
                this.memoryService
            );

            // Set up prefetch listeners
            this.setupPrefetchListeners();
        }

        this.isInitialized = true;
    }

    private setupFileEventListeners(): void {
        if (!this.vaultFileIndex) return;

        // Listen for file events from Obsidian
        this.vaultEventRefs.push(
            this.vault.on('create', async (file) => {
                if (file instanceof TFile && (file.extension === 'md' || file.extension === 'canvas')) {
                    await this.vaultFileIndex!.updateFile(file);
                }
            })
        );

        this.vaultEventRefs.push(
            this.vault.on('delete', (file) => {
                this.vaultFileIndex!.removeFile(file.path);
                // Also invalidate entity cache for files
                if (this.entityCache) {
                    this.entityCache.invalidateFile(file.path);
                }
            })
        );

        this.vaultEventRefs.push(
            this.vault.on('rename', async (file, oldPath) => {
                if (file instanceof TFile && (file.extension === 'md' || file.extension === 'canvas')) {
                    await this.vaultFileIndex!.renameFile(oldPath, file.path);
                }
            })
        );

        this.vaultEventRefs.push(
            this.vault.on('modify', async (file) => {
                if (file instanceof TFile && (file.extension === 'md' || file.extension === 'canvas')) {
                    await this.vaultFileIndex!.updateFile(file);
                }
            })
        );
    }

    private setupPrefetchListeners(): void {
        if (!this.entityCache || !this.prefetchManager) return;

        // Listen for entity cache events to trigger prefetching
        this.entityCacheEventRefs.push(
            this.entityCache.on('workspace:preloaded', (workspaceId) => {
                this.prefetchManager!.onWorkspaceLoaded(workspaceId as string);
            })
        );

        this.entityCacheEventRefs.push(
            this.entityCache.on('session:preloaded', (sessionId) => {
                this.prefetchManager!.onSessionLoaded(sessionId as string);
            })
        );

        this.entityCacheEventRefs.push(
            this.entityCache.on('state:preloaded', (stateId) => {
                this.prefetchManager!.onStateLoaded(stateId as string);
            })
        );
    }

    // Entity cache methods
    async preloadWorkspace(workspaceId: string): Promise<void> {
        if (!this.entityCache) {
            throw new Error('EntityCache not initialized');
        }
        await this.entityCache.preloadWorkspace(workspaceId);
    }

    async preloadSession(sessionId: string): Promise<void> {
        if (!this.entityCache) {
            throw new Error('EntityCache not initialized');
        }
        await this.entityCache.preloadSession(sessionId);
    }

    async preloadState(stateId: string): Promise<void> {
        if (!this.entityCache) {
            throw new Error('EntityCache not initialized');
        }
        await this.entityCache.preloadState(stateId);
    }

    getCachedWorkspace(workspaceId: string) {
        return this.entityCache?.getWorkspace(workspaceId);
    }

    getCachedSession(sessionId: string) {
        return this.entityCache?.getSession(sessionId);
    }

    getCachedState(stateId: string) {
        return this.entityCache?.getState(stateId);
    }

    // File index methods
    getFileMetadata(filePath: string) {
        return this.vaultFileIndex?.getFile(filePath);
    }

    getKeyFiles() {
        return this.vaultFileIndex?.getKeyFiles() || [];
    }

    getRecentFiles(limit?: number, folderPath?: string) {
        return this.vaultFileIndex?.getRecentFiles(limit, folderPath) || [];
    }

    getFilesInFolder(folderPath: string, recursive = false) {
        return this.vaultFileIndex?.getFilesInFolder(folderPath, recursive) || [];
    }

    searchFiles(predicate: (file: any) => boolean) {
        return this.vaultFileIndex?.searchFiles(predicate) || [];
    }

    async getFilesWithMetadata(filePaths: string[]) {
        return this.vaultFileIndex?.getFilesWithMetadata(filePaths) || [];
    }

    // Cache warming
    async warmCache(workspaceId?: string): Promise<void> {
        // If a specific workspace is provided, preload it
        if (workspaceId) {
            await this.preloadWorkspace(workspaceId);
        }

        // Preload key files metadata
        if (this.vaultFileIndex) {
            const keyFiles = this.getKeyFiles();
            const keyFilePaths = keyFiles.map((f: any) => f.path);
            await this.vaultFileIndex.warmup(keyFilePaths);
        }
    }

    // Cache management
    invalidateWorkspace(workspaceId: string): void {
        this.entityCache?.invalidateWorkspace(workspaceId);
    }

    invalidateSession(sessionId: string): void {
        this.entityCache?.invalidateSession(sessionId);
    }

    invalidateState(stateId: string): void {
        this.entityCache?.invalidateState(stateId);
    }

    clearCache(): void {
        this.entityCache?.clear();
        this.vaultFileIndex?.clear();
    }

    // Stats
    getStats() {
        return {
            entityCache: this.entityCache ? {
                workspaces: this.entityCache['workspaceCache'].size,
                sessions: this.entityCache['sessionCache'].size,
                states: this.entityCache['stateCache'].size,
                files: this.entityCache['fileMetadataCache'].size
            } : null,
            fileIndex: this.vaultFileIndex?.getStats() || null,
            prefetch: this.prefetchManager?.getStats() || null
        };
    }

    // Check if caches are ready
    isReady(): boolean {
        const entityCacheReady = !this.options.enableEntityCache || !!this.entityCache;
        const fileIndexReady = !this.options.enableFileIndex || this.vaultFileIndex?.isReady() || false;
        return this.isInitialized && entityCacheReady && fileIndexReady;
    }

    // Cleanup resources
    cleanup(): void {
        // Unregister vault event listeners
        for (const ref of this.vaultEventRefs) {
            this.vault.offref(ref);
        }
        this.vaultEventRefs = [];

        // Unregister entity cache event listeners
        if (this.entityCache) {
            for (const ref of this.entityCacheEventRefs) {
                this.entityCache.offref(ref);
            }
        }
        this.entityCacheEventRefs = [];

        // Cleanup VaultFileIndex and its metadata cache events
        if (this.vaultFileIndex) {
            this.vaultFileIndex.cleanup();
            this.vaultFileIndex = null;
        }

        // Clear entity cache
        if (this.entityCache) {
            this.entityCache.clear();
            this.entityCache = null;
        }

        // Reset prefetch manager
        if (this.prefetchManager) {
            this.prefetchManager.clearQueue();
            this.prefetchManager = null;
        }

        this.isInitialized = false;
    }
}
```

## database/services/cache/ContentCache.ts

```typescript
/**
 * Location: src/database/services/cache/ContentCache.ts
 *
 * Summary: Consolidated content caching service using Strategy pattern
 * Refactored to use cache strategies following SOLID principles
 *
 * Used by: All services requiring content caching capabilities
 * Dependencies: BaseCacheStrategy, CacheEvictionPolicy
 */

import { Events, Plugin, TFile } from 'obsidian';
import { BaseCacheStrategy } from './strategies/BaseCacheStrategy';
import { CachedEntry } from './strategies/CacheStrategy';
import { CacheEvictionPolicy } from './CacheEvictionPolicy';

export interface ContentCacheOptions {
  enableFileContentCache?: boolean;
  enableMetadataCache?: boolean;
  enableEmbeddingDataCache?: boolean;
  enableSearchCache?: boolean;
  defaultTTL?: number;
  maxCacheSize?: number;
  maxMemoryMB?: number;
}

export interface FileContent extends CachedEntry {
  filePath: string;
  content: string;
  metadata?: any;
  hash?: string;
}

export interface EmbeddingContent extends CachedEntry {
  filePath: string;
  embedding: number[];
  model: string;
  chunkIndex?: number;
}

export interface SearchResult extends CachedEntry {
  query: string;
  results: any[];
  type: string;
}

export interface CacheStats {
  totalEntries: number;
  totalSizeMB: number;
  hitRate: number;
  memoryUsageMB: number;
  cachesByType: Record<string, {
    count: number;
    sizeMB: number;
    oldestEntry: number;
    newestEntry: number;
  }>;
}

/**
 * File content cache strategy
 */
class FileContentCacheStrategy extends BaseCacheStrategy<FileContent> {}

/**
 * Embedding cache strategy
 */
class EmbeddingCacheStrategy extends BaseCacheStrategy<EmbeddingContent> {}

/**
 * Search results cache strategy
 */
class SearchCacheStrategy extends BaseCacheStrategy<SearchResult> {}

/**
 * Generic cached content strategy
 */
class GenericCacheStrategy extends BaseCacheStrategy<CachedEntry> {}

/**
 * Content Cache Service
 *
 * Provides unified caching with Strategy pattern for different cache types
 */
export class ContentCache extends Events {
  // Cache strategies
  private fileContentStrategy: FileContentCacheStrategy;
  private metadataStrategy: GenericCacheStrategy;
  private embeddingStrategy: EmbeddingCacheStrategy;
  private searchResultsStrategy: SearchCacheStrategy;
  private computedStrategy: GenericCacheStrategy;

  // Cache statistics
  private hits = 0;
  private misses = 0;
  private currentMemoryMB = 0;

  // Configuration
  private readonly defaultTTL: number;
  private readonly maxCacheSize: number;
  private readonly maxMemoryMB: number;

  // Cleanup timer
  private cleanupInterval: NodeJS.Timeout | null = null;

  constructor(
    private plugin: Plugin,
    private options: ContentCacheOptions = {}
  ) {
    super();

    // Apply default configuration
    this.defaultTTL = options.defaultTTL || 30 * 60 * 1000; // 30 minutes
    this.maxCacheSize = options.maxCacheSize || 1000;
    this.maxMemoryMB = options.maxMemoryMB || 100; // 100MB default

    // Initialize cache strategies
    this.fileContentStrategy = new FileContentCacheStrategy();
    this.metadataStrategy = new GenericCacheStrategy();
    this.embeddingStrategy = new EmbeddingCacheStrategy();
    this.searchResultsStrategy = new SearchCacheStrategy();
    this.computedStrategy = new GenericCacheStrategy();

    // Start periodic cleanup
    this.startCleanupTimer();
  }

  // =============================================================================
  // FILE CONTENT CACHING
  // =============================================================================

  /**
   * Cache file content with metadata
   */
  async cacheFileContent(
    filePath: string,
    content: string,
    metadata?: any,
    ttl?: number
  ): Promise<void> {
    if (!this.options.enableFileContentCache) {
      return;
    }

    const size = this.estimateSize(content);
    const cacheEntry: FileContent = {
      filePath,
      content,
      metadata,
      hash: this.generateHash(content),
      data: { content, metadata },
      timestamp: Date.now(),
      size,
      ttl: ttl || this.defaultTTL,
      accessCount: 1,
      lastAccess: Date.now()
    };

    this.fileContentStrategy.set(filePath, cacheEntry);
    this.currentMemoryMB += size / (1024 * 1024);

    this.trigger('cached', { type: 'file', filePath, size });
    this.enforceMemoryLimits();
  }

  /**
   * Get cached file content
   */
  getCachedFileContent(filePath: string): FileContent | null {
    const cached = this.fileContentStrategy.get(filePath);

    if (!cached) {
      this.misses++;
      return null;
    }

    this.hits++;
    return cached;
  }

  /**
   * Cache file content from TFile
   */
  async cacheFile(file: TFile, ttl?: number): Promise<void> {
    try {
      const content = await this.plugin.app.vault.read(file);
      const metadata = this.plugin.app.metadataCache.getFileCache(file);

      await this.cacheFileContent(file.path, content, metadata, ttl);
    } catch (error) {
      console.error(`[ContentCache] Failed to cache file ${file.path}:`, error);
    }
  }

  // =============================================================================
  // EMBEDDING CACHING
  // =============================================================================

  /**
   * Cache embedding data
   */
  cacheEmbedding(
    filePath: string,
    embedding: number[],
    model: string,
    chunkIndex?: number,
    ttl?: number
  ): void {
    if (!this.options.enableEmbeddingDataCache) {
      return;
    }

    const cacheKey = this.getEmbeddingCacheKey(filePath, model, chunkIndex);
    const size = this.estimateSize(embedding);

    const cacheEntry: EmbeddingContent = {
      filePath,
      embedding,
      model,
      chunkIndex,
      data: embedding,
      timestamp: Date.now(),
      size,
      ttl: ttl || this.defaultTTL,
      accessCount: 1,
      lastAccess: Date.now()
    };

    this.embeddingStrategy.set(cacheKey, cacheEntry);
    this.currentMemoryMB += size / (1024 * 1024);

    this.trigger('cached', { type: 'embedding', filePath, model, size });
    this.enforceMemoryLimits();
  }

  /**
   * Get cached embedding
   */
  getCachedEmbedding(
    filePath: string,
    model: string,
    chunkIndex?: number
  ): EmbeddingContent | null {
    const cacheKey = this.getEmbeddingCacheKey(filePath, model, chunkIndex);
    const cached = this.embeddingStrategy.get(cacheKey);

    if (!cached) {
      this.misses++;
      return null;
    }

    this.hits++;
    return cached;
  }

  // =============================================================================
  // SEARCH RESULT CACHING
  // =============================================================================

  /**
   * Cache search results
   */
  cacheSearchResults(
    query: string,
    results: any[],
    searchType: string,
    ttl?: number
  ): void {
    if (!this.options.enableSearchCache) {
      return;
    }

    const cacheKey = this.getSearchCacheKey(query, searchType);
    const size = this.estimateSize(results);

    const cacheEntry: SearchResult = {
      query,
      results,
      type: searchType,
      data: results,
      timestamp: Date.now(),
      size,
      ttl: ttl || this.defaultTTL / 2, // Search results expire faster
      accessCount: 1,
      lastAccess: Date.now()
    };

    this.searchResultsStrategy.set(cacheKey, cacheEntry);
    this.currentMemoryMB += size / (1024 * 1024);

    this.trigger('cached', { type: 'search', query, searchType, size });
    this.enforceMemoryLimits();
  }

  /**
   * Get cached search results
   */
  getCachedSearchResults(query: string, searchType: string): SearchResult | null {
    const cacheKey = this.getSearchCacheKey(query, searchType);
    const cached = this.searchResultsStrategy.get(cacheKey);

    if (!cached) {
      this.misses++;
      return null;
    }

    this.hits++;
    return cached;
  }

  // =============================================================================
  // GENERIC COMPUTED VALUE CACHING
  // =============================================================================

  /**
   * Cache computed value with custom key
   */
  cacheValue(key: string, value: any, ttl?: number): void {
    const size = this.estimateSize(value);

    const cacheEntry: CachedEntry = {
      data: value,
      timestamp: Date.now(),
      size,
      ttl: ttl || this.defaultTTL,
      accessCount: 1,
      lastAccess: Date.now()
    };

    this.computedStrategy.set(key, cacheEntry);
    this.currentMemoryMB += size / (1024 * 1024);

    this.trigger('cached', { type: 'computed', key, size });
    this.enforceMemoryLimits();
  }

  /**
   * Get cached computed value
   */
  getCachedValue(key: string): any | null {
    const cached = this.computedStrategy.get(key);

    if (!cached) {
      this.misses++;
      return null;
    }

    this.hits++;
    return cached.data;
  }

  // =============================================================================
  // CACHE INVALIDATION AND MANAGEMENT
  // =============================================================================

  /**
   * Invalidate all caches for a specific file
   */
  invalidateFile(filePath: string): void {
    // Remove file content cache
    this.fileContentStrategy.delete(filePath);

    // Remove embedding caches for this file
    const embeddingCache = this.embeddingStrategy.getAll();
    for (const key of embeddingCache.keys()) {
      if (key.startsWith(`${filePath}:`)) {
        this.embeddingStrategy.delete(key);
      }
    }

    // Remove metadata cache
    this.metadataStrategy.delete(filePath);

    this.trigger('invalidated', { type: 'file', filePath });
  }

  /**
   * Clear all caches
   */
  clearAll(): void {
    this.fileContentStrategy.clear();
    this.metadataStrategy.clear();
    this.embeddingStrategy.clear();
    this.searchResultsStrategy.clear();
    this.computedStrategy.clear();

    this.currentMemoryMB = 0;
    this.hits = 0;
    this.misses = 0;

    this.trigger('cleared');
  }

  /**
   * Clean up expired entries
   */
  cleanup(): void {
    const now = Date.now();
    let cleanedCount = 0;

    cleanedCount += this.fileContentStrategy.cleanup(now);
    cleanedCount += this.embeddingStrategy.cleanup(now);
    cleanedCount += this.searchResultsStrategy.cleanup(now);
    cleanedCount += this.computedStrategy.cleanup(now);

    if (cleanedCount > 0) {
      this.trigger('cleaned', { removedEntries: cleanedCount });
    }
  }

  /**
   * Get cache statistics
   */
  getStats(): CacheStats {
    const totalRequests = this.hits + this.misses;
    const hitRate = totalRequests > 0 ? this.hits / totalRequests : 0;

    return {
      totalEntries: this.getTotalEntries(),
      totalSizeMB: this.currentMemoryMB,
      hitRate,
      memoryUsageMB: this.currentMemoryMB,
      cachesByType: {
        fileContent: this.fileContentStrategy.getStatistics(),
        embeddingData: this.embeddingStrategy.getStatistics(),
        searchResults: this.searchResultsStrategy.getStatistics(),
        computed: this.computedStrategy.getStatistics()
      }
    };
  }

  /**
   * Shutdown the cache service
   */
  shutdown(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }

    this.clearAll();
  }

  // =============================================================================
  // PRIVATE HELPER METHODS
  // =============================================================================

  private startCleanupTimer(): void {
    // Clean up every 5 minutes
    this.cleanupInterval = setInterval(() => {
      this.cleanup();
    }, 5 * 60 * 1000);
  }

  private enforceMemoryLimits(): void {
    if (this.currentMemoryMB <= this.maxMemoryMB) {
      return;
    }

    // Collect all cache groups
    const cacheGroups = new Map<string, Map<string, CachedEntry>>([
      ['file', this.fileContentStrategy.getAll()],
      ['embedding', this.embeddingStrategy.getAll()],
      ['searchResults', this.searchResultsStrategy.getAll()],
      ['computed', this.computedStrategy.getAll()]
    ]);

    // Use eviction policy to remove LRU entries
    const { evictedCount, freedMemoryMB } = CacheEvictionPolicy.enforceLimits(
      cacheGroups,
      this.currentMemoryMB,
      this.maxMemoryMB,
      (key, type, sizeMB) => {
        this.trigger('evicted', { key, type, sizeMB });
      }
    );

    this.currentMemoryMB -= freedMemoryMB;

    if (evictedCount > 0) {
      this.trigger('memoryLimitEnforced', { removedEntries: evictedCount, freedMemoryMB });
    }
  }

  private getTotalEntries(): number {
    return this.fileContentStrategy.getStatistics().count +
           this.embeddingStrategy.getStatistics().count +
           this.searchResultsStrategy.getStatistics().count +
           this.computedStrategy.getStatistics().count +
           this.metadataStrategy.getStatistics().count;
  }

  private estimateSize(data: any): number {
    // Rough estimation of object size in bytes
    try {
      const jsonString = JSON.stringify(data);
      return jsonString.length * 2; // Assume 2 bytes per character for Unicode
    } catch {
      return 1024; // Default 1KB if cannot stringify
    }
  }

  private generateHash(content: string): string {
    // Simple hash function for content comparison
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return hash.toString(36);
  }

  private getEmbeddingCacheKey(
    filePath: string,
    model: string,
    chunkIndex?: number
  ): string {
    return `${filePath}:${model}${chunkIndex !== undefined ? `:${chunkIndex}` : ''}`;
  }

  private getSearchCacheKey(query: string, searchType: string): string {
    return `${searchType}:${this.generateHash(query)}`;
  }
}

```

## database/services/cache/EntityCache.ts

```typescript
import { Events, Vault, TFile } from 'obsidian';
import { WorkspaceService } from '../../../services/WorkspaceService';
import { MemoryService } from '../../../agents/memoryManager/services/MemoryService';

interface TimestampedEntry {
    timestamp: number;
}

interface CachedWorkspace extends TimestampedEntry {
    data: any;
    sessionIds: string[];
    stateIds: string[];
    associatedFiles: string[];
}

interface CachedSession extends TimestampedEntry {
    data: any;
    traceIds: string[];
    associatedFiles: string[];
}

interface CachedState extends TimestampedEntry {
    data: any;
    associatedFiles: string[];
}

interface FileMetadata {
    path: string;
    name: string;
    modified: number;
    size: number;
    isKeyFile: boolean;
    frontmatter?: any;
    workspaceIds?: string[];
}

interface CacheOptions {
    ttl?: number; // Time to live in milliseconds
    maxSize?: number; // Maximum number of items per cache
}

export class EntityCache extends Events {
    private workspaceCache = new Map<string, CachedWorkspace>();
    private sessionCache = new Map<string, CachedSession>();
    private stateCache = new Map<string, CachedState>();
    private fileMetadataCache = new Map<string, FileMetadata>();
    
    private readonly defaultTTL = 30 * 60 * 1000; // 30 minutes
    private readonly maxCacheSize = 1000;
    
    constructor(
        private vault: Vault,
        private workspaceService: WorkspaceService,
        private memoryService: MemoryService,
        private options: CacheOptions = {}
    ) {
        super();
        this.options.ttl = options.ttl || this.defaultTTL;
        this.options.maxSize = options.maxSize || this.maxCacheSize;
    }

    // Workspace caching methods
    async preloadWorkspace(workspaceId: string): Promise<void> {
        try {
            // Check if already cached and valid
            const cached = this.workspaceCache.get(workspaceId);
            if (cached && this.isValid(cached.timestamp)) {
                return;
            }

            // Load workspace data
            const workspace = await this.workspaceService.getWorkspace(workspaceId);
            
            if (!workspace) {
                return;
            }

            // Collect related IDs
            const sessionIds: string[] = [];
            const stateIds: string[] = [];
            const associatedFiles = new Set<string>();

            // Get sessions for this workspace
            const sessionsResult = await this.memoryService.getSessions(workspaceId);
            sessionIds.push(...sessionsResult.items.map(s => s.id));

            // Get states for this workspace
            const statesResult = await this.memoryService.getStates(workspaceId);
            stateIds.push(...statesResult.items.map(s => s.id));

            // Collect associated files
            if (workspace.rootFolder) {
                associatedFiles.add(workspace.rootFolder);
            }
            // Note: ProjectWorkspace doesn't have associatedFiles property

            // Cache the workspace
            this.workspaceCache.set(workspaceId, {
                data: workspace,
                sessionIds,
                stateIds,
                associatedFiles: Array.from(associatedFiles),
                timestamp: Date.now()
            });

            // Preload related entities in parallel
            await Promise.all([
                ...sessionIds.map(id => this.preloadSession(id)),
                ...stateIds.slice(0, 5).map(id => this.preloadState(id)) // Limit states
            ]);

            // Preload file metadata
            await this.preloadFiles(Array.from(associatedFiles));

            this.trigger('workspace:preloaded', workspaceId);
        } catch (error) {
            console.error('Error preloading workspace:', error);
        }
    }

    async preloadSession(sessionId: string): Promise<void> {
        try {
            // Check if already cached and valid
            const cached = this.sessionCache.get(sessionId);
            if (cached && this.isValid(cached.timestamp)) {
                return;
            }

            // Load session data
            // First try to get the session directly
            const sessionData = await this.memoryService.getSession('default-workspace', sessionId);
            if (!sessionData) {
                return;
            }
            const session = sessionData;

            // Get memory traces for this session
            const tracesResult = await this.memoryService.getMemoryTraces(sessionId);
            const traceIds = tracesResult.items.map(t => t.id);

            // Collect associated files
            const associatedFiles = new Set<string>();
            // Note: WorkspaceSession doesn't have activeNote property
            tracesResult.items.forEach(trace => {
                const files =
                  (trace.metadata?.input?.files && Array.isArray(trace.metadata.input.files)
                    ? trace.metadata.input.files
                    : trace.metadata?.legacy?.relatedFiles) || [];
                files.forEach((f: string) => associatedFiles.add(f));
            });

            // Cache the session
            this.sessionCache.set(sessionId, {
                data: session,
                traceIds,
                associatedFiles: Array.from(associatedFiles),
                timestamp: Date.now()
            });

            // Preload file metadata
            await this.preloadFiles(Array.from(associatedFiles));

            this.trigger('session:preloaded', sessionId);
        } catch (error) {
            console.error('Error preloading session:', error);
        }
    }

    async preloadState(stateId: string): Promise<void> {
        try {
            // Check if already cached and valid
            const cached = this.stateCache.get(stateId);
            if (cached && this.isValid(cached.timestamp)) {
                return;
            }

            // Load state data
            const statesResult = await this.memoryService.getStates('default-workspace');
            const state = statesResult.items.find(s => s.id === stateId);

            if (!state) {
                return;
            }

            // Collect associated files from state context
            const associatedFiles = new Set<string>();
            // Note: WorkspaceState structure may vary

            // Cache the state
            this.stateCache.set(stateId, {
                data: state,
                associatedFiles: Array.from(associatedFiles),
                timestamp: Date.now()
            });

            // Preload file metadata
            await this.preloadFiles(Array.from(associatedFiles));

            this.trigger('state:preloaded', stateId);
        } catch (error) {
            console.error('Error preloading state:', error);
        }
    }

    async preloadFiles(filePaths: string[]): Promise<void> {
        const files = filePaths
            .map(path => this.vault.getAbstractFileByPath(path))
            .filter(file => file instanceof TFile) as TFile[];

        await Promise.all(files.map(file => this.cacheFileMetadata(file)));
    }

    private async cacheFileMetadata(file: TFile): Promise<void> {
        const keyFilePatterns = [/readme\.md$/i, /index\.md$/i, /\.canvas$/];
        
        this.fileMetadataCache.set(file.path, {
            path: file.path,
            name: file.name,
            modified: file.stat.mtime,
            size: file.stat.size,
            isKeyFile: keyFilePatterns.some(p => p.test(file.path)),
            // Frontmatter will be loaded lazily when needed
        });
    }

    // Batch loading methods
    async batchLoadSessions(sessionIds: string[]): Promise<any[]> {
        const uncached: string[] = [];
        const results: any[] = [];

        // Check cache first
        for (const id of sessionIds) {
            const cached = this.sessionCache.get(id);
            if (cached && this.isValid(cached.timestamp)) {
                results.push(cached.data);
            } else {
                uncached.push(id);
            }
        }

        // Batch load uncached items
        if (uncached.length > 0) {
            // Load sessions individually
            const sessionPromises = uncached.map(id => this.memoryService.getSession('default-workspace', id));
            const sessionResults = await Promise.all(sessionPromises);
            const sessions = sessionResults.filter((s): s is any => s !== undefined);
            
            // Cache the loaded sessions
            for (const session of sessions) {
                if (session) {
                    this.sessionCache.set(session.id, {
                        data: session,
                        traceIds: [],
                        associatedFiles: [],
                        timestamp: Date.now()
                    });
                    results.push(session);
                }
            }
        }

        return results;
    }

    async batchLoadStates(stateIds: string[]): Promise<any[]> {
        const uncached: string[] = [];
        const results: any[] = [];

        // Check cache first
        for (const id of stateIds) {
            const cached = this.stateCache.get(id);
            if (cached && this.isValid(cached.timestamp)) {
                results.push(cached.data);
            } else {
                uncached.push(id);
            }
        }

        // Batch load uncached items
        if (uncached.length > 0) {
            // Load all states and filter
            const statesResult = await this.memoryService.getStates('default-workspace');
            const states = statesResult.items.filter(s => uncached.includes(s.id));
            
            // Cache the loaded states
            for (const state of states) {
                if (state) {
                    this.stateCache.set(state.id, {
                        data: state,
                        associatedFiles: [],
                        timestamp: Date.now()
                    });
                    results.push(state);
                }
            }
        }

        return results;
    }


    // Cache access methods
    getWorkspace(workspaceId: string): CachedWorkspace | undefined {
        const cached = this.workspaceCache.get(workspaceId);
        if (cached && this.isValid(cached.timestamp)) {
            return cached;
        }
        this.workspaceCache.delete(workspaceId);
        return undefined;
    }

    getSession(sessionId: string): CachedSession | undefined {
        const cached = this.sessionCache.get(sessionId);
        if (cached && this.isValid(cached.timestamp)) {
            return cached;
        }
        this.sessionCache.delete(sessionId);
        return undefined;
    }

    getState(stateId: string): CachedState | undefined {
        const cached = this.stateCache.get(stateId);
        if (cached && this.isValid(cached.timestamp)) {
            return cached;
        }
        this.stateCache.delete(stateId);
        return undefined;
    }

    getFileMetadata(filePath: string): FileMetadata | undefined {
        return this.fileMetadataCache.get(filePath);
    }

    // Cache management
    invalidateWorkspace(workspaceId: string): void {
        this.workspaceCache.delete(workspaceId);
        this.trigger('workspace:invalidated', workspaceId);
    }

    invalidateSession(sessionId: string): void {
        this.sessionCache.delete(sessionId);
        this.trigger('session:invalidated', sessionId);
    }

    invalidateState(stateId: string): void {
        this.stateCache.delete(stateId);
        this.trigger('state:invalidated', stateId);
    }

    invalidateFile(filePath: string): void {
        this.fileMetadataCache.delete(filePath);
    }

    clear(): void {
        this.workspaceCache.clear();
        this.sessionCache.clear();
        this.stateCache.clear();
        this.fileMetadataCache.clear();
        this.trigger('cache:cleared');
    }

    private isValid(timestamp: number): boolean {
        return Date.now() - timestamp < (this.options.ttl || this.defaultTTL);
    }

    // Enforce cache size limits
    private enforceLimit<T extends TimestampedEntry>(cache: Map<string, T>): void {
        if (cache.size > (this.options.maxSize || this.maxCacheSize)) {
            // Remove oldest entries
            const entries = Array.from(cache.entries());
            entries.sort((a, b) => {
                const timestampA = a[1].timestamp || 0;
                const timestampB = b[1].timestamp || 0;
                return timestampA - timestampB;
            });

            const toRemove = entries.slice(0, Math.floor(cache.size * 0.2)); // Remove 20%
            toRemove.forEach(([key]) => cache.delete(key));
        }
    }
}

```

## database/services/cache/index.ts

```typescript
/**
 * Cache Services Exports
 */

export { CacheManager } from './CacheManager';
export { EntityCache } from './EntityCache';
export { ContentCache } from './ContentCache';
export { PrefetchManager } from './PrefetchManager';
export { VaultFileIndex } from './VaultFileIndex';
```

## database/services/cache/PrefetchManager.ts

```typescript
import { Events } from 'obsidian';
import { CacheManager } from './CacheManager';
import { WorkspaceService } from '../../../services/WorkspaceService';
import { MemoryService } from '../../../agents/memoryManager/services/MemoryService';
import { WorkspaceSession, WorkspaceState } from '../../types/session/SessionTypes';

export interface PrefetchOptions {
    maxConcurrentPrefetches?: number;
    prefetchDelay?: number;
    enableSmartPrefetch?: boolean;
}

export class PrefetchManager extends Events {
    private prefetchQueue: string[] = [];
    private isPrefetching = false;
    private prefetchHistory = new Map<string, number>(); // entityId -> last prefetch timestamp
    
    private readonly defaultMaxConcurrent = 3;
    private readonly defaultPrefetchDelay = 1000; // 1 second between prefetches
    private readonly prefetchCooldown = 5 * 60 * 1000; // 5 minutes cooldown

    constructor(
        private cacheManager: CacheManager,
        private workspaceService: WorkspaceService,
        private memoryService: MemoryService,
        private options: PrefetchOptions = {}
    ) {
        super();
        this.options.maxConcurrentPrefetches = options.maxConcurrentPrefetches || this.defaultMaxConcurrent;
        this.options.prefetchDelay = options.prefetchDelay || this.defaultPrefetchDelay;
        this.options.enableSmartPrefetch = options.enableSmartPrefetch ?? true;
    }

    /**
     * Called when a workspace is loaded - prefetch likely next items
     */
    async onWorkspaceLoaded(workspaceId: string): Promise<void> {
        if (!this.options.enableSmartPrefetch) return;

        try {
            // Get recent sessions for this workspace
            const sessionsResult = await this.memoryService.getSessions(workspaceId);
            const recentSessions = sessionsResult.items
                .sort((a, b) => (a.name || '').localeCompare(b.name || ''))
                .slice(0, 5);

            // Queue prefetch for recent sessions
            for (const session of recentSessions) {
                this.queuePrefetch('session', session.id);
            }

            // Start processing the queue
            this.processPrefetchQueue();
        } catch (error) {
            console.error('Error in onWorkspaceLoaded prefetch:', error);
        }
    }

    /**
     * Called when a session is loaded - prefetch associated data
     */
    async onSessionLoaded(sessionId: string): Promise<void> {
        if (!this.options.enableSmartPrefetch) return;

        try {
            // Get the session to find its workspace
            const session = await this.memoryService.getSession('default-workspace', sessionId);

            if (session && session.workspaceId) {
                // Prefetch the parent workspace if not already cached
                this.queuePrefetch('workspace', session.workspaceId);
            }

            // Get recent memory traces
            const tracesResult = await this.memoryService.getMemoryTraces(sessionId);
            const relatedFiles = new Set<string>();

            for (const trace of tracesResult.items) {
                const files =
                  (trace.metadata?.input?.files && Array.isArray(trace.metadata.input.files)
                    ? trace.metadata.input.files
                    : trace.metadata?.legacy?.relatedFiles) || [];
                files.forEach((f: string) => relatedFiles.add(f));
            }

            // Prefetch file metadata
            if (relatedFiles.size > 0) {
                await this.cacheManager.getFilesWithMetadata(Array.from(relatedFiles));
            }

            // Start processing the queue
            this.processPrefetchQueue();
        } catch (error) {
            console.error('Error in onSessionLoaded prefetch:', error);
        }
    }

    /**
     * Called when a state is loaded - prefetch related states
     */
    async onStateLoaded(stateId: string): Promise<void> {
        if (!this.options.enableSmartPrefetch) return;

        try {
            // Get the state to find related states
            const statesResult = await this.memoryService.getStates('default-workspace');
            const stateItem = statesResult.items.find(s => s.id === stateId);

            if (stateItem) {
                // Prefetch parent session
                if (stateItem.state.sessionId) {
                    this.queuePrefetch('session', stateItem.state.sessionId);
                }

                // Prefetch sibling states (same session)
                if (stateItem.state.sessionId) {
                    const siblingStates = statesResult.items
                        .filter(s => s.state.sessionId === stateItem.state.sessionId && s.id !== stateId)
                        .sort((a, b) => (b.state.timestamp ?? 0) - (a.state.timestamp ?? 0))
                        .slice(0, 3);

                    for (const sibling of siblingStates) {
                        this.queuePrefetch('state', sibling.id);
                    }
                }
            }

            // Start processing the queue
            this.processPrefetchQueue();
        } catch (error) {
            console.error('Error in onStateLoaded prefetch:', error);
        }
    }

    /**
     * Queue an entity for prefetching
     */
    private queuePrefetch(type: 'workspace' | 'session' | 'state', id: string): void {
        const key = `${type}:${id}`;
        
        // Check if recently prefetched
        const lastPrefetch = this.prefetchHistory.get(key);
        if (lastPrefetch && Date.now() - lastPrefetch < this.prefetchCooldown) {
            return; // Skip if recently prefetched
        }

        // Add to queue if not already there
        if (!this.prefetchQueue.includes(key)) {
            this.prefetchQueue.push(key);
            this.trigger('prefetch:queued', { type, id });
        }
    }

    /**
     * Process the prefetch queue
     */
    private async processPrefetchQueue(): Promise<void> {
        if (this.isPrefetching || this.prefetchQueue.length === 0) {
            return;
        }

        this.isPrefetching = true;

        try {
            // Process up to maxConcurrent items
            const itemsToProcess = this.prefetchQueue.splice(0, this.options.maxConcurrentPrefetches || this.defaultMaxConcurrent);
            
            const prefetchPromises = itemsToProcess.map(async (item) => {
                const [type, id] = item.split(':');
                
                try {
                    switch (type) {
                        case 'workspace':
                            await this.cacheManager.preloadWorkspace(id);
                            break;
                        case 'session':
                            await this.cacheManager.preloadSession(id);
                            break;
                        case 'state':
                            await this.cacheManager.preloadState(id);
                            break;
                    }
                    
                    // Record successful prefetch
                    this.prefetchHistory.set(item, Date.now());
                    this.trigger('prefetch:completed', { type, id });
                } catch (error) {
                    this.trigger('prefetch:failed', { type, id, error });
                }
            });

            await Promise.all(prefetchPromises);

            // If there are more items, continue after a delay
            if (this.prefetchQueue.length > 0) {
                setTimeout(() => {
                    this.isPrefetching = false;
                    this.processPrefetchQueue();
                }, this.options.prefetchDelay || this.defaultPrefetchDelay);
            } else {
                this.isPrefetching = false;
            }
        } catch (error) {
            console.error('Error processing prefetch queue:', error);
            this.isPrefetching = false;
        }
    }

    /**
     * Clear the prefetch queue
     */
    clearQueue(): void {
        this.prefetchQueue = [];
        this.isPrefetching = false;
        this.trigger('prefetch:queueCleared');
    }

    /**
     * Get prefetch statistics
     */
    getStats() {
        return {
            queueLength: this.prefetchQueue.length,
            isPrefetching: this.isPrefetching,
            historySize: this.prefetchHistory.size,
            recentPrefetches: Array.from(this.prefetchHistory.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10)
                .map(([key, timestamp]) => ({
                    key,
                    timestamp,
                    age: Date.now() - timestamp
                }))
        };
    }
}

```

## database/services/cache/strategies/BaseCacheStrategy.ts

```typescript
/**
 * Location: src/database/services/cache/strategies/BaseCacheStrategy.ts
 *
 * Purpose: Base implementation of cache strategy with common logic
 * Implements Strategy pattern with Template Method for customization
 *
 * Used by: Specific cache strategies (FileCache, EmbeddingCache, etc.)
 * Dependencies: CacheStrategy interface
 */

import { CachedEntry, CacheStrategy, CacheStatistics } from './CacheStrategy';

/**
 * Base cache strategy with common implementation
 */
export abstract class BaseCacheStrategy<T extends CachedEntry> implements CacheStrategy<T> {
  protected cache = new Map<string, T>();

  set(key: string, entry: T): void {
    this.cache.set(key, entry);
  }

  get(key: string): T | null {
    const entry = this.cache.get(key);

    if (!entry) {
      return null;
    }

    // Check if expired
    if (this.isExpired(entry)) {
      this.cache.delete(key);
      return null;
    }

    // Update access statistics
    entry.accessCount++;
    entry.lastAccess = Date.now();

    return entry;
  }

  has(key: string): boolean {
    const entry = this.cache.get(key);
    if (!entry) {
      return false;
    }

    if (this.isExpired(entry)) {
      this.cache.delete(key);
      return false;
    }

    return true;
  }

  delete(key: string): boolean {
    return this.cache.delete(key);
  }

  clear(): void {
    this.cache.clear();
  }

  getAll(): Map<string, T> {
    return new Map(this.cache);
  }

  getStatistics(): CacheStatistics {
    const entries = Array.from(this.cache.values());
    const count = entries.length;

    if (count === 0) {
      return { count: 0, sizeMB: 0, oldestEntry: 0, newestEntry: 0 };
    }

    const sizeMB = entries.reduce((sum, entry) => sum + (entry.size / (1024 * 1024)), 0);
    const timestamps = entries.map(entry => entry.timestamp);

    return {
      count,
      sizeMB,
      oldestEntry: Math.min(...timestamps),
      newestEntry: Math.max(...timestamps)
    };
  }

  cleanup(now: number): number {
    let cleanedCount = 0;

    for (const [key, entry] of this.cache.entries()) {
      if (this.isExpired(entry, now)) {
        this.cache.delete(key);
        cleanedCount++;
      }
    }

    return cleanedCount;
  }

  protected isExpired(entry: T, now?: number): boolean {
    const currentTime = now || Date.now();
    return (currentTime - entry.timestamp) > entry.ttl;
  }
}

```

## database/services/cache/strategies/CacheStrategy.ts

```typescript
/**
 * Location: src/database/services/cache/strategies/CacheStrategy.ts
 *
 * Purpose: Strategy interface for different cache types
 * Implements Strategy pattern for cache operations
 *
 * Used by: ContentCache for managing different cache types
 * Dependencies: None
 */

export interface CachedEntry {
  data: any;
  timestamp: number;
  size: number;
  ttl: number;
  accessCount: number;
  lastAccess: number;
}

export interface CacheStatistics {
  count: number;
  sizeMB: number;
  oldestEntry: number;
  newestEntry: number;
}

/**
 * Strategy interface for cache operations
 */
export interface CacheStrategy<T extends CachedEntry> {
  /**
   * Add entry to cache
   */
  set(key: string, entry: T): void;

  /**
   * Get entry from cache
   */
  get(key: string): T | null;

  /**
   * Check if entry exists
   */
  has(key: string): boolean;

  /**
   * Remove entry from cache
   */
  delete(key: string): boolean;

  /**
   * Clear all entries
   */
  clear(): void;

  /**
   * Get all entries
   */
  getAll(): Map<string, T>;

  /**
   * Get cache statistics
   */
  getStatistics(): CacheStatistics;

  /**
   * Clean up expired entries
   */
  cleanup(now: number): number;
}

```

## database/services/cache/VaultFileIndex.ts

```typescript
import { Events, Vault, TFile, TFolder, FileStats, MetadataCache, App, EventRef } from 'obsidian';

export interface IndexedFile {
    path: string;
    name: string;
    basename: string;
    extension: string;
    parent: string;
    modified: number;
    created: number;
    size: number;
    isKeyFile: boolean;
    tags?: string[];
    aliases?: string[];
    frontmatter?: any;
    backlinks?: string[];
    forwardLinks?: string[];
}

export interface IndexStats {
    totalFiles: number;
    keyFiles: number;
    lastUpdated: number;
    indexingTime: number;
}

export class VaultFileIndex extends Events {
    private fileIndex = new Map<string, IndexedFile>();
    private keyFilePatterns = [
        /readme\.md$/i,
        /index\.md$/i,
        /\.canvas$/,
        /overview\.md$/i,
        /summary\.md$/i,
        /main\.md$/i
    ];
    
    private folderIndex = new Map<string, string[]>(); // folder path -> file paths
    private tagIndex = new Map<string, string[]>(); // tag -> file paths
    private stats: IndexStats = {
        totalFiles: 0,
        keyFiles: 0,
        lastUpdated: 0,
        indexingTime: 0
    };

    private isIndexing = false;
    private indexPromise: Promise<void> | null = null;
    private metadataEventRefs: EventRef[] = [];

    constructor(private vault: Vault, private app?: App) {
        super();
    }

    async initialize(): Promise<void> {
        if (this.isIndexing) {
            return this.indexPromise || Promise.resolve();
        }

        this.isIndexing = true;
        const startTime = Date.now();

        this.indexPromise = this.buildIndex().then(() => {
            this.stats.indexingTime = Date.now() - startTime;
            this.stats.lastUpdated = Date.now();
            this.isIndexing = false;
            this.indexPromise = null;
            this.setupMetadataCacheEvents();
            this.trigger('index:ready', this.stats);
        }).catch(error => {
            console.error('Error building file index:', error);
            this.isIndexing = false;
            this.indexPromise = null;
            throw error;
        });

        return this.indexPromise;
    }

    private async buildIndex(): Promise<void> {
        this.clear();
        
        const files = this.vault.getFiles();
        const markdownFiles = files.filter(file => file.extension === 'md' || file.extension === 'canvas');
        
        // First pass: Create basic index entries
        for (const file of markdownFiles) {
            await this.indexFile(file, false);
        }


        // Second pass: Process metadata for key files (lazy load for others)
        const keyFiles = Array.from(this.fileIndex.values()).filter(f => f.isKeyFile);
        await Promise.all(keyFiles.map(f => this.loadFileMetadata(f.path)));

        this.updateStats();
        this.trigger('index:built', this.stats);
    }

    private async indexFile(file: TFile, loadMetadata = false): Promise<void> {
        const isKeyFile = this.keyFilePatterns.some(pattern => pattern.test(file.path));
        
        const indexed: IndexedFile = {
            path: file.path,
            name: file.name,
            basename: file.basename,
            extension: file.extension,
            parent: file.parent?.path || '/',
            modified: file.stat.mtime,
            created: file.stat.ctime,
            size: file.stat.size,
            isKeyFile
        };

        this.fileIndex.set(file.path, indexed);

        // Update folder index
        const folderPath = file.parent?.path || '/';
        if (!this.folderIndex.has(folderPath)) {
            this.folderIndex.set(folderPath, []);
        }
        this.folderIndex.get(folderPath)!.push(file.path);

        // Load metadata if requested or if it's a key file
        if (loadMetadata || isKeyFile) {
            await this.loadFileMetadata(file.path);
        }
    }

    private async loadFileMetadata(filePath: string): Promise<void> {
        const file = this.vault.getAbstractFileByPath(filePath);
        if (!(file instanceof TFile)) return;

        const indexed = this.fileIndex.get(filePath);
        if (!indexed) return;

        try {
            // Load frontmatter - Note: getFileCache may not be available in all vault types
            const cache = this.app?.metadataCache?.getFileCache(file);
            if (cache) {
                indexed.frontmatter = cache.frontmatter;
                indexed.tags = cache.tags?.map((t: { tag: string }) => t.tag) || [];
                indexed.aliases = cache.frontmatter?.aliases || [];

                // Update tag index
                if (indexed.tags) {
                    indexed.tags.forEach(tag => {
                        if (!this.tagIndex.has(tag)) {
                            this.tagIndex.set(tag, []);
                        }
                        this.tagIndex.get(tag)!.push(filePath);
                    });
                }

                // Extract links
                indexed.forwardLinks = cache.links?.map((l: { link: string }) => l.link) || [];
            }
        } catch (error) {
            console.error(`Error loading metadata for ${filePath}:`, error);
        }
    }

    // File operations
    async updateFile(file: TFile): Promise<void> {
        await this.indexFile(file, true);
        this.updateStats();
        this.trigger('file:updated', file.path);
    }

    removeFile(filePath: string): void {
        const indexed = this.fileIndex.get(filePath);
        if (!indexed) return;

        // Remove from main index
        this.fileIndex.delete(filePath);

        // Remove from folder index
        const folderFiles = this.folderIndex.get(indexed.parent);
        if (folderFiles) {
            const index = folderFiles.indexOf(filePath);
            if (index > -1) {
                folderFiles.splice(index, 1);
            }
        }

        // Remove from tag index
        indexed.tags?.forEach(tag => {
            const tagFiles = this.tagIndex.get(tag);
            if (tagFiles) {
                const index = tagFiles.indexOf(filePath);
                if (index > -1) {
                    tagFiles.splice(index, 1);
                }
            }
        });

        this.updateStats();
        this.trigger('file:removed', filePath);
    }

    async renameFile(oldPath: string, newPath: string): Promise<void> {
        const indexed = this.fileIndex.get(oldPath);
        if (!indexed) return;

        // Remove old entry
        this.removeFile(oldPath);

        // Add new entry
        const file = this.vault.getAbstractFileByPath(newPath);
        if (file instanceof TFile) {
            await this.updateFile(file);
        }

        this.trigger('file:renamed', { oldPath, newPath });
    }

    // Query methods
    getFile(filePath: string): IndexedFile | undefined {
        return this.fileIndex.get(filePath);
    }

    getFiles(): IndexedFile[] {
        return Array.from(this.fileIndex.values());
    }

    getKeyFiles(): IndexedFile[] {
        return Array.from(this.fileIndex.values()).filter(f => f.isKeyFile);
    }


    getFilesInFolder(folderPath: string, recursive = false): IndexedFile[] {
        if (!recursive) {
            const filePaths = this.folderIndex.get(folderPath) || [];
            return filePaths.map(path => this.fileIndex.get(path)).filter(Boolean) as IndexedFile[];
        }

        // Recursive search
        const results: IndexedFile[] = [];
        const processFolder = (path: string) => {
            const filePaths = this.folderIndex.get(path) || [];
            filePaths.forEach(filePath => {
                const file = this.fileIndex.get(filePath);
                if (file) results.push(file);
            });

            // Process subfolders
            this.folderIndex.forEach((_, folderPath) => {
                if (folderPath.startsWith(path + '/')) {
                    processFolder(folderPath);
                }
            });
        };

        processFolder(folderPath);
        return results;
    }

    getFilesWithTag(tag: string): IndexedFile[] {
        const filePaths = this.tagIndex.get(tag) || [];
        return filePaths.map(path => this.fileIndex.get(path)).filter(Boolean) as IndexedFile[];
    }

    getRecentFiles(limit = 10, folderPath?: string): IndexedFile[] {
        const files = folderPath 
            ? this.getFilesInFolder(folderPath, true)
            : this.getFiles();

        return files
            .sort((a, b) => b.modified - a.modified)
            .slice(0, limit);
    }

    searchFiles(predicate: (file: IndexedFile) => boolean): IndexedFile[] {
        return Array.from(this.fileIndex.values()).filter(predicate);
    }

    // Batch operations
    async getFilesWithMetadata(filePaths: string[]): Promise<IndexedFile[]> {
        const results: IndexedFile[] = [];
        
        for (const path of filePaths) {
            let indexed = this.fileIndex.get(path);
            if (indexed) {
                // Ensure metadata is loaded
                if (!indexed.frontmatter && !indexed.tags) {
                    await this.loadFileMetadata(path);
                    indexed = this.fileIndex.get(path);
                }
                if (indexed) {
                    results.push(indexed);
                }
            }
        }

        return results;
    }

    // Stats and maintenance
    getStats(): IndexStats {
        return { ...this.stats };
    }

    private updateStats(): void {
        this.stats.totalFiles = this.fileIndex.size;
        this.stats.keyFiles = Array.from(this.fileIndex.values()).filter(f => f.isKeyFile).length;
        this.stats.lastUpdated = Date.now();
    }

    clear(): void {
        this.fileIndex.clear();
        this.folderIndex.clear();
        this.tagIndex.clear();
        this.stats = {
            totalFiles: 0,
            keyFiles: 0,
            lastUpdated: 0,
            indexingTime: 0
        };
        this.trigger('index:cleared');
    }

    // Performance helpers
    async warmup(filePaths: string[]): Promise<void> {
        // Preload metadata for specified files
        await Promise.all(
            filePaths.map(path => this.loadFileMetadata(path))
        );
    }

    isReady(): boolean {
        return !this.isIndexing && this.fileIndex.size > 0;
    }

    /**
     * Set up metadata cache event listeners for real-time updates
     */
    private setupMetadataCacheEvents(): void {
        if (!this.app?.metadataCache) {
            return;
        }

        const metadataCache = this.app.metadataCache;

        // Listen for metadata changes (tags, frontmatter, links)
        const metadataChangedRef = metadataCache.on('changed', (file: TFile) => {
            this.handleMetadataChanged(file);
        });

        // Listen for resolved metadata (when a file's metadata is fully processed)
        const resolvedRef = metadataCache.on('resolved', () => {
            this.handleMetadataResolved();
        });

        // Store references for cleanup
        this.metadataEventRefs = [
            metadataChangedRef,
            resolvedRef
        ];
    }

    /**
     * Handle metadata cache changes for a specific file
     */
    private async handleMetadataChanged(file: TFile): Promise<void> {
        const indexed = this.fileIndex.get(file.path);
        if (!indexed) {
            // File not in our index yet, add it
            await this.indexFile(file, true);
            return;
        }

        // Clear old tag index entries for this file
        if (indexed.tags) {
            indexed.tags.forEach(tag => {
                const tagFiles = this.tagIndex.get(tag);
                if (tagFiles) {
                    const index = tagFiles.indexOf(file.path);
                    if (index > -1) {
                        tagFiles.splice(index, 1);
                        if (tagFiles.length === 0) {
                            this.tagIndex.delete(tag);
                        }
                    }
                }
            });
        }

        // Reload metadata and update index
        await this.loadFileMetadata(file.path);
        this.updateStats();
        this.trigger('metadata:updated', file.path, indexed);
    }

    /**
     * Handle when metadata cache resolution is complete
     */
    private handleMetadataResolved(): void {
        this.trigger('metadata:resolved');
    }

    /**
     * Clean up metadata cache event listeners
     */
    cleanup(): void {
        // Remove all metadata event listeners
        if (this.app?.metadataCache) {
            this.metadataEventRefs.forEach(eventRef => {
                this.app!.metadataCache.offref(eventRef);
            });
        }
        this.metadataEventRefs = [];

        // Clear all data
        this.clear();
    }
}
```

## database/services/ExportService.ts

```typescript
/**
 * Location: src/database/services/ExportService.ts
 *
 * Export Service
 *
 * Handles data export in various formats following Single Responsibility Principle.
 * Separated from HybridStorageAdapter to keep concerns focused.
 *
 * Export Formats:
 * - OpenAI Fine-tuning: JSONL format for model training
 * - Full Backup: Complete data export for migration/backup
 *
 * Related Files:
 * - src/database/adapters/HybridStorageAdapter.ts - Storage adapter
 * - src/database/repositories/* - Data repositories
 * - src/types/storage/HybridStorageTypes.ts - Export data types
 */

import { App } from 'obsidian';
import { ConversationRepository } from '../repositories/ConversationRepository';
import { MessageRepository } from '../repositories/MessageRepository';
import { ExportFilter, ExportData, MessageData, ConversationExportData, WorkspaceExportData } from '../../types/storage/HybridStorageTypes';

/**
 * Dependencies for ExportService
 * Following Dependency Inversion Principle - depends on abstractions
 */
export interface ExportServiceDependencies {
  app: App;
  conversationRepo: ConversationRepository;
  messageRepo: MessageRepository;
  // Workspace-related repos (if needed for full export)
  workspaceRepo?: any;
  sessionRepo?: any;
  stateRepo?: any;
  traceRepo?: any;
}

/**
 * Export service for data export operations
 *
 * Provides methods to export data in various formats:
 * - Fine-tuning format for LLM training
 * - Full backup format for data migration
 */
export class ExportService {
  private deps: ExportServiceDependencies;

  constructor(deps: ExportServiceDependencies) {
    this.deps = deps;
  }

  // ============================================================================
  // OpenAI Fine-tuning Export
  // ============================================================================

  /**
   * Export conversations in OpenAI fine-tuning format
   *
   * Format: One conversation per line, each line is a JSON object:
   * {"messages": [{"role": "system", "content": "..."}, {"role": "user", "content": "..."}, ...]}
   *
   * @param filter - Optional filter for which conversations to export
   * @returns JSONL string ready for OpenAI fine-tuning API
   */
  async exportForFineTuning(filter?: ExportFilter): Promise<string> {
    const output: string[] = [];

    // Get all conversations (paginated to handle large datasets)
    // Include branches for complete export
    const conversations = await this.deps.conversationRepo.getConversations({
      pageSize: 1000,
      sortBy: 'created',
      sortOrder: 'asc',
      includeBranches: true
    });

    for (const conv of conversations.items) {
      // Apply filters
      if (filter?.conversationIds && !filter.conversationIds.includes(conv.id)) {
        continue;
      }
      if (filter?.startDate && conv.created < filter.startDate) {
        continue;
      }
      if (filter?.endDate && conv.created > filter.endDate) {
        continue;
      }
      if (filter?.workspaceId && conv.workspaceId !== filter.workspaceId) {
        continue;
      }

      // Get all messages for this conversation
      const messagesResult = await this.deps.messageRepo.getMessages(conv.id, {
        pageSize: 10000
      });

      // Filter messages based on export filter
      const filteredMessages = messagesResult.items
        .filter(m => m.state === 'complete') // Only export complete messages
        .filter(m => filter?.includeSystem !== false || m.role !== 'system')
        .filter(m => filter?.includeTools !== false || m.role !== 'tool');

      if (filteredMessages.length === 0) {
        continue; // Skip conversations with no exportable messages
      }

      // Format messages for OpenAI fine-tuning
      const formattedMessages = filteredMessages.map(m => this.formatMessageForExport(m));

      // Inject system prompt from metadata if available and not already present
      const systemPrompt = conv.metadata?.chatSettings?.systemPrompt;
      if (systemPrompt && filter?.includeSystem !== false) {
        const hasSystemMessage = formattedMessages.length > 0 && formattedMessages[0].role === 'system';
        if (!hasSystemMessage) {
          formattedMessages.unshift({
            role: 'system',
            content: systemPrompt
          });
        }
      }

      // Output as single JSONL line
      output.push(JSON.stringify({ messages: formattedMessages }));
    }

    return output.join('\n');
  }

  /**
   * Format a message for OpenAI export
   */
  private formatMessageForExport(message: MessageData): any {
    const formatted: any = {
      role: message.role,
      content: message.content
    };

    // Include tool calls if present
    if (message.toolCalls && message.toolCalls.length > 0) {
      formatted.tool_calls = message.toolCalls.map(tc => ({
        id: tc.id,
        type: 'function',
        function: {
          name: tc.function.name,
          arguments: tc.function.arguments
        }
      }));
    }

    // Include tool call ID if this is a tool response
    if (message.toolCallId) {
      formatted.tool_call_id = message.toolCallId;
    }

    return formatted;
  }

  // ============================================================================
  // Full Data Export
  // ============================================================================

  /**
   * Export all data for backup or migration
   *
   * Includes:
   * - All conversations with messages
   * - All workspaces with sessions, states, and traces (if repos provided)
   *
   * @returns Complete export data structure
   */
  async exportAllData(): Promise<ExportData> {
    const exportedAt = Date.now();

    // Export conversations
    const conversations = await this.exportAllConversations();

    // Export workspaces (if repository provided)
    const workspaces = this.deps.workspaceRepo
      ? await this.exportAllWorkspaces()
      : [];

    return {
      version: '1.0.0',
      exportedAt,
      deviceId: this.getDeviceId(),
      workspaces,
      conversations
    };
  }

  /**
   * Export all conversations with messages
   */
  private async exportAllConversations(): Promise<ConversationExportData[]> {
    // Include branches for complete backup
    const conversationsResult = await this.deps.conversationRepo.getConversations({
      pageSize: 10000,
      includeBranches: true
    });

    return Promise.all(
      conversationsResult.items.map(async (conv) => {
        const messagesResult = await this.deps.messageRepo.getMessages(conv.id, {
          pageSize: 10000
        });

        return {
          metadata: conv,
          messages: messagesResult.items
        };
      })
    );
  }

  /**
   * Export all workspaces with related data
   */
  private async exportAllWorkspaces(): Promise<WorkspaceExportData[]> {
    if (!this.deps.workspaceRepo) {
      return [];
    }

    const workspacesResult = await this.deps.workspaceRepo.getWorkspaces({
      pageSize: 10000
    });

    return Promise.all(
      workspacesResult.items.map(async (ws: any) => {
        // Get sessions
        const sessions = this.deps.sessionRepo
          ? (await this.deps.sessionRepo.getByWorkspaceId(ws.id, { pageSize: 10000 })).items
          : [];

        // Get states
        const states = this.deps.stateRepo
          ? (await this.deps.stateRepo.getStates(ws.id, undefined, { pageSize: 10000 })).items
          : [];

        // Get traces
        const traces = this.deps.traceRepo
          ? (await this.deps.traceRepo.getTraces(ws.id, undefined, { pageSize: 10000 })).items
          : [];

        return {
          metadata: ws,
          sessions,
          states,
          traces
        };
      })
    );
  }

  // ============================================================================
  // Helpers
  // ============================================================================

  /**
   * Get device ID from localStorage
   */
  private getDeviceId(): string {
    return localStorage.getItem('claudesidian-device-id') ?? 'unknown';
  }
}

```

## database/services/index.ts

```typescript
/**
 * Location: src/database/services/index.ts
 *
 * Database Services Exports
 *
 * Central export point for all database services.
 * Services handle cross-cutting concerns like export/import that span multiple repositories.
 */

export { ExportService } from './ExportService';
export type { ExportServiceDependencies } from './ExportService';

// TODO: Add ImportService when implemented
// export { ImportService } from './ImportService';

```

## database/storage/index.ts

```typescript
/**
 * Location: src/database/storage/index.ts
 *
 * Storage Layer - Central export point
 *
 * Exports all storage layer implementations for easy importing.
 */

export * from './JSONLWriter';
export * from './SQLiteCacheManager';

```

## database/storage/JSONLWriter.ts

```typescript
/**
 * Location: src/database/storage/JSONLWriter.ts
 *
 * JSONL File Writer for Append-Only Storage
 *
 * This file provides sync-safe JSONL file operations using Obsidian's Vault API.
 * All writes are append-only to prevent sync conflicts across multiple devices.
 *
 * Design Principles:
 * - Append-only writes prevent sync conflicts
 * - Each line is a complete JSON event
 * - DeviceId tracks which device created each event
 * - Uses Obsidian Vault API (not Node.js fs) for compatibility
 * - Graceful error handling with logging
 *
 * File Structure:
 * - .nexus/workspaces/[workspaceId].jsonl - Workspace events
 * - .nexus/conversations/[conversationId].jsonl - Conversation events
 * - .nexus/sessions/[workspaceId]/[sessionId].jsonl - Session events
 *
 * Related Files:
 * - src/database/interfaces/StorageEvents.ts - Event type definitions
 * - src/database/services/cache/EntityCache.ts - In-memory cache layer
 */

import { App } from 'obsidian';
import { StorageEvent, BaseStorageEvent } from '../interfaces/StorageEvents';
import { v4 as uuidv4 } from '../../utils/uuid';
import { NamedLocks } from '../../utils/AsyncLock';

/**
 * Configuration options for JSONLWriter
 */
export interface JSONLWriterOptions {
  /** Obsidian app instance for vault operations */
  app: App;
  /** Base path for storage (default: '.nexus') */
  basePath: string;
}

/**
 * JSONL Writer for sync-safe append-only storage
 *
 * Provides methods to append events to JSONL files and read them back.
 * Each event is tagged with a deviceId to track origin and enable
 * conflict-free sync across multiple devices.
 *
 * Usage:
 * ```typescript
 * const writer = new JSONLWriter({ app, basePath: '.nexus' });
 *
 * // Append an event
 * const event = await writer.appendEvent('workspaces/workspace-123.jsonl', {
 *   type: 'workspace_created',
 *   data: { id: 'workspace-123', name: 'My Workspace', ... }
 * });
 *
 * // Read all events
 * const events = await writer.readEvents('workspaces/workspace-123.jsonl');
 *
 * // Get events from other devices (for sync)
 * const remoteEvents = await writer.getEventsNotFromDevice(
 *   'workspaces/workspace-123.jsonl',
 *   writer.getDeviceId(),
 *   lastSyncTimestamp
 * );
 * ```
 */
export class JSONLWriter {
  private app: App;
  private basePath: string;
  private deviceId: string;
  private locks: NamedLocks;

  constructor(options: JSONLWriterOptions) {
    this.app = options.app;
    this.basePath = options.basePath;
    this.deviceId = this.getOrCreateDeviceId();
    this.locks = new NamedLocks();
  }

  // ============================================================================
  // Device Management
  // ============================================================================

  /**
   * Get or create a unique device ID for this installation
   *
   * The device ID is stored in localStorage and persists across sessions.
   * This allows tracking which device created each event for sync resolution.
   *
   * @returns Persistent device UUID
   */
  private getOrCreateDeviceId(): string {
    const storageKey = 'claudesidian-device-id';
    let deviceId = localStorage.getItem(storageKey);
    if (!deviceId) {
      deviceId = uuidv4();
      localStorage.setItem(storageKey, deviceId);
    }
    return deviceId;
  }

  /**
   * Get the current device ID
   *
   * @returns Device UUID for this installation
   */
  getDeviceId(): string {
    return this.deviceId;
  }

  // ============================================================================
  // Directory Management
  // ============================================================================

  /**
   * Ensure a directory exists, creating it if necessary
   *
   * @param subPath - Optional subdirectory path relative to basePath
   * @throws Error if directory creation fails
   */
  async ensureDirectory(subPath?: string): Promise<void> {
    const fullPath = subPath ? `${this.basePath}/${subPath}` : this.basePath;
    const folder = this.app.vault.getAbstractFileByPath(fullPath);

    if (!folder) {
      try {
        await this.app.vault.createFolder(fullPath);
      } catch (error) {
        // Ignore "already exists" errors (race condition with metadata cache)
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (!errorMessage.includes('already exists')) {
          console.error(`[JSONLWriter] Failed to ensure directory: ${subPath}`, error);
          throw new Error(`Failed to create directory: ${errorMessage}`);
        }
        // Folder exists on disk but wasn't in metadata cache - that's fine
      }
    }
  }

  // ============================================================================
  // Event Writing
  // ============================================================================

  /**
   * Append an event to a JSONL file (sync-safe)
   *
   * This method creates a complete event with id, deviceId, and timestamp,
   * then appends it as a single line to the JSONL file. If the file doesn't
   * exist, it will be created. Parent directories are created automatically.
   *
   * @param relativePath - File path relative to basePath (e.g., 'workspaces/ws-123.jsonl')
   * @param eventData - Event data without id, deviceId, timestamp (added automatically)
   * @returns The complete event with all metadata
   * @throws Error if append operation fails
   *
   * @example
   * ```typescript
   * const event = await writer.appendEvent('workspaces/ws-123.jsonl', {
   *   type: 'workspace_created',
   *   data: { id: 'ws-123', name: 'My Workspace', rootFolder: '/projects' }
   * });
   * ```
   */
  async appendEvent<T extends BaseStorageEvent>(
    relativePath: string,
    eventData: Omit<T, 'id' | 'deviceId' | 'timestamp'>
  ): Promise<T> {
    try {
      const fullPath = `${this.basePath}/${relativePath}`;

      // Create the full event with metadata
      const event: T = {
        ...eventData,
        id: uuidv4(),
        deviceId: this.deviceId,
        timestamp: Date.now(),
      } as T;

      const line = JSON.stringify(event) + '\n';

      // Ensure parent directory exists
      const lastSlashIndex = fullPath.lastIndexOf('/');
      if (lastSlashIndex > 0) {
        const parentPath = fullPath.substring(0, lastSlashIndex);
        const relativeParent = parentPath.replace(this.basePath + '/', '');
        await this.ensureDirectory(relativeParent);
      }

      // Use adapter methods for hidden folder support (.nexus/)
      // Use lock to prevent race conditions
      await this.locks.acquire(fullPath, async () => {
        const exists = await this.app.vault.adapter.exists(fullPath);

        if (exists) {
          // Use atomic append (DataAdapter always has append method)
          // Blind append: Safety first -> always add newline prefix to ensure separation
          // This might result in double newlines (harmless), but prevents merged lines (fatal)
          await this.app.vault.adapter.append(fullPath, '\n' + line);
        } else {
          // Create new file with this line
          await this.app.vault.adapter.write(fullPath, line);
        }
      });

      return event;
    } catch (error) {
      console.error(`[JSONLWriter] Failed to append event to ${relativePath}:`, error);
      const message = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to append event: ${message}`);
    }
  }

  /**
   * Append multiple events to a JSONL file in a single write (efficient for migration)
   *
   * Unlike appendEvent which reads/writes for each event, this batches all events
   * into a single file operation. Much faster for bulk operations.
   *
   * @param relativePath - File path relative to basePath
   * @param eventsData - Array of event data without id, deviceId, timestamp
   * @returns Array of complete events with all metadata
   */
  async appendEvents<T extends BaseStorageEvent>(
    relativePath: string,
    eventsData: Array<Omit<T, 'id' | 'deviceId' | 'timestamp'>>
  ): Promise<T[]> {
    if (eventsData.length === 0) {
      return [];
    }

    try {
      const fullPath = `${this.basePath}/${relativePath}`;

      // Create all events with metadata
      const events: T[] = eventsData.map(eventData => ({
        ...eventData,
        id: uuidv4(),
        deviceId: this.deviceId,
        timestamp: Date.now(),
      } as T));

      const lines = events.map(event => JSON.stringify(event)).join('\n') + '\n';

      // Ensure parent directory exists
      const lastSlashIndex = fullPath.lastIndexOf('/');
      if (lastSlashIndex > 0) {
        const parentPath = fullPath.substring(0, lastSlashIndex);
        const relativeParent = parentPath.replace(this.basePath + '/', '');
        await this.ensureDirectory(relativeParent);
      }

      // Use adapter methods for hidden folder support (.nexus/)
      // Use lock to prevent race conditions
      await this.locks.acquire(fullPath, async () => {
        const exists = await this.app.vault.adapter.exists(fullPath);

        if (exists) {
          // Use atomic append (DataAdapter always has append method)
          // Blind append: Safety first -> always add newline prefix
          await this.app.vault.adapter.append(fullPath, '\n' + lines);
        } else {
          // Create new file with all lines
          await this.app.vault.adapter.write(fullPath, lines);
        }
      });

      return events;
    } catch (error) {
      console.error(`[JSONLWriter] Failed to append ${eventsData.length} events to ${relativePath}:`, error);
      const message = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to append events: ${message}`);
    }
  }

  // ============================================================================
  // Event Reading
  // ============================================================================

  /**
   * Read all events from a JSONL file
   *
   * Parses each line as a JSON event. Invalid lines are logged and skipped.
   *
   * @param relativePath - File path relative to basePath
   * @returns Array of parsed events (empty if file doesn't exist)
   *
   * @example
   * ```typescript
   * const events = await writer.readEvents('workspaces/ws-123.jsonl');
   * console.log(`Found ${events.length} events`);
   * ```
   */
  async readEvents<T extends StorageEvent>(relativePath: string): Promise<T[]> {
    try {
      const fullPath = `${this.basePath}/${relativePath}`;

      // Use adapter.exists and adapter.read for hidden folder support (.nexus/)
      const exists = await this.app.vault.adapter.exists(fullPath);
      if (!exists) {
        return [];
      }

      const content = await this.app.vault.adapter.read(fullPath);
      const lines = content.split('\n').filter(line => line.trim());

      const events: T[] = [];
      for (let i = 0; i < lines.length; i++) {
        try {
          const event = JSON.parse(lines[i]) as T;
          events.push(event);
        } catch (e) {
        }
      }

      return events;
    } catch (error) {
      console.error(`[JSONLWriter] Failed to read events from ${relativePath}:`, error);
      return [];
    }
  }

  /**
   * Get events newer than a specific timestamp
   *
   * Useful for incremental sync operations.
   *
   * @param relativePath - File path relative to basePath
   * @param since - Unix timestamp (milliseconds)
   * @returns Array of events created after the timestamp
   *
   * @example
   * ```typescript
   * const lastSync = Date.now() - 3600000; // 1 hour ago
   * const recentEvents = await writer.getEventsSince('workspaces/ws-123.jsonl', lastSync);
   * ```
   */
  async getEventsSince<T extends StorageEvent>(
    relativePath: string,
    since: number
  ): Promise<T[]> {
    const events = await this.readEvents<T>(relativePath);
    return events.filter(event => event.timestamp > since);
  }

  /**
   * Get events from a specific device
   *
   * Useful for tracking what events were created locally.
   *
   * @param relativePath - File path relative to basePath
   * @param deviceId - Target device ID
   * @returns Array of events from the specified device
   */
  async getEventsFromDevice<T extends StorageEvent>(
    relativePath: string,
    deviceId: string
  ): Promise<T[]> {
    const events = await this.readEvents<T>(relativePath);
    return events.filter(event => event.deviceId === deviceId);
  }

  /**
   * Get events NOT from a specific device (for sync)
   *
   * This is the primary method for detecting remote changes during sync.
   * Returns events created by other devices, optionally filtered by timestamp.
   *
   * @param relativePath - File path relative to basePath
   * @param deviceId - Current device ID (to exclude)
   * @param since - Optional timestamp to filter recent events
   * @returns Array of events from other devices
   *
   * @example
   * ```typescript
   * // Get all remote changes since last sync
   * const remoteChanges = await writer.getEventsNotFromDevice(
   *   'workspaces/ws-123.jsonl',
   *   writer.getDeviceId(),
   *   lastSyncTimestamp
   * );
   * ```
   */
  async getEventsNotFromDevice<T extends StorageEvent>(
    relativePath: string,
    deviceId: string,
    since?: number
  ): Promise<T[]> {
    let events = await this.readEvents<T>(relativePath);
    events = events.filter(event => event.deviceId !== deviceId);
    if (since !== undefined) {
      events = events.filter(event => event.timestamp > since);
    }
    return events;
  }

  // ============================================================================
  // File Management
  // ============================================================================

  /**
   * List all JSONL files in a subdirectory
   *
   * @param subPath - Subdirectory path relative to basePath
   * @returns Array of relative file paths
   *
   * @example
   * ```typescript
   * const workspaceFiles = await writer.listFiles('workspaces');
   * // Returns: ['workspaces/ws-1.jsonl', 'workspaces/ws-2.jsonl']
   * ```
   */
  async listFiles(subPath: string): Promise<string[]> {
    try {
      const fullPath = `${this.basePath}/${subPath}`;

      // Use adapter.list for hidden folder support (.nexus/)
      const exists = await this.app.vault.adapter.exists(fullPath);
      if (!exists) {
        return [];
      }

      const listing = await this.app.vault.adapter.list(fullPath);
      return listing.files
        .filter(f => f.endsWith('.jsonl'))
        .map(f => f.replace(`${this.basePath}/`, ''));
    } catch (error) {
      console.error(`[JSONLWriter] Failed to list files in ${subPath}:`, error);
      return [];
    }
  }

  /**
   * Check if a JSONL file exists
   *
   * @param relativePath - File path relative to basePath
   * @returns True if file exists
   */
  async fileExists(relativePath: string): Promise<boolean> {
    const fullPath = `${this.basePath}/${relativePath}`;
    // Use adapter.exists for hidden folder support (.nexus/)
    return await this.app.vault.adapter.exists(fullPath);
  }

  /**
   * Delete a JSONL file
   *
   * Warning: This operation cannot be undone. Consider soft deletes using
   * deletion events instead.
   *
   * @param relativePath - File path relative to basePath
   * @throws Error if deletion fails
   */
  async deleteFile(relativePath: string): Promise<void> {
    try {
      const fullPath = `${this.basePath}/${relativePath}`;
      // Use adapter for hidden folder support (.nexus/)
      const exists = await this.app.vault.adapter.exists(fullPath);
      if (exists) {
        await this.app.vault.adapter.remove(fullPath);
      }
    } catch (error) {
      console.error(`[JSONLWriter] Failed to delete file ${relativePath}:`, error);
      const message = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to delete file: ${message}`);
    }
  }

  /**
   * Get file modification time
   *
   * @param relativePath - File path relative to basePath
   * @returns Unix timestamp (milliseconds) or null if file doesn't exist
   */
  async getFileModTime(relativePath: string): Promise<number | null> {
    try {
      const fullPath = `${this.basePath}/${relativePath}`;
      // Use adapter for hidden folder support (.nexus/)
      const exists = await this.app.vault.adapter.exists(fullPath);
      if (!exists) {
        return null;
      }
      const stat = await this.app.vault.adapter.stat(fullPath);
      return stat?.mtime ?? null;
    } catch (error) {
      console.error(`[JSONLWriter] Failed to get mod time for ${relativePath}:`, error);
      return null;
    }
  }

  /**
   * Get file size in bytes
   *
   * @param relativePath - File path relative to basePath
   * @returns File size in bytes or null if file doesn't exist
   */
  async getFileSize(relativePath: string): Promise<number | null> {
    try {
      const fullPath = `${this.basePath}/${relativePath}`;
      // Use adapter for hidden folder support (.nexus/)
      const exists = await this.app.vault.adapter.exists(fullPath);
      if (!exists) {
        return null;
      }
      const stat = await this.app.vault.adapter.stat(fullPath);
      return stat?.size ?? null;
    } catch (error) {
      console.error(`[JSONLWriter] Failed to get size for ${relativePath}:`, error);
      return null;
    }
  }

  /**
   * Get statistics about a JSONL file
   *
   * @param relativePath - File path relative to basePath
   * @returns File statistics or null if file doesn't exist
   */
  async getFileStats(relativePath: string): Promise<{
    exists: boolean;
    size: number;
    modTime: number;
    eventCount: number;
  } | null> {
    try {
      const exists = await this.fileExists(relativePath);
      if (!exists) {
        return null;
      }

      const size = await this.getFileSize(relativePath);
      const modTime = await this.getFileModTime(relativePath);
      const events = await this.readEvents(relativePath);

      return {
        exists: true,
        size: size || 0,
        modTime: modTime || 0,
        eventCount: events.length,
      };
    } catch (error) {
      console.error(`[JSONLWriter] Failed to get stats for ${relativePath}:`, error);
      return null;
    }
  }
}

```

## database/storage/SQLiteCacheManager.ts

```typescript
/**
 * Location: src/database/storage/SQLiteCacheManager.ts
 * Purpose: SQLite cache manager using @dao-xyz/sqlite3-vec WASM for hybrid storage system
 *
 * Provides:
 * - Local cache for fast queries and true pagination
 * - Native vector search via sqlite-vec (compiled into WASM)
 * - Manual file persistence via serialize/deserialize (Obsidian Sync compatible)
 * - Full-text search via FTS4
 * - Transaction support
 * - Event tracking to prevent duplicate processing
 *
 * Relationships:
 * - Used by StorageManager for fast queries
 * - Backed by JSONL files in EventLogManager
 * - Implements IStorageBackend interface
 *
 * Architecture Notes:
 * - Uses WASM build of SQLite with sqlite-vec statically compiled
 * - In-memory database with manual file persistence
 * - sqlite3_js_db_export() to serialize, sqlite3_deserialize() to load
 * - Works in Electron renderer (no native bindings)
 */

// Import the raw WASM sqlite3 module (has sqlite-vec compiled in)
// esbuild alias resolves this to index.mjs which exports sqlite3InitModule
// @ts-ignore - esbuild alias handling
import sqlite3InitModule from '@dao-xyz/sqlite3-vec/wasm';

import { App, normalizePath } from 'obsidian';
import { PaginatedResult, PaginationParams } from '../../types/pagination/PaginationTypes';
import { IStorageBackend, RunResult, DatabaseStats } from '../interfaces/IStorageBackend';
import type { SyncState, ISQLiteCacheManager } from '../sync/SyncCoordinator';
import { SQLiteSearchService } from './SQLiteSearchService';

// Import schema from TypeScript module (esbuild compatible)
import { SCHEMA_SQL } from '../schema/schema';
import { SchemaMigrator, CURRENT_SCHEMA_VERSION } from '../schema/SchemaMigrator';

export interface SQLiteCacheManagerOptions {
  app: App;
  dbPath: string;  // e.g., '.nexus/cache.db'
  autoSaveInterval?: number;  // ms between auto-saves (default: 30000)
}

export interface QueryResult<T> {
  items: T[];
  totalCount?: number;
}

/**
 * SQLite cache manager using @dao-xyz/sqlite3-vec WASM
 *
 * Features:
 * - SQLite + sqlite-vec via WASM (no native bindings)
 * - Manual file persistence via serialize/deserialize
 * - Native vector search for embeddings
 * - Full-text search with FTS4
 * - Cursor-based pagination
 * - Transaction support
 */
export class SQLiteCacheManager implements IStorageBackend, ISQLiteCacheManager {
  private app: App;
  private dbPath: string;  // Relative path within vault
  private sqlite3: any = null;  // The sqlite3 WASM module
  private db: any = null;  // The oo1.DB instance
  private isInitialized: boolean = false;
  private searchService: SQLiteSearchService;
  private hasUnsavedData: boolean = false;
  private autoSaveInterval: number;
  private autoSaveTimer: NodeJS.Timeout | null = null;

  constructor(options: SQLiteCacheManagerOptions) {
    this.app = options.app;
    this.dbPath = options.dbPath;
    this.autoSaveInterval = options.autoSaveInterval ?? 30000;  // 30 seconds default
    this.searchService = new SQLiteSearchService(this);
  }

  /**
   * Resolve the sqlite3.wasm path for the currently-installed plugin folder.
   *
   * Nexus supports legacy installs under `.obsidian/plugins/claudesidian-mcp/`
   * as well as the current `.obsidian/plugins/nexus/` folder.
   */
  private async resolveSqliteWasmPath(): Promise<string> {
    const configDir = this.app.vault.configDir || '.obsidian';
    const candidatePluginFolders = ['nexus', 'claudesidian-mcp'];
    const candidates = candidatePluginFolders.map(folder => `${configDir}/plugins/${folder}/sqlite3.wasm`);

    for (const candidate of candidates) {
      try {
        if (await this.app.vault.adapter.exists(candidate)) {
          return candidate;
        }
      } catch (error) {
        // Ignore adapter errors and continue trying other candidates.
      }
    }

    throw new Error(
      `[SQLiteCacheManager] sqlite3.wasm not found. Looked in: ${candidates.join(', ')}`
    );
  }

  /**
   * Initialize sqlite3 WASM and create/open database
   * Uses in-memory database with manual file persistence
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      // Load WASM binary using Obsidian's vault adapter
      // The WASM file is copied to the plugin directory by esbuild
      const wasmPath = await this.resolveSqliteWasmPath();

      // Read WASM binary using Obsidian's API
      const wasmBinary = await this.app.vault.adapter.readBinary(wasmPath);

      const originalWarn = console.warn;
      const originalLog = console.log;
      const suppressPatterns = [
        /OPFS sqlite3_vfs/,
        /Heap resize call/,
        /instantiateWasm/
      ];
      console.warn = (...args: any[]) => {
        const msg = args[0]?.toString() || '';
        if (!suppressPatterns.some(p => p.test(msg))) {
          originalWarn.apply(console, args);
        }
      };
      console.log = (...args: any[]) => {
        const msg = args[0]?.toString() || '';
        if (!suppressPatterns.some(p => p.test(msg))) {
          originalLog.apply(console, args);
        }
      };

      try {
        this.sqlite3 = await sqlite3InitModule({
          instantiateWasm: (imports: WebAssembly.Imports, successCallback: (instance: WebAssembly.Instance) => void) => {
            WebAssembly.instantiate(wasmBinary, imports)
              .then(result => {
                successCallback(result.instance);
              })
              .catch(err => {
                console.error('[SQLiteCacheManager] WASM instantiation failed:', err);
              });
            return {};
          },
          print: () => {},
          printErr: (msg: string) => console.error('[SQLite]', msg)
        });
      } finally {
        console.warn = originalWarn;
        console.log = originalLog;
      }

      // Ensure parent directory exists
      const parentPath = this.dbPath.substring(0, this.dbPath.lastIndexOf('/'));
      const parentExists = await this.app.vault.adapter.exists(parentPath);
      if (!parentExists) {
        await this.app.vault.adapter.mkdir(parentPath);
      }

      // Check if database file exists
      const dbExists = await this.app.vault.adapter.exists(this.dbPath);

      if (dbExists) {
        // Load existing database from file
        await this.loadFromFile();
      } else {
        this.db = new this.sqlite3.oo1.DB(':memory:');
        this.db.exec(SCHEMA_SQL);
        await this.saveToFile();
      }

      // Start auto-save timer
      if (this.autoSaveInterval > 0) {
        this.autoSaveTimer = setInterval(() => {
          if (this.hasUnsavedData) {
            this.saveToFile().catch(err => {
              console.error('[SQLiteCacheManager] Auto-save failed:', err);
            });
          }
        }, this.autoSaveInterval);
      }

      this.isInitialized = true;
    } catch (error) {
      console.error('[SQLiteCacheManager] Initialization failed:', error);
      throw error;
    }
  }

  /**
   * Load database from file using sqlite3_deserialize
   * Includes corruption detection and auto-recovery
   */
  private async loadFromFile(): Promise<void> {
    try {
      // Read binary data from vault
      const data = await this.app.vault.adapter.readBinary(this.dbPath);
      const uint8 = new Uint8Array(data);

      if (uint8.length === 0) {
        // Empty file, create new database
        this.db = new this.sqlite3.oo1.DB(':memory:');
        this.db.exec(SCHEMA_SQL);
        return;
      }

      // Allocate memory for the database bytes
      const ptr = this.sqlite3.wasm.allocFromTypedArray(uint8);

      // Create empty in-memory database
      this.db = new this.sqlite3.oo1.DB(':memory:');

      // Deserialize the data into the database
      const rc = this.sqlite3.capi.sqlite3_deserialize(
        this.db.pointer,
        'main',
        ptr,
        uint8.byteLength,
        uint8.byteLength,
        this.sqlite3.capi.SQLITE_DESERIALIZE_FREEONCLOSE |
        this.sqlite3.capi.SQLITE_DESERIALIZE_RESIZEABLE
      );

      if (rc !== 0) {
        throw new Error(`sqlite3_deserialize failed with code ${rc}`);
      }

      // Verify database integrity
      try {
        const integrityResult = this.db.selectValue('PRAGMA integrity_check');
        if (integrityResult !== 'ok') {
          throw new Error(`Database integrity check failed: ${integrityResult}`);
        }
      } catch (integrityError) {
        await this.recreateCorruptedDatabase();
        return;
      }

      this.hasUnsavedData = false;
    } catch (error) {
      console.error('[SQLiteCacheManager] Failed to load from file:', error);
      await this.recreateCorruptedDatabase();
    }
  }

  /**
   * Recreate database after corruption detected
   * Deletes corrupt file and creates fresh database
   */
  private async recreateCorruptedDatabase(): Promise<void> {
    if (this.db) {
      try {
        this.db.close();
      } catch {
      }
      this.db = null;
    }

    try {
      await this.app.vault.adapter.remove(this.dbPath);
    } catch {
    }

    this.db = new this.sqlite3.oo1.DB(':memory:');
    this.db.exec(SCHEMA_SQL);
    await this.saveToFile();
  }

  /**
   * Save database to file using sqlite3_js_db_export
   */
  private async saveToFile(): Promise<void> {
    if (!this.db) return;

    try {
      const originalLog = console.log;
      console.log = (...args: any[]) => {
        const msg = args[0]?.toString() || '';
        if (!/Heap resize call/.test(msg)) {
          originalLog.apply(console, args);
        }
      };

      let data: any;
      try {
        data = this.sqlite3.capi.sqlite3_js_db_export(this.db.pointer);
      } finally {
        console.log = originalLog;
      }

      await this.app.vault.adapter.writeBinary(this.dbPath, data.buffer);

      this.hasUnsavedData = false;
    } catch (error) {
      console.error('[SQLiteCacheManager] Failed to save to file:', error);
      throw error;
    }
  }

  /**
   * Close the database and save to file
   */
  async close(): Promise<void> {
    try {
      // Stop auto-save timer
      if (this.autoSaveTimer) {
        clearInterval(this.autoSaveTimer);
        this.autoSaveTimer = null;
      }

      // Final save
      if (this.hasUnsavedData) {
        await this.saveToFile();
      }

      if (this.db) {
        this.db.close();
        this.db = null;
      }
      this.isInitialized = false;
    } catch (error) {
      console.error('[SQLiteCacheManager] Error closing database:', error);
      throw error;
    }
  }

  /**
   * Execute raw SQL (for schema creation and multi-statement execution)
   * NOTE: Does not support parameters - use run() or query() for parameterized queries
   */
  async exec(sql: string): Promise<void> {
    if (!this.db) throw new Error('Database not initialized');

    try {
      this.db.exec(sql);
      this.hasUnsavedData = true;
    } catch (error) {
      console.error('[SQLiteCacheManager] Exec failed:', error);
      throw error;
    }
  }

  /**
   * Query returning multiple rows
   */
  async query<T>(sql: string, params?: any[]): Promise<T[]> {
    if (!this.db) throw new Error('Database not initialized');

    try {
      const stmt = this.db.prepare(sql);
      try {
        if (params?.length) {
          stmt.bind(params);
        }
        const results: T[] = [];
        while (stmt.step()) {
          results.push(stmt.get({}) as T);
        }
        return results;
      } finally {
        stmt.finalize();
      }
    } catch (error) {
      console.error('[SQLiteCacheManager] Query failed:', error, { sql, params });
      throw error;
    }
  }

  /**
   * Query returning single row
   */
  async queryOne<T>(sql: string, params?: any[]): Promise<T | null> {
    if (!this.db) throw new Error('Database not initialized');

    try {
      const stmt = this.db.prepare(sql);
      try {
        if (params?.length) {
          stmt.bind(params);
        }
        if (stmt.step()) {
          return stmt.get({}) as T;
        }
        return null;
      } finally {
        stmt.finalize();
      }
    } catch (error) {
      console.error('[SQLiteCacheManager] QueryOne failed:', error, { sql, params });
      throw error;
    }
  }

  /**
   * Run a statement (INSERT, UPDATE, DELETE)
   * Returns changes count and last insert rowid
   */
  async run(sql: string, params?: any[]): Promise<RunResult> {
    if (!this.db) throw new Error('Database not initialized');

    try {
      const stmt = this.db.prepare(sql);
      try {
        if (params?.length) {
          stmt.bind(params);
        }
        stmt.stepReset();
      } finally {
        stmt.finalize();
      }

      // Get changes count and last insert rowid
      const changes = this.db.changes();
      const lastInsertRowid = Number(this.sqlite3.capi.sqlite3_last_insert_rowid(this.db.pointer));

      this.hasUnsavedData = true;
      return { changes, lastInsertRowid };
    } catch (error) {
      console.error('[SQLiteCacheManager] Run failed:', error, { sql, params });
      throw error;
    }
  }

  /**
   * Begin a transaction
   */
  async beginTransaction(): Promise<void> {
    this.db.exec('BEGIN TRANSACTION');
  }

  /**
   * Commit a transaction
   */
  async commit(): Promise<void> {
    this.db.exec('COMMIT');
    this.hasUnsavedData = true;
  }

  /**
   * Rollback a transaction
   */
  async rollback(): Promise<void> {
    this.db.exec('ROLLBACK');
  }

  /**
   * Execute a function within a transaction
   */
  async transaction<T>(fn: () => Promise<T>): Promise<T> {
    await this.beginTransaction();
    try {
      const result = await fn();
      await this.commit();
      return result;
    } catch (error) {
      await this.rollback();
      throw error;
    }
  }

  // ==================== Higher-level query methods ====================

  /**
   * Get paginated results with offset-based pagination
   */
  async queryPaginated<T>(
    baseQuery: string,
    countQuery: string,
    options: PaginationParams = {},
    params: any[] = []
  ): Promise<PaginatedResult<T>> {
    const page = options.page ?? 0;
    const pageSize = Math.min(options.pageSize ?? 25, 200);
    const offset = page * pageSize;

    // Get total count
    const countResult = await this.queryOne<{ count: number }>(countQuery, params);
    const totalItems = countResult?.count ?? 0;
    const totalPages = Math.ceil(totalItems / pageSize);

    // Get paginated results
    const paginatedQuery = `${baseQuery} LIMIT ? OFFSET ?`;
    const items = await this.query<T>(paginatedQuery, [...params, pageSize, offset]);

    return {
      items,
      page,
      pageSize,
      totalItems,
      totalPages,
      hasNextPage: page < totalPages - 1,
      hasPreviousPage: page > 0
    };
  }

  // ==================== Event tracking ====================

  /**
   * Check if an event has already been applied
   */
  async isEventApplied(eventId: string): Promise<boolean> {
    const result = await this.queryOne<{ eventId: string }>(
      'SELECT eventId FROM applied_events WHERE eventId = ?',
      [eventId]
    );
    return result !== null;
  }

  /**
   * Mark an event as applied
   */
  async markEventApplied(eventId: string): Promise<void> {
    await this.run(
      'INSERT OR IGNORE INTO applied_events (eventId, appliedAt) VALUES (?, ?)',
      [eventId, Date.now()]
    );
  }

  /**
   * Get list of applied event IDs after a timestamp
   */
  async getAppliedEventsAfter(timestamp: number): Promise<string[]> {
    const results = await this.query<{ eventId: string }>(
      'SELECT eventId FROM applied_events WHERE appliedAt > ? ORDER BY appliedAt',
      [timestamp]
    );
    return results.map(r => r.eventId);
  }

  // ==================== Sync state ====================

  /**
   * Get sync state for a device
   */
  async getSyncState(deviceId: string): Promise<SyncState | null> {
    const result = await this.queryOne<{ deviceId: string; lastEventTimestamp: number; syncedFilesJson: string }>(
      'SELECT deviceId, lastEventTimestamp, syncedFilesJson FROM sync_state WHERE deviceId = ?',
      [deviceId]
    );

    if (!result) return null;

    return {
      deviceId: result.deviceId,
      lastEventTimestamp: result.lastEventTimestamp,
      fileTimestamps: result.syncedFilesJson ? JSON.parse(result.syncedFilesJson) : {}
    };
  }

  /**
   * Update sync state for a device
   */
  async updateSyncState(deviceId: string, lastEventTimestamp: number, fileTimestamps: Record<string, number>): Promise<void> {
    await this.run(
      `INSERT OR REPLACE INTO sync_state (deviceId, lastEventTimestamp, syncedFilesJson)
       VALUES (?, ?, ?)`,
      [deviceId, lastEventTimestamp, JSON.stringify(fileTimestamps)]
    );
  }

  // ==================== Data management ====================

  /**
   * Clear all data (for rebuilding from JSONL)
   */
  async clearAllData(): Promise<void> {
    await this.transaction(async () => {
      this.db.exec(`
        DELETE FROM messages;
        DELETE FROM conversations;
        DELETE FROM memory_traces;
        DELETE FROM states;
        DELETE FROM sessions;
        DELETE FROM workspaces;
        DELETE FROM applied_events;
        DELETE FROM sync_state;
      `);
    });
  }

  /**
   * Rebuild FTS5 indexes after bulk data changes
   */
  async rebuildFTSIndexes(): Promise<void> {
    await this.transaction(async () => {
      // Rebuild workspace FTS5
      this.db.exec(`
        INSERT INTO workspace_fts(workspace_fts) VALUES ('rebuild');
      `);

      // Rebuild conversation FTS5
      this.db.exec(`
        INSERT INTO conversation_fts(conversation_fts) VALUES ('rebuild');
      `);

      // Rebuild message FTS5
      this.db.exec(`
        INSERT INTO message_fts(message_fts) VALUES ('rebuild');
      `);
    });
  }

  /**
   * Vacuum the database to reclaim space
   */
  async vacuum(): Promise<void> {
    if (!this.db) throw new Error('Database not initialized');

    try {
      this.db.exec('VACUUM');
      this.hasUnsavedData = true;
    } catch (error) {
      console.error('[SQLiteCacheManager] Vacuum failed:', error);
      throw error;
    }
  }

  // ==================== Full-text search ====================
  // Delegated to SQLiteSearchService for single responsibility

  /**
   * Search workspaces using FTS4
   */
  async searchWorkspaces(query: string, limit: number = 50): Promise<any[]> {
    return this.searchService.searchWorkspaces(query, limit);
  }

  /**
   * Search conversations using FTS4
   */
  async searchConversations(query: string, limit: number = 50): Promise<any[]> {
    return this.searchService.searchConversations(query, limit);
  }

  /**
   * Search messages using FTS4
   */
  async searchMessages(query: string, limit: number = 50): Promise<any[]> {
    return this.searchService.searchMessages(query, limit);
  }

  /**
   * Search messages within a specific conversation using FTS4
   */
  async searchMessagesInConversation(conversationId: string, query: string, limit: number = 50): Promise<any[]> {
    return this.searchService.searchMessagesInConversation(conversationId, query, limit);
  }

  // ==================== Statistics ====================

  /**
   * Get database statistics
   */
  async getStatistics(): Promise<{
    workspaces: number;
    sessions: number;
    states: number;
    traces: number;
    conversations: number;
    messages: number;
    appliedEvents: number;
    dbSizeBytes: number;
  }> {
    const stats = await Promise.all([
      this.queryOne<{ count: number }>('SELECT COUNT(*) as count FROM workspaces'),
      this.queryOne<{ count: number }>('SELECT COUNT(*) as count FROM sessions'),
      this.queryOne<{ count: number }>('SELECT COUNT(*) as count FROM states'),
      this.queryOne<{ count: number }>('SELECT COUNT(*) as count FROM memory_traces'),
      this.queryOne<{ count: number }>('SELECT COUNT(*) as count FROM conversations'),
      this.queryOne<{ count: number }>('SELECT COUNT(*) as count FROM messages'),
      this.queryOne<{ count: number }>('SELECT COUNT(*) as count FROM applied_events'),
    ]);

    // Get file size from filesystem
    let dbSizeBytes = 0;
    try {
      const exists = await this.app.vault.adapter.exists(this.dbPath);
      if (exists) {
        const stat = await this.app.vault.adapter.stat(this.dbPath);
        dbSizeBytes = stat?.size ?? 0;
      }
    } catch {
    }

    return {
      workspaces: stats[0]?.count ?? 0,
      sessions: stats[1]?.count ?? 0,
      states: stats[2]?.count ?? 0,
      traces: stats[3]?.count ?? 0,
      conversations: stats[4]?.count ?? 0,
      messages: stats[5]?.count ?? 0,
      appliedEvents: stats[6]?.count ?? 0,
      dbSizeBytes
    };
  }

  // ==================== Utilities ====================

  /**
   * Check if database is initialized
   */
  isReady(): boolean {
    return this.isInitialized && this.db !== null;
  }

  /**
   * Get database path (relative)
   */
  getDbPath(): string {
    return this.dbPath;
  }

  /**
   * Force save to file
   */
  async save(): Promise<void> {
    await this.saveToFile();
  }

  /**
   * Check if there are unsaved changes
   */
  hasUnsavedChanges(): boolean {
    return this.hasUnsavedData;
  }

  // ==================== IStorageBackend interface methods ====================

  /**
   * Check if database is open and ready (IStorageBackend requirement)
   */
  isOpen(): boolean {
    return this.isReady();
  }

  /**
   * Get database path (IStorageBackend requirement)
   */
  getDatabasePath(): string | null {
    return this.dbPath;
  }

  /**
   * Get database statistics (IStorageBackend requirement)
   */
  async getStats(): Promise<DatabaseStats> {
    const stats = await this.getStatistics();

    // Count tables
    const tableCountResult = await this.queryOne<{ count: number }>(
      "SELECT COUNT(*) as count FROM sqlite_master WHERE type='table'"
    );
    const tableCount = tableCountResult?.count ?? 0;

    return {
      fileSize: stats.dbSizeBytes,
      tableCount,
      totalRows: stats.workspaces + stats.sessions + stats.states + stats.traces +
                 stats.conversations + stats.messages,
      tableCounts: {
        workspaces: stats.workspaces,
        sessions: stats.sessions,
        states: stats.states,
        memory_traces: stats.traces,
        conversations: stats.conversations,
        messages: stats.messages,
        applied_events: stats.appliedEvents
      },
      walMode: false  // WASM doesn't use WAL mode
    };
  }
}

```

## database/storage/SQLiteSearchService.ts

```typescript
/**
 * Location: src/database/storage/SQLiteSearchService.ts
 *
 * Full-text search service using SQLite FTS5.
 * Extracted from SQLiteCacheManager for single responsibility.
 */

export interface IQueryExecutor {
  query<T>(sql: string, params?: any[]): Promise<T[]>;
}

export class SQLiteSearchService {
  private queryExecutor: IQueryExecutor;

  constructor(queryExecutor: IQueryExecutor) {
    this.queryExecutor = queryExecutor;
  }

  /**
   * Search workspaces using FTS5
   */
  async searchWorkspaces(query: string, limit: number = 50): Promise<any[]> {
    // FTS5 uses double quotes for phrase search, escape special chars
    const ftsQuery = this.escapeFTS5Query(query);
    return this.queryExecutor.query(
      `SELECT w.* FROM workspaces w
       JOIN workspace_fts fts ON w.rowid = fts.rowid
       WHERE workspace_fts MATCH ?
       ORDER BY rank, w.lastAccessed DESC
       LIMIT ?`,
      [ftsQuery, limit]
    );
  }

  /**
   * Search conversations using FTS5
   */
  async searchConversations(query: string, limit: number = 50): Promise<any[]> {
    const ftsQuery = this.escapeFTS5Query(query);
    return this.queryExecutor.query(
      `SELECT c.* FROM conversations c
       JOIN conversation_fts fts ON c.rowid = fts.rowid
       WHERE conversation_fts MATCH ?
       ORDER BY rank, c.updated DESC
       LIMIT ?`,
      [ftsQuery, limit]
    );
  }

  /**
   * Search messages using FTS5
   */
  async searchMessages(query: string, limit: number = 50): Promise<any[]> {
    const ftsQuery = this.escapeFTS5Query(query);
    return this.queryExecutor.query(
      `SELECT m.* FROM messages m
       JOIN message_fts fts ON m.rowid = fts.rowid
       WHERE message_fts MATCH ?
       ORDER BY rank, m.timestamp DESC
       LIMIT ?`,
      [ftsQuery, limit]
    );
  }

  /**
   * Search messages within a specific conversation using FTS5
   */
  async searchMessagesInConversation(conversationId: string, query: string, limit: number = 50): Promise<any[]> {
    // Use FTS5 column filter syntax
    const ftsQuery = this.escapeFTS5Query(query);
    return this.queryExecutor.query(
      `SELECT m.* FROM messages m
       JOIN message_fts fts ON m.rowid = fts.rowid
       WHERE message_fts MATCH ? AND fts.conversationId = ?
       ORDER BY rank, m.timestamp DESC
       LIMIT ?`,
      [ftsQuery, conversationId, limit]
    );
  }

  /**
   * Escape special characters for FTS5 query
   * FTS5 special chars: " ( ) * : ^
   */
  private escapeFTS5Query(query: string): string {
    // For simple queries, wrap in double quotes for phrase matching
    // This escapes most special characters
    if (query.includes('"')) {
      // If query already has quotes, escape them
      return '"' + query.replace(/"/g, '""') + '"';
    }
    return '"' + query + '"';
  }
}

```

## database/sync/ConversationEventApplier.ts

```typescript
/**
 * Location: src/database/sync/ConversationEventApplier.ts
 *
 * Applies conversation-related events to SQLite cache.
 * Handles: conversation, message events.
 */

import {
  ConversationEvent,
  ConversationCreatedEvent,
  ConversationUpdatedEvent,
  MessageEvent,
  MessageUpdatedEvent,
} from '../interfaces/StorageEvents';
import { ISQLiteCacheManager } from './SyncCoordinator';

export class ConversationEventApplier {
  private sqliteCache: ISQLiteCacheManager;

  constructor(sqliteCache: ISQLiteCacheManager) {
    this.sqliteCache = sqliteCache;
  }

  /**
   * Apply a conversation-related event to SQLite cache.
   */
  async apply(event: ConversationEvent): Promise<void> {
    switch (event.type) {
      case 'metadata':
        await this.applyConversationCreated(event);
        break;
      case 'conversation_updated':
        await this.applyConversationUpdated(event);
        break;
      case 'message':
        await this.applyMessageAdded(event);
        break;
      case 'message_updated':
        await this.applyMessageUpdated(event);
        break;
      // Legacy branch events - no longer used in unified model (branches ARE conversations)
      // Skip silently to handle any old JSONL files with these events
      case 'branch_created':
      case 'branch_message':
      case 'branch_message_updated':
      case 'branch_updated':
        break;
    }
  }

  private async applyConversationCreated(event: ConversationCreatedEvent): Promise<void> {
    // Skip invalid conversation events
    if (!event.data?.id) {
      return;
    }

    await this.sqliteCache.run(
      `INSERT OR REPLACE INTO conversations
       (id, title, created, updated, vaultName, messageCount, metadataJson)
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [
        event.data.id,
        event.data.title ?? 'Untitled',
        event.data.created ?? Date.now(),
        event.data.created ?? Date.now(),
        event.data.vault ?? '',
        0,
        event.data.settings ? JSON.stringify(event.data.settings) : null
      ]
    );
  }

  private async applyConversationUpdated(event: ConversationUpdatedEvent): Promise<void> {
    const updates: string[] = [];
    const values: any[] = [];

    if (event.data.title !== undefined) { updates.push('title = ?'); values.push(event.data.title); }
    if (event.data.updated !== undefined) { updates.push('updated = ?'); values.push(event.data.updated); }
    if (event.data.settings !== undefined) { updates.push('metadataJson = ?'); values.push(JSON.stringify(event.data.settings)); }

    if (updates.length > 0) {
      values.push(event.conversationId);
      await this.sqliteCache.run(
        `UPDATE conversations SET ${updates.join(', ')} WHERE id = ?`,
        values
      );
    }
  }

  private async applyMessageAdded(event: MessageEvent): Promise<void> {
    // Skip invalid message events
    if (!event.data?.id || !event.conversationId) {
      return;
    }

    await this.sqliteCache.run(
      `INSERT OR REPLACE INTO messages
       (id, conversationId, role, content, timestamp, state, toolCallsJson, toolCallId, reasoningContent, sequenceNumber, alternativesJson, activeAlternativeIndex)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        event.data.id,
        event.conversationId,
        event.data.role ?? 'user',
        event.data.content ?? '',
        event.timestamp ?? Date.now(),
        event.data.state ?? 'complete',
        event.data.tool_calls ? JSON.stringify(event.data.tool_calls) : null,
        event.data.tool_call_id ?? null,
        event.data.reasoning ?? null,
        event.data.sequenceNumber ?? 0,
        event.data.alternatives ? JSON.stringify(event.data.alternatives) : null,
        event.data.activeAlternativeIndex ?? 0
      ]
    );

    // Update message count
    await this.sqliteCache.run(
      `UPDATE conversations SET messageCount = messageCount + 1, updated = ? WHERE id = ?`,
      [event.timestamp ?? Date.now(), event.conversationId]
    );
  }

  private async applyMessageUpdated(event: MessageUpdatedEvent): Promise<void> {
    const updates: string[] = [];
    const values: any[] = [];

    if (event.data.content !== undefined) { updates.push('content = ?'); values.push(event.data.content); }
    if (event.data.state !== undefined) { updates.push('state = ?'); values.push(event.data.state); }
    if (event.data.reasoning !== undefined) { updates.push('reasoningContent = ?'); values.push(event.data.reasoning); }
    if (event.data.tool_calls !== undefined) {
      updates.push('toolCallsJson = ?');
      values.push(event.data.tool_calls ? JSON.stringify(event.data.tool_calls) : null);
    }
    if (event.data.tool_call_id !== undefined) {
      updates.push('toolCallId = ?');
      values.push(event.data.tool_call_id);
    }
    if (event.data.alternatives !== undefined) {
      updates.push('alternativesJson = ?');
      values.push(event.data.alternatives ? JSON.stringify(event.data.alternatives) : null);
    }
    if (event.data.activeAlternativeIndex !== undefined) {
      updates.push('activeAlternativeIndex = ?');
      values.push(event.data.activeAlternativeIndex);
    }

    if (updates.length > 0) {
      values.push(event.messageId);
      await this.sqliteCache.run(
        `UPDATE messages SET ${updates.join(', ')} WHERE id = ?`,
        values
      );
    }
  }
}

```

## database/sync/index.ts

```typescript
/**
 * Location: /src/database/sync/index.ts
 *
 * Synchronization utilities for hybrid storage system.
 *
 * Coordinates sync between JSONL (source of truth) and SQLite (cache).
 *
 * Related Files:
 * - /src/database/storage/JSONLWriter.ts - JSONL event log
 * - /src/database/storage/SQLiteCacheManager.ts - SQLite cache
 * - /src/database/optimizations/BatchOperations.ts - Used for batch processing
 */

export { SyncCoordinator } from './SyncCoordinator';
export type {
  SyncResult,
  SyncOptions,
  SyncState,
  IJSONLWriter,
  ISQLiteCacheManager
} from './SyncCoordinator';

```

## database/sync/SyncCoordinator.ts

```typescript
/**
 * Location: src/database/sync/SyncCoordinator.ts
 *
 * Synchronization coordinator between JSONL (source of truth) and SQLite (cache).
 *
 * Thin orchestrator that delegates event application to:
 * - WorkspaceEventApplier: workspace, session, state, trace events
 * - ConversationEventApplier: conversation, message events
 *
 * Design Principles:
 * - Single Responsibility: Orchestration only
 * - Open/Closed: Add new event types via new appliers
 * - Dependency Injection: All dependencies passed to constructor
 */

import { BatchOperations } from '../optimizations/BatchOperations';
import {
  StorageEvent,
  WorkspaceEvent,
  ConversationEvent,
} from '../interfaces/StorageEvents';
import { WorkspaceEventApplier } from './WorkspaceEventApplier';
import { ConversationEventApplier } from './ConversationEventApplier';

// ============================================================================
// Interfaces
// ============================================================================

export interface IJSONLWriter {
  getDeviceId(): string;
  listFiles(category: 'workspaces' | 'conversations'): Promise<string[]>;
  readEvents<T extends StorageEvent>(file: string): Promise<T[]>;
  getEventsNotFromDevice<T extends StorageEvent>(
    file: string,
    deviceId: string,
    sinceTimestamp: number
  ): Promise<T[]>;
}

export interface ISQLiteCacheManager {
  getSyncState(deviceId: string): Promise<SyncState | null>;
  updateSyncState(deviceId: string, lastEventTimestamp: number, fileTimestamps: Record<string, number>): Promise<void>;
  isEventApplied(eventId: string): Promise<boolean>;
  markEventApplied(eventId: string): Promise<void>;
  run(sql: string, params?: any[]): Promise<any>;
  clearAllData(): Promise<void>;
  rebuildFTSIndexes(): Promise<void>;
  save(): Promise<void>;
}

export interface SyncState {
  deviceId: string;
  lastEventTimestamp: number;
  fileTimestamps: Record<string, number>;
}

export interface SyncResult {
  success: boolean;
  eventsApplied: number;
  eventsSkipped: number;
  errors: string[];
  duration: number;
  filesProcessed: string[];
  lastSyncTimestamp: number;
}

export interface SyncOptions {
  forceRebuild?: boolean;
  onProgress?: (phase: string, progress: number, total: number) => void;
  batchSize?: number;
}

// ============================================================================
// SyncCoordinator
// ============================================================================

export class SyncCoordinator {
  private jsonlWriter: IJSONLWriter;
  private sqliteCache: ISQLiteCacheManager;
  private deviceId: string;
  private workspaceApplier: WorkspaceEventApplier;
  private conversationApplier: ConversationEventApplier;

  constructor(jsonlWriter: IJSONLWriter, sqliteCache: ISQLiteCacheManager) {
    this.jsonlWriter = jsonlWriter;
    this.sqliteCache = sqliteCache;
    this.deviceId = jsonlWriter.getDeviceId();
    this.workspaceApplier = new WorkspaceEventApplier(sqliteCache);
    this.conversationApplier = new ConversationEventApplier(sqliteCache);
  }

  /**
   * Synchronize JSONL files to SQLite cache.
   */
  async sync(options: SyncOptions = {}): Promise<SyncResult> {
    const startTime = Date.now();
    const errors: string[] = [];
    let eventsApplied = 0;
    let eventsSkipped = 0;
    const filesProcessed: string[] = [];

    try {
      if (options.forceRebuild) {
        return this.fullRebuild(options);
      }

      const syncState = await this.sqliteCache.getSyncState(this.deviceId);
      const lastSync = syncState?.lastEventTimestamp ?? 0;

      // Process workspace files
      const workspaceResult = await this.processWorkspaceFiles(lastSync, options, errors);
      eventsApplied += workspaceResult.applied;
      eventsSkipped += workspaceResult.skipped;
      filesProcessed.push(...workspaceResult.files);

      // Process conversation files
      const conversationResult = await this.processConversationFiles(lastSync, options, errors);
      eventsApplied += conversationResult.applied;
      eventsSkipped += conversationResult.skipped;
      filesProcessed.push(...conversationResult.files);

      // Update sync state and save
      await this.sqliteCache.updateSyncState(this.deviceId, Date.now(), {});
      await this.sqliteCache.save();

      options.onProgress?.('Complete', 1, 1);

      return this.createResult(errors.length === 0, eventsApplied, eventsSkipped, errors, startTime, filesProcessed);
    } catch (error) {
      return this.createResult(false, eventsApplied, eventsSkipped, [...errors, `Sync failed: ${error}`], startTime, filesProcessed);
    }
  }

  /**
   * Full rebuild of SQLite from JSONL files.
   *
   * NOTE: Uses smaller batch size (25) to avoid OOM errors with sql.js asm.js version.
   * Saves after each file to prevent memory accumulation.
   */
  async fullRebuild(options: SyncOptions = {}): Promise<SyncResult> {
    const startTime = Date.now();
    const errors: string[] = [];
    let eventsApplied = 0;
    const filesProcessed: string[] = [];
    // Use smaller batch size for full rebuild to avoid OOM
    const batchSize = options.batchSize ?? 25;

    try {
      options.onProgress?.('Clearing cache', 0, 1);
      await this.sqliteCache.clearAllData();

      // Rebuild workspaces
      const workspaceResult = await this.rebuildWorkspaces(options, errors, batchSize);
      eventsApplied += workspaceResult.applied;
      filesProcessed.push(...workspaceResult.files);

      // Rebuild conversations
      const conversationResult = await this.rebuildConversations(options, errors, batchSize);
      eventsApplied += conversationResult.applied;
      filesProcessed.push(...conversationResult.files);

      // Rebuild FTS and save
      options.onProgress?.('Rebuilding search indexes', 0, 1);
      await this.sqliteCache.rebuildFTSIndexes();
      await this.sqliteCache.updateSyncState(this.deviceId, Date.now(), {});
      await this.sqliteCache.save();

      options.onProgress?.('Complete', 1, 1);

      return this.createResult(errors.length === 0, eventsApplied, 0, errors, startTime, filesProcessed);
    } catch (error) {
      console.error('[SyncCoordinator] Full rebuild failed:', error);
      // Still save sync state so we don't rebuild again on next restart
      try {
        await this.sqliteCache.updateSyncState(this.deviceId, Date.now(), {});
        await this.sqliteCache.save();
      } catch (saveError) {
        console.error('[SyncCoordinator] Failed to save sync state:', saveError);
      }
      return this.createResult(false, eventsApplied, 0, [...errors, `Rebuild failed: ${error}`], startTime, filesProcessed);
    }
  }

  // ============================================================================
  // Private Helpers
  // ============================================================================

  private async processWorkspaceFiles(
    lastSync: number,
    options: SyncOptions,
    errors: string[]
  ): Promise<{ applied: number; skipped: number; files: string[] }> {
    let applied = 0;
    let skipped = 0;
    const files: string[] = [];

    const workspaceFiles = await this.jsonlWriter.listFiles('workspaces');
    options.onProgress?.('Processing workspaces', 0, workspaceFiles.length);

    for (let i = 0; i < workspaceFiles.length; i++) {
      const file = workspaceFiles[i];
      try {
        const events = await this.jsonlWriter.getEventsNotFromDevice<WorkspaceEvent>(
          file, this.deviceId, lastSync
        );

        for (const event of events) {
          if (await this.sqliteCache.isEventApplied(event.id)) {
            skipped++;
            continue;
          }
          await this.workspaceApplier.apply(event);
          await this.sqliteCache.markEventApplied(event.id);
          applied++;
        }

        files.push(file);
        options.onProgress?.('Processing workspaces', i + 1, workspaceFiles.length);
      } catch (e) {
        errors.push(`Failed to process ${file}: ${e}`);
      }
    }

    return { applied, skipped, files };
  }

  private async processConversationFiles(
    lastSync: number,
    options: SyncOptions,
    errors: string[]
  ): Promise<{ applied: number; skipped: number; files: string[] }> {
    let applied = 0;
    let skipped = 0;
    const files: string[] = [];

    const conversationFiles = await this.jsonlWriter.listFiles('conversations');
    options.onProgress?.('Processing conversations', 0, conversationFiles.length);

    for (let i = 0; i < conversationFiles.length; i++) {
      const file = conversationFiles[i];
      try {
        const events = await this.jsonlWriter.getEventsNotFromDevice<ConversationEvent>(
          file, this.deviceId, lastSync
        );

        for (const event of events) {
          if (await this.sqliteCache.isEventApplied(event.id)) {
            skipped++;
            continue;
          }
          await this.conversationApplier.apply(event);
          await this.sqliteCache.markEventApplied(event.id);
          applied++;
        }

        files.push(file);
        options.onProgress?.('Processing conversations', i + 1, conversationFiles.length);
      } catch (e) {
        errors.push(`Failed to process ${file}: ${e}`);
      }
    }

    return { applied, skipped, files };
  }

  private async rebuildWorkspaces(
    options: SyncOptions,
    errors: string[],
    batchSize: number
  ): Promise<{ applied: number; files: string[] }> {
    let applied = 0;
    const files: string[] = [];

    const workspaceFiles = await this.jsonlWriter.listFiles('workspaces');
    options.onProgress?.('Processing workspaces', 0, workspaceFiles.length);

    for (let i = 0; i < workspaceFiles.length; i++) {
      const file = workspaceFiles[i];
      try {
        const events = await this.jsonlWriter.readEvents<WorkspaceEvent>(file);
        events.sort((a, b) => a.timestamp - b.timestamp);

        // Process in very small batches with delays to avoid OOM
        const result = await BatchOperations.executeBatch(
          events,
          async (event) => {
            await this.workspaceApplier.apply(event);
            await this.sqliteCache.markEventApplied(event.id);
          },
          { batchSize: Math.min(batchSize, 10), delayBetweenBatches: 10 }
        );

        applied += result.totalProcessed;
        if (result.errors.length > 0) {
          errors.push(...result.errors.map(e => `${file}: ${e.error.message}`));
        }

        files.push(file);
        options.onProgress?.('Processing workspaces', i + 1, workspaceFiles.length);

        // Save after each file to prevent memory accumulation (OOM prevention)
        await this.sqliteCache.save();
      } catch (e) {
        errors.push(`Failed to process ${file}: ${e}`);
      }
    }

    return { applied, files };
  }

  private async rebuildConversations(
    options: SyncOptions,
    errors: string[],
    batchSize: number
  ): Promise<{ applied: number; files: string[] }> {
    let applied = 0;
    const files: string[] = [];

    const conversationFiles = await this.jsonlWriter.listFiles('conversations');
    options.onProgress?.('Processing conversations', 0, conversationFiles.length);

    for (let i = 0; i < conversationFiles.length; i++) {
      const file = conversationFiles[i];
      try {
        const events = await this.jsonlWriter.readEvents<ConversationEvent>(file);
        events.sort((a, b) => a.timestamp - b.timestamp);

        const result = await BatchOperations.executeBatch(
          events,
          async (event) => {
            await this.conversationApplier.apply(event);
            await this.sqliteCache.markEventApplied(event.id);
          },
          { batchSize }
        );

        applied += result.totalProcessed;
        if (result.errors.length > 0) {
          errors.push(...result.errors.map(e => `${file}: ${e.error.message}`));
        }

        files.push(file);
        options.onProgress?.('Processing conversations', i + 1, conversationFiles.length);

        // Save after each file to prevent memory accumulation (OOM prevention)
        await this.sqliteCache.save();
      } catch (e) {
        errors.push(`Failed to process ${file}: ${e}`);
      }
    }

    return { applied, files };
  }

  private createResult(
    success: boolean,
    eventsApplied: number,
    eventsSkipped: number,
    errors: string[],
    startTime: number,
    filesProcessed: string[]
  ): SyncResult {
    return {
      success,
      eventsApplied,
      eventsSkipped,
      errors,
      duration: Date.now() - startTime,
      filesProcessed,
      lastSyncTimestamp: Date.now()
    };
  }
}

```

## database/sync/WorkspaceEventApplier.ts

```typescript
/**
 * Location: src/database/sync/WorkspaceEventApplier.ts
 *
 * Applies workspace-related events to SQLite cache.
 * Handles: workspace, session, state, trace events.
 */

import {
  WorkspaceEvent,
  WorkspaceCreatedEvent,
  WorkspaceUpdatedEvent,
  WorkspaceDeletedEvent,
  SessionCreatedEvent,
  SessionUpdatedEvent,
  StateSavedEvent,
  StateDeletedEvent,
  TraceAddedEvent,
} from '../interfaces/StorageEvents';
import { ISQLiteCacheManager } from './SyncCoordinator';

export class WorkspaceEventApplier {
  private sqliteCache: ISQLiteCacheManager;

  constructor(sqliteCache: ISQLiteCacheManager) {
    this.sqliteCache = sqliteCache;
  }

  /**
   * Apply a workspace-related event to SQLite cache.
   */
  async apply(event: WorkspaceEvent): Promise<void> {
    switch (event.type) {
      case 'workspace_created':
        await this.applyWorkspaceCreated(event);
        break;
      case 'workspace_updated':
        await this.applyWorkspaceUpdated(event);
        break;
      case 'workspace_deleted':
        await this.applyWorkspaceDeleted(event);
        break;
      case 'session_created':
        await this.applySessionCreated(event);
        break;
      case 'session_updated':
        await this.applySessionUpdated(event);
        break;
      case 'state_saved':
        await this.applyStateSaved(event);
        break;
      case 'state_deleted':
        await this.applyStateDeleted(event);
        break;
      case 'trace_added':
        await this.applyTraceAdded(event);
        break;
    }
  }

  private async applyWorkspaceCreated(event: WorkspaceCreatedEvent): Promise<void> {
    if (!event.data?.id || !event.data?.name) {
      return;
    }

    await this.sqliteCache.run(
      `INSERT OR REPLACE INTO workspaces
       (id, name, description, rootFolder, created, lastAccessed, isActive, contextJson, dedicatedAgentId)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        event.data.id,
        event.data.name,
        event.data.description ?? null,
        event.data.rootFolder ?? '',
        event.data.created ?? Date.now(),
        event.data.created ?? Date.now(),
        // Default to 1 (active) if not specified
        event.data.isActive !== undefined ? (event.data.isActive ? 1 : 0) : 1,
        event.data.contextJson ?? null,
        event.data.dedicatedAgentId ?? null
      ]
    );
  }

  private async applyWorkspaceUpdated(event: WorkspaceUpdatedEvent): Promise<void> {
    const updates: string[] = [];
    const values: any[] = [];

    if (event.data.name !== undefined) { updates.push('name = ?'); values.push(event.data.name); }
    if (event.data.description !== undefined) { updates.push('description = ?'); values.push(event.data.description); }
    if (event.data.rootFolder !== undefined) { updates.push('rootFolder = ?'); values.push(event.data.rootFolder); }
    if (event.data.lastAccessed !== undefined) { updates.push('lastAccessed = ?'); values.push(event.data.lastAccessed); }
    if (event.data.isActive !== undefined) { updates.push('isActive = ?'); values.push(event.data.isActive ? 1 : 0); }
    if (event.data.contextJson !== undefined) { updates.push('contextJson = ?'); values.push(event.data.contextJson); }
    if (event.data.dedicatedAgentId !== undefined) { updates.push('dedicatedAgentId = ?'); values.push(event.data.dedicatedAgentId); }

    if (updates.length > 0) {
      values.push(event.workspaceId);
      await this.sqliteCache.run(
        `UPDATE workspaces SET ${updates.join(', ')} WHERE id = ?`,
        values
      );
    }
  }

  private async applyWorkspaceDeleted(event: WorkspaceDeletedEvent): Promise<void> {
    await this.sqliteCache.run('DELETE FROM workspaces WHERE id = ?', [event.workspaceId]);
  }

  private async applySessionCreated(event: SessionCreatedEvent): Promise<void> {
    if (!event.data?.id || !event.workspaceId) {
      return;
    }

    await this.sqliteCache.run(
      `INSERT OR REPLACE INTO sessions
       (id, workspaceId, name, description, startTime, isActive)
       VALUES (?, ?, ?, ?, ?, ?)`,
      [
        event.data.id,
        event.workspaceId,
        event.data.name ?? 'Unnamed Session',
        event.data.description ?? null,
        event.data.startTime ?? Date.now(),
        1
      ]
    );
  }

  private async applySessionUpdated(event: SessionUpdatedEvent): Promise<void> {
    const updates: string[] = [];
    const values: any[] = [];

    if (event.data.name !== undefined) { updates.push('name = ?'); values.push(event.data.name); }
    if (event.data.description !== undefined) { updates.push('description = ?'); values.push(event.data.description); }
    if (event.data.endTime !== undefined) { updates.push('endTime = ?'); values.push(event.data.endTime); }
    if (event.data.isActive !== undefined) { updates.push('isActive = ?'); values.push(event.data.isActive ? 1 : 0); }

    if (updates.length > 0) {
      values.push(event.sessionId);
      await this.sqliteCache.run(
        `UPDATE sessions SET ${updates.join(', ')} WHERE id = ?`,
        values
      );
    }
  }

  private async applyStateSaved(event: StateSavedEvent): Promise<void> {
    if (!event.data?.id || !event.sessionId || !event.workspaceId) {
      return;
    }

    await this.sqliteCache.run(
      `INSERT OR REPLACE INTO states
       (id, sessionId, workspaceId, name, description, created, stateJson, tagsJson)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        event.data.id,
        event.sessionId,
        event.workspaceId,
        event.data.name ?? 'Unnamed State',
        event.data.description ?? null,
        event.data.created ?? Date.now(),
        event.data.stateJson ?? '{}',
        event.data.tags ? JSON.stringify(event.data.tags) : null
      ]
    );
  }

  private async applyStateDeleted(event: StateDeletedEvent): Promise<void> {
    await this.sqliteCache.run('DELETE FROM states WHERE id = ?', [event.stateId]);
  }

  private async applyTraceAdded(event: TraceAddedEvent): Promise<void> {
    if (!event.data?.id || !event.sessionId || !event.workspaceId) {
      return;
    }

    await this.sqliteCache.run(
      `INSERT OR REPLACE INTO memory_traces
       (id, sessionId, workspaceId, timestamp, type, content, metadataJson)
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [
        event.data.id,
        event.sessionId,
        event.workspaceId,
        event.timestamp ?? Date.now(),
        event.data.traceType ?? null,
        event.data.content ?? '',
        event.data.metadataJson ?? null
      ]
    );
  }
}

```

## database/types/cache/CacheTypes.ts

```typescript
/**
 * Cache Types
 * Extracted from workspace-types.ts for better organization
 */

/**
 * In-memory cache for workspace data
 */
export interface WorkspaceCache {
  /**
   * Hot cache (in-memory, limited size, instant access)
   */
  hotCache: Map<string, {
    search: number[];
    metadata: any;
    lastAccessed: number;
    accessCount: number;
  }>;
  
  /**
   * IndexedDB store prefix for this workspace
   */
  warmCachePrefix: string;
  
  /**
   * Usage statistics
   */
  cacheHits: number;
  cacheMisses: number;
  
  /**
   * Cache management settings
   */
  maxHotCacheSize: number;
  pruneThreshold: number;
}
```

## database/types/index.ts

```typescript
/**
 * Database Types Export Barrel
 * Provides centralized access to all database-related types
 * Organized by domain for better maintainability
 */

// Workspace types
export type {
  ItemStatus,
  ProjectWorkspace
} from './workspace/WorkspaceTypes';

export type {
  WorkspaceParameters,
  WorkspaceResult,
  ListWorkspacesParameters,
  ListWorkspacesResult,
  CreateWorkspaceParameters,
  CreateWorkspaceResult,
  EditWorkspaceParameters,
  DeleteWorkspaceParameters,
  LoadWorkspaceParameters,
  LoadWorkspaceResult,
  AddFilesToWorkspaceParameters,
  AddFilesToWorkspaceResult,
  QuickCreateWorkspaceParameters
} from './workspace/ParameterTypes';

// Session types
export type {
  WorkspaceSession,
  StateContext,
  State,
  WorkspaceState,
  // Deprecated aliases for backward compatibility
  StateSnapshot,
  WorkspaceStateSnapshot
} from './session/SessionTypes';

// Memory types
export type {
  WorkspaceMemoryTrace,
  TraceMetadata,
  TraceToolMetadata,
  TraceContextMetadata,
  TraceInputMetadata,
  TraceOutcomeMetadata,
  TraceLegacyMetadata,
  LegacyWorkspaceTraceMetadata
} from './memory/MemoryTypes';

// Cache types
export type {
  WorkspaceCache
} from './cache/CacheTypes';

```

## database/types/memory/MemoryTypes.ts

```typescript
/**
 * Memory Types
 * Extracted from workspace-types.ts for better organization
 * Uses simplified JSON-based storage
 */

/**
 * Minimal set of fields recorded for every tool call trace.
 */
export interface TraceToolMetadata {
  id: string;
  agent: string;
  mode: string;
  callId?: string;
  pluginVersion?: string;
}

/**
 * Legacy context object - kept for backward compatibility with existing traces.
 * New traces should use TraceContextMetadataV2.
 */
export interface LegacyTraceContextMetadata {
  workspaceId: string;
  sessionId: string;
  sessionDescription?: string;
  sessionMemory?: string;
  toolContext?: Record<string, unknown>;
  primaryGoal?: string;
  subgoal?: string;
  tags?: string[];
  additionalContext?: Record<string, unknown>;
}

/**
 * New context schema for two-tool architecture.
 * Uses memory/goal/constraints instead of the verbose legacy fields.
 * This schema is designed for:
 * - Context efficiency (local models with small context windows)
 * - Memory â†’ Goal â†’ Constraints flow (each informs the next)
 * - Queryable through searchMemory for later reference
 */
export interface TraceContextMetadataV2 {
  /** Workspace scope identifier */
  workspaceId: string;

  /** Session identifier for tracking */
  sessionId: string;

  /** Compressed essence of conversation (1-3 sentences) */
  memory: string;

  /** Current objective informed by memory (1-3 sentences) */
  goal: string;

  /** Optional rules/limits to follow (1-3 sentences) */
  constraints?: string;

  /** Optional tags for categorization */
  tags?: string[];
}

/**
 * Union type that accepts both legacy and new context formats.
 * Use `isNewTraceContextFormat()` to determine which version.
 */
export type TraceContextMetadata = LegacyTraceContextMetadata | TraceContextMetadataV2;

/**
 * Type guard to check if context is the new V2 format.
 * New format has 'memory' and 'goal' fields.
 */
export function isNewTraceContextFormat(context: TraceContextMetadata): context is TraceContextMetadataV2 {
  return 'memory' in context && 'goal' in context;
}

/**
 * Type guard to check if context is the legacy format.
 */
export function isLegacyTraceContextFormat(context: TraceContextMetadata): context is LegacyTraceContextMetadata {
  return !isNewTraceContextFormat(context);
}

/**
 * Tool input parameters that should be preserved for future reference.
 */
export interface TraceInputMetadata {
  arguments?: any;
  files?: string[];
  notes?: string;
}

/**
 * Outcome of the tool call. We only persist the durable signal (success/error)
 * instead of large response payloads.
 */
export interface TraceOutcomeMetadata {
  success: boolean;
  error?: {
    type?: string;
    message: string;
    code?: string | number;
  };
}

/**
 * Legacy blobs that we keep during migration for backward compatibility.
 */
export interface TraceLegacyMetadata {
  params?: any;
  result?: any;
  relatedFiles?: string[];
}

/**
 * Legacy metadata shape retained for compatibility with older callers.
 */
export interface LegacyWorkspaceTraceMetadata {
  tool?: string;
  params?: any;
  result?: any;
  relatedFiles?: string[];
  request?: Record<string, any>;
  response?: Record<string, any>;
  execution?: Record<string, any>;
  [key: string]: any;
}

/**
 * Canonical metadata structure saved with each memory trace.
 */
export interface TraceMetadata {
  schemaVersion: number;
  tool: TraceToolMetadata;
  context: TraceContextMetadata;
  input?: TraceInputMetadata;
  outcome: TraceOutcomeMetadata;
  legacy?: TraceLegacyMetadata;
}

/**
 * Memory trace for workspace activity
 * Records tool interactions for JSON-based storage and search
 */
export interface WorkspaceMemoryTrace {
  /**
   * Unique identifier
   */
  id: string;

  /**
   * Associated workspace ID
   */
  workspaceId: string;

  /**
   * When this interaction occurred
   */
  timestamp: number;

  /**
   * Type of memory trace interaction
   */
  type: string;

  /**
   * The actual interaction content
   */
  content: string;

  /**
   * Additional information about the interaction
   */
  metadata?: TraceMetadata | LegacyWorkspaceTraceMetadata;

  /**
   * Associated session ID (if created during a session)
   */
  sessionId?: string;
}

```

## database/types/session/SessionTypes.ts

```typescript
/**
 * Session Types
 * Simple session and state types focused on LLM restoration
 */

import { WorkspaceContext } from '../workspace/WorkspaceTypes';

/**
 * Session tracking for workspace activities
 * Simplified to only essential fields for clean auto-session creation
 */
export interface WorkspaceSession {
  /**
   * Unique session identifier
   */
  id: string;
  
  /**
   * Associated workspace ID
   */
  workspaceId: string;
  
  /**
   * Optional session name
   */
  name?: string;
  
  /**
   * Optional session description
   */
  description?: string;
}

/**
 * State context data - everything needed to resume work
 */
export interface StateContext {
  /**
   * Workspace context at save time
   */
  workspaceContext: WorkspaceContext;

  /**
   * What was happening when you decided to save this state?
   */
  conversationContext: string;

  /**
   * What task were you actively working on?
   */
  activeTask: string;

  /**
   * Which files were you working with?
   */
  activeFiles: string[];

  /**
   * What are the immediate next steps when you resume?
   */
  nextSteps: string[];
}

/**
 * Simple state interface - our agreed-upon clean schema
 */
export interface State {
  id: string;
  name: string;
  workspaceId: string;
  created: number;
  context: StateContext;
}

/**
 * WorkspaceState interface - full state with optional legacy fields
 * Extends the simple State with additional metadata
 */
export interface WorkspaceState extends State {
  // Legacy fields for backward compatibility
  sessionId?: string;
  timestamp?: number;
  description?: string;
  state?: {
    workspace: any;
    recentTraces: string[];
    contextFiles: string[];
    metadata: Record<string, any>;
  };
}

/**
 * @deprecated Use StateContext instead
 */
export type StateSnapshot = StateContext;

/**
 * @deprecated Use WorkspaceState instead
 */
export type WorkspaceStateSnapshot = WorkspaceState;
```

## database/types/workspace/ParameterTypes.ts

```typescript
/**
 * Workspace Parameter Types
 * Parameter types that prompt LLMs to provide the correct structured workspace data
 */

import { CommonParameters, CommonResult } from '../../../types/mcp';
import { ProjectWorkspace, WorkspaceContext } from './WorkspaceTypes';
import { StateContext } from '../session/SessionTypes';

/**
 * Create workspace parameters - LLM must provide complete WorkspaceContext structure
 */
export interface CreateWorkspaceParameters extends CommonParameters {
  /**
   * Workspace name (required)
   */
  name: string;

  /**
   * Description of what this workspace is for (required)
   * Example: "Screenplay development project"
   */
  description: string;

  /**
   * Root folder path (required)
   */
  rootFolder: string;

  /**
   * What is this workspace for? (required)
   * Example: "Apply for marketing manager positions"
   */
  purpose: string;

  /**
   * Workflows for different situations (optional)
   * Provide an array of workflows with name, when to use, and steps as a single string
   * Example: [{"name": "New Application", "when": "When applying to new position", "steps": "Research company\nCustomize cover letter\nApply\nTrack"}]
   */
  workflows?: Array<{
    name: string;
    when: string;
    steps: string;
  }>;

  /**
   * Simple key files list for quick reference (optional)
   * Provide array of file paths for key files in this workspace
   * Example: ["path/to/resume.md", "path/to/portfolio.md"]
   */
  keyFiles?: string[];

  /**
   * User preferences as actionable guidelines (optional)
   * Provide specific preferences about how to work
   * Example: "Use professional tone. Focus on tech companies. Keep cover letters under 300 words."
   */
  preferences?: string;

  /**
   * ID of dedicated agent for this workspace (optional)
   * This agent's systemPrompt will be included when loading the workspace
   * Example: "agent_12345"
   */
  dedicatedAgentId?: string;


  // Optional legacy fields for backward compatibility
  relatedFolders?: string[];
  relatedFiles?: string[];
  keyFileInstructions?: string;
}

/**
 * Create workspace result
 */
export interface CreateWorkspaceResult extends CommonResult {
  data: {
    workspaceId: string;
    workspace: ProjectWorkspace;
  };
}

/**
 * Load workspace result - returns actionable briefing instead of raw data
 */
export interface LoadWorkspaceResult extends CommonResult {
  data: {
    context: {
      name: string;
      description?: string;
      purpose?: string;
      rootFolder: string;
      recentActivity: string[];
    };
    workflows: string[];
    workspaceStructure: string[];
    recentFiles: Array<{
      path: string;
      modified: number;
    }>;
    keyFiles: Record<string, string>;
    preferences: string;
    sessions: Array<{
      id: string;
      name: string;
      description?: string;
      created: number;
    }>;
    states: Array<{
      id: string;
      name: string;
      description?: string;
      sessionId: string;
      created: number;
      tags?: string[];
    }>;
  };
  pagination?: {
    sessions: {
      page: number;
      pageSize: number;
      totalItems: number;
      totalPages: number;
      hasNextPage: boolean;
      hasPreviousPage: boolean;
    };
    states: {
      page: number;
      pageSize: number;
      totalItems: number;
      totalPages: number;
      hasNextPage: boolean;
      hasPreviousPage: boolean;
    };
  };
}

/**
 * Create state parameters - LLM must provide complete StateContext structure
 */
export interface CreateStateParameters extends CommonParameters {
  /**
   * State name (required)
   */
  name: string;
  
  /**
   * What was happening when you decided to save this state? (required)
   * Provide a summary of the conversation and what you were working on
   * Example: "We were customizing the cover letter for Google's Marketing Manager position. We researched their team and identified key requirements."
   */
  conversationContext: string;
  
  /**
   * What task were you actively working on? (required)
   * Be specific about the current task
   * Example: "Finishing the cover letter paragraph about data-driven campaign optimization results"
   */
  activeTask: string;
  
  /**
   * Which files were you working with? (required)
   * List the files that were being edited or referenced
   * Example: ["cover-letter-google.md", "application-tracker.md"]
   */
  activeFiles: string[];
  
  /**
   * What are the immediate next steps when you resume? (required)
   * Provide specific actionable next steps
   * Example: ["Complete cover letter customization", "Review resume for Google-specific keywords", "Submit application"]
   */
  nextSteps: string[];
  
  /**
   * Why are you saving this state right now? (required)
   * Explain the reason for saving at this point
   * Example: "Saving before context limit, about to submit application"
   */
  reasoning: string;
  
  // Optional legacy fields
  description?: string;
  workspaceContext?: any;
  targetSessionId?: string;
  includeSummary?: boolean;
  includeFileContents?: boolean;
  maxFiles?: number;
  maxTraces?: number;
  tags?: string[];
  reason?: string;
}

/**
 * Load state result - returns actionable restoration context
 */
export interface LoadStateResult extends CommonResult {
  data: {
    resumingFrom: string;
    workspaceContext: string;
    whereYouLeftOff: string;
    currentTask: string;
    activeFiles: string[];
    nextSteps: string[];
    workflow: string;
  };
}

// Legacy parameter types for backward compatibility
export interface LoadWorkspaceParameters extends CommonParameters {
  id: string;
  limit?: number; // Optional limit for sessions, states, and recentActivity (default: 3)
}

export interface LoadStateParams extends CommonParameters {
  stateId: string;
  sessionName?: string;
  sessionDescription?: string;
  restorationGoal?: string;
  createContinuationSession?: boolean;
  tags?: string[];
}

export interface ListWorkspacesParameters extends CommonParameters {
  includeArchived?: boolean;
  sortBy?: 'name' | 'created' | 'lastAccessed';
  order?: 'asc' | 'desc';
  limit?: number;
}

export interface EditWorkspaceParameters extends CommonParameters {
  id: string;
  name?: string;
  description?: string;
  rootFolder?: string;
  relatedFolders?: string[];
  relatedFiles?: string[];
  preferences?: Record<string, any>;
  keyFileInstructions?: string;
}

export interface DeleteWorkspaceParameters extends CommonParameters {
  id: string;
  deleteChildren?: boolean;
  preserveSettings?: boolean;
}

export interface AddFilesToWorkspaceParameters extends CommonParameters {
  workspaceId: string;
  files?: string[];
  folders?: string[];
  addAsRelated?: boolean;
  markAsKeyFiles?: boolean;
}

// Legacy result types
export interface StateResult extends CommonResult {
  data?: {
    stateId: string;
    name: string;
    workspaceId: string;
    sessionId: string;
    timestamp: number;
    capturedContext?: any;
  };
}

export interface ListWorkspacesResult extends CommonResult {
  data: {
    workspaces: Array<{
      id: string;
      name: string;
      description?: string;
      rootFolder: string;
      lastAccessed: number;
      childCount: number;
    }>;
  };
}

export interface AddFilesToWorkspaceResult extends CommonResult {
  data: {
    filesAdded: number;
    foldersAdded: number;
    addedFiles: string[];
    failedFiles: Array<{
      path: string;
      reason: string;
    }>;
    workspace: {
      id: string;
      name: string;
      totalFiles: number;
      totalRelatedFiles: number;
    };
  };
}

// Legacy exports for backward compatibility
export interface WorkspaceParameters extends LoadWorkspaceParameters {}
export interface WorkspaceResult extends LoadWorkspaceResult {}
export interface QuickCreateWorkspaceParameters extends CreateWorkspaceParameters {}
```

## database/types/workspace/WorkspaceTypes.ts

```typescript
/**
 * Core Workspace Types
 * Simple, clean workspace types focused on LLM usability
 */


/**
 * Status types for individual items within a workspace
 */
export type ItemStatus = 'notStarted' | 'inProgress' | 'completed';

/**
 * Simple workspace context for LLM understanding
 */
export interface WorkspaceContext {
  /**
   * What is this workspace for?
   * Example: "Apply for marketing manager positions"
   */
  purpose?: string;

  /**
   * Workflows for different situations
   */
  workflows?: Array<{
    name: string;           // "New Application", "Follow-up", "Interview Prep"
    when: string;           // "When applying to new position"
    steps: string;          // "Research company\nCustomize cover letter\nApply\nTrack"
  }>;

  /**
   * Simple key files list for quick reference
   */
  keyFiles?: string[];       // ["path/to/resume.md", "path/to/portfolio.md"]

  /**
   * User preferences as actionable guidelines
   */
  preferences?: string;      // "Use professional tone. Focus on tech companies."

  /**
   * Single dedicated agent for this workspace
   */
  dedicatedAgent?: {
    agentId: string;        // Unique identifier for the agent
    agentName: string;      // Display name of the agent
  };

}

/**
 * Simple workspace interface - our agreed-upon clean schema
 */
export interface Workspace {
  id: string;
  name: string;
  context?: WorkspaceContext;  // Optional for backward compatibility
  rootFolder: string;
  created: number;
  lastAccessed: number;
  isArchived?: boolean;  // Soft delete flag
}

/**
 * Legacy ProjectWorkspace interface for backward compatibility
 * Extends the simple Workspace with optional legacy fields
 */
export interface ProjectWorkspace extends Workspace {
  // Core functionality
  isActive?: boolean;

  // Legacy fields for backward compatibility
  description?: string;
  relatedFolders?: string[];
  relatedFiles?: string[];
  associatedNotes?: string[];
  keyFileInstructions?: string;
  activityHistory?: Array<{
    timestamp: number;
    action: 'view' | 'edit' | 'create' | 'tool';
    toolName?: string;
    duration?: number;
    context?: string;
  }>;
  preferences?: Record<string, any>;
  projectPlan?: string;
  checkpoints?: Array<{
    id: string;
    date: number;
    description: string;
    completed: boolean;
  }>;
  completionStatus?: Record<string, {
    status: ItemStatus;
    completedDate?: number;
    completionNotes?: string;
  }>;
}
```

## database/utils/ContentCache.ts

```typescript
/**
 * Cache entry for file content
 */
interface CacheEntry {
  content: string;
  timestamp: number;
  size: number;
}

/**
 * LRU (Least Recently Used) cache for file contents
 * Used to temporarily store file contents before modifications
 */
export class ContentCache {
  private cache: Map<string, CacheEntry> = new Map();
  private maxSize: number;
  private currentSize = 0;
  private ttl: number;
  
  /**
   * Create a new content cache
   * @param maxSize Maximum cache size in bytes (default: 10MB)
   * @param ttl Time to live in milliseconds (default: 5 minutes)
   */
  constructor(maxSize: number = 10 * 1024 * 1024, ttl: number = 5 * 60 * 1000) {
    this.maxSize = maxSize;
    this.ttl = ttl;
    
    // Periodically clean up expired entries
    setInterval(() => this.cleanupExpired(), 60 * 1000); // Every minute
  }
  
  /**
   * Get content from cache
   * @param filePath File path
   * @returns Content if found and not expired, undefined otherwise
   */
  get(filePath: string): string | undefined {
    const entry = this.cache.get(filePath);
    if (!entry) return undefined;
    
    // Check if expired
    if (Date.now() - entry.timestamp > this.ttl) {
      this.delete(filePath);
      return undefined;
    }
    
    // Move to end (most recently used)
    this.cache.delete(filePath);
    this.cache.set(filePath, entry);
    
    return entry.content;
  }
  
  /**
   * Store content in cache
   * @param filePath File path
   * @param content File content
   */
  set(filePath: string, content: string): void {
    // Remove existing entry if present
    if (this.cache.has(filePath)) {
      this.delete(filePath);
    }
    
    const size = content.length * 2; // Approximate size in bytes (UTF-16)
    
    // Make room if needed
    while (this.currentSize + size > this.maxSize && this.cache.size > 0) {
      // Remove least recently used (first item)
      const firstKey = this.cache.keys().next().value;
      if (firstKey) {
        this.delete(firstKey);
      }
    }
    
    // Add new entry
    this.cache.set(filePath, {
      content,
      timestamp: Date.now(),
      size
    });
    
    this.currentSize += size;
  }
  
  /**
   * Delete an entry from cache
   * @param filePath File path
   */
  delete(filePath: string): boolean {
    const entry = this.cache.get(filePath);
    if (!entry) return false;
    
    this.cache.delete(filePath);
    this.currentSize -= entry.size;
    return true;
  }
  
  /**
   * Clear all entries from cache
   */
  clear(): void {
    this.cache.clear();
    this.currentSize = 0;
  }
  
  /**
   * Clean up expired entries
   */
  private cleanupExpired(): void {
    const now = Date.now();
    const expiredKeys: string[] = [];
    
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > this.ttl) {
        expiredKeys.push(key);
      }
    }
    
    for (const key of expiredKeys) {
      this.delete(key);
    }
  }
  
  /**
   * Get cache statistics
   */
  getStats(): {
    size: number;
    maxSize: number;
    entries: number;
    utilization: number;
  } {
    return {
      size: this.currentSize,
      maxSize: this.maxSize,
      entries: this.cache.size,
      utilization: this.currentSize / this.maxSize
    };
  }
}
```

## database/utils/FileUtils.ts

```typescript
/**
 * FileUtils - Utility functions for file operations and validation
 * 
 * This utility module provides common file validation and checking patterns
 * used across the hash comparison and search services. Consolidates
 * repeated file existence checking logic into reusable methods.
 */

import { TAbstractFile, TFile } from 'obsidian';

export class FileUtils {
  /**
   * Check if an abstract file is a valid readable file (not a folder)
   * @param file Abstract file to check
   * @returns True if file is valid and readable
   */
  static isValidFile(file: TAbstractFile | null): file is TFile {
    return file !== null && !('children' in file);
  }

  /**
   * Check if a file path points to a valid readable file
   * @param app Obsidian app instance
   * @param filePath Path to check
   * @returns True if path points to a valid file
   */
  static isValidFilePath(app: any, filePath: string): boolean {
    const file = app.vault.getAbstractFileByPath(filePath);
    return this.isValidFile(file);
  }

  /**
   * Normalize file path to use forward slashes consistently
   * @param filePath Path to normalize
   * @returns Normalized path with forward slashes
   */
  static normalizePath(filePath: string): string {
    return filePath.replace(/\\/g, '/');
  }
}
```

## database/utils/graph/constants.ts

```typescript
/**
 * Default graph boost factor
 */
export const DEFAULT_GRAPH_BOOST_FACTOR = 0.3;

/**
 * Default max distance for graph boosting
 */
export const DEFAULT_GRAPH_MAX_DISTANCE = 1;
```

## database/utils/graph/GraphOperations.ts

```typescript
import { DEFAULT_GRAPH_BOOST_FACTOR, DEFAULT_GRAPH_MAX_DISTANCE } from './constants';
import { LinkUtils } from './LinkUtils';

// Types needed for graph operations
interface searchRecord {
    id: string;
    filePath: string;
    content: string;
    metadata: {
        links?: {
            outgoing: Array<{
                displayText: string;
                targetPath: string;
            }>;
            incoming: Array<{
                sourcePath: string;
                displayText: string;
            }>;
        };
        [key: string]: any;
    };
}

interface GraphOptions {
    useGraphBoost: boolean;
    boostFactor?: number;
    includeNeighbors?: boolean;
    maxDistance?: number;
    seedNotes?: string[];
}

/**
 * Handles graph-based operations for relevance boosting
 */
export class GraphOperations {
    private linkUtils: LinkUtils;
    
    constructor() {
        this.linkUtils = new LinkUtils();
    }
    
    /**
     * Apply graph-based boost to search results
     * Increases scores for records that are connected to high-scoring records
     * 
     * @param records Records with similarity scores
     * @param graphOptions Graph boosting options
     */
    applyGraphBoost(
        records: Array<{ record: searchRecord; similarity: number }>,
        graphOptions: GraphOptions
    ): Array<{ record: searchRecord; similarity: number }> {
        const boostFactor = graphOptions.boostFactor || DEFAULT_GRAPH_BOOST_FACTOR;
        const maxDistance = graphOptions.maxDistance || DEFAULT_GRAPH_MAX_DISTANCE;
        const seedNotes = graphOptions.seedNotes || [];
        
        // If no records, return as-is
        if (!records.length) {
            return records;
        }
        
        // If not using graph boost, return as-is
        if (!graphOptions.useGraphBoost) {
            return records;
        }
        
        // Create a graph of connections
        const graph = this.buildConnectionGraph(records);
        
        // Apply boost to seed notes if specified
        let resultsearchs = records;
        if (seedNotes.length > 0) {
            resultsearchs = this.applySeedBoost(resultsearchs, seedNotes);
        }
        
        // Apply multi-level graph boosting
        // Start with initial scores
        const currentScores = new Map<string, number>();
        resultsearchs.forEach(item => {
            currentScores.set(item.record.filePath, item.similarity);
        });
        
        // Apply boost for each level of depth up to maxDistance
        for (let distance = 1; distance <= maxDistance; distance++) {
            const nextScores = new Map<string, number>();
            
            // Start with current scores - convert to array for compatibility
            Array.from(currentScores.entries()).forEach(([filePath, score]) => {
                nextScores.set(filePath, score);
            });
            
            // Apply boost for this distance level - convert to array for compatibility
            Array.from(currentScores.entries()).forEach(([filePath, score]) => {
                const connections = graph.get(filePath) || new Set<string>();
                const levelBoostFactor = boostFactor / distance; // Reduce boost for higher distances
                
                connections.forEach(connectedPath => {
                    // Only boost if the connected path is in our results
                    if (currentScores.has(connectedPath)) {
                        const currentScore = nextScores.get(connectedPath) || 0;
                        // Add a boost proportional to this file's score
                        const boost = score * levelBoostFactor;
                        nextScores.set(connectedPath, currentScore + boost);
                    }
                });
            });
            
            // Update current scores for next iteration
            currentScores.clear();
            // We need to manually copy the values to avoid TypeScript errors
            const entries = Array.from(nextScores.entries());
            for (let i = 0; i < entries.length; i++) {
                const [key, value] = entries[i];
                currentScores.set(key, value);
            }
        }
        
        // Apply final boosted scores
        return resultsearchs.map(item => {
            const filePath = item.record.filePath;
            const boostedScore = currentScores.get(filePath) || item.similarity;
            return {
                record: item.record,
                similarity: boostedScore
            };
        });
    }
    
    /**
     * Apply seed note boosting to search results
     * @param records Records with similarity scores
     * @param seedNotes Array of seed note paths
     */
    applySeedBoost(
        records: Array<{ record: searchRecord; similarity: number }>,
        seedNotes: string[]
    ): Array<{ record: searchRecord; similarity: number }> {
        // If no seed notes, return as-is
        if (!seedNotes.length) {
            return records;
        }
        
        // Create a set of seed note paths for quick lookup
        const seedNoteSet = new Set(seedNotes);
        
        // Create a map of file paths to base name (without extension) for fuzzy matching
        const fileBaseNames = new Map<string, string>();
        records.forEach(item => {
            const baseName = item.record.filePath.split('/').pop()?.replace(/\.[^/.]+$/, '') || '';
            fileBaseNames.set(item.record.filePath, baseName.toLowerCase());
        });
        
        // Create a set of normalized seed note names for fuzzy matching
        const normalizedSeedNames = new Set<string>();
        seedNotes.forEach(path => {
            const baseName = path.split('/').pop()?.replace(/\.[^/.]+$/, '') || '';
            normalizedSeedNames.add(baseName.toLowerCase());
        });
        
        // Apply boost to seed notes and their connections
        return records.map(item => {
            let boostFactor = 1.0; // No boost by default
            
            // Direct exact match with seed note
            if (seedNoteSet.has(item.record.filePath)) {
                boostFactor = 1.5; // 50% boost for direct seed note match
            } 
            // Fuzzy match with seed note name
            else if (normalizedSeedNames.has(fileBaseNames.get(item.record.filePath) || '')) {
                boostFactor = 1.3; // 30% boost for fuzzy seed note match
            }
            
            return {
                record: item.record,
                similarity: item.similarity * boostFactor
            };
        });
    }
    
    /**
     * Build a graph of connections between documents
     * @param records Records with similarity scores
     * @returns Map of file paths to sets of connected file paths
     */
    private buildConnectionGraph(
        records: Array<{ record: searchRecord; similarity: number }>
    ): Map<string, Set<string>> {
        // Create a graph of connections
        const graph = new Map<string, Set<string>>();
        
        // Create a map of normalized link text to file paths
        // This helps with resolving unresolved links
        const normalizedLinkMap = new Map<string, string[]>();
        const fullPathMap = new Map<string, string>(); // Map from filename to full path
        
        // First pass: build normalized link map
        records.forEach(item => {
            const filePath = item.record.filePath;
            const fileName = filePath.split('/').pop() || '';
            const baseName = fileName.replace(/\.[^/.]+$/, '');
            
            // Store multiple ways to reference this file
            this.linkUtils.addToLinkMap(normalizedLinkMap, baseName, filePath);
            this.linkUtils.addToLinkMap(normalizedLinkMap, fileName, filePath);
            
            // Also store the path components
            const pathParts = filePath.split('/');
            pathParts.forEach(part => {
                if (part && part !== baseName && part !== fileName) {
                    this.linkUtils.addToLinkMap(normalizedLinkMap, part, filePath);
                }
            });
            
            // Add to full path map
            fullPathMap.set(fileName, filePath);
            fullPathMap.set(baseName, filePath);
            
            // Initialize graph
            if (!graph.has(filePath)) {
                graph.set(filePath, new Set<string>());
            }
        });
        
        // Second pass: process links from metadata
        records.forEach(item => {
            const filePath = item.record.filePath;
            const links = item.record.metadata.links;
            
            if (!links) {
                return;
            }
            
            // Process outgoing links
            if (links.outgoing && links.outgoing.length > 0) {
                links.outgoing.forEach(link => {
                    const targetPath = link.targetPath;
                    
                    // Ensure source node exists in graph
                    if (!graph.has(filePath)) {
                        graph.set(filePath, new Set<string>());
                    }
                    
                    // Add direct link
                    const connections = graph.get(filePath);
                    connections?.add(targetPath);
                    
                    // Ensure target node exists in graph (bidirectional connection)
                    if (!graph.has(targetPath)) {
                        graph.set(targetPath, new Set<string>());
                    }
                    
                    // Add reverse link
                    const targetConnections = graph.get(targetPath);
                    targetConnections?.add(filePath);
                });
            }
            
            // Process incoming links
            if (links.incoming && links.incoming.length > 0) {
                links.incoming.forEach(link => {
                    const sourcePath = link.sourcePath;
                    
                    // Ensure target node exists in graph
                    if (!graph.has(filePath)) {
                        graph.set(filePath, new Set<string>());
                    }
                    
                    // Add reverse link
                    const connections = graph.get(filePath);
                    connections?.add(sourcePath);
                    
                    // Ensure source node exists in graph (bidirectional connection)
                    if (!graph.has(sourcePath)) {
                        graph.set(sourcePath, new Set<string>());
                    }
                    
                    // Add direct link
                    const sourceConnections = graph.get(sourcePath);
                    sourceConnections?.add(filePath);
                });
            }
        });
        
        // Third pass: process unresolved links and content links
        records.forEach(item => {
            const filePath = item.record.filePath;
            const content = item.record.content || '';
            
            // Extract potential link mentions from content (using a mock implementation)
            const potentialLinks: string[] = [];
            // This is a simple regex to find potential links in markdown/wikilinks syntax
            const linkRegex = /\[\[([^\]]+)\]\]|\[([^\]]+)\]\([^\)]+\)/g;
            let match;
            while ((match = linkRegex.exec(content)) !== null) {
                potentialLinks.push(match[1] || match[2]);
            }
            
            potentialLinks.forEach((linkText: string) => {
                const normalizedLink = this.linkUtils.normalizeLinkText(linkText);
                
                // Try to resolve link from our normalized link map
                const matchingPaths = normalizedLinkMap.get(normalizedLink) || [];
                
                matchingPaths.forEach(targetPath => {
                    // Skip self-links
                    if (targetPath === filePath) {
                        return;
                    }
                    
                    // Add to graph
                    const connections = graph.get(filePath) || new Set<string>();
                    connections.add(targetPath);
                    graph.set(filePath, connections);
                    
                    // Add reverse connection
                    const targetConnections = graph.get(targetPath) || new Set<string>();
                    targetConnections.add(filePath);
                    graph.set(targetPath, targetConnections);
                });
            });
        });
        
        return graph;
    }
}
```

## database/utils/graph/LinkUtils.ts

```typescript
/**
 * Utility class for handling link operations
 * Provides methods for normalizing links and finding fuzzy matches
 */
export class LinkUtils {
    /**
     * Normalize link text for more robust matching
     * Removes spaces, special characters, and converts to lowercase
     * 
     * @param linkText The link text to normalize
     * @returns Normalized link text
     */
    normalizeLinkText(linkText: string): string {
        return linkText
            .toLowerCase()
            .replace(/\s+/g, '_')
            .replace(/[^\w\s-]/g, '');
    }
    
    /**
     * Add a filename to the normalized link map
     * 
     * @param linkMap The map to add to
     * @param text The text to normalize and add
     * @param filePath The file path to associate with the text
     */
    addToLinkMap(linkMap: Map<string, string[]>, text: string, filePath: string): void {
        const normalizedText = this.normalizeLinkText(text);
        
        if (!linkMap.has(normalizedText)) {
            linkMap.set(normalizedText, []);
        }
        
        const paths = linkMap.get(normalizedText);
        if (paths && !paths.includes(filePath)) {
            paths.push(filePath);
        }
    }
    
    /**
     * Generate different normalized variants of a link text
     * 
     * @param text The text to generate variants for
     * @returns Array of normalized variants
     */
    getNormalizedVariants(text: string): string[] {
        const variants = new Set<string>();
        
        // Add original
        variants.add(this.normalizeLinkText(text));
        
        // Add with spaces replaced by underscores
        variants.add(this.normalizeLinkText(text.replace(/\s+/g, '_')));
        
        // Add with spaces replaced by hyphens
        variants.add(this.normalizeLinkText(text.replace(/\s+/g, '-')));
        
        // Add without special characters
        variants.add(this.normalizeLinkText(text.replace(/[^\w\s]/g, '')));
        
        // Handle common file extensions (.md)
        const withoutExt = text.endsWith('.md') ? text.slice(0, -3) : text;
        variants.add(this.normalizeLinkText(withoutExt));
        
        return Array.from(variants);
    }
    
    /**
     * Find fuzzy matches for a link text
     * 
     * @param linkMap The normalized link map
     * @param text The text to find fuzzy matches for
     * @returns Array of matching file paths
     */
    findFuzzyMatches(linkMap: Map<string, string[]>, text: string): string[] {
        const matches = new Set<string>();
        const normalizedText = this.normalizeLinkText(text);
        
        // For each key in the map, check if either contains the other
        // Convert to array for compatibility
        Array.from(linkMap.entries()).forEach(([key, paths]) => {
            // If the key contains our text or our text contains the key
            if (key.includes(normalizedText) || normalizedText.includes(key)) {
                paths.forEach(path => matches.add(path));
            }
        });
        
        return Array.from(matches);
    }
}
```

## database/utils/progressTracker.ts

```typescript
import type {
  ProgressUpdateData,
  ProgressCompleteData,
  ProgressCancelData
} from '../../components/ProgressBar';

/**
 * Tracks progress for long-running operations
 */
export class ProgressTracker {
  /**
   * Update progress
   */
  updateProgress(data: ProgressUpdateData): void {
    // Use global handler if available
    if (window.mcpProgressHandlers?.updateProgress) {
      window.mcpProgressHandlers.updateProgress(data);
    }
  }

  /**
   * Complete progress
   */
  completeProgress(data: ProgressCompleteData): void {
    // Use global handler if available
    if (window.mcpProgressHandlers?.completeProgress) {
      window.mcpProgressHandlers.completeProgress(data);
    }
  }

  /**
   * Cancel progress
   */
  cancelProgress(data: ProgressCancelData): void {
    // Use global handler if available
    if (window.mcpProgressHandlers?.cancelProgress) {
      window.mcpProgressHandlers.cancelProgress(data);
    }
  }
}
```

## database/workspace-types.ts

```typescript
/**
 * Legacy Workspace Types File - Refactored for Modular Organization
 * 
 * This file now re-exports all types from the organized modular structure.
 * The original workspace-types.ts file has been broken down into domain-specific modules:
 * 
 * - src/database/types/workspace/: Core workspace types and parameter definitions
 * - src/database/types/session/: Session tracking and state types
 * - src/database/types/memory/: Memory traces and file search types
 * - src/database/types/cache/: Cache management types
 * 
 * This approach follows SOLID principles:
 * - Single Responsibility: Each module handles one domain
 * - Open/Closed: Easy to extend without modifying existing code
 * - Interface Segregation: Clients depend only on what they use
 * - Dependency Inversion: Modules depend on abstractions
 */

// Re-export all types from the modular structure for backward compatibility
export * from './types';
```

## handlers/index.ts

```typescript
// Main router
export { RequestRouter } from './RequestRouter';

// Interfaces
export type * from './interfaces/IRequestHandlerServices';

// Services
export { ValidationService } from './services/ValidationService';
export { SessionService } from './services/SessionService';
export { ToolExecutionService } from './services/ToolExecutionService';
export { ResponseFormatter } from './services/ResponseFormatter';
export { ToolListService } from './services/ToolListService';

// Strategies
export type { IRequestStrategy } from './strategies/IRequestStrategy';
export { ToolExecutionStrategy } from './strategies/ToolExecutionStrategy';
export { ToolListStrategy } from './strategies/ToolListStrategy';

// All request handling is now done through RequestRouter using the strategy pattern
```

## handlers/interfaces/IRequestHandlerServices.ts

```typescript
import { IAgent } from '../../agents/interfaces/IAgent';
import { SessionContextManager } from '../../services/SessionContextManager';
import { ISchemaProvider } from './ISchemaProvider';

export interface IValidationService {
    validateToolParams(params: any, schema?: any, toolName?: string): Promise<any>;
    validateSessionId(sessionId: string): Promise<string>;
    validateBatchOperations(operations: any[]): Promise<void>;
    validateBatchPaths(paths: any[]): Promise<void>;
}

export interface ISessionService {
    processSessionId(sessionId: string | undefined): Promise<{
        sessionId: string;
        isNewSession: boolean;
        isNonStandardId: boolean;
        originalSessionId?: string;
    }>;
    generateSessionId(): string;
    isStandardSessionId(sessionId: string): boolean;
    shouldInjectInstructions(sessionId: string, sessionContextManager?: SessionContextManager): boolean;
}

export interface IToolExecutionService {
    executeAgent(
        agent: IAgent,
        tool: string,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        params: any
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ): Promise<any>;
}


export interface IResponseFormatter {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    formatToolExecutionResponse(result: any, sessionInfo?: any, context?: { tool?: string }): any;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    formatSessionInstructions(sessionId: string, result: any): any;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    formatErrorResponse(error: Error): any;
}

export interface IToolListService {
    generateToolList(
        agents: Map<string, IAgent>,
        isVaultEnabled: boolean,
        vaultName?: string
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ): Promise<{ tools: any[] }>;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    buildAgentSchema(agent: IAgent): any;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    mergeToolSchemasIntoAgent(agent: IAgent, agentSchema: any): any;
    setSchemaEnhancementService(service: ISchemaEnhancementService): void;
}

export interface IResourceListService {
    listResources(): Promise<{ resources: Array<{ uri: string; name: string; mimeType: string }> }>;
    listResourcesByPath(pathPrefix?: string): Promise<{ resources: Array<{ uri: string; name: string; mimeType: string }> }>;
}

export interface IResourceReadService {
    readResource(uri: string): Promise<{ contents: Array<{ uri: string; text: string; mimeType: string }> }>;
    readMultipleResources(uris: string[]): Promise<{ contents: Array<{ uri: string; text: string; mimeType: string }> }>;
    resourceExists(uri: string): Promise<boolean>;
}

export interface IPromptsListService {
    listPrompts(): Promise<{ prompts: Array<{ name: string; description?: string; arguments?: any[] }> }>;
    listPromptsByCategory(category?: string): Promise<{ prompts: Array<{ name: string; description?: string; arguments?: any[] }> }>;
    promptExists(name: string): Promise<boolean>;
    getPrompt(name: string): Promise<string | null>;
}

export interface IToolHelpService {
    generateToolHelp(
        getAgent: (name: string) => IAgent,
        toolName: string,
        toolSlug: string
    ): Promise<{ content: Array<{ type: string; text: string }> }>;
    generateAgentHelp(
        getAgent: (name: string) => IAgent,
        toolName: string
    ): Promise<{ content: Array<{ type: string; text: string }> }>;
    validateToolExists(
        getAgent: (name: string) => IAgent,
        toolName: string,
        toolSlug: string
    ): Promise<boolean>;
}

export interface IRequestContext {
    agentName: string;
    tool: string;
    params: Record<string, unknown>;
    sessionId: string;
    fullToolName: string;
    sessionContextManager?: SessionContextManager;
}

export interface ISchemaEnhancementService {
    enhanceToolSchema(toolName: string, baseSchema: any): Promise<any>;
    getAvailableEnhancements(): Promise<string[]>;
    registerProvider(provider: ISchemaProvider): void;
    unregisterProvider(providerName: string): boolean;
    hasProvider(providerName: string): boolean;
    clearProviders(): void;
    getProviderInfo(): Array<{ name: string; description: string; priority: number }>;
}

export interface IRequestHandlerDependencies {
    validationService: IValidationService;
    sessionService: ISessionService;
    toolExecutionService: IToolExecutionService;
    responseFormatter: IResponseFormatter;
    toolListService: IToolListService;
    resourceListService: IResourceListService;
    resourceReadService: IResourceReadService;
    promptsListService: IPromptsListService;
    toolHelpService: IToolHelpService;
    schemaEnhancementService: ISchemaEnhancementService;
}
```

## handlers/interfaces/ISchemaProvider.ts

```typescript
/**
 * Location: src/handlers/interfaces/ISchemaProvider.ts
 * 
 * Interface for schema enhancement providers that can enhance tool schemas
 * with additional properties, validation rules, and improvements.
 * Used by SchemaEnhancementService to provide modular enhancement capabilities.
 */

export interface ISchemaProvider {
    /**
     * The name of this schema provider
     */
    readonly name: string;
    
    /**
     * The description of what this provider enhances
     */
    readonly description: string;
    
    /**
     * Check if this provider can enhance the given tool schema
     * @param toolName The name of the tool to check
     * @param baseSchema The base schema to potentially enhance
     * @returns Promise<boolean> true if this provider can enhance the schema
     */
    canEnhance(toolName: string, baseSchema: any): Promise<boolean>;
    
    /**
     * Enhance the given schema with additional properties or validation
     * @param toolName The name of the tool being enhanced
     * @param baseSchema The base schema to enhance
     * @returns Promise<any> The enhanced schema
     */
    enhanceSchema(toolName: string, baseSchema: any): Promise<any>;
    
    /**
     * Get the priority of this provider (higher numbers = higher priority)
     * Used to determine the order of enhancement application
     * @returns number The priority value
     */
    getPriority(): number;
}
```

## handlers/RequestRouter.ts

```typescript
import { App } from 'obsidian';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IAgent } from '../agents/interfaces/IAgent';
import { SessionContextManager } from '../services/SessionContextManager';
import { IRequestHandlerDependencies } from './interfaces/IRequestHandlerServices';
import { IRequestStrategy } from './strategies/IRequestStrategy';

// Import services
import { ValidationService } from './services/ValidationService';
import { SessionService } from './services/SessionService';
import { ToolExecutionService } from './services/ToolExecutionService';
import { ResponseFormatter } from './services/ResponseFormatter';
import { ToolListService } from './services/ToolListService';
import { ResourceListService } from './services/ResourceListService';
import { ResourceReadService } from './services/ResourceReadService';
import { PromptsListService } from './services/PromptsListService';
import { CustomPromptStorageService } from "../agents/promptManager/services/CustomPromptStorageService";
import { ToolHelpService } from './services/ToolHelpService';
import { SchemaEnhancementService } from './services/SchemaEnhancementService';
import { VaultSchemaProvider } from './services/providers/VaultSchemaProvider';
import { WorkspaceSchemaProvider } from './services/providers/WorkspaceSchemaProvider';
import { AgentSchemaProvider } from './services/providers/AgentSchemaProvider';

// Import strategies
import { ToolExecutionStrategy } from './strategies/ToolExecutionStrategy';
import { ToolListStrategy } from './strategies/ToolListStrategy';
import { ResourceListStrategy } from './strategies/ResourceListStrategy';
import { ResourceReadStrategy } from './strategies/ResourceReadStrategy';
import { PromptsListStrategy } from './strategies/PromptsListStrategy';
import { PromptsGetStrategy } from './strategies/PromptsGetStrategy';
import { ToolHelpStrategy } from './strategies/ToolHelpStrategy';

// All requests now handled through modern strategy pattern

export class RequestRouter {
    private dependencies!: IRequestHandlerDependencies;
    private strategies: IRequestStrategy[] = [];

    constructor(
        private app: App,
        private agents: Map<string, IAgent>,
        private isVaultEnabled: boolean,
        private vaultName?: string,
        private sessionContextManager?: SessionContextManager,
        private customPromptStorage?: CustomPromptStorageService,
        private onToolResponse?: (toolName: string, params: any, response: any, success: boolean, executionTime: number) => Promise<void>
    ) {
        this.initializeDependencies();
        this.initializeStrategies();
    }

    private initializeDependencies(): void {
        const schemaEnhancementService = new SchemaEnhancementService();
        const toolListService = new ToolListService();
        
        // Register schema enhancement providers
        if (this.app) {
            const vaultSchemaProvider = new VaultSchemaProvider(this.app);
            schemaEnhancementService.registerProvider(vaultSchemaProvider);
        }
        
        // Register AgentSchemaProvider with access to agents and custom prompt storage
        const agentSchemaProvider = new AgentSchemaProvider();
        agentSchemaProvider.setAgentsMap(this.agents);
        if (this.customPromptStorage) {
            agentSchemaProvider.setCustomPromptStorage(this.customPromptStorage);
        }
        schemaEnhancementService.registerProvider(agentSchemaProvider);
        
        // Inject schema enhancement service into tool list service
        toolListService.setSchemaEnhancementService(schemaEnhancementService);
        
        this.dependencies = {
            validationService: new ValidationService(),
            sessionService: new SessionService(),
            toolExecutionService: new ToolExecutionService(),
            responseFormatter: new ResponseFormatter(),
            toolListService: toolListService,
            resourceListService: new ResourceListService(this.app),
            resourceReadService: new ResourceReadService(this.app),
            promptsListService: new PromptsListService(this.customPromptStorage),
            toolHelpService: new ToolHelpService(),
            schemaEnhancementService: schemaEnhancementService
        };
    }

    private initializeStrategies(): void {
        this.strategies = [
            new ToolListStrategy(
                this.dependencies,
                this.agents,
                this.isVaultEnabled,
                this.vaultName
            ),
            new ToolExecutionStrategy(
                this.dependencies,
                this.getAgent.bind(this),
                this.sessionContextManager,
                this.onToolResponse
            ),
            new ResourceListStrategy(
                this.dependencies,
                this.app
            ),
            new ResourceReadStrategy(
                this.dependencies,
                this.app
            ),
            new PromptsListStrategy(
                this.dependencies
            ),
            new PromptsGetStrategy(
                this.dependencies
            ),
            new ToolHelpStrategy(
                this.dependencies,
                this.getAgent.bind(this)
            )
        ];
    }

    async handleRequest(method: string, request: any): Promise<any> {
        // All requests now handled through strategy pattern
        const requestWithMethod = { method, ...request };
        return await this.handleWithStrategy(requestWithMethod);
    }

    private async handleWithStrategy(request: any): Promise<any> {
        for (const strategy of this.strategies) {
            if (strategy.canHandle(request)) {
                return await strategy.handle(request);
            }
        }
        
        throw new McpError(
            ErrorCode.MethodNotFound,
            `No strategy found for request: ${request.method || 'unknown'}`
        );
    }

    private getAgent(name: string): IAgent {
        const agent = this.agents.get(name);
        if (!agent) {
            // Build helpful error with suggestions
            const errorMessage = this.buildAgentNotFoundError(name);
            throw new McpError(
                ErrorCode.InvalidParams,
                errorMessage
            );
        }
        return agent;
    }

    /**
     * Build helpful error message when agent is not found
     * Suggests correct agent name if case is wrong, or lists available agents
     */
    private buildAgentNotFoundError(incorrectName: string): string {
        const lines: string[] = [];

        // Check for case-insensitive match
        const lowerName = incorrectName.toLowerCase();
        for (const agentName of this.agents.keys()) {
            if (agentName.toLowerCase() === lowerName) {
                lines.push(`Agent "${incorrectName}" not found.`);
                lines.push(`ðŸ’¡ Did you mean: ${agentName}?`);
                lines.push('');
                lines.push('Note: Agent names are case-sensitive.');
                return lines.join('\n');
            }
        }

        // List available agents
        const agentNames = Array.from(this.agents.keys());
        lines.push(`Agent "${incorrectName}" not found.`);
        lines.push('');
        lines.push('Available agents:');
        agentNames.forEach(name => lines.push(`  - ${name}`));

        return lines.join('\n');
    }

    // Expose dependencies for testing or extended functionality
    getDependencies(): IRequestHandlerDependencies {
        return this.dependencies;
    }

    // Allow adding custom strategies
    addStrategy(strategy: IRequestStrategy): void {
        this.strategies.push(strategy);
    }

    /**
     * Register WorkspaceSchemaProvider with the schema enhancement service
     * This is called after agents are initialized to ensure WorkspaceService is available
     */
    async registerWorkspaceSchemaProvider(): Promise<void> {
        try {
            // Get MemoryManager agent to access WorkspaceService
            const memoryManagerAgent = this.agents.get('memoryManager');
            if (!memoryManagerAgent) {
                return;
            }

            // Get WorkspaceService from MemoryManager agent
            const agentWithWorkspaceService = memoryManagerAgent as { getWorkspaceServiceAsync?: () => Promise<unknown> };
            const workspaceService = agentWithWorkspaceService.getWorkspaceServiceAsync
                ? await agentWithWorkspaceService.getWorkspaceServiceAsync()
                : null;
            if (!workspaceService) {
                return;
            }

            // Create and register WorkspaceSchemaProvider
            // Cast to unknown first since workspaceService comes from dynamic agent method
            const workspaceSchemaProvider = WorkspaceSchemaProvider.forMemoryManager(workspaceService as unknown as import('../services/WorkspaceService').WorkspaceService);
            this.dependencies.schemaEnhancementService.registerProvider(workspaceSchemaProvider);
            
        } catch (error) {
        }
    }
}
```

## handlers/services/BaseSchemaProvider.ts

```typescript
/**
 * Location: src/handlers/services/BaseSchemaProvider.ts
 * 
 * Base abstract class for schema enhancement providers. Implements common
 * functionality for schema enhancement and provides DRY foundation for
 * specific enhancement providers.
 * Extends this class to create specific enhancement providers.
 */

import { ISchemaProvider } from '../interfaces/ISchemaProvider';
import { logger } from '../../utils/logger';
import { getErrorMessage } from '../../utils/errorUtils';

export abstract class BaseSchemaProvider implements ISchemaProvider {
    abstract readonly name: string;
    abstract readonly description: string;

    /**
     * Default priority - can be overridden by implementations
     */
    getPriority(): number {
        return 100;
    }

    /**
     * Default implementation - checks tool name patterns.
     * Override for more sophisticated logic.
     */
    async canEnhance(toolName: string, baseSchema: any): Promise<boolean> {
        try {
            return this.shouldEnhanceToolName(toolName) && this.hasValidSchema(baseSchema);
        } catch (error) {
            logger.systemError(error as Error, `${this.name} - Error in canEnhance`);
            return false;
        }
    }

    abstract enhanceSchema(toolName: string, baseSchema: any): Promise<any>;

    /**
     * Common utility: Check if tool name should be enhanced by this provider
     * Override this method to define tool name patterns for enhancement
     */
    protected shouldEnhanceToolName(toolName: string): boolean {
        // Default: enhance all tools (override in subclasses for specific patterns)
        return true;
    }

    /**
     * Common utility: Validate that base schema is valid for enhancement
     */
    protected hasValidSchema(baseSchema: any): boolean {
        return baseSchema && typeof baseSchema === 'object' && baseSchema.properties;
    }

    /**
     * Common utility: Deep clone schema to avoid mutations
     */
    protected cloneSchema(schema: any): any {
        try {
            return JSON.parse(JSON.stringify(schema));
        } catch (error) {
            logger.systemError(error as Error, `${this.name} - Error cloning schema`);
            return { ...schema }; // Shallow clone fallback
        }
    }

    /**
     * Common utility: Merge enhanced properties into base schema
     */
    protected mergeProperties(baseSchema: any, enhancedProperties: any): any {
        const enhanced = this.cloneSchema(baseSchema);
        
        if (enhancedProperties) {
            enhanced.properties = {
                ...enhanced.properties,
                ...enhancedProperties
            };
        }
        
        return enhanced;
    }

    /**
     * Common utility: Add conditional validation rules to schema
     */
    protected addConditionalValidation(schema: any, condition: any, validation: any): any {
        const enhanced = this.cloneSchema(schema);
        
        if (!enhanced.allOf) {
            enhanced.allOf = [];
        }
        
        enhanced.allOf.push({
            if: condition,
            then: validation
        });
        
        return enhanced;
    }

    /**
     * Common utility: Add required fields conditionally
     */
    protected addConditionalRequired(schema: any, condition: any, requiredFields: string[]): any {
        return this.addConditionalValidation(schema, condition, {
            required: requiredFields
        });
    }

    /**
     * Common utility: Log enhancement activity for debugging
     */
    protected logEnhancement(toolName: string, action: string, details?: any): void {
        logger.systemLog(`[${this.name}] Enhanced ${toolName}: ${action}`, details);
    }

    /**
     * Common utility: Safe error handling wrapper for enhancement operations
     */
    protected async safeEnhance<T>(
        operation: () => Promise<T>,
        fallbackValue: T,
        operationName: string
    ): Promise<T> {
        try {
            return await operation();
        } catch (error) {
            logger.systemError(
                error as Error, 
                `${this.name} - Error in ${operationName}: ${getErrorMessage(error)}`
            );
            return fallbackValue;
        }
    }
}
```

## handlers/services/PromptsListService.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IPromptsListService } from '../interfaces/IRequestHandlerServices';
import { logger } from '../../utils/logger';
import { CustomPromptStorageService } from "../../agents/promptManager/services/CustomPromptStorageService";

/**
 * Prompt interface for MCP prompt listing
 */
interface Prompt {
    name: string;
    description?: string;
    arguments?: Array<{
        name: string;
        description?: string;
        required?: boolean;
    }>;
}

/**
 * Service for listing available prompts
 * Applies Single Responsibility Principle by focusing solely on prompt enumeration
 * 
 * Includes both system prompts and user-defined custom prompts
 */
export class PromptsListService implements IPromptsListService {
    private customPromptStorage?: CustomPromptStorageService;

    constructor(customPromptStorage?: CustomPromptStorageService) {
        this.customPromptStorage = customPromptStorage;
    }

    /**
     * Get all available prompts
     * @returns Promise resolving to array of prompts
     */
    async listPrompts(): Promise<{ prompts: Prompt[] }> {
        try {
            
            const prompts: Prompt[] = [];
            
            // Add system prompts (currently none)
            // Future enhancement: Could add predefined system prompt templates
            
            // Add custom prompts if storage service is available
            if (this.customPromptStorage && this.customPromptStorage.isEnabled()) {
                const customPrompts = this.customPromptStorage.getEnabledPrompts();
                
                // Convert custom prompts to MCP Prompt format
                const mcpPrompts = customPrompts.map(customPrompt => ({
                    name: customPrompt.name,
                    description: customPrompt.description,
                    // Custom prompts don't have arguments for now
                    arguments: []
                }));
                
                prompts.push(...mcpPrompts);
            }
            
            return { prompts };
        } catch (error) {
            logger.systemError(error as Error, 'PromptsListService');
            throw new McpError(ErrorCode.InternalError, 'Failed to list prompts', error);
        }
    }

    /**
     * Get prompts by category (future enhancement)
     * @param category Optional category to filter prompts
     * @returns Promise resolving to filtered prompts
     */
    async listPromptsByCategory(category?: string): Promise<{ prompts: Prompt[] }> {
        try {
            const allPrompts = await this.listPrompts();
            
            if (!category) {
                return allPrompts;
            }
            
            // Future: Filter prompts by category when implemented
            return { prompts: [] };
        } catch (error) {
            logger.systemError(error as Error, 'PromptsListService');
            throw new McpError(ErrorCode.InternalError, 'Failed to list prompts by category', error);
        }
    }

    /**
     * Check if prompt exists by name
     * @param name Prompt name
     * @returns Promise resolving to boolean
     */
    async promptExists(name: string): Promise<boolean> {
        try {
            // Check custom prompts first if available
            if (this.customPromptStorage && this.customPromptStorage.isEnabled()) {
                const customPrompt = this.customPromptStorage.getPromptByNameOrId(name);
                if (customPrompt && customPrompt.isEnabled) {
                    return true;
                }
            }
            
            // Check system prompts (currently none)
            // Future: Add system prompt checking here
            
            return false;
        } catch (error) {
            logger.systemWarn(`PromptsListService: Prompt existence check failed for ${name}`);
            return false;
        }
    }

    /**
     * Get a specific prompt by name (for MCP prompts/get endpoint)
     * @param name Prompt name
     * @returns Promise resolving to prompt content or null
     */
    async getPrompt(name: string): Promise<string | null> {
        try {
            if (this.customPromptStorage && this.customPromptStorage.isEnabled()) {
                const customPrompt = this.customPromptStorage.getPromptByNameOrId(name);
                if (customPrompt && customPrompt.isEnabled) {
                    return customPrompt.prompt;
                }
            }
            
            // Check system prompts (currently none)
            // Future: Add system prompt retrieval here
            
            return null;
        } catch (error) {
            logger.systemError(error as Error, 'PromptsListService');
            return null;
        }
    }
}
```

## handlers/services/providers/AgentSchemaProvider.ts

```typescript
/**
 * Location: src/handlers/services/providers/AgentSchemaProvider.ts
 *
 * Schema provider for dynamic domain agent and prompt ID injection into PromptManager tool schemas.
 * Extends BaseSchemaProvider to enhance PromptManager tool schemas with available domain agent names,
 * custom prompt IDs, and contextual descriptions. Used by SchemaEnhancementService to
 * provide dynamic agent and prompt context for better AI assistant understanding.
 */

import { BaseSchemaProvider } from '../BaseSchemaProvider';
import { IAgent } from '../../../agents/interfaces/IAgent';
import { CustomPromptStorageService } from '../../../agents/promptManager/services/CustomPromptStorageService';
import { CustomPrompt } from '../../../types';
import { logger } from '../../../utils/logger';

interface AgentInfo {
    name: string;
    description: string;
    enabled: boolean;
}

interface PromptInfo {
    id: string;
    name: string;
    description: string;
    enabled: boolean;
}

interface CachedData {
    agents: AgentInfo[];
    prompts: PromptInfo[];
    timestamp: number;
}

/**
 * Schema provider that injects available domain agent names and custom prompt IDs
 * into PromptManager tool schemas for dynamic context enhancement
 */
export class AgentSchemaProvider extends BaseSchemaProvider {
    readonly name = 'AgentSchemaProvider';
    readonly description = 'Injects available domain agent names and custom prompt IDs into PromptManager tool schemas';
    
    private cache: CachedData | null = null;
    private readonly CACHE_DURATION_MS = 30000; // 30 seconds
    private readonly MAX_AGENTS_TO_SHOW = 15;
    private readonly MAX_PROMPTS_TO_SHOW = 10;

    private agentsMap: Map<string, IAgent> | null = null;
    private customPromptStorage: CustomPromptStorageService | null = null;

    /**
     * Set the agents map for querying available agents
     */
    setAgentsMap(agentsMap: Map<string, IAgent>): void {
        this.agentsMap = agentsMap;
        this.clearCache(); // Clear cache when agents change
    }

    /**
     * Set the custom prompt storage service for querying custom prompts
     */
    setCustomPromptStorage(customPromptStorage: CustomPromptStorageService): void {
        this.customPromptStorage = customPromptStorage;
        this.clearCache(); // Clear cache when storage changes
    }

    /**
     * Get priority for this provider (higher than base providers)
     */
    getPriority(): number {
        return 200; // High priority for agent-specific enhancements
    }

    /**
     * Check if this provider should enhance the given tool schema
     * Only enhances PromptManager tool schemas
     */
    protected shouldEnhanceToolName(toolName: string): boolean {
        return toolName.startsWith('promptManager-');
    }

    /**
     * Enhance PromptManager tool schemas with domain agent names and prompt IDs
     */
    async enhanceSchema(toolName: string, baseSchema: any): Promise<any> {
        return await this.safeEnhance(
            async () => this.performEnhancement(toolName, baseSchema),
            baseSchema,
            'enhanceSchema'
        );
    }

    /**
     * Perform the actual schema enhancement
     */
    private async performEnhancement(toolName: string, baseSchema: any): Promise<any> {
        // Get cached or fresh data
        const data = await this.getCachedData();

        // Clone the base schema
        const enhanced = this.cloneSchema(baseSchema);

        // Extract the mode from tool name (e.g., 'promptManager-executePrompt' -> 'executePrompt')
        const mode = toolName.replace('promptManager-', '');
        
        // Enhance based on the mode
        switch (mode) {
            case 'executePrompt':
            case 'batchExecutePrompt':
                this.enhanceExecutePromptSchema(enhanced, data);
                break;
            case 'createPrompt':
            case 'updatePrompt':
            case 'getPrompt':
            case 'deletePrompt':
            case 'togglePrompt':
                this.enhancePromptManagementSchema(enhanced, data);
                break;
            case 'listPrompts':
                this.enhanceListPromptsSchema(enhanced, data);
                break;
            default:
                // For other modes, add general context
                this.enhanceGeneralSchema(enhanced, data);
                break;
        }
        
        this.logEnhancement(toolName, 'injected agent and prompt context', {
            agentsCount: data.agents.length,
            promptsCount: data.prompts.length
        });
        
        return enhanced;
    }

    /**
     * Enhance executePrompt and batchExecutePrompt schemas
     */
    private enhanceExecutePromptSchema(schema: any, data: CachedData): void {
        // Enhance agent parameter with available agent names
        if (schema.properties?.agent) {
            schema.properties.agent.enum = data.agents
                .filter(agent => agent.enabled)
                .slice(0, this.MAX_AGENTS_TO_SHOW)
                .map(agent => agent.name);
            
            schema.properties.agent.description = this.buildAgentDescription(data.agents);
            
            // Add examples
            const enabledAgents = data.agents.filter(agent => agent.enabled);
            if (enabledAgents.length > 0) {
                schema.properties.agent.examples = enabledAgents.slice(0, 3).map(agent => agent.name);
            }
        }

        // Add prompt ID parameter if not present
        if (!schema.properties?.promptId && data.prompts.length > 0) {
            schema.properties.promptId = {
                type: 'string',
                description: this.buildPromptIdDescription(data.prompts),
                enum: data.prompts
                    .filter(prompt => prompt.enabled)
                    .slice(0, this.MAX_PROMPTS_TO_SHOW)
                    .map(prompt => prompt.id),
                examples: data.prompts
                    .filter(prompt => prompt.enabled)
                    .slice(0, 3)
                    .map(prompt => prompt.id)
            };
        }

        // Update tool description with agent and prompt context
        if (data.agents.length > 0 || data.prompts.length > 0) {
            schema.description = `${schema.description}\n\n${this.buildContextSummary(data)}`;
        }
    }

    /**
     * Enhance prompt management schemas (create, update, get, delete, toggle)
     */
    private enhancePromptManagementSchema(schema: any, data: CachedData): void {
        // For ID-based operations, enhance with available prompt IDs
        if (schema.properties?.id && data.prompts.length > 0) {
            schema.properties.id.enum = data.prompts.map(prompt => prompt.id);
            schema.properties.id.description = `${schema.properties.id.description || 'Prompt ID'}\n\nAvailable prompt IDs:\n${
                data.prompts.map(prompt => `â€¢ ${prompt.id}: ${prompt.name} ${prompt.enabled ? 'âœ…' : 'âŒ'}`).join('\n')
            }`;
        }

        // For name-based operations, enhance with available prompt names
        if (schema.properties?.name && data.prompts.length > 0) {
            schema.properties.name.enum = data.prompts.map(prompt => prompt.name);
            schema.properties.name.examples = data.prompts.slice(0, 3).map(prompt => prompt.name);
        }
    }

    /**
     * Enhance listPrompts schema
     */
    private enhanceListPromptsSchema(schema: any, data: CachedData): void {
        if (data.prompts.length > 0) {
            schema.description = `${schema.description}\n\nCurrent prompts: ${data.prompts.length} total (${
                data.prompts.filter(p => p.enabled).length
            } enabled)`;
        }
    }

    /**
     * Enhance general schemas with basic context
     */
    private enhanceGeneralSchema(schema: any, data: CachedData): void {
        if (data.agents.length > 0 || data.prompts.length > 0) {
            schema.description = `${schema.description}\n\n${this.buildContextSummary(data)}`;
        }
    }

    /**
     * Build agent parameter description with available agents
     */
    private buildAgentDescription(agents: AgentInfo[]): string {
        const enabledAgents = agents.filter(agent => agent.enabled);
        
        if (enabledAgents.length === 0) {
            return 'Agent name to use for prompt execution. No custom prompt agents currently available.';
        }
        
        const agentsList = enabledAgents
            .slice(0, this.MAX_AGENTS_TO_SHOW)
            .map(agent => `â€¢ ${agent.name}: ${agent.description || 'No description'}`)
            .join('\n');
        
        return `Agent name to use for prompt execution. Available custom prompt agents:\n${agentsList}${
            enabledAgents.length > this.MAX_AGENTS_TO_SHOW ? '\n...and more' : ''
        }`;
    }

    /**
     * Build prompt ID parameter description with available prompts
     */
    private buildPromptIdDescription(prompts: PromptInfo[]): string {
        const enabledPrompts = prompts.filter(prompt => prompt.enabled);
        
        if (enabledPrompts.length === 0) {
            return 'Custom prompt ID to execute directly (alternative to specifying agent). No custom prompts currently available.';
        }
        
        const promptsList = enabledPrompts
            .slice(0, this.MAX_PROMPTS_TO_SHOW)
            .map(prompt => `â€¢ ${prompt.id}: ${prompt.name} - ${prompt.description || 'No description'}`)
            .join('\n');
        
        return `Custom prompt ID to execute directly (alternative to specifying agent). Available custom prompts:\n${promptsList}${
            enabledPrompts.length > this.MAX_PROMPTS_TO_SHOW ? '\n...and more' : ''
        }`;
    }

    /**
     * Build context summary for tool descriptions
     */
    private buildContextSummary(data: CachedData): string {
        const parts: string[] = [];
        
        const enabledAgents = data.agents.filter(agent => agent.enabled);
        if (enabledAgents.length > 0) {
            parts.push(`Available agents: ${enabledAgents.length} enabled`);
        }
        
        const enabledPrompts = data.prompts.filter(prompt => prompt.enabled);
        if (enabledPrompts.length > 0) {
            parts.push(`Custom prompts: ${enabledPrompts.length} enabled`);
        }
        
        if (parts.length === 0) {
            return 'No custom agents or prompts currently available.';
        }
        
        return `ðŸ¤– ${parts.join(' | ')}`;
    }

    /**
     * Get cached data or refresh if stale
     */
    private async getCachedData(): Promise<CachedData> {
        const now = Date.now();
        
        if (this.cache && (now - this.cache.timestamp) < this.CACHE_DURATION_MS) {
            return this.cache;
        }
        
        // Refresh cache
        const agents = await this.queryAvailableAgents();
        const prompts = await this.queryAvailablePrompts();
        
        this.cache = {
            agents,
            prompts,
            timestamp: now
        };
        
        return this.cache;
    }

    /**
     * Query available agents from the agents map
     */
    private async queryAvailableAgents(): Promise<AgentInfo[]> {
        if (!this.agentsMap) {
            return [];
        }
        
        try {
            const agents: AgentInfo[] = [];
            
            for (const [name, agent] of this.agentsMap.entries()) {
                // Skip the PromptManager agent itself to avoid confusion
                if (name === 'promptManager') {
                    continue;
                }
                
                agents.push({
                    name,
                    description: agent.description || 'No description available',
                    enabled: true // Regular agents are always considered enabled
                });
            }
            
            return agents;
        } catch (error) {
            logger.systemError(error as Error, `${this.name} - Error querying available agents`);
            return [];
        }
    }

    /**
     * Query available custom prompts from storage service
     */
    private async queryAvailablePrompts(): Promise<PromptInfo[]> {
        if (!this.customPromptStorage) {
            return [];
        }
        
        try {
            // Check if custom prompts are enabled globally
            if (!this.customPromptStorage.isEnabled()) {
                return [];
            }
            
            const allPrompts = this.customPromptStorage.getAllPrompts();
            
            return allPrompts.map(prompt => ({
                id: prompt.id,
                name: prompt.name,
                description: prompt.description || 'No description available',
                enabled: prompt.isEnabled
            }));
        } catch (error) {
            logger.systemError(error as Error, `${this.name} - Error querying available prompts`);
            return [];
        }
    }

    /**
     * Clear cache (useful when agents or prompts change)
     */
    private clearCache(): void {
        this.cache = null;
    }
}
```

## handlers/services/providers/VaultSchemaProvider.ts

```typescript
/**
 * VaultSchemaProvider - Dynamic vault structure injection for VaultManager tool schemas
 * Location: /src/handlers/services/providers/VaultSchemaProvider.ts
 * 
 * This file provides dynamic enhancement of VaultManager tool schemas by injecting
 * current vault folder and file structure information. Uses the Obsidian Vault API
 * to query vault structure and enhance tool descriptions and parameter schemas
 * with contextual vault information for better Claude understanding.
 */

import { ISchemaProvider } from '../../interfaces/ISchemaProvider';
import { BaseSchemaProvider } from '../BaseSchemaProvider';
import { App, TFile, TFolder } from 'obsidian';
import { logger } from '../../../utils/logger';
import { FileUtils } from '../../../database/utils/FileUtils';

interface VaultStructureInfo {
  rootFolders: Array<{
    name: string;
    fileCount: number;
    subfolderCount: number;
  }>;
  rootFileCount: number;
  totalFiles: number;
  totalFolders: number;
  recentFiles: Array<{
    name: string;
    path: string;
    folder?: string;
  }>;
}

interface CachedVaultData {
  structure: VaultStructureInfo;
  timestamp: number;
  vaultName: string;
}

/**
 * Schema provider that injects current vault structure into VaultManager tool schemas
 * Extends BaseSchemaProvider to provide vault-specific context for file operations
 */
export class VaultSchemaProvider extends BaseSchemaProvider {
  readonly name = 'VaultSchemaProvider';
  readonly description = 'Injects current vault structure into VaultManager tool schemas for better context';
  
  private cache: CachedVaultData | null = null;
  private readonly CACHE_DURATION_MS = 30000; // 30 seconds
  private readonly MAX_FOLDERS_TO_SHOW = 10;
  private readonly MAX_FILES_TO_SHOW = 8;
  private readonly MAX_DEPTH = 2; // Root + 1 sublevel
  private app: App;

  constructor(app: App) {
    super();
    this.app = app;
  }

  /**
   * Get provider priority (higher numbers = higher priority)
   * VaultSchemaProvider has medium priority
   */
  getPriority(): number {
    return 50;
  }

  /**
   * Check if tool name should be enhanced by this provider
   * Only enhances VaultManager tools
   */
  protected shouldEnhanceToolName(toolName: string): boolean {
    // Check if this is a VaultManager tool
    return toolName.toLowerCase().includes('vault') || 
           toolName.toLowerCase().includes('vaultmanager');
  }

  /**
   * Enhance the schema with vault structure information
   * Adds vault context to relevant parameters and descriptions
   */
  async enhanceSchema(toolName: string, baseSchema: any): Promise<any> {
    return this.safeEnhance(async () => {
      const vaultInfo = await this.getVaultStructure();
      if (!vaultInfo) {
        return baseSchema;
      }

      // Deep clone to avoid modifying original using BaseSchemaProvider utility
      const enhanced = this.cloneSchema(baseSchema);

      // Enhance the schema based on available modes and properties
      this.enhanceSchemaWithVaultContext(enhanced, vaultInfo);
      
      // Log enhancement activity for debugging
      this.logEnhancement(toolName, 'Added vault structure context', {
        rootFolders: vaultInfo.rootFolders.length,
        totalFiles: vaultInfo.totalFiles
      });

      return enhanced;
    }, baseSchema, 'vault structure enhancement');
  }

  /**
   * Get vault structure information with caching
   * Limits depth to avoid schema bloat while providing useful context
   */
  private async getVaultStructure(): Promise<VaultStructureInfo | null> {
    try {
      // Check cache first
      const now = Date.now();
      if (this.cache && (now - this.cache.timestamp) < this.CACHE_DURATION_MS) {
        return this.cache.structure;
      }

      const markdownFiles = this.app.vault.getMarkdownFiles();
      const rootFolder = this.app.vault.getRoot();

      // Get root folders with file counts
      const rootFolders = rootFolder.children
        .filter(child => child instanceof TFolder)
        .slice(0, this.MAX_FOLDERS_TO_SHOW) // Limit to prevent schema bloat
        .map(folder => {
          const typedFolder = folder as TFolder;
          const filesInFolder = markdownFiles.filter(file => 
            file.path.startsWith(typedFolder.path + '/')
          ).length;

          const subfolderCount = typedFolder.children
            .filter(child => child instanceof TFolder)
            .length;

          return {
            name: typedFolder.name,
            fileCount: filesInFolder,
            subfolderCount
          };
        });

      // Get root files count
      const rootFileCount = markdownFiles.filter(file => !file.path.includes('/')).length;

      // Get recent files for examples
      const recentFiles = markdownFiles
        .sort((a, b) => b.stat.mtime - a.stat.mtime)
        .slice(0, this.MAX_FILES_TO_SHOW)
        .map(file => ({
          name: file.name,
          path: file.path,
          folder: file.path.includes('/') ? file.path.split('/')[0] : undefined
        }));

      const structure: VaultStructureInfo = {
        rootFolders,
        rootFileCount,
        totalFiles: markdownFiles.length,
        totalFolders: rootFolders.length,
        recentFiles
      };

      // Update cache
      this.cache = {
        structure,
        timestamp: now,
        vaultName: this.app.vault.getName()
      };

      return structure;
    } catch (error) {
      logger.systemError(error as Error, 'VaultSchemaProvider: Failed to get vault structure');
      return null;
    }
  }

  /**
   * Enhance schema with vault structure context
   * Adds contextual information to relevant parameters
   */
  private enhanceSchemaWithVaultContext(schema: any, vaultInfo: VaultStructureInfo): void {
    try {
      // Add vault structure information to the schema description
      if (schema.description) {
        const vaultContext = this.formatVaultStructureForDescription(vaultInfo);
        schema.description = `${schema.description}\n\n${vaultContext}`;
      }

      // Enhance properties based on their names and types
      if (schema.properties) {
        this.enhancePropertiesWithVaultContext(schema.properties, vaultInfo);
      }

      // Enhance conditional schemas in allOf array (used by ToolListService)
      if (schema.allOf && Array.isArray(schema.allOf)) {
        schema.allOf.forEach((condition: any) => {
          if (condition.then && condition.then.properties) {
            this.enhancePropertiesWithVaultContext(condition.then.properties, vaultInfo);
          }
        });
      }
    } catch (error) {
      logger.systemWarn(`VaultSchemaProvider: Failed to enhance schema with vault context: ${String(error)}`);
    }
  }

  /**
   * Enhance individual properties with vault context
   */
  private enhancePropertiesWithVaultContext(properties: any, vaultInfo: VaultStructureInfo): void {
    Object.keys(properties).forEach(propName => {
      const prop = properties[propName];
      
      // Enhance path-related properties
      if (this.isPathProperty(propName) && prop.type === 'string') {
        this.enhancePathProperty(prop, propName, vaultInfo);
      }
      
      // Enhance mode enum with contextual information
      if (propName === 'mode' && prop.enum && Array.isArray(prop.enum)) {
        this.enhanceModeProperty(prop, vaultInfo);
      }
    });
  }

  /**
   * Check if a property name indicates a file/folder path
   */
  private isPathProperty(propName: string): boolean {
    const pathKeywords = ['path', 'file', 'folder', 'directory', 'target', 'source', 'note'];
    return pathKeywords.some(keyword => propName.toLowerCase().includes(keyword));
  }

  /**
   * Enhance path properties with vault examples and context
   */
  private enhancePathProperty(prop: any, propName: string, vaultInfo: VaultStructureInfo): void {
    // Add vault-specific examples based on property type
    if (propName.toLowerCase().includes('folder') || propName.toLowerCase().includes('directory')) {
      // Folder-related properties
      const folderExamples = vaultInfo.rootFolders.slice(0, 3).map(f => f.name);
      if (folderExamples.length > 0) {
        prop.examples = folderExamples;
        
        prop.description = prop.description + 
          `\n\nAvailable folders: ${folderExamples.join(', ')}` +
          (vaultInfo.rootFolders.length > 3 ? ` (and ${vaultInfo.rootFolders.length - 3} more)` : '');
      }
    } else if (propName.toLowerCase().includes('file') || propName.toLowerCase().includes('note')) {
      // File-related properties
      const fileExamples = vaultInfo.recentFiles.slice(0, 3).map(f => f.path);
      if (fileExamples.length > 0) {
        prop.examples = fileExamples;
        
        prop.description = prop.description + 
          `\n\nRecent files: ${fileExamples.join(', ')}`;
      }
    } else {
      // General path properties (could be files or folders)
      const pathExamples = vaultInfo.rootFolders.slice(0, 2).map(f => f.name)
        .concat(vaultInfo.recentFiles.slice(0, 2).map(f => f.path));
      
      if (pathExamples.length > 0) {
        prop.examples = pathExamples.slice(0, 4);
        
        prop.description = prop.description + 
          `\n\nExample paths: ${pathExamples.slice(0, 3).join(', ')}`;
      }
    }
  }

  /**
   * Enhance mode property with contextual descriptions
   */
  private enhanceModeProperty(prop: any, vaultInfo: VaultStructureInfo): void {
    // Add vault context to mode description
    prop.description = prop.description + 
      `\n\nCurrent vault has ${vaultInfo.totalFiles} files in ${vaultInfo.totalFolders} folders.`;
  }

  /**
   * Format vault structure for schema description
   * Follows existing VaultManagerAgent.getVaultStructureSummary() pattern
   */
  private formatVaultStructureForDescription(structure: VaultStructureInfo): string {
    const summary = [
      `ðŸ“ Vault Structure: ${structure.totalFiles} files, ${structure.totalFolders} root folders`
    ];

    if (structure.rootFileCount > 0) {
      summary.push(`   â””â”€â”€ / (${structure.rootFileCount} files in root)`);
    }

    // Add folder structure (limited to prevent schema bloat)
    structure.rootFolders.slice(0, 5).forEach(folder => {
      const subfolderText = folder.subfolderCount > 0 ? `, ${folder.subfolderCount} subfolders` : '';
      summary.push(`   â””â”€â”€ ${folder.name}/ (${folder.fileCount} files${subfolderText})`);
    });

    if (structure.rootFolders.length > 5) {
      summary.push(`   â””â”€â”€ ... and ${structure.rootFolders.length - 5} more folders`);
    }

    // Add recent files as examples
    if (structure.recentFiles.length > 0) {
      summary.push(`\nðŸ“„ Recent files: ${structure.recentFiles.slice(0, 4).map(f => f.name).join(', ')}`);
    }

    return summary.join('\n');
  }

  /**
   * Clear cache (useful for testing or vault changes)
   */
  clearCache(): void {
    this.cache = null;
  }
}
```

## handlers/services/providers/WorkspaceSchemaProvider.ts

```typescript
/**
 * Location: /src/handlers/services/providers/WorkspaceSchemaProvider.ts
 * Purpose: Schema provider for injecting dynamic workspace information into MemoryManager tool schemas
 * 
 * This file enhances MemoryManager workspace-related modes with actual workspace IDs, names,
 * descriptions, and counts to help Claude understand available workspace options.
 * 
 * Used by: SchemaEnhancementService to enhance MemoryManager schemas during tool registration
 * Integrates with: WorkspaceService to query current workspace information
 */

import { ISchemaProvider } from '../../interfaces/ISchemaProvider';
import { WorkspaceService, GLOBAL_WORKSPACE_ID } from '../../../services/WorkspaceService';
import { logger } from '../../../utils/logger';

/**
 * Workspace enhancement data structure
 */
interface WorkspaceEnhancementData {
  /** Available workspace IDs for enum options */
  workspaceIds: string[];
  /** Workspace details for descriptions */
  workspaces: Array<{
    id: string;
    name: string;
    description?: string;
  }>;
  /** Statistics for schema descriptions */
  stats: {
    totalCount: number;
  };
}

/**
 * Schema provider for workspace-related enhancements
 */
export class WorkspaceSchemaProvider implements ISchemaProvider {
  public readonly name = 'WorkspaceSchemaProvider';
  public readonly description = 'Enhances MemoryManager schemas with dynamic workspace information';

  private workspaceService: WorkspaceService;
  private targetModes: string[];
  private cache: Map<string, WorkspaceEnhancementData> = new Map();
  private enableCaching: boolean;

  /**
   * Create a new WorkspaceSchemaProvider
   * @param workspaceService WorkspaceService instance for querying workspaces
   * @param targetModes Specific modes to target (defaults to workspace modes)
   * @param enableCaching Whether to enable caching (defaults to true)
   */
  constructor(
    workspaceService: WorkspaceService,
    targetModes: string[] = ['loadWorkspace', 'listWorkspaces'],
    enableCaching: boolean = true
  ) {
    this.workspaceService = workspaceService;
    this.targetModes = targetModes;
    this.enableCaching = enableCaching;
  }

  /**
   * Check if this provider can enhance the given tool schema
   * @param toolName Tool name (e.g., "memoryManager")
   * @param baseSchema Base schema to potentially enhance
   * @returns Promise<boolean> true if this provider can enhance the schema
   */
  async canEnhance(toolName: string, baseSchema: any): Promise<boolean> {
    try {
      // Extract agent name from tool name (handle both "memoryManager" and "memoryManager_vaultName" formats)
      const agentName = toolName.split('_')[0];
      
      // Only enhance memoryManager agent
      if (agentName !== 'memoryManager') {
        return false;
      }

      // Check if the schema has mode property with workspace-related modes
      if (!baseSchema?.properties?.mode?.enum) {
        return false;
      }

      // Check if any target modes are present in the schema
      const schemaModes = baseSchema.properties.mode.enum as string[];
      const hasTargetMode = this.targetModes.some(mode => schemaModes.includes(mode));
      
      logger.systemLog(`canEnhance(${toolName}): ${hasTargetMode}`, 'WorkspaceSchemaProvider');
      return hasTargetMode;

    } catch (error) {
      logger.systemError(error instanceof Error ? error : new Error(String(error)), 'WorkspaceSchemaProvider canEnhance');
      return false;
    }
  }

  /**
   * Enhance the given schema with workspace information
   * @param toolName Tool name
   * @param baseSchema Base schema to enhance
   * @returns Promise<any> The enhanced schema
   */
  async enhanceSchema(toolName: string, baseSchema: any): Promise<any> {
    try {
      // Get workspace data
      const workspaceData = await this.fetchEnhancementData();

      // Apply enhancements to schema
      const enhancedSchema = this.applyEnhancement(baseSchema, workspaceData);

      logger.systemLog(`Enhanced schema for ${toolName} with ${workspaceData.workspaceIds.length} workspaces`, 'WorkspaceSchemaProvider');
      return enhancedSchema;

    } catch (error) {
      logger.systemError(error instanceof Error ? error : new Error(String(error)), `WorkspaceSchemaProvider enhanceSchema for ${toolName}`);
      
      // Return original schema on error
      return baseSchema;
    }
  }

  /**
   * Get the priority of this provider
   * @returns Priority number (higher = higher priority)
   */
  getPriority(): number {
    return 100; // High priority for workspace information
  }

  /**
   * Fetch workspace enhancement data
   * @returns Workspace enhancement data
   */
  private async fetchEnhancementData(): Promise<WorkspaceEnhancementData> {
    const cacheKey = 'workspace_data';
    
    // Check cache first
    if (this.enableCaching && this.cache.has(cacheKey)) {
      const cachedData = this.cache.get(cacheKey)!;
      logger.systemLog(`Using cached workspace data (${cachedData.stats.totalCount} workspaces)`, 'WorkspaceSchemaProvider');
      return cachedData;
    }

    try {
      // Query all workspaces
      const workspaces = await this.workspaceService.listWorkspaces();

      logger.systemLog(`Fetched ${workspaces.length} workspaces for schema enhancement`, 'WorkspaceSchemaProvider');

      // Extract workspace IDs and details
      const workspaceIds = workspaces.map(ws => ws.id);
      const workspaceDetails = workspaces.map(ws => ({
        id: ws.id,
        name: ws.name || 'Unnamed Workspace',
        description: ws.description
      }));

      // Calculate statistics
      const stats = {
        totalCount: workspaces.length
      };

      const enhancementData = {
        workspaceIds,
        workspaces: workspaceDetails,
        stats
      };

      // Cache the data if caching is enabled
      if (this.enableCaching) {
        this.cache.set(cacheKey, enhancementData);
      }

      return enhancementData;

    } catch (error) {
      logger.systemError(error instanceof Error ? error : new Error(String(error)), 'WorkspaceSchemaProvider fetchEnhancementData');
      
      // Return minimal fallback data with global workspace
      const fallbackData = {
        workspaceIds: [GLOBAL_WORKSPACE_ID],
        workspaces: [{
          id: GLOBAL_WORKSPACE_ID,
          name: 'Global Workspace',
          description: 'Default workspace for general work'
        }],
        stats: {
          totalCount: 1
        }
      };

      // Cache fallback data too
      if (this.enableCaching) {
        this.cache.set(cacheKey, fallbackData);
      }

      return fallbackData;
    }
  }

  /**
   * Apply workspace enhancement to schema
   * @param originalSchema Original schema
   * @param enhancementData Workspace enhancement data
   * @returns Enhanced schema
   */
  private applyEnhancement(originalSchema: any, enhancementData: WorkspaceEnhancementData): any {
    // Deep clone the original schema
    const enhancedSchema = JSON.parse(JSON.stringify(originalSchema));

    // Ensure properties exist
    if (!enhancedSchema.properties) {
      enhancedSchema.properties = {};
    }

    // Check which modes are available in this schema and enhance them
    const schemaModes = enhancedSchema.properties?.mode?.enum as string[] || [];
    
    // Enhance loadWorkspace mode if it exists
    if (schemaModes.includes('loadWorkspace') && this.targetModes.includes('loadWorkspace')) {
      this.enhanceLoadWorkspaceSchema(enhancedSchema, enhancementData);
    }

    // Enhance listWorkspaces mode if it exists
    if (schemaModes.includes('listWorkspaces') && this.targetModes.includes('listWorkspaces')) {
      this.enhanceListWorkspacesSchema(enhancedSchema, enhancementData);
    }

    return enhancedSchema;
  }

  /**
   * Enhance loadWorkspace mode schema with workspace options
   * @param schema Schema to enhance
   * @param data Enhancement data
   */
  private enhanceLoadWorkspaceSchema(schema: any, data: WorkspaceEnhancementData): void {
    if (!schema.properties.id) {
      return; // Skip if 'id' parameter doesn't exist
    }

    // Add enum with available workspace IDs
    schema.properties.id.enum = data.workspaceIds;

    // Enhance description with available workspaces
    const workspaceList = data.workspaces
      .map(ws => `"${ws.id}": ${ws.name}${ws.description ? ` - ${ws.description}` : ''}`)
      .join(', ');

    schema.properties.id.description = 
      `Workspace ID to load (REQUIRED). Available workspaces (${data.stats.totalCount} total): ${workspaceList}`;

    // Add workspace count information to schema description
    if (!schema.description) {
      schema.description = 'Load a workspace by ID and restore context and state';
    }
    
    schema.description += ` | ${data.stats.totalCount} workspaces available`;

    logger.systemLog(`Enhanced loadWorkspace schema with ${data.workspaceIds.length} workspace options`, 'WorkspaceSchemaProvider');
  }

  /**
   * Enhance listWorkspaces mode schema with workspace statistics
   * @param schema Schema to enhance
   * @param data Enhancement data
   */
  private enhanceListWorkspacesSchema(schema: any, data: WorkspaceEnhancementData): void {
    // Enhance schema description with current workspace counts
    if (!schema.description) {
      schema.description = 'List available workspaces with filters and sorting';
    }

    schema.description += ` | Current workspace inventory: ${data.stats.totalCount} total`;

    logger.systemLog(`Enhanced listWorkspaces schema with workspace statistics`, 'WorkspaceSchemaProvider');
  }

  /**
   * Create a pre-configured instance for MemoryManager workspace modes
   * @param workspaceService WorkspaceService instance
   * @returns Configured WorkspaceSchemaProvider
   */
  static forMemoryManager(workspaceService: WorkspaceService): WorkspaceSchemaProvider {
    return new WorkspaceSchemaProvider(
      workspaceService,
      ['loadWorkspace', 'listWorkspaces'],
      true
    );
  }

  /**
   * Create a provider for specific workspace modes
   * @param workspaceService WorkspaceService instance
   * @param targetModes Specific modes to target
   * @returns Configured WorkspaceSchemaProvider
   */
  static forModes(workspaceService: WorkspaceService, targetModes: string[]): WorkspaceSchemaProvider {
    return new WorkspaceSchemaProvider(workspaceService, targetModes, true);
  }

  /**
   * Clear the cache (useful for testing or when workspace data changes)
   */
  public clearCache(): void {
    this.cache.clear();
  }

  /**
   * Get the current cache size
   * @returns Number of cached entries
   */
  public getCacheSize(): number {
    return this.cache.size;
  }
}
```

## handlers/services/ResourceListService.ts

```typescript
import { App } from 'obsidian';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IResourceListService } from '../interfaces/IRequestHandlerServices';
import { logger } from '../../utils/logger';

/**
 * Resource interface for MCP resource listing
 */
interface Resource {
    uri: string;
    name: string;
    mimeType: string;
}

/**
 * Service for listing vault resources
 * Applies Single Responsibility Principle by focusing solely on resource enumeration
 */
export class ResourceListService implements IResourceListService {
    constructor(private app: App) {}

    /**
     * Get all vault resources as MCP resources
     * @returns Promise resolving to array of resources
     */
    async listResources(): Promise<{ resources: Resource[] }> {
        try {
            
            const resources: Resource[] = [];
            const files = this.app.vault.getMarkdownFiles();
            
            for (const file of files) {
                resources.push({
                    uri: `obsidian://${file.path}`,
                    name: file.basename,
                    mimeType: "text/markdown"
                });
            }
            
            return { resources };
        } catch (error) {
            logger.systemError(error as Error, 'ResourceListService');
            throw new McpError(ErrorCode.InternalError, 'Failed to list resources', error);
        }
    }

    /**
     * Get resources filtered by path prefix (future enhancement)
     * @param pathPrefix Optional path prefix to filter resources
     * @returns Promise resolving to filtered resources
     */
    async listResourcesByPath(pathPrefix?: string): Promise<{ resources: Resource[] }> {
        try {
            const allResources = await this.listResources();
            
            if (!pathPrefix) {
                return allResources;
            }
            
            const filteredResources = allResources.resources.filter(resource => 
                resource.uri.includes(pathPrefix)
            );
            
            return { resources: filteredResources };
        } catch (error) {
            logger.systemError(error as Error, 'ResourceListService');
            throw new McpError(ErrorCode.InternalError, 'Failed to list resources by path', error);
        }
    }
}
```

## handlers/services/ResourceReadService.ts

```typescript
import { App, TFile } from 'obsidian';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IResourceReadService } from '../interfaces/IRequestHandlerServices';
import { logger } from '../../utils/logger';

/**
 * Resource content interface for MCP resource reading
 */
interface ResourceContent {
    uri: string;
    text: string;
    mimeType: string;
}

/**
 * Service for reading vault resource content
 * Applies Single Responsibility Principle by focusing solely on resource content retrieval
 */
export class ResourceReadService implements IResourceReadService {
    constructor(private app: App) {}

    /**
     * Read resource content by URI
     * @param uri Resource URI to read
     * @returns Promise resolving to resource content
     */
    async readResource(uri: string): Promise<{ contents: ResourceContent[] }> {
        try {
            logger.systemLog(`ResourceReadService: Reading resource ${uri}`);
            
            const content = await this.getResourceContent(uri);
            
            return {
                contents: [{
                    uri,
                    text: content,
                    mimeType: "text/markdown"
                }]
            };
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'ResourceReadService');
            throw new McpError(ErrorCode.InternalError, 'Failed to read resource', error);
        }
    }

    /**
     * Read multiple resources by URIs (future enhancement)
     * @param uris Array of resource URIs to read
     * @returns Promise resolving to array of resource contents
     */
    async readMultipleResources(uris: string[]): Promise<{ contents: ResourceContent[] }> {
        try {
            logger.systemLog(`ResourceReadService: Reading ${uris.length} resources`);
            
            const contents: ResourceContent[] = [];
            
            for (const uri of uris) {
                try {
                    const content = await this.getResourceContent(uri);
                    contents.push({
                        uri,
                        text: content,
                        mimeType: "text/markdown"
                    });
                } catch (error) {
                    logger.systemWarn(`ResourceReadService: Failed to read resource ${uri}`);
                    // Continue with other resources, but log the failure
                }
            }
            
            return { contents };
        } catch (error) {
            logger.systemError(error as Error, 'ResourceReadService');
            throw new McpError(ErrorCode.InternalError, 'Failed to read multiple resources', error);
        }
    }

    /**
     * Get resource content from vault file
     * @param uri Resource URI
     * @returns Promise resolving to file content
     * @private
     */
    private async getResourceContent(uri: string): Promise<string> {
        // Parse obsidian:// URI to get file path
        const path = this.parseResourceUri(uri);
        
        // Get file from vault
        const file = this.app.vault.getAbstractFileByPath(path);
        
        if (!(file instanceof TFile)) {
            throw new McpError(ErrorCode.InvalidParams, `Resource not found: ${uri}`);
        }
        
        // Read file content
        return await this.app.vault.read(file);
    }


    /**
     * Parse resource URI to extract file path
     * @param uri Resource URI (e.g., "obsidian://path/to/file.md")
     * @returns File path
     * @private
     */
    private parseResourceUri(uri: string): string {
        if (!uri.startsWith('obsidian://')) {
            throw new McpError(ErrorCode.InvalidParams, `Invalid resource URI format: ${uri}`);
        }
        
        return uri.replace('obsidian://', '');
    }

    /**
     * Check if resource exists in vault
     * @param uri Resource URI
     * @returns Promise resolving to boolean
     */
    async resourceExists(uri: string): Promise<boolean> {
        try {
            const path = this.parseResourceUri(uri);
            const file = this.app.vault.getAbstractFileByPath(path);
            return file instanceof TFile;
        } catch (error) {
            logger.systemWarn(`ResourceReadService: Resource existence check failed for ${uri}`);
            return false;
        }
    }
}
```

## handlers/services/ResponseFormatter.ts

```typescript
import { IResponseFormatter } from '../interfaces/IRequestHandlerServices';
import { safeStringify } from '../../utils/jsonUtils';

export class ResponseFormatter implements IResponseFormatter {

    formatToolExecutionResponse(result: any, sessionInfo?: any, _context?: { tool?: string }): any {
        // Check if result contains an error and format it appropriately
        if (result && !result.success && result.error) {
            return this.formatDetailedError(result, sessionInfo);
        }

        // Only show session ID message when Claude's ID was REPLACED (non-standard format)
        // If Claude provided a valid format ID, no need to announce - just use it silently
        if (sessionInfo && sessionInfo.isNonStandardId) {
            return this.formatWithSessionInstructions(result, sessionInfo);
        }

        return {
            content: [{
                type: "text",
                text: safeStringify(result)
            }]
        };
    }

    formatSessionInstructions(sessionId: string, result: any): any {
        result.sessionId = sessionId;
        return result;
    }

    formatErrorResponse(error: Error): any {
        return {
            content: [{
                type: "text",
                text: `Error: ${error.message}`
            }]
        };
    }

    /**
     * Format detailed error with helpful context
     * Shows the actual error message and any additional context that can help the AI fix the issue
     */
    private formatDetailedError(result: any, sessionInfo?: any): any {
        let errorText = "";
        
        // Compact session ID notice when replaced
        if (sessionInfo?.isNonStandardId && sessionInfo.originalSessionId) {
            errorText += `[Session ID changed: Use "${sessionInfo.sessionId}" for all future requests]\n\n`;
        }
        
        errorText += `âŒ Error: ${result.error}\n\n`;
        
        // Add parameter-specific hints if available
        if (result.parameterHints) {
            errorText += `ðŸ’¡ Parameter Help:\n${result.parameterHints}\n\n`;
        }
        
        // Add what was provided vs what was expected
        if (result.providedParams) {
            errorText += `ðŸ“‹ Provided Parameters:\n${safeStringify(result.providedParams)}\n\n`;
        }
        
        if (result.expectedParams) {
            errorText += `âœ… Expected Parameters:\n${safeStringify(result.expectedParams)}\n\n`;
        }
        
        // Add suggestions for common mistakes
        if (result.suggestions) {
            errorText += `ðŸ’­ Suggestions:\n`;
            for (const suggestion of result.suggestions) {
                errorText += `  â€¢ ${suggestion}\n`;
            }
            errorText += '\n';
        }
        
        // Include the full result object for debugging
        errorText += `ðŸ” Full Error Details:\n${safeStringify(result)}`;
        
        return {
            content: [{
                type: "text",
                text: errorText
            }]
        };
    }

    private formatWithSessionInstructions(result: any, sessionInfo: any): any {
        this.formatSessionInstructions(sessionInfo.sessionId, result);

        let responseText = "";

        // Compact session ID notice when replaced
        if (sessionInfo.originalSessionId) {
            responseText += `[Session ID changed: Use "${sessionInfo.sessionId}" for all future requests]\n\n`;
        }

        responseText += safeStringify(result);

        return {
            content: [{
                type: "text",
                text: responseText
            }]
        };
    }
}
```

## handlers/services/SchemaEnhancementService.ts

```typescript
/**
 * Location: src/handlers/services/SchemaEnhancementService.ts
 * 
 * Central service for enhancing tool schemas with additional properties,
 * validation rules, and improvements through registered schema providers.
 * Used by ToolListService to enhance schemas before returning to clients.
 */

import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { ISchemaEnhancementService } from '../interfaces/IRequestHandlerServices';
import { ISchemaProvider } from '../interfaces/ISchemaProvider';
import { logger } from '../../utils/logger';
import { getErrorMessage } from '../../utils/errorUtils';

export class SchemaEnhancementService implements ISchemaEnhancementService {
    private providers: ISchemaProvider[] = [];

    /**
     * Register a schema enhancement provider
     */
    registerProvider(provider: ISchemaProvider): void {
        try {
            // Check if provider is already registered
            if (this.providers.some(p => p.name === provider.name)) {
                logger.systemLog(`Schema provider ${provider.name} already registered, skipping`);
                return;
            }

            this.providers.push(provider);
            
            // Sort providers by priority (highest first)
            this.providers.sort((a, b) => b.getPriority() - a.getPriority());
            
            logger.systemLog(`Registered schema provider: ${provider.name} (priority: ${provider.getPriority()})`);
        } catch (error) {
            logger.systemError(error as Error, `Error registering schema provider: ${provider.name}`);
        }
    }

    /**
     * Unregister a schema enhancement provider
     */
    unregisterProvider(providerName: string): boolean {
        try {
            const initialLength = this.providers.length;
            this.providers = this.providers.filter(p => p.name !== providerName);
            
            const wasRemoved = this.providers.length < initialLength;
            if (wasRemoved) {
                logger.systemLog(`Unregistered schema provider: ${providerName}`);
            }
            
            return wasRemoved;
        } catch (error) {
            logger.systemError(error as Error, `Error unregistering schema provider: ${providerName}`);
            return false;
        }
    }

    /**
     * Enhance a tool schema using all applicable registered providers
     */
    async enhanceToolSchema(toolName: string, baseSchema: any): Promise<any> {
        try {
            // Validate input
            if (!toolName || typeof toolName !== 'string') {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    'Tool name must be a non-empty string'
                );
            }

            if (!baseSchema || typeof baseSchema !== 'object') {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    'Base schema must be a valid object'
                );
            }

            // Start with a deep clone of the base schema to avoid mutations
            let enhancedSchema = JSON.parse(JSON.stringify(baseSchema));

            // Track which providers were applied for debugging
            const appliedProviders: string[] = [];

            // Apply each provider that can enhance this tool
            for (const provider of this.providers) {
                try {
                    const canEnhance = await provider.canEnhance(toolName, enhancedSchema);
                    if (canEnhance) {
                        const providerResult = await provider.enhanceSchema(toolName, enhancedSchema);
                        
                        // Validate the provider returned a valid schema
                        if (providerResult && typeof providerResult === 'object') {
                            enhancedSchema = providerResult;
                            appliedProviders.push(provider.name);
                            logger.systemLog(`Applied schema enhancement: ${provider.name} to ${toolName}`);
                        } else {
                            logger.systemError(
                                new Error(`Invalid schema returned from provider: ${provider.name}`),
                                'Schema Enhancement'
                            );
                        }
                    }
                } catch (error) {
                    logger.systemError(
                        error as Error,
                        `Error applying schema provider ${provider.name} to tool ${toolName}: ${getErrorMessage(error)}`
                    );
                    // Continue with other providers instead of failing completely
                }
            }

            // Log enhancement summary
            if (appliedProviders.length > 0) {
                logger.systemLog(`Enhanced schema for ${toolName} with providers: ${appliedProviders.join(', ')}`);
            }

            return enhancedSchema;

        } catch (error) {
            logger.systemError(error as Error, `Error enhancing schema for tool ${toolName}`);
            
            // Return original schema on error to avoid breaking tool functionality
            if (error instanceof McpError) {
                throw error;
            } else {
                throw new McpError(
                    ErrorCode.InternalError,
                    `Failed to enhance schema for tool ${toolName}`,
                    error
                );
            }
        }
    }

    /**
     * Get list of available enhancement provider names
     */
    async getAvailableEnhancements(): Promise<string[]> {
        try {
            return this.providers.map(provider => provider.name);
        } catch (error) {
            logger.systemError(error as Error, 'Error getting available enhancements');
            return [];
        }
    }

    /**
     * Get detailed information about registered providers
     */
    getProviderInfo(): Array<{ name: string; description: string; priority: number }> {
        try {
            return this.providers.map(provider => ({
                name: provider.name,
                description: provider.description,
                priority: provider.getPriority()
            }));
        } catch (error) {
            logger.systemError(error as Error, 'Error getting provider info');
            return [];
        }
    }

    /**
     * Check if a specific provider is registered
     */
    hasProvider(providerName: string): boolean {
        return this.providers.some(p => p.name === providerName);
    }

    /**
     * Clear all registered providers (mainly for testing)
     */
    clearProviders(): void {
        const count = this.providers.length;
        this.providers = [];
        logger.systemLog(`Cleared ${count} schema enhancement providers`);
    }
}
```

## handlers/services/SessionService.ts

```typescript
import { ISessionService } from '../interfaces/IRequestHandlerServices';
import { SessionContextManager } from '../../services/SessionContextManager';
import { 
    generateSessionId, 
    isStandardSessionId 
} from '../../utils/sessionUtils';
import { logger } from '../../utils/logger';

export class SessionService implements ISessionService {
    async processSessionId(sessionId: string | undefined): Promise<{
        sessionId: string;
        isNewSession: boolean;
        isNonStandardId: boolean;
        originalSessionId?: string;
    }> {
        if (!sessionId) {
            const newSessionId = this.generateSessionId();
            logger.systemLog(`Created new session with standardized ID: ${newSessionId}`);
            
            return {
                sessionId: newSessionId,
                isNewSession: true,
                isNonStandardId: false
            };
        }
        
        if (!this.isStandardSessionId(sessionId)) {
            const standardizedId = this.generateSessionId();
            logger.systemLog(`Replaced non-standard session ID: ${sessionId} with standardized ID: ${standardizedId}`);
            
            return {
                sessionId: standardizedId,
                isNewSession: false,
                isNonStandardId: true,
                originalSessionId: sessionId
            };
        }
        
        return {
            sessionId,
            isNewSession: false,
            isNonStandardId: false
        };
    }

    generateSessionId(): string {
        return generateSessionId();
    }

    isStandardSessionId(sessionId: string): boolean {
        return isStandardSessionId(sessionId);
    }

    shouldInjectInstructions(
        sessionId: string, 
        sessionContextManager?: SessionContextManager
    ): boolean {
        return sessionContextManager ? 
            !sessionContextManager.hasReceivedInstructions(sessionId) : 
            false;
    }
}
```

## handlers/services/ToolExecutionService.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IToolExecutionService } from '../interfaces/IRequestHandlerServices';
import { IAgent } from '../../agents/interfaces/IAgent';
import { logger } from '../../utils/logger';
import { getErrorMessage } from '../../utils/errorUtils';

export class ToolExecutionService implements IToolExecutionService {
    async executeAgent(
        agent: IAgent,
        tool: string,
        params: Record<string, unknown>
    ): Promise<unknown> {
        try {
            this.validateToolSpecificParams(agent.name, tool, params);
            return await agent.executeTool(tool, params);
        } catch (error) {
            logger.systemError(error as Error, `Tool Execution - ${agent.name}:${tool}`);
            throw error;
        }
    }

    private validateToolSpecificParams(agentName: string, tool: string, params: Record<string, unknown>): void {
        switch (agentName) {
            case 'memoryManager':
                this.validateMemoryManagerParams(tool, params);
                break;
            case 'storageManager':
                this.validateStorageManagerParams(tool, params);
                break;
            case 'contentManager':
                this.validateContentManagerParams(tool, params);
                break;
        }
    }

    private validateMemoryManagerParams(tool: string, params: Record<string, unknown>): void {
        if (tool === 'createState' && !params.name) {
            throw new McpError(
                ErrorCode.InvalidParams,
                'Missing required parameter: name for createState tool'
            );
        }
    }

    private validateStorageManagerParams(tool: string, params: Record<string, unknown>): void {
        if (['list', 'createFolder'].includes(tool) &&
            params.path === undefined) {
            throw new McpError(
                ErrorCode.InvalidParams,
                `Missing required parameter: path for ${tool} tool`
            );
        }
    }

    private validateContentManagerParams(tool: string, params: Record<string, unknown>): void {
        if (tool === 'createContent') {
            if (!params.filePath) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    'Missing required parameter: filePath for createContent tool'
                );
            }
            if (params.content === undefined || params.content === null) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    'Missing required parameter: content for createContent tool'
                );
            }
        }
    }
}
```

## handlers/services/ToolHelpService.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IToolHelpService } from '../interfaces/IRequestHandlerServices';
import { IAgent } from '../../agents/interfaces/IAgent';
import { logger } from '../../utils/logger';
import {
    generateToolHelp,
    formatToolHelp
} from '../../utils/parameterHintUtils';

/**
 * Help content interface for MCP tool help
 */
interface HelpContent {
    type: string;
    text: string;
}

/**
 * Service for generating tool help content
 * Applies Single Responsibility Principle by focusing solely on help generation
 */
export class ToolHelpService implements IToolHelpService {
    constructor() {}

    /**
     * Generate help content for a specific agent mode
     * @param getAgent Function to retrieve agent by name
     * @param toolName Full tool name (may include vault suffix)
     * @param mode Mode name to get help for
     * @returns Promise resolving to help content
     */
    async generateToolHelp(
        getAgent: (name: string) => IAgent,
        toolName: string,
        mode: string
    ): Promise<{ content: HelpContent[] }> {
        try {
            logger.systemLog(`ToolHelpService: Generating help for tool ${toolName}, mode ${mode}`);
            
            // Extract agent name from tool name (removes vault suffix if present)
            const agentName = this.extractAgentName(toolName);
            
            // Validate mode parameter
            if (!mode) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    `Missing required parameter: mode for help on agent ${agentName}`
                );
            }
            
            // Get the agent
            const agent = getAgent(agentName);
            if (!agent) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    `Agent ${agentName} not found`
                );
            }
            
            // Get the tool instance
            const toolInstance = agent.getTool(mode);
            if (!toolInstance) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    `Tool ${mode} not found in agent ${agentName}`
                );
            }

            // Get the tool's parameter schema
            const schema = toolInstance.getParameterSchema();

            // Generate help content
            const help = generateToolHelp(
                mode,
                toolInstance.description,
                schema
            );

            // Format the help text
            const helpText = formatToolHelp(help);
            
            logger.systemLog(`ToolHelpService: Generated help for ${agentName}_${mode}`);
            
            return {
                content: [{
                    type: "text",
                    text: helpText
                }]
            };
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'ToolHelpService');
            throw new McpError(ErrorCode.InternalError, 'Failed to get tool help', error);
        }
    }

    /**
     * Generate help for all modes of an agent (future enhancement)
     * @param getAgent Function to retrieve agent by name
     * @param toolName Full tool name
     * @returns Promise resolving to comprehensive help content
     */
    async generateAgentHelp(
        getAgent: (name: string) => IAgent,
        toolName: string
    ): Promise<{ content: HelpContent[] }> {
        try {
            const agentName = this.extractAgentName(toolName);
            const agent = getAgent(agentName);
            
            if (!agent) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    `Agent ${agentName} not found`
                );
            }
            
            const tools = agent.getTools().map(tool => tool.slug);
            const helpContent: HelpContent[] = [];

            // Add agent overview
            helpContent.push({
                type: "text",
                text: `# ${agentName} Agent\n\n${agent.description}\n\n## Available Tools:\n`
            });

            // Add help for each tool
            for (const toolSlug of tools) {
                try {
                    const toolHelpContent = await this.generateToolHelp(getAgent, toolName, toolSlug);
                    helpContent.push(...toolHelpContent.content);
                    helpContent.push({
                        type: "text",
                        text: "\n---\n"
                    });
                } catch (error) {
                    logger.systemWarn(`ToolHelpService: Failed to generate help for tool ${toolSlug}`);
                }
            }
            
            return { content: helpContent };
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'ToolHelpService');
            throw new McpError(ErrorCode.InternalError, 'Failed to get agent help', error);
        }
    }

    /**
     * Extract the agent name from a tool name that may have a vault name suffix
     * @param toolName Tool name (e.g., "contentManager_vaultName" or "contentManager")
     * @returns Agent name without vault suffix
     * @private
     */
    private extractAgentName(toolName: string): string {
        const lastUnderscoreIndex = toolName.lastIndexOf('_');
        
        if (lastUnderscoreIndex === -1) {
            // No underscore found, return the tool name as-is
            return toolName;
        }
        
        // Extract everything before the last underscore as the agent name
        return toolName.substring(0, lastUnderscoreIndex);
    }

    /**
     * Validate if tool exists for agent (utility method)
     * @param getAgent Function to retrieve agent by name
     * @param toolName Full tool name
     * @param toolSlug Tool slug to validate
     * @returns Promise resolving to boolean
     */
    async validateToolExists(
        getAgent: (name: string) => IAgent,
        toolName: string,
        toolSlug: string
    ): Promise<boolean> {
        try {
            const agentName = this.extractAgentName(toolName);
            const agent = getAgent(agentName);

            if (!agent) {
                return false;
            }

            const toolInstance = agent.getTool(toolSlug);
            return toolInstance !== undefined;
        } catch (error) {
            logger.systemWarn(`ToolHelpService: Tool validation failed for ${toolName}.${toolSlug}`);
            return false;
        }
    }

    /**
     * @deprecated Use validateToolExists instead
     */
    async validateModeExists(
        getAgent: (name: string) => IAgent,
        toolName: string,
        mode: string
    ): Promise<boolean> {
        return this.validateToolExists(getAgent, toolName, mode);
    }
}
```

## handlers/services/ToolListService.ts

```typescript
import { NexusError, NexusErrorCode } from '../../utils/errors';
import { IToolListService, ISchemaEnhancementService } from '../interfaces/IRequestHandlerServices';
import { IAgent } from '../../agents/interfaces/IAgent';
import { logger } from '../../utils/logger';

interface AgentSchema {
    type: string;
    properties: {
        tool: {
            type: string;
            enum: string[];
            description: string;
        };
        [key: string]: unknown;
    };
    required: string[];
    allOf: unknown[];
}

export class ToolListService implements IToolListService {
    private schemaEnhancementService?: ISchemaEnhancementService;
    async generateToolList(
        agents: Map<string, IAgent>,
        isVaultEnabled: boolean,
        vaultName?: string
    ): Promise<{ tools: any[] }> {
        try {
            if (!isVaultEnabled) {
                return { tools: [] };
            }
            
            const tools: any[] = [];
            
            for (const agent of agents.values()) {
                const agentSchema = this.buildAgentSchema(agent);
                this.mergeToolSchemasIntoAgent(agent, agentSchema);

                // Use agent name directly - vault context is already provided by IPC connection
                // No need to add vault suffix which causes parsing issues with vault names containing underscores
                const toolName = agent.name;
                
                // Enhance the schema and description if enhancement service is available
                let finalSchema = agentSchema;
                let finalDescription = agent.description;
                
                if (this.schemaEnhancementService) {
                    try {
                        // Cast to our enhanced interface if available
                        const enhancedService = this.schemaEnhancementService as ISchemaEnhancementService & { enhanceAgentDescription?: (agent: IAgent, vaultName?: string) => Promise<string> };

                        // Enhance schema with agent context
                        finalSchema = await this.schemaEnhancementService.enhanceToolSchema(
                            toolName,
                            agentSchema
                        );

                        // Enhance description if the service supports it
                        if (enhancedService.enhanceAgentDescription) {
                            finalDescription = await enhancedService.enhanceAgentDescription(agent, vaultName);
                        }
                    } catch (error) {
                        logger.systemError(error as Error, `Error enhancing schema for ${toolName}`);
                        // Use original schema and description on enhancement failure
                        finalSchema = agentSchema;
                        finalDescription = agent.description;
                    }
                }
                
                // Clean up the schema - remove empty allOf arrays
                // Claude API doesn't support allOf/oneOf/anyOf at top level
                const cleanedSchema = this.cleanSchema(finalSchema);

                tools.push({
                    name: toolName,
                    description: finalDescription,
                    inputSchema: cleanedSchema
                });
            }

            return { tools };
        } catch (error) {
            logger.systemError(error as Error, "Error in generateToolList");
            throw new NexusError(NexusErrorCode.InternalError, 'Failed to list tools', error);
        }
    }

    buildAgentSchema(agent: IAgent): AgentSchema {
        return {
            type: 'object',
            properties: {
                tool: {
                    type: 'string',
                    enum: [] as string[],
                    description: 'The tool to execute on this agent'
                },
                sessionId: {
                    type: 'string',
                    description: 'Session identifier to track related tool calls'
                }
            },
            required: ['tool', 'sessionId'],
            allOf: []
        };
    }

    mergeToolSchemasIntoAgent(agent: IAgent, agentSchema: AgentSchema): AgentSchema {
        const agentTools = agent.getTools();

        for (const tool of agentTools) {
            agentSchema.properties.tool.enum.push(tool.slug);

            try {
                const toolSchema = tool.getParameterSchema();

                if (toolSchema && typeof toolSchema === 'object') {
                    const toolSchemaCopy = JSON.parse(JSON.stringify(toolSchema)) as Record<string, unknown>;

                    if (toolSchemaCopy.properties && typeof toolSchemaCopy.properties === 'object') {
                        const props = toolSchemaCopy.properties as Record<string, unknown>;
                        if (props.tool) {
                            delete props.tool;
                        }
                    }

                    if (toolSchemaCopy.required && Array.isArray(toolSchemaCopy.required) && toolSchemaCopy.required.length > 0) {
                        const conditionalRequired = (toolSchemaCopy.required as string[]).filter(
                            (prop: string) => prop !== 'tool' && prop !== 'sessionId'
                        );

                        if (conditionalRequired.length > 0) {
                            agentSchema.allOf.push({
                                if: {
                                    properties: {
                                        tool: { enum: [tool.slug] }
                                    }
                                },
                                then: {
                                    required: conditionalRequired
                                }
                            });
                        }
                    }

                    if (toolSchemaCopy.properties && typeof toolSchemaCopy.properties === 'object') {
                        const props = toolSchemaCopy.properties as Record<string, unknown>;
                        for (const [propName, propSchema] of Object.entries(props)) {
                            if (propName !== 'tool' && propName !== 'sessionId') {
                                agentSchema.properties[propName] = propSchema;
                            }
                        }
                    }

                    ['allOf', 'anyOf', 'oneOf', 'not'].forEach(validationType => {
                        if (toolSchemaCopy[validationType]) {
                            agentSchema.allOf.push({
                                if: {
                                    properties: {
                                        tool: { enum: [tool.slug] }
                                    }
                                },
                                then: {
                                    [validationType]: toolSchemaCopy[validationType]
                                }
                            });
                        }
                    });
                }
            } catch (error) {
                logger.systemError(error as Error, `Error processing schema for tool ${tool.slug}`);
            }
        }

        return agentSchema;
    }

    /**
     * @deprecated Use mergeToolSchemasIntoAgent instead
     */
    mergeModeSchemasIntoAgent(agent: IAgent, agentSchema: AgentSchema): AgentSchema {
        return this.mergeToolSchemasIntoAgent(agent, agentSchema);
    }

    setSchemaEnhancementService(service: ISchemaEnhancementService): void {
        this.schemaEnhancementService = service;
    }

    /**
     * Clean schema to be compatible with Claude's API
     * Remove allOf/oneOf/anyOf at top level if empty or move conditionals to description
     */
    private cleanSchema(schema: any): any {
        const cleaned = { ...schema };

        // Remove allOf if it's empty
        if (cleaned.allOf && Array.isArray(cleaned.allOf) && cleaned.allOf.length === 0) {
            delete cleaned.allOf;
        }

        // If allOf has items, we need to flatten them or remove them
        // Claude API doesn't support conditional schemas at top level
        if (cleaned.allOf && Array.isArray(cleaned.allOf) && cleaned.allOf.length > 0) {
            // For now, just remove allOf - tool-specific validation will happen server-side
            // We keep all properties merged, just remove the conditional required fields
            delete cleaned.allOf;
        }

        return cleaned;
    }
}
```

## handlers/services/ValidationService.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IValidationService } from '../interfaces/IRequestHandlerServices';
import { validateParams, formatValidationErrors, ValidationError } from '../../utils/validationUtils';
import { generateHintsForErrors } from '../../utils/parameterHintUtils';
import { getErrorMessage } from '../../utils/errorUtils';
import { logger } from '../../utils/logger';
import { smartNormalizePath, normalizePath, OperationType } from '../../utils/pathUtils';

export class ValidationService implements IValidationService {
    async validateToolParams(params: any, schema?: any, toolName?: string): Promise<any> {
        const enhancedParams = { ...params };
        
        // Apply smart path normalization to common path parameters before validation
        this.normalizePathParameters(enhancedParams, toolName);
        
        if (schema) {
            await this.validateAgainstSchema(enhancedParams, schema);
        }
        
        if (enhancedParams.operations && Array.isArray(enhancedParams.operations)) {
            await this.validateBatchOperations(enhancedParams.operations);
        }
        
        if (enhancedParams.paths) {
            await this.validateBatchPaths(enhancedParams.paths);
        }
        
        return enhancedParams;
    }

    async validateSessionId(sessionId: string): Promise<string> {
        if (!sessionId || typeof sessionId !== 'string') {
            throw new McpError(
                ErrorCode.InvalidParams,
                'Session ID must be a non-empty string'
            );
        }
        return sessionId;
    }

    /**
     * Apply appropriate path normalization based on operation type
     */
    private normalizePathParameters(params: any, toolName?: string): void {
        const operationType = this.getOperationType(toolName);
        
        // Common path parameter names used across modes
        const pathParameterNames = [
            'path',           
            'filePath',       
            'sourcePath',     
            'targetPath',     
            'newPath',        
            'oldPath'         
        ];

        // Normalize individual path parameters
        for (const paramName of pathParameterNames) {
            if (params[paramName] && typeof params[paramName] === 'string') {
                if (operationType === 'DIRECTORY') {
                    // Directory operations: only basic normalization
                    params[paramName] = normalizePath(params[paramName]);
                } else {
                    // Note operations: smart normalization with .md extension
                    params[paramName] = smartNormalizePath(params[paramName], false, operationType);
                }
            }
        }

        // Handle array of paths (like in batch operations)
        if (params.paths && Array.isArray(params.paths)) {
            params.paths = params.paths.map((path: any) => {
                if (typeof path === 'string') {
                    return operationType === 'DIRECTORY' 
                        ? normalizePath(path) 
                        : smartNormalizePath(path, false, operationType);
                }
                return path;
            });
        }

        // Handle file paths in operations arrays (batch operations)
        // These typically need NOTE operation type for .md extension handling
        if (params.operations && Array.isArray(params.operations)) {
            params.operations.forEach((operation: any) => {
                if (operation && operation.params) {
                    // For batch operations, we need to check the operation type
                    const operationType = operation.type || '';
                    this.normalizePathParameters(operation.params, operationType);
                }
            });
        }

        // Handle contextFiles arrays in agent operations (these are typically file paths)
        if (params.contextFiles && Array.isArray(params.contextFiles)) {
            params.contextFiles = params.contextFiles.map((path: any) => 
                typeof path === 'string' ? smartNormalizePath(path, false, 'NOTE') : path
            );
        }

        // Handle filepaths arrays (used in some prompt execution modes - these are typically file paths)
        if (params.filepaths && Array.isArray(params.filepaths)) {
            params.filepaths = params.filepaths.map((path: any) => 
                typeof path === 'string' ? smartNormalizePath(path, false, 'NOTE') : path
            );
        }
    }

    /**
     * Determine operation type based on tool name
     */
    private getOperationType(toolName?: string): OperationType {
        if (!toolName) return 'GENERIC';

        // Directory operations - never need .md extension
        const directoryOperations = [
            'list', 'createFolder', 'archive', 'move', 'copy'
        ];

        // Note operations - need .md extension when no extension present
        const noteOperations = [
            'open', 'readContent', 'createContent', 'appendContent',
            'prependContent', 'replaceContent', 'deleteContent'
        ];

        if (directoryOperations.some(op => toolName.includes(op) || toolName.endsWith(op))) {
            return 'DIRECTORY';
        }

        if (noteOperations.some(op => toolName.includes(op) || toolName.endsWith(op))) {
            return 'NOTE';
        }

        return 'GENERIC';
    }

    async validateBatchOperations(operations: any[]): Promise<void> {
        const batchErrors: ValidationError[] = [];
        
        operations.forEach((operation: any, index: number) => {
            if (!operation || typeof operation !== 'object') {
                batchErrors.push({
                    path: ['operations', index.toString()],
                    message: 'Operation must be an object',
                    code: 'TYPE_ERROR',
                    expectedType: 'object',
                    receivedType: typeof operation
                });
                return;
            }
            
            if (!operation.type) {
                batchErrors.push({
                    path: ['operations', index.toString(), 'type'],
                    message: "Missing 'type' property",
                    code: 'MISSING_REQUIRED',
                    hint: "Each operation must have a 'type' property that specifies the operation type"
                });
            }
            
            if (!operation.params) {
                batchErrors.push({
                    path: ['operations', index.toString(), 'params'],
                    message: "Missing 'params' property",
                    code: 'MISSING_REQUIRED',
                    hint: "Each operation must have a 'params' object containing the operation parameters"
                });
            } else if (typeof operation.params !== 'object' || Array.isArray(operation.params)) {
                batchErrors.push({
                    path: ['operations', index.toString(), 'params'],
                    message: "'params' must be an object",
                    code: 'TYPE_ERROR',
                    expectedType: 'object',
                    receivedType: Array.isArray(operation.params) ? 'array' : typeof operation.params
                });
            }
        });
        
        if (batchErrors.length > 0) {
            throw new McpError(
                ErrorCode.InvalidParams,
                formatValidationErrors(batchErrors)
            );
        }
    }

    async validateBatchPaths(paths: any): Promise<void> {
        const pathErrors: ValidationError[] = [];
        
        if (!Array.isArray(paths)) {
            if (typeof paths === 'string' &&
                paths.trim().startsWith('[') &&
                paths.trim().endsWith(']')) {
                try {
                    JSON.parse(paths);
                    return;
                } catch (error) {
                    pathErrors.push({
                        path: ['paths'],
                        message: `Failed to parse 'paths' as JSON array: ${getErrorMessage(error)}`,
                        code: 'PARSE_ERROR',
                        expectedType: 'array',
                        receivedType: 'string',
                        hint: "The 'paths' parameter must be a valid JSON array of strings. Example: [\"file1.md\", \"file2.md\"]"
                    });
                }
            } else {
                pathErrors.push({
                    path: ['paths'],
                    message: `'paths' must be an array, not a ${typeof paths}`,
                    code: 'TYPE_ERROR',
                    expectedType: 'array',
                    receivedType: typeof paths,
                    hint: "The 'paths' parameter must be an array of strings. Example: [\"Projects/file.md\"] or [\"/\"] for root"
                });
            }
        } else {
            paths.forEach((path: any, index: number) => {
                if (typeof path !== 'string') {
                    pathErrors.push({
                        path: ['paths', index.toString()],
                        message: `Path at index ${index} must be a string, not ${typeof path}`,
                        code: 'TYPE_ERROR',
                        expectedType: 'string',
                        receivedType: typeof path,
                        hint: "Each path in the 'paths' array must be a string representing a file or folder path"
                    });
                }
            });
        }
        
        if (pathErrors.length > 0) {
            const errorMessage = formatValidationErrors(pathErrors);
            throw new McpError(
                ErrorCode.InvalidParams,
                `âŒ Path Validation Failed\n\n${errorMessage}\n\nðŸ’¡ Tip: Paths should be an array of strings like ["/"] or ["folder/file.md"]`
            );
        }
    }

    private async validateAgainstSchema(params: any, schema: any): Promise<void> {
        const validationErrors = validateParams(params, schema);
        if (validationErrors.length > 0) {
            logger.systemLog('DEBUG: Validation errors found:', JSON.stringify(validationErrors, null, 2));
            logger.systemLog('DEBUG: Schema used for validation:', JSON.stringify(schema, null, 2));
            logger.systemLog('DEBUG: Params being validated:', JSON.stringify(params, null, 2));
            
            const hints = generateHintsForErrors(validationErrors, schema);
            
            for (const error of validationErrors) {
                if (error.path.length === 1) {
                    const paramName = error.path[0];
                    if (hints[paramName] && !error.hint) {
                        error.hint = hints[paramName];
                    }
                }
            }
            
            if (schema.required && Array.isArray(schema.required) && schema.required.length > 0) {
                const missingRequiredParams = schema.required.filter(
                    (param: string) => !params[param]
                );
                
                if (missingRequiredParams.length > 0) {
                    const missingParamsInfo = missingRequiredParams.map((param: string) => {
                        const paramSchema = schema.properties[param];
                        let info = `- ${param}: ${paramSchema?.description || 'No description'}`;
                        
                        if (paramSchema?.type) {
                            info += ` (type: ${paramSchema.type})`;
                        }
                        
                        if (paramSchema?.examples && paramSchema.examples.length > 0) {
                            const exampleValue = typeof paramSchema.examples[0] === 'string' 
                                ? `"${paramSchema.examples[0]}"`
                                : JSON.stringify(paramSchema.examples[0]);
                            info += `\n  Example: ${exampleValue}`;
                        }
                        
                        return info;
                    }).join('\n\n');
                    
                    const requiredParamsMessage = `\n\nðŸ“‹ Missing Required Parameters:\n${missingParamsInfo}\n\nðŸ’¡ Tip: Check the tool schema to see what parameters are needed.`;
                    
                    throw new McpError(
                        ErrorCode.InvalidParams,
                        `âŒ Validation Failed\n\n` + formatValidationErrors(validationErrors) + requiredParamsMessage
                    );
                }
            }
            
            throw new McpError(
                ErrorCode.InvalidParams,
                `âŒ Validation Failed\n\n` + formatValidationErrors(validationErrors) + `\n\nðŸ’¡ Check parameter types and required fields.`
            );
        }
    }
}

```

## handlers/strategies/IRequestStrategy.ts

```typescript
export interface IRequestStrategy<TRequest = any, TResponse = any> {
    canHandle(request: TRequest): boolean;
    handle(request: TRequest): Promise<TResponse>;
}

export interface IRequestStrategyContext {
    agentName?: string;
    mode?: string;
    requestType?: string;
}
```

## handlers/strategies/PromptsGetStrategy.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IRequestStrategy } from './IRequestStrategy';
import { IRequestHandlerDependencies } from '../interfaces/IRequestHandlerServices';
import { logger } from '../../utils/logger';

interface PromptsGetRequest {
    method: string;
    params?: {
        name: string;
        arguments?: Record<string, any>;
    };
}

interface PromptsGetResponse {
    description?: string;
    messages: Array<{
        role: 'user' | 'assistant';
        content: {
            type: 'text';
            text: string;
        };
    }>;
}

/**
 * Strategy for handling prompts get requests
 * Follows Strategy Pattern for clean request handling
 */
export class PromptsGetStrategy implements IRequestStrategy<PromptsGetRequest, PromptsGetResponse> {
    constructor(
        private dependencies: IRequestHandlerDependencies
    ) {}

    canHandle(request: PromptsGetRequest): boolean {
        return request.method === 'prompts/get';
    }

    async handle(request: PromptsGetRequest): Promise<PromptsGetResponse> {
        try {
            logger.systemLog('PromptsGetStrategy: Handling prompts get request');
            
            const promptName = request.params?.name;
            if (!promptName) {
                throw new McpError(ErrorCode.InvalidParams, 'Prompt name is required');
            }
            
            // Get the prompt content
            const promptContent = await this.dependencies.promptsListService.getPrompt(promptName);
            
            if (!promptContent) {
                throw new McpError(ErrorCode.InvalidParams, `Prompt "${promptName}" not found`);
            }
            
            // Return the prompt as a user message in MCP format
            return {
                messages: [
                    {
                        role: 'user',
                        content: {
                            type: 'text',
                            text: promptContent
                        }
                    }
                ]
            };
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'PromptsGetStrategy');
            throw new McpError(ErrorCode.InternalError, 'Failed to get prompt', error);
        }
    }
}
```

## handlers/strategies/PromptsListStrategy.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IRequestStrategy } from './IRequestStrategy';
import { IRequestHandlerDependencies } from '../interfaces/IRequestHandlerServices';
import { logger } from '../../utils/logger';

interface PromptsListRequest {
    method: string;
    params?: {
        category?: string;
    };
}

interface PromptsListResponse {
    prompts: Array<{
        name: string;
        description?: string;
        arguments?: any[];
    }>;
}

/**
 * Strategy for handling prompts list requests
 * Follows Strategy Pattern for clean request handling
 */
export class PromptsListStrategy implements IRequestStrategy<PromptsListRequest, PromptsListResponse> {
    constructor(
        private dependencies: IRequestHandlerDependencies
    ) {}

    canHandle(request: PromptsListRequest): boolean {
        return request.method === 'prompts/list';
    }

    async handle(request: PromptsListRequest): Promise<PromptsListResponse> {
        try {
            
            const category = request.params?.category;
            
            if (category) {
                return await this.dependencies.promptsListService.listPromptsByCategory(category);
            } else {
                return await this.dependencies.promptsListService.listPrompts();
            }
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'PromptsListStrategy');
            throw new McpError(ErrorCode.InternalError, 'Failed to list prompts', error);
        }
    }
}
```

## handlers/strategies/ResourceListStrategy.ts

```typescript
import { App } from 'obsidian';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IRequestStrategy } from './IRequestStrategy';
import { IRequestHandlerDependencies } from '../interfaces/IRequestHandlerServices';
import { logger } from '../../utils/logger';

interface ResourceListRequest {
    method: string;
    params?: {
        pathPrefix?: string;
    };
}

interface ResourceListResponse {
    resources: Array<{
        uri: string;
        name: string;
        mimeType: string;
    }>;
}

/**
 * Strategy for handling resource list requests
 * Follows Strategy Pattern for clean request handling
 */
export class ResourceListStrategy implements IRequestStrategy<ResourceListRequest, ResourceListResponse> {
    constructor(
        private dependencies: IRequestHandlerDependencies,
        private app: App
    ) {}

    canHandle(request: ResourceListRequest): boolean {
        return request.method === 'resources/list';
    }

    async handle(request: ResourceListRequest): Promise<ResourceListResponse> {
        try {
            
            const pathPrefix = request.params?.pathPrefix;
            
            if (pathPrefix) {
                return await this.dependencies.resourceListService.listResourcesByPath(pathPrefix);
            } else {
                return await this.dependencies.resourceListService.listResources();
            }
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'ResourceListStrategy');
            throw new McpError(ErrorCode.InternalError, 'Failed to list resources', error);
        }
    }
}
```

## handlers/strategies/ResourceReadStrategy.ts

```typescript
import { App } from 'obsidian';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IRequestStrategy } from './IRequestStrategy';
import { IRequestHandlerDependencies } from '../interfaces/IRequestHandlerServices';
import { logger } from '../../utils/logger';

interface ResourceReadRequest {
    method: string;
    params: {
        uri: string;
        uris?: string[];
    };
}

interface ResourceReadResponse {
    contents: Array<{
        uri: string;
        text: string;
        mimeType: string;
    }>;
}

/**
 * Strategy for handling resource read requests
 * Follows Strategy Pattern for clean request handling
 */
export class ResourceReadStrategy implements IRequestStrategy<ResourceReadRequest, ResourceReadResponse> {
    constructor(
        private dependencies: IRequestHandlerDependencies,
        private app: App
    ) {}

    canHandle(request: ResourceReadRequest): boolean {
        return request.method === 'resources/read';
    }

    async handle(request: ResourceReadRequest): Promise<ResourceReadResponse> {
        try {
            logger.systemLog('ResourceReadStrategy: Handling resource read request');
            
            const { uri, uris } = request.params;
            
            // Validate parameters
            if (!uri && (!uris || uris.length === 0)) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    'Either uri or uris parameter is required'
                );
            }
            
            // Handle multiple URIs if provided
            if (uris && uris.length > 0) {
                return await this.dependencies.resourceReadService.readMultipleResources(uris);
            }
            
            // Handle single URI
            if (uri) {
                return await this.dependencies.resourceReadService.readResource(uri);
            }
            
            throw new McpError(
                ErrorCode.InvalidParams,
                'No valid URI provided for resource read'
            );
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'ResourceReadStrategy');
            throw new McpError(ErrorCode.InternalError, 'Failed to read resource', error);
        }
    }
}
```

## handlers/strategies/ToolExecutionStrategy.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IRequestStrategy } from './IRequestStrategy';
import { IRequestHandlerDependencies, IRequestContext } from '../interfaces/IRequestHandlerServices';
import { IAgent } from '../../agents/interfaces/IAgent';
import { SessionContextManager } from '../../services/SessionContextManager';
import { logger } from '../../utils/logger';
import { getErrorMessage } from '../../utils/errorUtils';

interface ToolExecutionRequest {
    params: {
        name: string;
        arguments: any;
    };
}

interface ToolExecutionResponse {
    content: Array<{
        type: string;
        text: string;
    }>;
}

export class ToolExecutionStrategy implements IRequestStrategy<ToolExecutionRequest, ToolExecutionResponse> {
    private readonly instanceId = `TES_V2_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    private readonly buildVersion = 'BUILD_20250803_1755'; // Force new instances
    
    constructor(
        private dependencies: IRequestHandlerDependencies,
        private getAgent: (name: string) => IAgent,
        private sessionContextManager?: SessionContextManager,
        private onToolResponse?: (toolName: string, params: any, response: any, success: boolean, executionTime: number) => Promise<void>
    ) {
        // ToolExecutionStrategy initialized with callback support
    }

    canHandle(request: ToolExecutionRequest): boolean {
        // Handle all tool execution requests
        // We'll validate the tool exists in handle() method
        return !!(request.params && request.params.name && request.params.arguments);
    }

    async handle(request: ToolExecutionRequest): Promise<ToolExecutionResponse> {
        const startTime = Date.now();
        let context: any;
        let success = false;
        let result: any;
        
        try {
            context = await this.buildRequestContext(request);
            const processedParams = await this.processParameters(context);
            result = await this.executeTool(context, processedParams);
            success = true;
            
            // Trigger response capture callback if available
            if (this.onToolResponse) {
                try {
                    const executionTime = Date.now() - startTime;
                    await this.onToolResponse(
                        request.params.name,
                        context.params,
                        result,
                        success,
                        executionTime
                    );
                } catch (captureError) {
                    // Silently ignore capture errors
                }
            }
            
            return this.dependencies.responseFormatter.formatToolExecutionResponse(
                result,
                context.sessionInfo,
                { tool: context.tool }
            );
        } catch (error) {
            // Trigger error response capture callback if available
            if (this.onToolResponse && context) {
                try {
                    const executionTime = Date.now() - startTime;
                    await this.onToolResponse(
                        request.params.name,
                        context.params,
                        { error: (error as Error).message },
                        false,
                        executionTime
                    );
                } catch (captureError) {
                    // Silently ignore capture errors
                }
            }
            
            logger.systemError(error as Error, 'Tool Execution Strategy');
            
            // Build detailed error result object
            const errorMsg = (error as Error).message || 'Unknown error';
            let enhancedMessage = errorMsg;
            let parameterSchema: any = null;
            
            // Add helpful hints for common parameter errors
            if (errorMsg.toLowerCase().includes('parameter') || 
                errorMsg.toLowerCase().includes('required') ||
                errorMsg.toLowerCase().includes('missing')) {
                enhancedMessage += '\n\nðŸ’¡ Parameter Help: Check the tool schema for required parameters and their correct format.';
                
                // Try to get parameter schema for additional context
                if (context && context.agentName && context.tool) {
                    try {
                        const agent = this.getAgent(context.agentName);
                        const toolInstance = agent.getTool(context.tool);
                        if (toolInstance && typeof toolInstance.getParameterSchema === 'function') {
                            parameterSchema = toolInstance.getParameterSchema();
                            if (parameterSchema && parameterSchema.required) {
                                enhancedMessage += `\n\nðŸ“‹ Required Parameters: ${parameterSchema.required.join(', ')}`;
                            }
                        }
                    } catch (schemaError) {
                        // Ignore schema retrieval errors
                    }
                }
            }
            
            // Instead of throwing, return a formatted error response
            // This allows Claude Desktop to see the actual error message
            const errorResult = {
                success: false,
                error: enhancedMessage,
                providedParams: context?.params,
                expectedParams: parameterSchema?.required,
                suggestions: [
                    'Double-check all required parameters are provided',
                    'Ensure parameter names match the schema exactly',
                    'Check that parameter values are the correct type (string, array, object, etc.)'
                ]
            };
            
            return this.dependencies.responseFormatter.formatToolExecutionResponse(
                errorResult,
                context?.sessionInfo,
                { tool: context?.tool }
            );
        }
    }

    private async buildRequestContext(request: ToolExecutionRequest): Promise<IRequestContext & { sessionInfo: any }> {
        const { name: fullToolName, arguments: parsedArgs } = request.params;

        if (!parsedArgs) {
            throw new McpError(
                ErrorCode.InvalidParams,
                `âŒ Missing arguments for tool ${fullToolName}\n\nðŸ’¡ Provide the required parameters including "tool" to specify the operation.`
            );
        }

        // Two-Tool Architecture: Handle underscore format (toolManager_getTools, toolManager_useTool)
        // MCP requires tool names match ^[a-zA-Z0-9_-]{1,64}$ (no dots allowed)
        let agentName: string;
        let tool: string;
        let params: Record<string, unknown> & {
            context?: { sessionId?: string; workspaceId?: string; [key: string]: unknown };
            sessionId?: string;
            workspaceContext?: { workspaceId?: string; [key: string]: unknown };
        };

        // Check if this is a toolManager tool (toolManager_getTools or toolManager_useTool)
        if (fullToolName.startsWith('toolManager_')) {
            // Two-tool architecture: "toolManager_getTools" â†’ agent="toolManager", tool="getTools"
            agentName = 'toolManager';
            tool = fullToolName.substring('toolManager_'.length);
            params = { ...(parsedArgs as typeof params) };
        } else {
            // Legacy format: "contentManager_readContent" â†’ agent="contentManager", tool from args
            agentName = this.extractAgentName(fullToolName);
            const { tool: toolFromArgs, ...restParams } = parsedArgs as { tool: string; [key: string]: unknown };
            tool = toolFromArgs;
            params = restParams as typeof params;

            if (!tool) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    `âŒ Missing required parameter: tool for agent ${agentName}\n\nðŸ’¡ Specify which tool to use.\n\nExample: { "tool": "searchDirectory", "query": "search term", ... }`
                );
            }
        }

        // Use SessionContextManager for unified session handling instead of separate SessionService
        const sessionId = params.context?.sessionId || params.sessionId;
        
        let sessionInfo: any;
        if (this.sessionContextManager && sessionId) {
            try {
                const validationResult = await this.sessionContextManager.validateSessionId(sessionId);
                const isNonStandardId = validationResult.id !== sessionId;
                
                sessionInfo = {
                    sessionId: validationResult.id,
                    isNewSession: validationResult.created,
                    isNonStandardId: isNonStandardId,
                    originalSessionId: isNonStandardId ? sessionId : undefined
                };
                
                // Update params with validated session ID (both locations for compatibility)
                if (params.context) {
                    params.context.sessionId = validationResult.id;
                }
                params.sessionId = validationResult.id;
            } catch (error) {
                logger.systemWarn(`SessionContextManager validation failed: ${getErrorMessage(error)}. Falling back to SessionService`);
                // Fallback to original SessionService if SessionContextManager fails
                sessionInfo = await this.dependencies.sessionService.processSessionId(sessionId);
                if (params.context) {
                    params.context.sessionId = sessionInfo.sessionId;
                }
                params.sessionId = sessionInfo.sessionId;
            }
        } else {
            // Fallback to original SessionService if no SessionContextManager or sessionId
            // processSessionId handles undefined by generating a new session ID
            sessionInfo = await this.dependencies.sessionService.processSessionId(sessionId);
            if (params.context) {
                params.context.sessionId = sessionInfo.sessionId;
            }
            params.sessionId = sessionInfo.sessionId;
        }
        
        const shouldInjectInstructions = this.dependencies.sessionService.shouldInjectInstructions(
            sessionInfo.sessionId, 
            this.sessionContextManager
        );

        return {
            agentName,
            tool,
            params,
            sessionId: sessionInfo.sessionId,
            fullToolName,
            sessionContextManager: this.sessionContextManager,
            sessionInfo: {
                ...sessionInfo,
                shouldInjectInstructions
            }
        };
    }

    private async processParameters(context: IRequestContext): Promise<any> {
        const agent = this.getAgent(context.agentName);
        const toolInstance = agent.getTool(context.tool);

        let paramSchema;
        try {
            if (toolInstance && typeof toolInstance.getParameterSchema === 'function') {
                paramSchema = toolInstance.getParameterSchema();
            }
        } catch (error) {
            logger.systemWarn(`Failed to get parameter schema for tool ${context.tool}: ${getErrorMessage(error)}`);
        }

        const enhancedParams = await this.dependencies.validationService.validateToolParams(
            context.params, 
            paramSchema,
            context.fullToolName
        );

        // Session validation is now handled in buildRequestContext() to avoid duplication
        // Session description updates: support both new format (goal) and legacy (sessionDescription)
        // Note: In new format, 'goal' is the current objective. We update session description
        // to keep track of what the session is working on.
        const sessionGoal = enhancedParams.context?.goal || enhancedParams.context?.sessionDescription;
        if (this.sessionContextManager &&
            enhancedParams.context?.sessionId &&
            sessionGoal) {
            try {
                // Safety check: ensure sessionId is not undefined
                const sessionIdToUpdate = enhancedParams.context.sessionId;
                if (sessionIdToUpdate && sessionIdToUpdate !== 'undefined') {
                    await this.sessionContextManager.updateSessionDescription(
                        sessionIdToUpdate,
                        sessionGoal
                    );
                } else {
                    logger.systemWarn(`Skipping session description update - sessionId is undefined or invalid`);
                }
            } catch (error) {
                logger.systemWarn(`Session description update failed: ${getErrorMessage(error)}`);
            }
        }

        let processedParams = { ...enhancedParams };
        if (this.sessionContextManager && processedParams.context?.sessionId) {
            // Check if we need to apply workspace context from session manager
            // Skip if we already have workspaceId in context or workspaceContext
            const hasWorkspaceId = processedParams.context?.workspaceId || 
                                   (processedParams.workspaceContext && processedParams.workspaceContext.workspaceId);
            
            if (!hasWorkspaceId) {
                processedParams = this.sessionContextManager.applyWorkspaceContext(
                    processedParams.context.sessionId, 
                    processedParams
                );
            }
            
            // If we have workspaceId in context but no workspaceContext, create one for backward compatibility
            if (processedParams.context?.workspaceId && !processedParams.workspaceContext) {
                processedParams.workspaceContext = {
                    workspaceId: processedParams.context.workspaceId,
                    workspacePath: [],
                    contextDepth: 'standard'
                };
            }
        }

        return processedParams;
    }

    private async executeTool(context: IRequestContext, processedParams: any): Promise<any> {
        const agent = this.getAgent(context.agentName);
        const result = await this.dependencies.toolExecutionService.executeAgent(
            agent,
            context.tool,
            processedParams
        );

        // Update session context from result (for load operations that return new workspace context)
        if (this.sessionContextManager && processedParams.sessionId && result.workspaceContext) {
            this.sessionContextManager.updateFromResult(processedParams.sessionId, result);
        }

        return result;
    }

    private extractAgentName(toolName: string): string {
        const lastUnderscoreIndex = toolName.lastIndexOf('_');
        return lastUnderscoreIndex === -1 ? toolName : toolName.substring(0, lastUnderscoreIndex);
    }
}
```

## handlers/strategies/ToolHelpStrategy.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IRequestStrategy } from './IRequestStrategy';
import { IRequestHandlerDependencies } from '../interfaces/IRequestHandlerServices';
import { IAgent } from '../../agents/interfaces/IAgent';
import { logger } from '../../utils/logger';

interface ToolHelpRequest {
    method: string;
    params: {
        name: string;
        arguments: {
            mode: string;
        };
    };
}

interface ToolHelpResponse {
    content: Array<{
        type: string;
        text: string;
    }>;
}

/**
 * Strategy for handling tool help requests
 * Follows Strategy Pattern for clean request handling
 */
export class ToolHelpStrategy implements IRequestStrategy<ToolHelpRequest, ToolHelpResponse> {
    constructor(
        private dependencies: IRequestHandlerDependencies,
        private getAgent: (name: string) => IAgent
    ) {}

    canHandle(request: ToolHelpRequest): boolean {
        return request.method === 'tools/help';
    }

    async handle(request: ToolHelpRequest): Promise<ToolHelpResponse> {
        try {
            logger.systemLog('ToolHelpStrategy: Handling tool help request');
            
            const { name: toolName, arguments: args } = request.params;
            const { mode } = args;
            
            // Validate required parameters
            if (!toolName) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    'Tool name is required for help request'
                );
            }
            
            if (!mode) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    'Mode parameter is required for tool help'
                );
            }
            
            // Generate help using the service
            return await this.dependencies.toolHelpService.generateToolHelp(
                this.getAgent,
                toolName,
                mode
            );
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            logger.systemError(error as Error, 'ToolHelpStrategy');
            throw new McpError(ErrorCode.InternalError, 'Failed to get tool help', error);
        }
    }
}
```

## handlers/strategies/ToolListStrategy.ts

```typescript
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { IRequestStrategy } from './IRequestStrategy';
import { IRequestHandlerDependencies } from '../interfaces/IRequestHandlerServices';
import { IAgent } from '../../agents/interfaces/IAgent';
import { ITool } from '../../agents/interfaces/ITool';
import { logger } from '../../utils/logger';

interface ToolListRequest {
    method: string;
}

interface ToolListResponse {
    tools: Array<{
        name: string;
        description: string;
        inputSchema: Record<string, unknown>;
    }>;
}

/**
 * Two-Tool Architecture: Returns only toolManager_getTools and toolManager_useTools
 *
 * This replaces the old 50+ tool surface with just 2 tools:
 * - toolManager_getTools: Discovery - returns tool schemas for LLM reference
 * - toolManager_useTools: Execution - single entry point with context-first design
 *
 * Token savings: ~95% reduction in upfront schemas (~15,000 â†’ ~500 tokens)
 */
export class ToolListStrategy implements IRequestStrategy<ToolListRequest, ToolListResponse> {
    constructor(
        private dependencies: IRequestHandlerDependencies,
        private agents: Map<string, IAgent>,
        private isVaultEnabled: boolean,
        private vaultName?: string
    ) {}

    canHandle(request: ToolListRequest): boolean {
        return request.method === 'tools/list';
    }

    async handle(request: ToolListRequest): Promise<ToolListResponse> {
        try {
            // Two-Tool Architecture: Return only toolManager tools
            const toolManagerAgent = this.agents.get('toolManager');

            if (!toolManagerAgent) {
                logger.systemWarn('[ToolListStrategy] ToolManager agent not found - returning empty tools list');
                return { tools: [] };
            }

            // Get tools from toolManager (getTools and useTools)
            const toolManagerTools = toolManagerAgent.getTools();

            // Convert to MCP tool format
            // Use underscore separator (MCP requires ^[a-zA-Z0-9_-]{1,64}$ - no dots allowed)
            const tools = toolManagerTools.map((tool: ITool<unknown, unknown>) => ({
                name: `toolManager_${tool.slug}`,
                description: tool.description,
                inputSchema: tool.getParameterSchema() as Record<string, unknown>
            }));

            return { tools };
        } catch (error) {
            logger.systemError(error as Error, "Tool List Strategy");
            throw new McpError(ErrorCode.InternalError, 'Failed to list tools', error);
        }
    }
}
```

## main.ts

```typescript
import { Plugin, Notice, Platform } from 'obsidian';
import { Settings } from './settings';
import { ServiceManager } from './core/ServiceManager';
import { PluginLifecycleManager, type PluginLifecycleConfig } from './core/PluginLifecycleManager';
import { BRAND_NAME } from './constants/branding';
import { supportsMCPBridge } from './utils/platform';
import { WasmEnsurer } from './utils/WasmEnsurer';

// MCPConnector type for desktop-only dynamic import
type MCPConnectorType = import('./connector').MCPConnector;

export default class NexusPlugin extends Plugin {
    public settings!: Settings;
    private connector!: MCPConnectorType;
    private serviceManager!: ServiceManager;
    private lifecycleManager!: PluginLifecycleManager;

    /**
     * Get a service asynchronously
     */
    public async getService<T>(name: string, timeoutMs?: number): Promise<T | null> {
        if (!this.serviceManager) {
            return null;
        }
        try {
            return await this.serviceManager.getService<T>(name);
        } catch (error) {
            console.error(`[${BRAND_NAME}] Failed to get service ${name}:`, error);
            return null;
        }
    }

    // Get service if already initialized (non-blocking)
    public getServiceIfReady<T>(name: string): T | null {
        if (!this.serviceManager) {
            return null;
        }
        return this.serviceManager.getServiceIfReady<T>(name);
    }

    // Service registry - for backward compatibility
    public get services(): Record<string, any> {
        const services: Record<string, any> = {};
        if (!this.serviceManager) {
            return services;
        }
        // Return only ready services for immediate access
        // These are used by agent tools for activity recording and UI components
        const serviceNames = ['memoryService', 'workspaceService', 'sessionService', 'conversationService', 'customPromptStorageService'];
        for (const name of serviceNames) {
            const service = this.serviceManager.getServiceIfReady(name);
            if (service) {
                services[name] = service;
            }
        }
        return services;
    }

    async onload() {
        try {
            // Ensure sqlite3.wasm exists (desktop only - SQLite not used on mobile)
            if (Platform.isDesktop) {
                const wasmEnsurer = new WasmEnsurer(this);
                const wasmReady = await wasmEnsurer.ensureWasmExists();
                if (!wasmReady) {
                    console.warn(`[${BRAND_NAME}] SQLite WASM not available - some features may be limited`);
                }
            }

            // Create service manager and settings
            this.settings = new Settings(this);
            this.serviceManager = new ServiceManager(this.app, this);

            // MCP server and connector only work on desktop (requires Node.js)
            // Use dynamic imports to avoid bundling Node.js dependencies on mobile
            if (supportsMCPBridge()) {
                try {
                    // Dynamic import - only loads on desktop, avoids Node.js deps on mobile
                    const { ConnectorEnsurer } = await import('./utils/ConnectorEnsurer');
                    const { MCPConnector } = await import('./connector');

                    // Ensure connector.js exists (self-healing if missing)
                    const connectorEnsurer = new ConnectorEnsurer(this);
                    await connectorEnsurer.ensureConnectorExists();

                    // Initialize connector skeleton (no agents yet)
                    this.connector = new MCPConnector(this.app, this);
                } catch (error) {
                    console.error(`[${BRAND_NAME}] Failed to initialize MCP connector:`, error);
                    // Continue without MCP - chat still works
                }
            }

            // Create and initialize lifecycle manager
            const lifecycleConfig: PluginLifecycleConfig = {
                plugin: this,
                app: this.app,
                serviceManager: this.serviceManager,
                settings: this.settings,
                connector: this.connector, // May be undefined on mobile
                manifest: this.manifest
            };

            this.lifecycleManager = new PluginLifecycleManager(lifecycleConfig);
            await this.lifecycleManager.initialize();

        } catch (error) {
            console.error(`[${BRAND_NAME}] Plugin loading failed:`, error);
            new Notice(`${BRAND_NAME}: Plugin failed to load. Check console for details.`);
            throw error;
        }
    }

    async onunload() {
        // Shutdown lifecycle manager first (handles UI cleanup)
        if (this.lifecycleManager) {
            await this.lifecycleManager.shutdown();
        }

        // Stop connector
        if (this.connector) {
            await this.connector.stop();
        }

        // Service manager cleanup handled by lifecycle manager
    }

    /**
     * Get service manager for direct access if needed
     */
    public getServiceContainer(): ServiceManager {
        return this.serviceManager;
    }
}

```

## obsidian.d.ts

```typescript
import { App as ObsidianApp } from 'obsidian';
import type {
  ProgressUpdateData,
  ProgressCompleteData,
  ProgressCancelData
} from './components/ProgressBar';

// Extend the Obsidian App interface to include the version property
declare module 'obsidian' {
  interface App extends ObsidianApp {
    version: string;
  }
}

declare global {
  interface Window {
    app: App;
    mcpProgressHandlers?: {
      updateProgress: (data: ProgressUpdateData) => void;
      completeProgress: (data: ProgressCompleteData) => void;
      cancelProgress: (data: ProgressCancelData) => void;
    };
  }
}

export {};
```

## server.ts

```typescript
/**
 * server.ts - Refactored following SOLID principles
 * Main export for backward compatibility
 */

// Export the refactored MCPServer as the main MCPServer
export { MCPServer } from './server/MCPServer';

// Export specialized services for direct use if needed
export { ServerConfiguration } from './server/services/ServerConfiguration';
export { AgentRegistry } from './server/services/AgentRegistry';
export { StdioTransportManager } from './server/transport/StdioTransportManager';
export { IPCTransportManager } from './server/transport/IPCTransportManager';
export { RequestHandlerFactory } from './server/handlers/RequestHandlerFactory';
export { ServerLifecycleManager } from './server/lifecycle/ServerLifecycleManager';
export { AgentExecutionManager } from './server/execution/AgentExecutionManager';

// Export types if needed
export type { ServerConfigurationOptions } from './server/services/ServerConfiguration';
```

## server/execution/AgentExecutionManager.ts

```typescript
/**
 * AgentExecutionManager - Handles agent execution and session management
 * Follows Single Responsibility Principle by focusing only on agent execution
 */

import { AgentRegistry } from '../services/AgentRegistry';
import { SessionContextManager, WorkspaceContext } from '../../services/SessionContextManager';
import { NexusError, NexusErrorCode } from '../../utils/errors';
import { logger } from '../../utils/logger';
import { getErrorMessage } from '../../utils/errorUtils';
import { generateToolHelp, formatToolHelp } from '../../utils/parameterHintUtils';
import { CommonResult } from '../../types';

/**
 * Safely extracts sessionId from params as a string
 * Returns undefined if not present or not a string
 */
function getSessionIdFromParams(params: Record<string, unknown>): string | undefined {
    const sessionId = params.sessionId;
    return typeof sessionId === 'string' ? sessionId : undefined;
}

/**
 * Type guard to verify a value conforms to CommonResult interface
 */
function isCommonResult(value: unknown): value is CommonResult {
    return (
        typeof value === 'object' &&
        value !== null &&
        'success' in value &&
        typeof (value as CommonResult).success === 'boolean'
    );
}

/**
 * Service responsible for agent execution and session management
 * Follows SRP by focusing only on agent execution operations
 */
export class AgentExecutionManager {
    constructor(
        private agentRegistry: AgentRegistry,
        private sessionContextManager?: SessionContextManager
    ) {}

    /**
     * Execute a tool on an agent
     */
    async executeAgentTool(agentName: string, tool: string, params: Record<string, unknown>): Promise<unknown> {
        try {
            // Get the agent
            const agent = this.agentRegistry.validateAndGetAgent(agentName);

            // Process session context
            const processedParams = await this.processSessionContext(params);

            // Execute the tool
            const result = await agent.executeTool(tool, processedParams);

            // Update session context with result
            await this.updateSessionContext(processedParams, result);

            // Add session instructions if needed
            return this.addSessionInstructions(processedParams, result);
        } catch (error) {
            if (error instanceof NexusError) {
                throw error;
            }
            throw new NexusError(
                NexusErrorCode.InternalError,
                `Failed to execute agent ${agentName} tool ${tool}`,
                error
            );
        }
    }

    /**
     * @deprecated Use executeAgentTool instead
     */
    async executeAgentMode(agentName: string, mode: string, params: Record<string, unknown>): Promise<unknown> {
        return this.executeAgentTool(agentName, mode, params);
    }

    /**
     * Get detailed help for a specific tool
     */
    getToolHelp(agentName: string, toolName: string): string {
        try {
            // Get the agent
            const agent = this.agentRegistry.validateAndGetAgent(agentName);

            // Get the tool
            const tool = agent.getTool(toolName);

            if (!tool) {
                throw new NexusError(
                    NexusErrorCode.InvalidParams,
                    `Tool ${toolName} not found in agent ${agentName}`
                );
            }

            // Get the tool's parameter schema
            const schema = tool.getParameterSchema();

            // Generate tool help
            const help = generateToolHelp(
                toolName,
                tool.description,
                schema
            );

            // Format and return the help
            return formatToolHelp(help);
        } catch (error) {
            if (error instanceof NexusError) {
                throw error;
            }
            throw new NexusError(
                NexusErrorCode.InternalError,
                `Failed to get help for agent ${agentName} tool ${toolName}`,
                error
            );
        }
    }

    /**
     * @deprecated Use getToolHelp instead
     */
    getModeHelp(agentName: string, modeName: string): string {
        return this.getToolHelp(agentName, modeName);
    }

    /**
     * Process session context for parameters
     */
    private async processSessionContext(params: Record<string, unknown>): Promise<Record<string, unknown>> {
        const sessionId = getSessionIdFromParams(params);
        if (!this.sessionContextManager || !sessionId) {
            return params;
        }

        try {
            // Validate session ID - destructure the result to get the actual ID
            const { id: validatedSessionId } = await this.sessionContextManager.validateSessionId(sessionId);
            params.sessionId = validatedSessionId;

            // Apply workspace context
            params = this.sessionContextManager.applyWorkspaceContext(validatedSessionId, params);

            return params;
        } catch (error) {
            logger.systemWarn(`Session validation failed: ${getErrorMessage(error)}. Using original ID`);
            return params;
        }
    }

    /**
     * Update session context with execution result
     */
    private async updateSessionContext(params: Record<string, unknown>, result: unknown): Promise<void> {
        const sessionId = getSessionIdFromParams(params);
        if (!this.sessionContextManager || !sessionId || !isCommonResult(result) || !result.workspaceContext) {
            return;
        }

        try {
            this.sessionContextManager.updateFromResult(sessionId, result);
        } catch (error) {
            logger.systemWarn(`Session context update failed: ${getErrorMessage(error)}`);
        }
    }

    /**
     * Add session instructions to result if needed
     */
    private addSessionInstructions(params: Record<string, unknown>, result: unknown): unknown {
        if (!this.sessionContextManager || !result || typeof result !== 'object') {
            return result;
        }

        const sessionId = getSessionIdFromParams(params);
        if (!sessionId) {
            return result;
        }

        const needsInstructions = (params._isNewSession || params._isNonStandardId) &&
                               !this.sessionContextManager.hasReceivedInstructions(sessionId);

        if (!needsInstructions) {
            return result;
        }

        // Cast to Record for mutation - this is safe since we verified it's an object
        const resultObj = result as Record<string, unknown>;

        // Add session instructions
        const originalSessionId = typeof params._originalSessionId === 'string' ? params._originalSessionId : undefined;
        if (params._isNonStandardId && originalSessionId) {
            resultObj.sessionIdCorrection = {
                originalId: originalSessionId,
                correctedId: sessionId,
                message: "Your session ID has been standardized. Please use this corrected session ID for all future requests in this conversation."
            };
        } else if (params._isNewSession && !originalSessionId) {
            resultObj.newSessionInfo = {
                sessionId: sessionId,
                message: "A new session has been created. This ID must be used for all future requests in this conversation."
            };
        }

        // Mark instructions as received
        this.sessionContextManager.markInstructionsReceived(sessionId);

        return resultObj;
    }

    /**
     * Add auto-generated session info if needed
     */
    private addAutoGeneratedSessionInfo(params: Record<string, unknown>, result: Record<string, unknown>): Record<string, unknown> {
        if (!params._autoGeneratedSessionId || !result || params._originalSessionId) {
            return result;
        }

        result.newSessionId = params.sessionId;
        result.validSessionInfo = {
            originalId: null,
            newId: params.sessionId,
            message: "No session ID was provided. A new session has been created. Please use this session ID for future requests."
        };

        return result;
    }

    /**
     * Get execution statistics
     */
    getExecutionStatistics(): {
        totalAgents: number;
        totalTools: number;
        availableTools: Array<{
            agentName: string;
            toolName: string;
            description: string;
        }>;
        hasSessionManager: boolean;
    } {
        const agentStats = this.agentRegistry.getAgentStatistics();
        const availableTools = this.agentRegistry.getAllAvailableTools();

        return {
            totalAgents: agentStats.totalAgents,
            totalTools: availableTools.length,
            availableTools,
            hasSessionManager: !!this.sessionContextManager
        };
    }

    /**
     * Validate execution parameters
     */
    validateExecutionParameters(agentName: string, tool: string, params: Record<string, unknown> | null | undefined): {
        isValid: boolean;
        errors: string[];
        warnings: string[];
    } {
        const errors: string[] = [];
        const warnings: string[] = [];

        // Validate agent name
        if (!agentName || typeof agentName !== 'string') {
            errors.push('Agent name must be a non-empty string');
        } else if (!this.agentRegistry.hasAgent(agentName)) {
            errors.push(`Agent ${agentName} not found`);
        }

        // Validate tool
        if (!tool || typeof tool !== 'string') {
            errors.push('Tool must be a non-empty string');
        } else if (agentName && !this.agentRegistry.agentSupportsTool(agentName, tool)) {
            errors.push(`Agent ${agentName} does not support tool ${tool}`);
        }

        // Validate params
        if (params === null || params === undefined) {
            errors.push('Parameters cannot be null or undefined');
        } else if (typeof params !== 'object') {
            errors.push('Parameters must be an object');
        }

        // Session warnings
        if (params && params.sessionId && !this.sessionContextManager) {
            warnings.push('Session ID provided but no session context manager available');
        }

        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }

    /**
     * Execute agent tool with validation
     */
    async executeAgentToolWithValidation(agentName: string, tool: string, params: Record<string, unknown>): Promise<unknown> {
        // Validate parameters
        const validation = this.validateExecutionParameters(agentName, tool, params);

        if (!validation.isValid) {
            throw new NexusError(
                NexusErrorCode.InvalidParams,
                `Invalid execution parameters: ${validation.errors.join(', ')}`
            );
        }

        // Log warnings
        validation.warnings.forEach(warning => {
            logger.systemWarn(warning);
        });

        // Execute with validation passed
        return await this.executeAgentTool(agentName, tool, params);
    }

    /**
     * @deprecated Use executeAgentToolWithValidation instead
     */
    async executeAgentModeWithValidation(agentName: string, mode: string, params: Record<string, unknown>): Promise<unknown> {
        return this.executeAgentToolWithValidation(agentName, mode, params);
    }

    /**
     * Get agent tool schema
     */
    getAgentToolSchema(agentName: string, toolName: string): Record<string, unknown> {
        const agent = this.agentRegistry.validateAndGetAgent(agentName);
        const tool = agent.getTool(toolName);

        if (!tool) {
            throw new NexusError(
                NexusErrorCode.InvalidParams,
                `Tool ${toolName} not found in agent ${agentName}`
            );
        }

        return tool.getParameterSchema();
    }

    /**
     * @deprecated Use getAgentToolSchema instead
     */
    getAgentModeSchema(agentName: string, modeName: string): Record<string, unknown> {
        return this.getAgentToolSchema(agentName, modeName);
    }

    /**
     * Get execution context info
     */
    getExecutionContextInfo(sessionId?: string): {
        hasSessionManager: boolean;
        workspaceContext?: WorkspaceContext;
    } {
        const info: {
            hasSessionManager: boolean;
            workspaceContext?: WorkspaceContext;
        } = {
            hasSessionManager: !!this.sessionContextManager
        };

        if (this.sessionContextManager && sessionId) {
            try {
                // Get workspace context if available
                const workspaceContext = this.sessionContextManager.getWorkspaceContext(sessionId);
                if (workspaceContext) {
                    info.workspaceContext = workspaceContext;
                }
            } catch (error) {
                logger.systemWarn(`Failed to get execution context: ${getErrorMessage(error)}`);
            }
        }

        return info;
    }
}
```

## server/handlers/RequestHandlerFactory.ts

```typescript
/**
 * RequestHandlerFactory - Creates and configures request handlers
 * Follows Single Responsibility Principle by focusing only on handler setup
 */

import { Server as MCPSDKServer } from '@modelcontextprotocol/sdk/server/index.js';
import {
    ListResourcesRequestSchema,
    ReadResourceRequestSchema,
    ListToolsRequestSchema,
    CallToolRequestSchema,
    ListPromptsRequestSchema,
    GetPromptRequestSchema
} from '@modelcontextprotocol/sdk/types.js';
import { RequestRouter } from '../../handlers/RequestRouter';
import { parseJsonArrays } from '../../utils/jsonUtils';
import { logger } from '../../utils/logger';

/**
 * Service responsible for creating and configuring request handlers
 * Follows SRP by focusing only on handler setup operations
 */
export class RequestHandlerFactory {
    constructor(
        private server: MCPSDKServer,
        private requestRouter: RequestRouter,
        private onToolCall?: (toolName: string, params: any) => Promise<void>
    ) {}

    /**
     * Initialize all request handlers
     */
    initializeHandlers(): void {
        this.setupResourceHandlers();
        this.setupPromptHandlers();
        this.setupToolHandlers();
    }

    /**
     * Setup resource request handlers
     */
    private setupResourceHandlers(): void {
        // Handle resource listing
        this.server.setRequestHandler(ListResourcesRequestSchema, async (request) => {
            return await this.requestRouter.handleRequest('resources/list', request);
        });

        // Handle resource reading
        this.server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
            return await this.requestRouter.handleRequest('resources/read', request);
        });
    }

    /**
     * Setup prompt request handlers
     */
    private setupPromptHandlers(): void {
        // Handle prompts listing
        this.server.setRequestHandler(ListPromptsRequestSchema, async (request) => {
            return await this.requestRouter.handleRequest('prompts/list', request);
        });

        // Handle prompts get
        this.server.setRequestHandler(GetPromptRequestSchema, async (request) => {
            return await this.requestRouter.handleRequest('prompts/get', request);
        });
    }

    /**
     * Setup tool request handlers
     */
    private setupToolHandlers(): void {
        // Handle tool listing
        this.server.setRequestHandler(ListToolsRequestSchema, async (request) => {
            try {
                return await this.requestRouter.handleRequest('tools/list', request);
            } catch (error) {
                console.error("Error in tool list handler:", error);
                logger.systemError(error as Error, 'Tool List Handler');
                // Return empty list in case of error to avoid timeout
                return { tools: [] };
            }
        });

        // Handle tool execution
        this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
            return await this.handleToolCall(request);
        });
    }

    /**
     * Handle tool call with preprocessing
     */
    private async handleToolCall(request: any): Promise<any> {
        const parsedArgs = parseJsonArrays(request.params.arguments);
        
        // Trigger tool call hook for lazy loading
        await this.triggerToolCallHook(request.params.name, parsedArgs);
        
        // Check if this is a help request
        if (this.isHelpRequest(parsedArgs)) {
            return await this.handleHelpRequest(request, parsedArgs);
        }
        
        // Normal execution
        return await this.handleNormalExecution(request, parsedArgs);
    }

    /**
     * Trigger tool call hook if available
     */
    private async triggerToolCallHook(toolName: string, params: any): Promise<void> {
        if (!this.onToolCall) {
            return;
        }

        try {
            await this.onToolCall(toolName, params);
        } catch (error) {
        }
    }

    /**
     * Check if this is a help request
     */
    private isHelpRequest(parsedArgs: any): boolean {
        return parsedArgs && parsedArgs.help === true;
    }

    /**
     * Handle help request
     */
    private async handleHelpRequest(request: any, parsedArgs: any): Promise<any> {
        return await this.requestRouter.handleRequest('tools/help', {
            ...request,
            params: {
                ...request.params,
                arguments: parsedArgs
            }
        });
    }

    /**
     * Handle normal tool execution
     */
    private async handleNormalExecution(request: any, parsedArgs: any): Promise<any> {
        return await this.requestRouter.handleRequest('tools/call', {
            ...request,
            params: {
                ...request.params,
                arguments: parsedArgs
            }
        });
    }

    /**
     * Get handler statistics
     */
    getHandlerStatistics(): {
        totalHandlers: number;
        handlerTypes: string[];
        resourceHandlers: number;
        promptHandlers: number;
        toolHandlers: number;
    } {
        return {
            totalHandlers: 6,
            handlerTypes: ['resources', 'prompts', 'tools'],
            resourceHandlers: 2,
            promptHandlers: 2,
            toolHandlers: 2
        };
    }

    /**
     * Validate handler setup
     */
    validateHandlerSetup(): {
        isValid: boolean;
        errors: string[];
        warnings: string[];
    } {
        const errors: string[] = [];
        const warnings: string[] = [];

        if (!this.server) {
            errors.push('Server instance not provided');
        }

        if (!this.requestRouter) {
            errors.push('Request router not provided');
        }

        if (!this.onToolCall) {
            warnings.push('No tool call hook provided');
        }

        return {
            isValid: errors.length === 0,
            errors,
            warnings
        };
    }

    /**
     * Get request handler info
     */
    getRequestHandlerInfo(): Array<{
        schema: string;
        route: string;
        description: string;
        hasCustomLogic: boolean;
    }> {
        return [
            {
                schema: 'ListResourcesRequestSchema',
                route: 'resources/list',
                description: 'List available resources',
                hasCustomLogic: false
            },
            {
                schema: 'ReadResourceRequestSchema',
                route: 'resources/read',
                description: 'Read specific resource',
                hasCustomLogic: false
            },
            {
                schema: 'ListPromptsRequestSchema',
                route: 'prompts/list',
                description: 'List available prompts',
                hasCustomLogic: false
            },
            {
                schema: 'GetPromptRequestSchema',
                route: 'prompts/get',
                description: 'Get specific prompt',
                hasCustomLogic: false
            },
            {
                schema: 'ListToolsRequestSchema',
                route: 'tools/list',
                description: 'List available tools',
                hasCustomLogic: true
            },
            {
                schema: 'CallToolRequestSchema',
                route: 'tools/call',
                description: 'Execute tool',
                hasCustomLogic: true
            }
        ];
    }
}
```

## server/lifecycle/ServerLifecycleManager.ts

```typescript
/**
 * ServerLifecycleManager - Handles server lifecycle operations
 * Follows Single Responsibility Principle by focusing only on lifecycle management
 */

import { Events } from 'obsidian';
import { AgentRegistry } from '../services/AgentRegistry';
import { HttpTransportManager } from '../transport/HttpTransportManager';
import { IPCTransportManager } from '../transport/IPCTransportManager';
import { ServerStatus } from '../../types';
import { logger } from '../../utils/logger';

/**
 * Service responsible for server lifecycle management
 * Follows SRP by focusing only on lifecycle operations
 */
export class ServerLifecycleManager {
    private status: ServerStatus = 'stopped';

    constructor(
        private agentRegistry: AgentRegistry,
        private httpTransportManager: HttpTransportManager,
        private ipcTransportManager: IPCTransportManager,
        private events: Events
    ) {}

    /**
     * Start the server
     */
    async startServer(): Promise<void> {
        if (this.status === 'running') {
            logger.systemWarn('Server is already running');
            return;
        }

        try {
            this.status = 'starting';
            logger.systemLog('Starting server...');

            // Initialize agents
            await this.initializeAgents();

            // Start transports
            await this.startTransports();

            this.status = 'running';
            this.events.trigger('server:started');
            logger.systemLog('Server started successfully with IPC transport');
        } catch (error) {
            this.status = 'error';
            logger.systemError(error as Error, 'Server Start');
            throw error;
        }
    }

    /**
     * Stop the server
     */
    async stopServer(): Promise<void> {
        if (this.status === 'stopped') {
            logger.systemWarn('Server is already stopped');
            return;
        }

        try {
            this.status = 'stopping';
            logger.systemLog('Stopping server...');

            // Stop transports
            await this.stopTransports();

            this.status = 'stopped';
            this.events.trigger('server:stopped');
            logger.systemLog('Server stopped successfully');
        } catch (error) {
            this.status = 'error';
            logger.systemError(error as Error, 'Server Stop');
            throw error;
        }
    }

    /**
     * Restart the server
     */
    async restartServer(): Promise<void> {
        logger.systemLog('Restarting server...');
        await this.stopServer();
        await this.startServer();
    }

    /**
     * Initialize all registered agents
     */
    private async initializeAgents(): Promise<void> {
        try {
            await this.agentRegistry.initializeAgents();
            logger.systemLog('All agents initialized successfully');
        } catch (error) {
            logger.systemError(error as Error, 'Agent Initialization');
            throw error;
        }
    }

    /**
     * Start transports
     */
    private async startTransports(): Promise<void> {
        try {
            // Start IPC transport only (used by both external clients and internal chatbot)
            const ipcResult = await this.ipcTransportManager.startTransport();
            logger.systemLog('IPC transport started successfully');
        } catch (error) {
            logger.systemError(error as Error, 'Transport Start');
            throw error;
        }
    }

    /**
     * Stop both transports
     */
    private async stopTransports(): Promise<void> {
        try {
            // Only stop IPC transport (no HTTP to stop)
            await this.ipcTransportManager.stopTransport();

            logger.systemLog('IPC transport stopped successfully');
        } catch (error) {
            logger.systemError(error as Error, 'Transport Stop');
            throw error;
        }
    }

    /**
     * Get current server status
     */
    getStatus(): ServerStatus {
        return this.status;
    }

    /**
     * Check if server is running
     */
    isRunning(): boolean {
        return this.status === 'running';
    }

    /**
     * Check if server is in error state
     */
    isInError(): boolean {
        return this.status === 'error';
    }

    /**
     * Get detailed server status
     */
    getDetailedStatus(): {
        status: ServerStatus;
        isRunning: boolean;
        agentCount: number;
        httpTransportStatus: any;
        ipcTransportStatus: any;
        uptime?: number;
    } {
        return {
            status: this.status,
            isRunning: this.isRunning(),
            agentCount: this.agentRegistry.getAgentCount(),
            ipcTransportStatus: this.ipcTransportManager.getTransportStatus(),
            httpTransportStatus: this.httpTransportManager.getTransportStatus()
        };
    }

    /**
     * Handle server error
     */
    handleServerError(error: Error): void {
        logger.systemError(error, 'Server Error');
        this.status = 'error';
        this.events.trigger('server:error', error);
    }

    /**
     * Perform health check
     */
    async performHealthCheck(): Promise<{
        isHealthy: boolean;
        status: ServerStatus;
        agentStatus: any;
        transportStatus: any;
        issues: string[];
    }> {
        const issues: string[] = [];

        // Check status
        if (this.status !== 'running') {
            issues.push(`Server status is ${this.status}, expected 'running'`);
        }

        // Check agents
        const agentStats = this.agentRegistry.getAgentStatistics();
        if (agentStats.totalAgents === 0) {
            issues.push('No agents registered');
        }

        // Check transports
        const httpStatus = this.httpTransportManager.getTransportStatus();
        const ipcStatus = this.ipcTransportManager.getTransportStatus();

        if (!httpStatus.isRunning) {
            issues.push('STDIO transport not connected');
        }

        if (!ipcStatus.isRunning) {
            issues.push('IPC transport not running');
        }

        return {
            isHealthy: issues.length === 0,
            status: this.status,
            agentStatus: agentStats,
            transportStatus: {
                http: httpStatus,
                ipc: ipcStatus
            },
            issues
        };
    }

    /**
     * Get server diagnostics
     */
    async getDiagnostics(): Promise<{
        lifecycle: any;
        agents: any;
        transports: any;
        events: any;
    }> {
        return {
            lifecycle: {
                status: this.status,
                isRunning: this.isRunning(),
                isInError: this.isInError()
            },
            agents: this.agentRegistry.getAgentStatistics(),
            transports: {
                http: this.httpTransportManager.getTransportStatus(),
                ipc: this.ipcTransportManager.getDiagnostics()
            },
            events: {
                hasEvents: !!this.events
            }
        };
    }

    /**
     * Force shutdown (emergency stop)
     */
    async forceShutdown(): Promise<void> {
        logger.systemWarn('Force shutdown initiated');
        
        try {
            // Try to stop transports gracefully first
            await Promise.race([
                this.stopTransports(),
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Transport shutdown timeout')), 5000)
                )
            ]);
        } catch (error) {
            logger.systemError(error as Error, 'Force Shutdown - Transport Stop');
        }

        // Force cleanup
        try {
            await this.ipcTransportManager.forceCleanupSocket();
        } catch (error) {
            logger.systemError(error as Error, 'Force Shutdown - Socket Cleanup');
        }

        this.status = 'stopped';
        this.events.trigger('server:force-shutdown');
        logger.systemWarn('Force shutdown completed');
    }
}
```

## server/MCPServer.ts

```typescript
/**
 * MCPServer - Refactored following SOLID principles
 * Main orchestrator for MCP server operations
 */

import { App, Plugin, Events } from 'obsidian';
import { IMCPServer, ServerStatus } from '../types';
import { IAgent } from '../agents/interfaces/IAgent';
import { SessionContextManager } from '../services/SessionContextManager';
import { CustomPromptStorageService } from "../agents/promptManager/services/CustomPromptStorageService";
import { Server as MCPSDKServer } from '@modelcontextprotocol/sdk/server/index.js';
import { RequestRouter } from '../handlers/RequestRouter';
import { logger } from '../utils/logger';
import { getErrorMessage } from '../utils/errorUtils';

// Import specialized services
import { ServerConfiguration } from './services/ServerConfiguration';
import { AgentRegistry } from './services/AgentRegistry';
import { HttpTransportManager } from './transport/HttpTransportManager';
import { IPCTransportManager } from './transport/IPCTransportManager';
import { StdioTransportManager } from './transport/StdioTransportManager';
import { RequestHandlerFactory } from './handlers/RequestHandlerFactory';
import { ServerLifecycleManager } from './lifecycle/ServerLifecycleManager';
import { AgentExecutionManager } from './execution/AgentExecutionManager';

/**
 * Refactored MCP Server following SOLID principles
 * Orchestrates specialized services for server operations
 */
export class MCPServer implements IMCPServer {
    // Core SDK server
    private server: MCPSDKServer;
    
    // Specialized services following Dependency Injection principle
    private configuration: ServerConfiguration;
    private agentRegistry: AgentRegistry;
    private httpTransportManager: HttpTransportManager;
    private stdioTransportManager: StdioTransportManager;
    private ipcTransportManager: IPCTransportManager;
    private requestHandlerFactory: RequestHandlerFactory;
    private lifecycleManager: ServerLifecycleManager;
    private executionManager: AgentExecutionManager;
    
    // Request routing
    private requestRouter!: RequestRouter;

    constructor(
        private app: App,
        _plugin: Plugin,
        private events: Events,
        private sessionContextManager?: SessionContextManager,
        serverName?: string,
        private customPromptStorage?: CustomPromptStorageService,
        private onToolCall?: (toolName: string, params: any) => Promise<void>,
        private onToolResponse?: (toolName: string, params: any, response: any, success: boolean, executionTime: number) => Promise<void>
    ) {
        // Initialize configuration service
        this.configuration = new ServerConfiguration(app, { serverName });
        
        // Initialize core SDK server
        this.server = this.createMCPSDKServer();
        
        // Initialize specialized services
        this.agentRegistry = new AgentRegistry();
        this.httpTransportManager = new HttpTransportManager(this.server, 3000, 'localhost');
        this.stdioTransportManager = new StdioTransportManager(this.server);
        this.ipcTransportManager = new IPCTransportManager(this.configuration, this.stdioTransportManager);
        this.executionManager = new AgentExecutionManager(this.agentRegistry, sessionContextManager);

        // Initialize request routing
        this.initializeRequestRouter();
        
        // Initialize request handlers
        this.requestHandlerFactory = new RequestHandlerFactory(
            this.server,
            this.requestRouter,
            this.onToolCall
        );
        
        // Initialize lifecycle manager
        this.lifecycleManager = new ServerLifecycleManager(
            this.agentRegistry,
            this.httpTransportManager,
            this.ipcTransportManager,
            this.events
        );
        
        // Setup handlers
        this.requestHandlerFactory.initializeHandlers();
    }

    /**
     * Create the MCP SDK server instance
     */
    private createMCPSDKServer(): MCPSDKServer {
        try {
            return new MCPSDKServer(
                this.configuration.getServerInfo(),
                this.configuration.getServerOptions()
            );
        } catch (error) {
            logger.systemError(error as Error, 'MCP SDK Server Creation');
            throw error;
        }
    }

    /**
     * Initialize the request router
     */
    private initializeRequestRouter(): void {
        try {
            this.requestRouter = new RequestRouter(
                this.app,
                this.agentRegistry.getAgents(),
                true, // isVaultEnabled
                this.configuration.getSanitizedVaultName(),
                this.sessionContextManager,
                this.customPromptStorage,
                this.onToolResponse
            );
        } catch (error) {
            logger.systemError(error as Error, 'Request Router Initialization');
            throw error;
        }
    }

    /**
     * Start the MCP server
     */
    async start(): Promise<void> {
        await this.lifecycleManager.startServer();
    }

    /**
     * Stop the MCP server
     */
    async stop(): Promise<void> {
        await this.lifecycleManager.stopServer();
    }

    /**
     * Check if the server is running
     */
    isRunning(): boolean {
        return this.lifecycleManager.isRunning();
    }

    /**
     * Get the current server status
     */
    getStatus(): ServerStatus {
        return this.lifecycleManager.getStatus();
    }

    /**
     * Register an agent with the server
     */
    registerAgent(agent: IAgent): void {
        this.agentRegistry.registerAgent(agent);
    }

    /**
     * Get an agent by name
     */
    getAgent(name: string): IAgent {
        return this.agentRegistry.getAgent(name);
    }

    /**
     * Get all registered agents
     */
    getAgents(): Map<string, IAgent> {
        return this.agentRegistry.getAgents();
    }

    /**
     * Get detailed help for a specific mode
     */
    getModeHelp(agentName: string, modeName: string): string {
        return this.executionManager.getModeHelp(agentName, modeName);
    }

    /**
     * Execute a mode on an agent
     */
    async executeAgentMode(agentName: string, mode: string, params: any): Promise<any> {
        return await this.executionManager.executeAgentModeWithValidation(agentName, mode, params);
    }

    /**
     * Get server configuration summary
     */
    getConfigurationSummary(): any {
        return this.configuration.getConfigurationSummary();
    }

    /**
     * Get server diagnostics
     */
    async getDiagnostics(): Promise<any> {
        return await this.lifecycleManager.getDiagnostics();
    }

    /**
     * Perform health check
     */
    async performHealthCheck(): Promise<any> {
        return await this.lifecycleManager.performHealthCheck();
    }

    /**
     * Get execution statistics
     */
    getExecutionStatistics(): any {
        return this.executionManager.getExecutionStatistics();
    }

    /**
     * Get request handler statistics
     */
    getRequestHandlerStatistics(): any {
        return this.requestHandlerFactory.getHandlerStatistics();
    }

    /**
     * Restart the server
     */
    async restart(): Promise<void> {
        await this.lifecycleManager.restartServer();
    }

    /**
     * Force shutdown (emergency stop)
     */
    async forceShutdown(): Promise<void> {
        await this.lifecycleManager.forceShutdown();
    }

    /**
     * Get detailed server status
     */
    getDetailedStatus(): any {
        return this.lifecycleManager.getDetailedStatus();
    }

    /**
     * Get agent statistics
     */
    getAgentStatistics(): any {
        return this.agentRegistry.getAgentStatistics();
    }

    /**
     * Get transport status
     */
    getTransportStatus(): {
        http: any;
        ipc: any;
    } {
        return {
            http: this.httpTransportManager.getTransportStatus(),
            ipc: this.ipcTransportManager.getTransportStatus()
        };
    }

    /**
     * Get HTTP server URL for MCP integration
     */
    getServerUrl(): string {
        return this.httpTransportManager.getServerUrl();
    }

    /**
     * Validate execution parameters
     */
    validateExecutionParameters(agentName: string, mode: string, params: any): any {
        return this.executionManager.validateExecutionParameters(agentName, mode, params);
    }

    /**
     * Get execution context info
     */
    getExecutionContextInfo(sessionId?: string): any {
        return this.executionManager.getExecutionContextInfo(sessionId);
    }

    /**
     * Get agent mode schema
     */
    getAgentModeSchema(agentName: string, modeName: string): any {
        return this.executionManager.getAgentModeSchema(agentName, modeName);
    }

    /**
     * Update server configuration
     */
    updateConfiguration(updates: any): void {
        if (updates.capabilities) {
            this.configuration.updateCapabilities(updates.capabilities);
        }
    }

    /**
     * Reinitialize request router with current agents
     * Call this after agents have been registered
     */
    reinitializeRequestRouter(): void {
        try {
            this.requestRouter = new RequestRouter(
                this.app,
                this.agentRegistry.getAgents(),
                true, // isVaultEnabled
                this.configuration.getSanitizedVaultName(),
                this.sessionContextManager,
                this.customPromptStorage,
                this.onToolResponse // Callback should be available as class property
            );
            
            // Register WorkspaceSchemaProvider after RequestRouter is created with agents
            this.requestRouter.registerWorkspaceSchemaProvider().catch(error => {
                logger.systemError(error as Error, 'WorkspaceSchemaProvider Registration');
            });
            
            // Reinitialize request handlers with new router
            this.requestHandlerFactory = new RequestHandlerFactory(
                this.server,
                this.requestRouter,
                this.onToolCall
            );
            this.requestHandlerFactory.initializeHandlers();
        } catch (error) {
            logger.systemError(error as Error, 'Request Router Reinitialization');
            throw error;
        }
    }

    /**
     * Get server info
     */
    getServerInfo(): any {
        return {
            configuration: this.configuration.getConfigurationSummary(),
            status: this.getDetailedStatus(),
            agents: this.getAgentStatistics(),
            transports: this.getTransportStatus(),
            handlers: this.getRequestHandlerStatistics(),
            execution: this.getExecutionStatistics()
        };
    }
}
```

## server/services/AgentRegistry.ts

```typescript
/**
 * AgentRegistry - Handles agent registration and management
 * Follows Single Responsibility Principle by focusing only on agent operations
 */

import { IAgent } from '../../agents/interfaces/IAgent';
import { NexusError, NexusErrorCode } from '../../utils/errors';
import { logger } from '../../utils/logger';

/**
 * Service responsible for agent registration and management
 * Follows SRP by focusing only on agent operations
 */
export class AgentRegistry {
    private agents: Map<string, IAgent> = new Map();

    /**
     * Register an agent with the registry
     */
    registerAgent(agent: IAgent): void {
        if (this.agents.has(agent.name)) {
            throw new NexusError(
                NexusErrorCode.InvalidParams,
                `Agent ${agent.name} is already registered`
            );
        }

        this.agents.set(agent.name, agent);
        logger.systemLog(`Agent registered: ${agent.name}`);
    }

    /**
     * Get an agent by name
     */
    getAgent(name: string): IAgent {
        const agent = this.agents.get(name);
        
        if (!agent) {
            throw new NexusError(
                NexusErrorCode.InvalidParams,
                `Agent ${name} not found`
            );
        }

        return agent;
    }

    /**
     * Check if an agent is registered
     */
    hasAgent(name: string): boolean {
        return this.agents.has(name);
    }

    /**
     * Get all registered agents
     */
    getAgents(): Map<string, IAgent> {
        return new Map(this.agents);
    }

    /**
     * Get all agent names
     */
    getAgentNames(): string[] {
        return Array.from(this.agents.keys());
    }

    /**
     * Remove an agent from the registry
     */
    unregisterAgent(name: string): boolean {
        const removed = this.agents.delete(name);
        
        if (removed) {
            logger.systemLog(`Agent unregistered: ${name}`);
        }
        
        return removed;
    }

    /**
     * Initialize all registered agents
     */
    async initializeAgents(): Promise<void> {
        const initPromises = Array.from(this.agents.values()).map(async (agent) => {
            try {
                await agent.initialize();
                logger.systemLog(`Agent initialized: ${agent.name}`);
            } catch (error) {
                logger.systemError(error as Error, `Agent Initialization: ${agent.name}`);
                throw error;
            }
        });

        await Promise.all(initPromises);
    }

    /**
     * Get agent count
     */
    getAgentCount(): number {
        return this.agents.size;
    }

    /**
     * Clear all agents
     */
    clearAgents(): void {
        this.agents.clear();
    }

    /**
     * Get agent statistics
     */
    getAgentStatistics(): {
        totalAgents: number;
        agentNames: string[];
        agentInfo: Array<{
            name: string;
            description: string;
            toolCount: number;
        }>;
    } {
        const agentInfo = Array.from(this.agents.values()).map(agent => {
            try {
                const tools = agent.getTools();
                return {
                    name: agent.name,
                    description: agent.description,
                    toolCount: tools.length
                };
            } catch (error) {
                return {
                    name: agent.name,
                    description: agent.description,
                    toolCount: 0
                };
            }
        });

        return {
            totalAgents: this.agents.size,
            agentNames: this.getAgentNames(),
            agentInfo
        };
    }

    /**
     * Validate agent exists and get it
     */
    validateAndGetAgent(name: string): IAgent {
        if (!name || typeof name !== 'string') {
            throw new NexusError(
                NexusErrorCode.InvalidParams,
                'Agent name must be a non-empty string'
            );
        }

        return this.getAgent(name);
    }

    /**
     * Get agent tool help
     */
    getAgentToolHelp(agentName: string, toolName: string): string {
        const agent = this.validateAndGetAgent(agentName);
        const tool = agent.getTool(toolName);

        if (!tool) {
            throw new NexusError(
                NexusErrorCode.InvalidParams,
                `Tool ${toolName} not found in agent ${agentName}`
            );
        }

        const toolWithHelp = tool as { getHelpText?: () => string };
        return toolWithHelp.getHelpText?.() || `Help for ${agentName}.${toolName}`;
    }

    /**
     * @deprecated Use getAgentToolHelp instead
     */
    getAgentModeHelp(agentName: string, modeName: string): string {
        return this.getAgentToolHelp(agentName, modeName);
    }

    /**
     * Check if agent supports a specific tool
     */
    agentSupportsTool(agentName: string, toolName: string): boolean {
        try {
            const agent = this.getAgent(agentName);
            return agent.getTool(toolName) !== undefined;
        } catch (error) {
            return false;
        }
    }

    /**
     * @deprecated Use agentSupportsTool instead
     */
    agentSupportsMode(agentName: string, modeName: string): boolean {
        return this.agentSupportsTool(agentName, modeName);
    }

    /**
     * Get all available tools across all agents
     */
    getAllAvailableTools(): Array<{
        agentName: string;
        toolName: string;
        description: string;
    }> {
        const allTools: Array<{
            agentName: string;
            toolName: string;
            description: string;
        }> = [];

        for (const [agentName, agent] of this.agents) {
            try {
                const tools = agent.getTools();
                for (const tool of tools) {
                    allTools.push({
                        agentName,
                        toolName: tool.name,
                        description: tool.description
                    });
                }
            } catch (error) {
                logger.systemError(error as Error, `Tool Enumeration: ${agentName}`);
            }
        }

        return allTools;
    }

    /**
     * @deprecated Use getAllAvailableTools instead
     */
    getAllAvailableModes(): Array<{
        agentName: string;
        modeName: string;
        description: string;
    }> {
        // Convert tool names to legacy mode names for backward compatibility
        return this.getAllAvailableTools().map(t => ({
            agentName: t.agentName,
            modeName: t.toolName,
            description: t.description
        }));
    }
}
```

## server/services/ServerConfiguration.ts

```typescript
/**
 * ServerConfiguration - Handles server configuration and identification
 * Follows Single Responsibility Principle by focusing only on configuration
 */

import { App } from 'obsidian';
import { sanitizeVaultName } from '../../utils/vaultUtils';
import { logger } from '../../utils/logger';
import { platform } from 'os';
import { getPrimaryServerKey, getPrimaryIpcPath } from '../../constants/branding';

export interface ServerConfigurationOptions {
    serverName?: string;
    vaultName?: string;
    capabilities?: any;
}

/**
 * Service responsible for server configuration management
 * Follows SRP by focusing only on configuration operations
 */
export class ServerConfiguration {
    private serverName?: string;
    private vaultName: string;
    private sanitizedVaultName: string;
    private capabilities: any;

    constructor(
        private app: App,
        options: ServerConfigurationOptions = {}
    ) {
        this.serverName = options.serverName;
        this.vaultName = options.vaultName || this.getVaultName();
        this.sanitizedVaultName = sanitizeVaultName(this.vaultName);
        this.capabilities = options.capabilities || this.getDefaultCapabilities();
    }

    /**
     * Get the vault name from the app
     */
    private getVaultName(): string {
        try {
            return this.app.vault.getName();
        } catch (error) {
            logger.systemError(error as Error, 'Vault Name Retrieval');
            return 'default';
        }
    }

    /**
     * Get default server capabilities
     */
    private getDefaultCapabilities(): any {
        return {
            resources: {
                supportsUriTemplates: true,
                supportsContentWatch: false,
                supportsListWatch: false
            },
            tools: {
                supportsToolDescriptionMarkdown: true,
                supportsToolArgumentsMarkdown: true
            },
            prompts: {}
        };
    }

    /**
     * Get the server identifier
     */
    getServerIdentifier(): string {
        if (this.serverName) {
            return this.serverName;
        }
        
        return getPrimaryServerKey(this.vaultName);
    }

    /**
     * Get the server info for SDK initialization
     */
    getServerInfo(): { name: string; version: string } {
        return {
            name: this.getServerIdentifier(),
            version: "1.0.0"
        };
    }

    /**
     * Get server options for SDK initialization
     */
    getServerOptions(): { capabilities: any } {
        return {
            capabilities: this.capabilities
        };
    }

    /**
     * Get the IPC path for this server
     */
    getIPCPath(): string {
        return getPrimaryIpcPath(this.vaultName, this.isWindows());
    }

    /**
     * Get the vault name
     */
    getVaultNameValue(): string {
        return this.vaultName;
    }

    /**
     * Get the sanitized vault name
     */
    getSanitizedVaultName(): string {
        return this.sanitizedVaultName;
    }

    /**
     * Get the server capabilities
     */
    getCapabilities(): any {
        return this.capabilities;
    }

    /**
     * Update server capabilities
     */
    updateCapabilities(capabilities: any): void {
        this.capabilities = { ...this.capabilities, ...capabilities };
    }

    /**
     * Check if this is a Windows platform
     */
    isWindows(): boolean {
        return platform() === 'win32';
    }

    /**
     * Get configuration summary
     */
    getConfigurationSummary(): {
        serverIdentifier: string;
        vaultName: string;
        sanitizedVaultName: string;
        ipcPath: string;
        isWindows: boolean;
        hasCustomName: boolean;
    } {
        return {
            serverIdentifier: this.getServerIdentifier(),
            vaultName: this.vaultName,
            sanitizedVaultName: this.sanitizedVaultName,
            ipcPath: this.getIPCPath(),
            isWindows: this.isWindows(),
            hasCustomName: !!this.serverName
        };
    }
}

```

## server/transport/HttpTransportManager.ts

```typescript
/**
 * HttpTransportManager - Modern HTTP transport using StreamableHTTPServerTransport
 * Based on MCP SDK examples and supports the latest protocol
 */

import { Server as MCPSDKServer } from '@modelcontextprotocol/sdk/server/index.js';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import { McpError, ErrorCode, isInitializeRequest } from '@modelcontextprotocol/sdk/types.js';
import { logger } from '../../utils/logger';
import { randomUUID } from 'node:crypto';
import http from 'http';
import express from 'express';
import cors from 'cors';
import { SERVER_LABELS } from '../../constants/branding';

/**
 * Modern HTTP transport manager using StreamableHTTP
 * Supports both JSON response mode and streaming
 */
export class HttpTransportManager {
    private httpServer: http.Server | null = null;
    private app: express.Application;
    private isRunning: boolean = false;
    private port: number;
    private host: string;
    private transports: { [sessionId: string]: StreamableHTTPServerTransport } = {};

    constructor(
        private server: MCPSDKServer, 
        port: number = 3000, 
        host: string = 'localhost'
    ) {
        this.port = port;
        this.host = host;
        this.app = express();
        this.setupMiddleware();
        this.setupRoutes();
    }

    /**
     * Setup Express middleware
     */
    private setupMiddleware(): void {
        // Enable CORS for cross-origin requests
        this.app.use(cors({
            origin: '*',
            methods: ['GET', 'POST', 'OPTIONS'],
            allowedHeaders: ['Content-Type', 'Authorization']
        }));
        
        // Parse JSON bodies
        this.app.use(express.json());

        // Add request logging
        this.app.use((req, res, next) => {
            logger.systemLog(`[HTTP Transport] ${req.method} ${req.path} from ${req.ip}`);
            next();
        });
    }

    /**
     * Setup Express routes for MCP
     */
    private setupRoutes(): void {
        // Health check endpoint
        this.app.get('/health', (req, res) => {
            res.json({
                status: 'healthy',
                server: SERVER_LABELS.current,
                timestamp: new Date().toISOString()
            });
        });

        // Main MCP endpoint (supports both initialization and regular requests)
        this.app.post('/sse', async (req, res) => {
            try {
                await this.handleMCPRequest(req, res);
            } catch (error) {
                logger.systemError(error as Error, 'MCP Request Handler');
                if (!res.headersSent) {
                    res.status(500).json({
                        jsonrpc: '2.0',
                        error: {
                            code: -32603,
                            message: 'Internal server error',
                        },
                        id: null,
                    });
                }
            }
        });

        // Alternative endpoint for compatibility
        this.app.post('/mcp', async (req, res) => {
            try {
                await this.handleMCPRequest(req, res);
            } catch (error) {
                logger.systemError(error as Error, 'MCP Request Handler');
                if (!res.headersSent) {
                    res.status(500).json({
                        jsonrpc: '2.0',
                        error: {
                            code: -32603,
                            message: 'Internal server error',
                        },
                        id: null,
                    });
                }
            }
        });
    }

    /**
     * Handle MCP requests (both initialization and regular requests)
     */
    private async handleMCPRequest(req: express.Request, res: express.Response): Promise<void> {
        const sessionId = req.headers['x-session-id'] as string;
        
        let transport: StreamableHTTPServerTransport;
        
        if (sessionId && this.transports[sessionId]) {
            // Reuse existing transport
            transport = this.transports[sessionId];
            logger.systemLog(`[HTTP Transport] Reusing session: ${sessionId}`);
        } else if (!sessionId && isInitializeRequest(req.body)) {
            // New initialization request - create new transport
            logger.systemLog(`[HTTP Transport] Creating new session for initialization`);
            
            transport = new StreamableHTTPServerTransport({
                sessionIdGenerator: () => randomUUID(),
                enableJsonResponse: true, // Enable JSON response mode for OpenAI MCP
                onsessioninitialized: (newSessionId: string) => {
                    logger.systemLog(`[HTTP Transport] Session initialized: ${newSessionId}`);
                    this.transports[newSessionId] = transport;
                }
            });
            
            // Connect the transport to the MCP server
            await this.server.connect(transport);
            
            // Handle the initialization request
            await transport.handleRequest(req, res, req.body);
            return;
        } else {
            // Invalid request - no session ID or not initialization request
            logger.systemWarn(`[HTTP Transport] Invalid request: sessionId=${sessionId}, isInit=${isInitializeRequest(req.body)}`);
            res.status(400).json({
                jsonrpc: '2.0',
                error: {
                    code: -32000,
                    message: 'Bad Request: No valid session ID provided or not initialization request',
                },
                id: null,
            });
            return;
        }
        
        // Handle regular request with existing transport
        await transport.handleRequest(req, res, req.body);
    }

    /**
     * Start the HTTP transport
     */
    async startTransport(): Promise<{ httpServer: http.Server; app: express.Application }> {
        if (this.httpServer) {
            return { httpServer: this.httpServer, app: this.app };
        }
        try {
            // Create HTTP server with Express app
            this.httpServer = http.createServer(this.app);
            
            // Start HTTP server
            await new Promise<void>((resolve, reject) => {
                this.httpServer!.listen(this.port, this.host, () => {
                    this.isRunning = true;
                    logger.systemLog(`HTTP MCP server started on ${this.host}:${this.port}`);
                    logger.systemLog(`MCP endpoint available at: http://${this.host}:${this.port}/sse`);
                    resolve();
                });
                
                this.httpServer!.on('error', (error: NodeJS.ErrnoException) => {
                    if (error.code === 'EADDRINUSE') {
                        logger.systemError(error, `Port ${this.port} is already in use`);
                    } else {
                        logger.systemError(error, 'HTTP Server Start');
                    }
                    reject(error);
                });
            });

            logger.systemLog('HTTP transport started successfully');
            
            return { httpServer: this.httpServer, app: this.app };
        } catch (error) {
            logger.systemError(error as Error, 'HTTP Transport Start');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to start HTTP transport',
                error
            );
        }
    }

    /**
     * Stop the HTTP transport
     */
    async stopTransport(): Promise<void> {
        if (!this.httpServer) {
            return; // Nothing to stop
        }

        try {
            // Close all active transports
            for (const sessionId in this.transports) {
                try {
                    logger.systemLog(`Closing transport for session ${sessionId}`);
                    await this.transports[sessionId].close();
                    delete this.transports[sessionId];
                } catch (error) {
                    logger.systemError(error as Error, `Error closing transport for session ${sessionId}`);
                }
            }

            // Close HTTP server
            await new Promise<void>((resolve, reject) => {
                this.httpServer!.close((error) => {
                    if (error) {
                        reject(error);
                    } else {
                        this.httpServer = null;
                        this.isRunning = false;
                        logger.systemLog('HTTP transport stopped successfully');
                        resolve();
                    }
                });
            });
        } catch (error) {
            logger.systemError(error as Error, 'HTTP Transport Stop');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to stop HTTP transport',
                error
            );
        }
    }

    /**
     * Get transport status
     */
    getTransportStatus(): {
        isRunning: boolean;
        endpoint?: string;
        port: number;
        host: string;
        activeSessions: number;
        sessions: string[];
    } {
        return {
            isRunning: this.isRunning,
            endpoint: this.isRunning ? `http://${this.host}:${this.port}/sse` : undefined,
            port: this.port,
            host: this.host,
            activeSessions: Object.keys(this.transports).length,
            sessions: Object.keys(this.transports)
        };
    }

    /**
     * Check if transport is running
     */
    isTransportRunning(): boolean {
        return this.isRunning;
    }

    /**
     * Get the server endpoint URL
     */
    getServerUrl(): string {
        if (!this.isRunning) {
            throw new McpError(
                ErrorCode.InternalError,
                'Cannot get server URL: transport not running'
            );
        }
        return `http://${this.host}:${this.port}/sse`;
    }

    /**
     * Update port configuration (only when stopped)
     */
    setPort(port: number): void {
        if (this.isRunning) {
            throw new McpError(
                ErrorCode.InvalidParams,
                'Cannot change port while transport is running'
            );
        }
        this.port = port;
    }

    /**
     * Update host configuration (only when stopped)
     */
    setHost(host: string): void {
        if (this.isRunning) {
            throw new McpError(
                ErrorCode.InvalidParams,
                'Cannot change host while transport is running'
            );
        }
        this.host = host;
    }

    /**
     * Get active session count
     */
    getActiveSessionCount(): number {
        return Object.keys(this.transports).length;
    }

    /**
     * Clean up a specific session
     */
    async cleanupSession(sessionId: string): Promise<void> {
        const transport = this.transports[sessionId];
        if (transport) {
            try {
                await transport.close();
                delete this.transports[sessionId];
                logger.systemLog(`Cleaned up session: ${sessionId}`);
            } catch (error) {
                logger.systemError(error as Error, `Error cleaning up session ${sessionId}`);
            }
        }
    }
}

```

## server/transport/IPCTransportManager.ts

```typescript
/**
 * IPCTransportManager - Handles IPC transport management
 * Follows Single Responsibility Principle by focusing only on IPC transport
 */

import { Server as NetServer, createServer } from 'net';
import { promises as fs } from 'fs';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { Server as MCPSDKServer } from '@modelcontextprotocol/sdk/server/index.js';
import { ServerConfiguration } from '../services/ServerConfiguration';
import { StdioTransportManager } from './StdioTransportManager';
import { logger } from '../../utils/logger';

/**
 * Service responsible for IPC transport management
 * Follows SRP by focusing only on IPC transport operations
 */
export class IPCTransportManager {
    private ipcServer: NetServer | null = null;
    private isRunning: boolean = false;

    constructor(
        private configuration: ServerConfiguration,
        private stdioTransportManager: StdioTransportManager
    ) {}

    /**
     * Start the IPC transport server
     */
    async startTransport(): Promise<NetServer> {
        if (this.ipcServer) {
            return this.ipcServer;
        }

        const isWindows = this.configuration.isWindows();
        const ipcPath = this.configuration.getIPCPath();

        if (!isWindows) {
            await this.cleanupSocket();
        }

        return new Promise((resolve, reject) => {
            try {
                const server = createServer((socket) => {
                    this.handleSocketConnection(socket);
                });

                this.setupServerErrorHandling(server, ipcPath, isWindows, reject);
                this.startListening(server, ipcPath, isWindows, resolve, reject);
            } catch (error) {
                logger.systemError(error as Error, 'IPC Server Creation');
                reject(error);
            }
        });
    }

    /**
     * Handle new socket connections
     */
    private handleSocketConnection(socket: NodeJS.ReadWriteStream): void {
        try {
            const transport = this.stdioTransportManager.createSocketTransport(socket, socket);
            
            this.stdioTransportManager.connectSocketTransport(transport)
                .then(() => {
                    logger.systemLog('IPC socket connected successfully');
                })
                .catch(error => {
                    logger.systemError(error as Error, 'IPC Socket Connection');
                });
        } catch (error) {
            logger.systemError(error as Error, 'IPC Socket Handling');
        }
    }

    /**
     * Setup server error handling
     */
    private setupServerErrorHandling(
        server: NetServer,
        ipcPath: string,
        isWindows: boolean,
        reject: (error: Error) => void
    ): void {
        server.on('error', (error) => {
            logger.systemError(error as Error, 'IPC Server');
            
            if (!isWindows && (error as NodeJS.ErrnoException).code === 'EADDRINUSE') {
                this.handleAddressInUse(server, ipcPath, reject);
            } else {
                reject(error);
            }
        });
    }

    /**
     * Handle address in use error
     */
    private handleAddressInUse(
        server: NetServer,
        ipcPath: string,
        reject: (error: Error) => void
    ): void {
        this.cleanupSocket()
            .then(() => {
                try {
                    server.listen(ipcPath);
                } catch (listenError) {
                    logger.systemError(listenError as Error, 'Server Listen Retry');
                    reject(listenError as Error);
                }
            })
            .catch(cleanupError => {
                logger.systemError(cleanupError as Error, 'Socket Cleanup');
                reject(cleanupError);
            });
    }

    /**
     * Start listening on the IPC path
     */
    private startListening(
        server: NetServer,
        ipcPath: string,
        isWindows: boolean,
        resolve: (server: NetServer) => void,
        reject: (error: Error) => void
    ): void {
        server.listen(ipcPath, () => {
            this.handleListeningStarted(server, ipcPath, isWindows, resolve, reject);
        });
    }

    /**
     * Handle successful listening start
     */
    private handleListeningStarted(
        server: NetServer,
        ipcPath: string,
        isWindows: boolean,
        resolve: (server: NetServer) => void,
        reject: (error: Error) => void
    ): void {
        if (!isWindows) {
            fs.chmod(ipcPath, 0o666).catch(error => {
                logger.systemError(error as Error, 'Socket Permissions');
            });
        }

        this.ipcServer = server;
        this.isRunning = true;
        
        logger.systemLog(`IPC server started on path: ${ipcPath}`);
        resolve(server);
    }

    /**
     * Stop the IPC transport server
     */
    async stopTransport(): Promise<void> {
        if (!this.ipcServer) {
            return;
        }

        try {
            this.ipcServer.close();
            this.ipcServer = null;
            this.isRunning = false;
            
            await this.cleanupSocket();
            
            logger.systemLog('IPC transport stopped successfully');
        } catch (error) {
            logger.systemError(error as Error, 'IPC Transport Stop');
            throw error;
        }
    }

    /**
     * Clean up the socket file
     */
    private async cleanupSocket(): Promise<void> {
        if (this.configuration.isWindows()) {
            return;
        }

        try {
            await fs.unlink(this.configuration.getIPCPath());
        } catch (error) {
            // Ignore if file doesn't exist
            if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
                logger.systemError(error as Error, 'Socket Cleanup');
            }
        }
    }

    /**
     * Check if the transport is running
     */
    isTransportRunning(): boolean {
        return this.isRunning && this.ipcServer !== null;
    }

    /**
     * Get the server instance
     */
    getServer(): NetServer | null {
        return this.ipcServer;
    }

    /**
     * Restart the transport
     */
    async restartTransport(): Promise<NetServer> {
        await this.stopTransport();
        return await this.startTransport();
    }

    /**
     * Get transport status
     */
    getTransportStatus(): {
        isRunning: boolean;
        hasServer: boolean;
        transportType: string;
        ipcPath: string;
        isWindows: boolean;
    } {
        return {
            isRunning: this.isRunning,
            hasServer: this.ipcServer !== null,
            transportType: 'ipc',
            ipcPath: this.configuration.getIPCPath(),
            isWindows: this.configuration.isWindows()
        };
    }

    /**
     * Get transport diagnostics
     */
    getDiagnostics(): {
        transportType: string;
        isRunning: boolean;
        hasServer: boolean;
        ipcPath: string;
        isWindows: boolean;
        socketExists?: boolean;
    } {
        type DiagnosticsWithSocket = {
            transportType: string;
            isRunning: boolean;
            hasServer: boolean;
            ipcPath: string;
            isWindows: boolean;
        } & { socketExists?: boolean };

        const diagnostics: DiagnosticsWithSocket = {
            transportType: 'ipc',
            isRunning: this.isRunning,
            hasServer: this.ipcServer !== null,
            ipcPath: this.configuration.getIPCPath(),
            isWindows: this.configuration.isWindows()
        };

        // Check if socket exists (for Unix systems)
        if (!this.configuration.isWindows()) {
            try {
                fs.access(this.configuration.getIPCPath())
                    .then(() => {
                        diagnostics.socketExists = true;
                    })
                    .catch(() => {
                        diagnostics.socketExists = false;
                    });
            } catch (error) {
                diagnostics.socketExists = false;
            }
        }

        return diagnostics;
    }

    /**
     * Force cleanup socket (for emergency cleanup)
     */
    async forceCleanupSocket(): Promise<void> {
        if (this.configuration.isWindows()) {
            return;
        }

        try {
            await fs.unlink(this.configuration.getIPCPath());
            logger.systemLog('Socket force cleaned up successfully');
        } catch (error) {
            logger.systemError(error as Error, 'Force Socket Cleanup');
        }
    }
}
```

## server/transport/StdioTransportManager.ts

```typescript
/**
 * StdioTransportManager - Handles STDIO transport management
 * Follows Single Responsibility Principle by focusing only on STDIO transport
 */

import { Server as MCPSDKServer } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';
import { logger } from '../../utils/logger';

/**
 * Service responsible for STDIO transport management
 * Follows SRP by focusing only on STDIO transport operations
 */
export class StdioTransportManager {
    private stdioTransport: StdioServerTransport | null = null;
    private isConnected: boolean = false;

    constructor(private server: MCPSDKServer) {}

    /**
     * Start the STDIO transport
     */
    async startTransport(): Promise<StdioServerTransport> {
        if (this.stdioTransport) {
            return this.stdioTransport;
        }

        try {
            const transport = new StdioServerTransport();
            
            await this.server.connect(transport);
            
            this.stdioTransport = transport;
            this.isConnected = true;
            
            logger.systemLog('STDIO transport started successfully');
            
            return transport;
        } catch (error) {
            logger.systemError(error as Error, 'STDIO Transport Start');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to start STDIO transport',
                error
            );
        }
    }

    /**
     * Stop the STDIO transport
     */
    async stopTransport(): Promise<void> {
        if (!this.stdioTransport) {
            return;
        }

        try {
            await this.stdioTransport.close();
            this.stdioTransport = null;
            this.isConnected = false;
            
            logger.systemLog('STDIO transport stopped successfully');
        } catch (error) {
            logger.systemError(error as Error, 'STDIO Transport Stop');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to stop STDIO transport',
                error
            );
        }
    }

    /**
     * Check if the transport is connected
     */
    isTransportConnected(): boolean {
        return this.isConnected && this.stdioTransport !== null;
    }

    /**
     * Get the transport instance
     */
    getTransport(): StdioServerTransport | null {
        return this.stdioTransport;
    }

    /**
     * Restart the transport
     */
    async restartTransport(): Promise<StdioServerTransport> {
        await this.stopTransport();
        return await this.startTransport();
    }

    /**
     * Get transport status
     */
    getTransportStatus(): {
        isConnected: boolean;
        hasTransport: boolean;
        transportType: string;
    } {
        return {
            isConnected: this.isConnected,
            hasTransport: this.stdioTransport !== null,
            transportType: 'stdio'
        };
    }

    /**
     * Create a new transport instance (for socket connections)
     */
    createSocketTransport(inputStream: any, outputStream: any): StdioServerTransport {
        return new StdioServerTransport(inputStream, outputStream);
    }

    /**
     * Connect a socket transport to the server
     */
    async connectSocketTransport(transport: StdioServerTransport): Promise<void> {
        try {
            await this.server.connect(transport);
            logger.systemLog('Socket transport connected successfully');
        } catch (error) {
            logger.systemError(error as Error, 'Socket Transport Connection');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to connect socket transport',
                error
            );
        }
    }

    /**
     * Handle transport errors
     */
    handleTransportError(error: Error): void {
        logger.systemError(error, 'STDIO Transport Error');
        
        // Reset connection state
        this.isConnected = false;
        
        // Attempt to clean up
        if (this.stdioTransport) {
            try {
                this.stdioTransport.close().catch(closeError => {
                    logger.systemError(closeError as Error, 'Transport Error Cleanup');
                });
            } catch (cleanupError) {
                logger.systemError(cleanupError as Error, 'Transport Error Cleanup');
            }
        }
    }

    /**
     * Get transport diagnostics
     */
    getDiagnostics(): {
        transportType: string;
        isConnected: boolean;
        hasTransport: boolean;
        lastError?: string;
    } {
        return {
            transportType: 'stdio',
            isConnected: this.isConnected,
            hasTransport: this.stdioTransport !== null
        };
    }
}
```

## services/agent/AgentInitializationService.ts

```typescript
/**
 * Location: src/services/agent/AgentInitializationService.ts
 *
 * Purpose: Handles individual agent initialization logic
 * Extracted from AgentRegistrationService.ts to follow Single Responsibility Principle
 *
 * Used by: AgentRegistrationService for agent creation
 * Dependencies: Agent implementations, ServiceManager
 */

import { App, Plugin } from 'obsidian';
import NexusPlugin from '../../main';
import { AgentManager } from '../AgentManager';
import { ServiceManager } from '../../core/ServiceManager';
import {
  ContentManagerAgent,
  CommandManagerAgent,
  StorageManagerAgent,
  SearchManagerAgent,
  MemoryManagerAgent,
  PromptManagerAgent,
  ToolManagerAgent
} from '../../agents';
import { logger } from '../../utils/logger';
import { CustomPromptStorageService } from "../../agents/promptManager/services/CustomPromptStorageService";
import { LLMProviderManager } from '../llm/providers/ProviderManager';
import { DEFAULT_LLM_PROVIDER_SETTINGS, MCPSettings, MemorySettings } from '../../types';
import { Settings } from '../../settings';
import { MemoryService } from '../../agents/memoryManager/services/MemoryService';
import { WorkspaceService } from '../WorkspaceService';
import { VaultOperations } from '../../core/VaultOperations';
import { UsageTracker } from '../UsageTracker';

/**
 * Type guard to check if plugin has Settings
 */
function hasSettings(plugin: Plugin | NexusPlugin): plugin is NexusPlugin {
  return 'settings' in plugin && plugin.settings !== undefined;
}

/**
 * Type guard to check if plugin has services
 */
function hasServices(plugin: Plugin | NexusPlugin): plugin is NexusPlugin & { services: Record<string, unknown> } {
  return 'services' in plugin && typeof plugin.services === 'object' && plugin.services !== null;
}

/**
 * Service for initializing individual agents
 */
export class AgentInitializationService {
  constructor(
    private app: App,
    private plugin: Plugin | NexusPlugin,
    private agentManager: AgentManager,
    private serviceManager?: ServiceManager,
    private customPromptStorage?: CustomPromptStorageService
  ) {}

  /**
   * Initialize ContentManager agent
   */
  async initializeContentManager(): Promise<void> {
    const contentManagerAgent = new ContentManagerAgent(
      this.app,
      hasSettings(this.plugin) ? this.plugin : undefined
    );

    this.agentManager.registerAgent(contentManagerAgent);
    logger.systemLog('ContentManager agent initialized successfully');
  }

  /**
   * Initialize CommandManager agent
   */
  async initializeCommandManager(): Promise<void> {
    const commandManagerAgent = new CommandManagerAgent(this.app);
    this.agentManager.registerAgent(commandManagerAgent);
    logger.systemLog('CommandManager agent initialized successfully');
  }

  /**
   * Initialize StorageManager agent
   */
  async initializeStorageManager(): Promise<void> {
    const storageManagerAgent = new StorageManagerAgent(this.app);

    this.agentManager.registerAgent(storageManagerAgent);
    logger.systemLog('StorageManager agent initialized successfully');
  }

  /**
   * Initialize PromptManager agent
   */
  async initializePromptManager(enableLLMModes: boolean): Promise<void> {
    if (!this.customPromptStorage) {
      // Try to create custom prompt storage directly if settings are available
      if (hasSettings(this.plugin)) {
        try {
          this.customPromptStorage = new CustomPromptStorageService(this.plugin.settings);
          logger.systemLog('AgentManager - created custom prompt storage during initialization');
        } catch (error) {
          logger.systemError(error as Error, 'AgentManager - Failed to create custom prompt storage');
          return;
        }
      } else {
        logger.systemError(new Error('Plugin settings not available'), 'AgentManager agent initialization');
        return;
      }
    }

    // Initialize LLM Provider Manager if LLM modes are enabled
    let llmProviderManager: LLMProviderManager | null = null;
    let usageTracker: UsageTracker | null = null;

    if (enableLLMModes) {
      try {
        // Get LLM provider settings from plugin settings or use defaults
        const pluginSettings = hasSettings(this.plugin) ? this.plugin.settings.settings : undefined;
        const llmProviderSettings = pluginSettings?.llmProviders || DEFAULT_LLM_PROVIDER_SETTINGS;

        // Create LLM Provider Manager with vault for Nexus (WebLLM) support
        llmProviderManager = new LLMProviderManager(llmProviderSettings, this.app.vault);

        if (this.serviceManager) {
          try {
            const vaultOperations = await this.serviceManager.getService('vaultOperations');
            if (vaultOperations) {
              llmProviderManager.setVaultOperations(vaultOperations);
            }
          } catch (error) {
          }
        }

        // Create usage tracker
        const { UsageTracker } = await import('../UsageTracker');
        usageTracker = new UsageTracker('llm', pluginSettings);

      } catch (error) {
        logger.systemError(error as Error, 'LLM Provider Manager Initialization');
        // Continue without LLM modes - basic prompt management will still work
      }
    } else {
      logger.systemLog('LLM modes disabled - AgentManager will function with prompt management only');
    }

    // Create PromptManagerAgent with constructor injection
    if (llmProviderManager && usageTracker && hasSettings(this.plugin)) {
      const promptManagerAgent = new PromptManagerAgent(
        this.plugin.settings,
        llmProviderManager,
        this.agentManager,
        usageTracker,
        this.app.vault
      );

      this.agentManager.registerAgent(promptManagerAgent);
      logger.systemLog(`PromptManager agent created with full LLM support - LLM modes enabled: ${enableLLMModes}`);
    } else {
      // Create basic PromptManager with minimal dependencies for prompt management
      try {
        // Create minimal LLM provider manager and usage tracker for basic functionality
        const pluginSettings = hasSettings(this.plugin) ? this.plugin.settings.settings : undefined;
        const llmProviderSettings = pluginSettings?.llmProviders || DEFAULT_LLM_PROVIDER_SETTINGS;

        const minimalProviderManager = new LLMProviderManager(llmProviderSettings, this.app.vault);
        const minimalUsageTracker = new UsageTracker('llm', pluginSettings);

        if (!hasSettings(this.plugin)) {
          logger.systemError(new Error('Plugin settings not available for basic PromptManager'), 'Basic PromptManager Creation');
          return;
        }

        const promptManagerAgent = new PromptManagerAgent(
          this.plugin.settings,
          minimalProviderManager,
          this.agentManager,
          minimalUsageTracker,
          this.app.vault
        );

        this.agentManager.registerAgent(promptManagerAgent);
        logger.systemLog('PromptManager agent created with basic support - LLM features may be limited');
      } catch (basicError) {
        logger.systemError(basicError as Error, 'Basic PromptManager Creation');
        logger.systemLog('PromptManager agent creation failed - prompt management features unavailable');
      }
    }
  }

  /**
   * Initialize SearchManager agent
   */
  async initializeSearchManager(enableSearchModes: boolean, memorySettings: MemorySettings): Promise<void> {
    // Get required services
    let memoryService: MemoryService | null = null;
    let workspaceService: WorkspaceService | null = null;

    if (this.serviceManager) {
      memoryService = this.serviceManager.getServiceIfReady<MemoryService>('memoryService');
      workspaceService = this.serviceManager.getServiceIfReady<WorkspaceService>('workspaceService');
    } else if (hasServices(this.plugin)) {
      // Fallback to plugin's direct service access
      memoryService = this.plugin.services.memoryService as MemoryService | undefined || null;
      workspaceService = this.plugin.services.workspaceService as WorkspaceService | undefined || null;
    }

    const searchManagerAgent = new SearchManagerAgent(
      this.app,
      enableSearchModes,  // Pass search modes enabled status
      memoryService,
      workspaceService
    );

    // Update SearchManager with memory settings
    if (memorySettings) {
      searchManagerAgent.updateSettings(memorySettings);
    }

    this.agentManager.registerAgent(searchManagerAgent);
    logger.systemLog('SearchManager agent initialized successfully');
  }

  /**
   * Initialize MemoryManager agent
   */
  async initializeMemoryManager(): Promise<void> {
    // Get required services - try ServiceManager first, then plugin direct access
    let memoryService: MemoryService | null = null;
    let workspaceService: WorkspaceService | null = null;

    if (this.serviceManager) {
      memoryService = this.serviceManager.getServiceIfReady<MemoryService>('memoryService');
      workspaceService = this.serviceManager.getServiceIfReady<WorkspaceService>('workspaceService');
    } else if (hasServices(this.plugin)) {
      // Fallback to plugin's direct service access
      memoryService = this.plugin.services.memoryService as MemoryService | undefined || null;
      workspaceService = this.plugin.services.workspaceService as WorkspaceService | undefined || null;
    }

    if (!memoryService || !workspaceService) {
      logger.systemError(new Error(`Required services not available - memoryService: ${!!memoryService}, workspaceService: ${!!workspaceService}`), 'MemoryManager Agent Initialization');
      return;
    }

    const memoryManagerAgent = new MemoryManagerAgent(
      this.app,
      this.plugin,
      memoryService,
      workspaceService
    );

    this.agentManager.registerAgent(memoryManagerAgent);
    logger.systemLog('MemoryManager agent initialized successfully');
  }

  /**
   * Initialize ToolManager agent
   * MUST be called AFTER all other agents are initialized
   * ToolManager needs access to all registered agents for tool discovery/execution
   */
  async initializeToolManager(): Promise<void> {
    // Get all currently registered agents as a Map
    const agents = this.agentManager.getAgents();
    const agentRegistry = new Map<string, typeof agents[0]>();
    for (const agent of agents) {
      agentRegistry.set(agent.name, agent);
    }

    // Build schema data for dynamic tool descriptions
    const schemaData = await this.buildSchemaData();

    // Create ToolManagerAgent with the full agent registry and schema data
    const toolManagerAgent = new ToolManagerAgent(this.app, agentRegistry, schemaData);

    this.agentManager.registerAgent(toolManagerAgent);
    logger.systemLog(`ToolManager agent initialized successfully with ${agentRegistry.size} agents`);
  }

  /**
   * Build schema data for ToolManager
   * Fetches workspaces, custom agents, and vault root structure
   */
  private async buildSchemaData(): Promise<{
    workspaces: { name: string; description?: string }[];
    customAgents: { name: string; description?: string }[];
    vaultRoot: string[];
  }> {
    const schemaData: {
      workspaces: { name: string; description?: string }[];
      customAgents: { name: string; description?: string }[];
      vaultRoot: string[];
    } = {
      workspaces: [],
      customAgents: [],
      vaultRoot: []
    };

    // Fetch workspaces
    try {
      let workspaceService: WorkspaceService | null = null;

      if (this.serviceManager) {
        workspaceService = this.serviceManager.getServiceIfReady<WorkspaceService>('workspaceService');
      } else if (hasServices(this.plugin)) {
        workspaceService = this.plugin.services.workspaceService as WorkspaceService | undefined || null;
      }

      if (workspaceService) {
        const workspaces = await workspaceService.listWorkspaces();
        schemaData.workspaces = workspaces.map(w => ({
          name: w.name,
          description: w.description
        }));
      }
    } catch (error) {
      logger.systemWarn('Failed to fetch workspaces for schema data');
    }

    // Fetch custom agents
    try {
      if (this.customPromptStorage) {
        const prompts = await this.customPromptStorage.getAllPrompts();
        schemaData.customAgents = prompts.map(p => ({
          name: p.name,
          description: p.description
        }));
      }
    } catch (error) {
      logger.systemWarn('Failed to fetch custom agents for schema data');
    }

    // Get vault root structure (top-level files and folders)
    try {
      const root = this.app.vault.getRoot();
      const children = root.children || [];
      schemaData.vaultRoot = children
        .map(child => child.name)
        .filter(name => !name.startsWith('.')) // Exclude hidden folders
        .sort();
    } catch (error) {
      logger.systemWarn('Failed to fetch vault root for schema data');
    }

    return schemaData;
  }
}

```

## services/agent/AgentRegistrationService.ts

```typescript
/**
 * Location: src/services/agent/AgentRegistrationService.ts
 *
 * This service orchestrates agent initialization and registration
 * Refactored to use extracted services following SOLID principles
 *
 * Used by: MCPConnector
 * Dependencies: AgentInitializationService, AgentValidationService
 */

import { App, Plugin, Events } from 'obsidian';
import NexusPlugin from '../../main';
import { AgentManager } from '../AgentManager';
import type { ServiceManager } from '../../core/ServiceManager';
import { AgentFactoryRegistry } from '../../core/ServiceFactory';
import { NexusError, NexusErrorCode } from '../../utils/errors';
import { logger } from '../../utils/logger';
import { CustomPromptStorageService } from "../../agents/promptManager/services/CustomPromptStorageService";
import { AgentInitializationService } from './AgentInitializationService';
import { AgentValidationService } from './AgentValidationService';

export interface AgentRegistrationServiceInterface {
  /**
   * Initializes all configured agents
   */
  initializeAllAgents(): Promise<Map<string, any>>;

  /**
   * Gets registered agent by name
   */
  getAgent(name: string): any | null;

  /**
   * Gets all registered agents
   */
  getAllAgents(): Map<string, any>;

  /**
   * Registers agents with server
   */
  registerAgentsWithServer(registerFunction: (agent: any) => void): void;

  /**
   * Gets agent registration status
   */
  getRegistrationStatus(): AgentRegistrationStatus;
}

export interface AgentRegistrationStatus {
  totalAgents: number;
  initializedAgents: number;
  failedAgents: number;
  initializationErrors: Record<string, Error>;
  registrationTime: Date;
  registrationDuration: number;
}

export class AgentRegistrationService implements AgentRegistrationServiceInterface {
  private agentManager: AgentManager;
  private registrationStatus: AgentRegistrationStatus;
  private initializationErrors: Record<string, Error> = {};
  private factoryRegistry: AgentFactoryRegistry;
  private initializationService: AgentInitializationService;
  private validationService: AgentValidationService;

  constructor(
    private app: App,
    private plugin: Plugin | NexusPlugin,
    private events: Events,
    private serviceManager?: ServiceManager,
    private customPromptStorage?: CustomPromptStorageService,
    sharedAgentManager?: AgentManager
  ) {
    // Use shared AgentManager if provided, otherwise create a new one
    this.agentManager = sharedAgentManager ?? new AgentManager(app, plugin, events);
    this.factoryRegistry = new AgentFactoryRegistry();
    this.registrationStatus = {
      totalAgents: 0,
      initializedAgents: 0,
      failedAgents: 0,
      initializationErrors: {},
      registrationTime: new Date(),
      registrationDuration: 0
    };

    // Initialize extracted services
    this.initializationService = new AgentInitializationService(
      app,
      plugin,
      this.agentManager,
      serviceManager,
      customPromptStorage
    );
    this.validationService = new AgentValidationService(plugin);
  }

  /**
   * Initializes all configured agents using ServiceManager and constructor injection
   */
  async initializeAllAgentsWithServiceManager(): Promise<Map<string, any>> {
    if (!this.serviceManager) {
      throw new Error('ServiceManager is required for dependency injection');
    }

    const startTime = Date.now();
    this.registrationStatus.registrationTime = new Date();
    this.initializationErrors = {};

    try {
      logger.systemLog('Initializing agents with ServiceManager dependency injection...');

      const agentNames = ['contentManager', 'commandManager', 'storageManager', 'searchManager', 'memoryManager', 'promptManager'];
      const initializedAgents = new Map<string, any>();

      for (const agentName of agentNames) {
        try {
          await this.initializeAgentWithFactory(agentName);
          const agent = this.agentManager.getAgent(agentName);
          if (agent) {
            initializedAgents.set(agentName, agent);
          }
        } catch (error) {
          this.initializationErrors[agentName] = error as Error;
          logger.systemError(error as Error, `${agentName} Agent Initialization`);
        }
      }

      // Calculate final statistics
      this.registrationStatus = {
        totalAgents: agentNames.length,
        initializedAgents: initializedAgents.size,
        failedAgents: Object.keys(this.initializationErrors).length,
        initializationErrors: this.initializationErrors,
        registrationTime: this.registrationStatus.registrationTime,
        registrationDuration: Date.now() - startTime
      };

      logger.systemLog(`ServiceManager-based agent initialization completed - ${this.registrationStatus.initializedAgents}/${this.registrationStatus.totalAgents} agents initialized`);

      return initializedAgents;

    } catch (error) {
      this.registrationStatus.registrationDuration = Date.now() - startTime;
      logger.systemError(error as Error, 'Agent Registration with ServiceManager');
      throw new NexusError(
        NexusErrorCode.InternalError,
        'Failed to initialize agents with ServiceManager',
        error
      );
    }
  }

  /**
   * Initialize single agent using factory pattern with dependency injection
   */
  private async initializeAgentWithFactory(agentName: string): Promise<void> {
    const factory = this.factoryRegistry.getFactory(agentName);
    if (!factory) {
      throw new Error(`No factory found for agent: ${agentName}`);
    }

    // Resolve dependencies using ServiceManager
    const dependencies = new Map<string, any>();
    for (const depName of factory.dependencies) {
      try {
        const dependency = await this.serviceManager!.getService(depName);
        dependencies.set(depName, dependency);
      } catch (error) {
        logger.systemWarn(`Optional dependency '${depName}' not available for agent '${agentName}': ${error}`);
        // For optional dependencies, continue without them
        dependencies.set(depName, null);
      }
    }

    // Create agent with injected dependencies
    const agent = await factory.create(dependencies, this.app, this.plugin);
    this.agentManager.registerAgent(agent);

    logger.systemLog(`${agentName} agent initialized successfully with dependency injection`);
  }

  /**
   * Initializes all configured agents (legacy method - maintain backward compatibility)
   */
  async initializeAllAgents(): Promise<Map<string, any>> {
    const startTime = Date.now();
    this.registrationStatus.registrationTime = new Date();
    this.initializationErrors = {};

    try {
      // Get memory settings to determine what to enable
      const pluginWithSettings = this.plugin as Plugin & { settings?: { settings?: { memory?: { enabled?: boolean } } } };
      const memorySettings = pluginWithSettings?.settings?.settings?.memory;
      const isMemoryEnabled = memorySettings?.enabled;

      // Get capability status
      const { hasValidLLMKeys, enableSearchModes, enableLLMModes } = await this.validationService.getCapabilityStatus();

      logger.systemLog(`Agent initialization started - Search modes: ${enableSearchModes}, LLM modes: ${enableLLMModes}`);

      // Log additional debugging info for AgentManager
      if (!hasValidLLMKeys) {
        logger.systemLog('LLM validation failed - AgentManager features may be limited');
      }

      // Initialize agents in order using AgentInitializationService
      await this.safeInitialize('contentManager', () => this.initializationService.initializeContentManager());
      await this.safeInitialize('commandManager', () => this.initializationService.initializeCommandManager());
      await this.safeInitialize('storageManager', () => this.initializationService.initializeStorageManager());
      await this.safeInitialize('promptManager', () => this.initializationService.initializePromptManager(enableLLMModes));
      await this.safeInitialize('searchManager', () => this.initializationService.initializeSearchManager(enableSearchModes, memorySettings ?? { enabled: false }));
      await this.safeInitialize('memoryManager', () => this.initializationService.initializeMemoryManager());

      // ToolManager MUST be initialized LAST - it needs all other agents to be registered
      await this.safeInitialize('toolManager', () => this.initializationService.initializeToolManager());

      logger.systemLog('Using native chatbot UI instead of ChatAgent');

      // Calculate final statistics
      const agents = this.agentManager.getAgents();
      this.registrationStatus = {
        totalAgents: agents.length,
        initializedAgents: agents.length - Object.keys(this.initializationErrors).length,
        failedAgents: Object.keys(this.initializationErrors).length,
        initializationErrors: this.initializationErrors,
        registrationTime: this.registrationStatus.registrationTime,
        registrationDuration: Date.now() - startTime
      };

      // Log conditional mode availability status
      if (!enableSearchModes && !enableLLMModes) {
        logger.systemLog("No valid API keys found - modes requiring API keys will be disabled");
      } else {
        if (!enableSearchModes) {
          logger.systemLog("Search modes disabled");
        }
        if (!enableLLMModes) {
          logger.systemLog("LLM modes disabled - no valid LLM API keys configured");
        }
      }

      logger.systemLog(`Agent initialization completed - ${this.registrationStatus.initializedAgents}/${this.registrationStatus.totalAgents} agents initialized`);

      return new Map(agents.map(agent => [agent.name, agent]));

    } catch (error) {
      this.registrationStatus.registrationDuration = Date.now() - startTime;

      logger.systemError(error as Error, 'Agent Registration');
      throw new NexusError(
        NexusErrorCode.InternalError,
        'Failed to initialize agents',
        error
      );
    }
  }

  /**
   * Safe initialization wrapper with error handling
   */
  private async safeInitialize(agentName: string, initFn: () => Promise<void>): Promise<void> {
    try {
      await initFn();
    } catch (error) {
      this.initializationErrors[agentName] = error as Error;
      logger.systemError(error as Error, `${agentName} Agent Initialization`);
    }
  }

  /**
   * Gets registered agent by name
   */
  getAgent(name: string): any | null {
    try {
      return this.agentManager.getAgent(name);
    } catch (error) {
      return null;
    }
  }

  /**
   * Gets all registered agents
   */
  getAllAgents(): Map<string, any> {
    const agents = this.agentManager.getAgents();
    return new Map(agents.map(agent => [agent.name, agent]));
  }

  /**
   * Registers agents with server
   */
  registerAgentsWithServer(registerFunction: (agent: any) => void): void {
    try {
      const agents = this.agentManager.getAgents();

      for (const agent of agents) {
        registerFunction(agent);
      }

      logger.systemLog(`Registered ${agents.length} agents with server`);
    } catch (error) {
      logger.systemError(error as Error, 'Agent Server Registration');
      throw new NexusError(
        NexusErrorCode.InternalError,
        'Failed to register agents with server',
        error
      );
    }
  }

  /**
   * Gets agent registration status
   */
  getRegistrationStatus(): AgentRegistrationStatus {
    return { ...this.registrationStatus };
  }
}

```

## services/agent/AgentValidationService.ts

```typescript
/**
 * Location: src/services/agent/AgentValidationService.ts
 *
 * Purpose: Checks if API keys are configured for agent capabilities
 * Extracted from AgentRegistrationService.ts to follow Single Responsibility Principle
 *
 * Used by: AgentRegistrationService for capability validation
 */

import { Plugin } from 'obsidian';
import NexusPlugin from '../../main';
import { DEFAULT_LLM_PROVIDER_SETTINGS } from '../../types';
import { logger } from '../../utils/logger';

/**
 * Service for validating agent capabilities and API keys
 */
export class AgentValidationService {
  constructor(private plugin: Plugin | NexusPlugin) {}

  /**
   * Check if LLM API keys are configured (not validated - validation happens on first use)
   * This enables LLM modes without making network requests on every startup
   */
  async validateLLMApiKeys(): Promise<boolean> {
    try {
      const pluginWithSettings = this.plugin as Plugin & { settings?: { settings?: { llmProviders?: typeof DEFAULT_LLM_PROVIDER_SETTINGS } } };
      const pluginSettings = pluginWithSettings?.settings?.settings;
      const llmProviderSettings = pluginSettings?.llmProviders || DEFAULT_LLM_PROVIDER_SETTINGS;

      const defaultProvider = llmProviderSettings.defaultModel?.provider;
      if (!defaultProvider) {
        return false;
      }

      const providerConfig = llmProviderSettings.providers?.[defaultProvider];
      if (!providerConfig?.apiKey) {
        return false;
      }

      // Just check if an API key is configured - don't validate on startup
      // Validation will happen on first use, providing better UX
      return true;
    } catch (error) {
      logger.systemError(error as Error, 'LLM API Key Check');
      return false;
    }
  }

  /**
   * Get agent capability status
   */
  async getCapabilityStatus(): Promise<{
    hasValidLLMKeys: boolean;
    enableSearchModes: boolean;
    enableLLMModes: boolean;
  }> {
    const hasValidLLMKeys = await this.validateLLMApiKeys();

    // Search modes disabled
    const enableSearchModes = false;

    // Enable LLM-dependent modes only if valid LLM API keys exist
    const enableLLMModes = hasValidLLMKeys;

    return {
      hasValidLLMKeys,
      enableSearchModes,
      enableLLMModes
    };
  }
}

```

## services/agent/PromptDiscoveryService.ts

```typescript
/**
 * PromptDiscoveryService - Shared service for custom prompt discovery and querying
 *
 * Responsibilities:
 * - Load custom prompts from CustomPromptStorageService
 * - Filter prompts by enabled status
 * - Provide prompt lookup by ID
 * - Shared by ModelAgentManager (chat UI) and ListPromptsMode (MCP)
 *
 * Follows Single Responsibility Principle - only handles prompt discovery.
 */

export interface PromptInfo {
  id: string;
  name: string;
  description: string;
  prompt: string;
  isEnabled: boolean;
  createdAt?: number;
  updatedAt?: number;
}

export class PromptDiscoveryService {
  constructor(
    private customPromptStorageService: any
  ) {}

  /**
   * Get all available prompts
   * @param enabledOnly - If true, only return enabled prompts
   */
  async getAvailablePrompts(enabledOnly: boolean = false): Promise<PromptInfo[]> {
    try {
      // Get all prompts from storage
      const allPrompts = await this.customPromptStorageService.getAllPrompts();

      // Filter by enabled status if requested
      const prompts = enabledOnly
        ? allPrompts.filter((prompt: any) => prompt.isEnabled)
        : allPrompts;

      // Map to PromptInfo format
      return prompts.map((prompt: any) => this.mapToPromptInfo(prompt));
    } catch (error) {
      console.error('[PromptDiscoveryService] Failed to get prompts:', error);
      return [];
    }
  }

  /**
   * Find a specific prompt by ID
   */
  async findPrompt(promptId: string): Promise<PromptInfo | null> {
    try {
      const allPrompts = await this.getAvailablePrompts(false);
      return allPrompts.find(prompt => prompt.id === promptId) || null;
    } catch (error) {
      console.error('[PromptDiscoveryService] Failed to find prompt:', error);
      return null;
    }
  }

  /**
   * Get enabled prompts only
   */
  async getEnabledPrompts(): Promise<PromptInfo[]> {
    return this.getAvailablePrompts(true);
  }

  /**
   * Map custom prompt to PromptInfo format
   */
  private mapToPromptInfo(promptData: any): PromptInfo {
    return {
      id: promptData.id,
      name: promptData.name,
      description: promptData.description || '',
      prompt: promptData.prompt || '',
      isEnabled: promptData.isEnabled !== false, // Default to true if not specified
      createdAt: promptData.createdAt,
      updatedAt: promptData.updatedAt
    };
  }
}

```

## services/AgentManager.ts

```typescript
import { IAgent } from '../agents/interfaces/IAgent';
import { App, Events } from 'obsidian';

/**
 * Agent management service
 * Manages agent registration, initialization, and execution
 */
export class AgentManager {
  private agents: Map<string, IAgent> = new Map();

  /**
   * Create a new agent manager
   * @param app Obsidian app instance
   * @param plugin Plugin instance
   * @param events Obsidian Events instance
   */
  constructor(
    _app: App,
    _plugin: any,
    _events: Events
  ) {
    // We're not currently using these parameters but they might be needed in the future
    // No need to store them as class properties for now
    // Using underscore prefix to indicate intentionally unused parameters
  }
  
  /**
   * Register an agent
   * @param agent Agent to register
   * @throws Error if agent with same name is already registered
   */
  registerAgent(agent: IAgent): void {
    if (this.agents.has(agent.name)) {
      throw new Error(`Agent ${agent.name} is already registered`);
    }
    
    this.agents.set(agent.name, agent);
    
    // Set the agent manager reference for inter-agent communication
    agent.setAgentManager(this);
  }
  
  /**
   * Get an agent by name
   * @param name Name of the agent
   * @returns Agent instance
   * @throws Error if agent not found
   */
  getAgent(name: string): IAgent {
    const agent = this.agents.get(name);
    if (!agent) {
      throw new Error(`Agent ${name} not found`);
    }
    
    return agent;
  }
  
  /**
   * Get all registered agents
   * @returns Array of agent instances
   */
  getAgents(): IAgent[] {
    return Array.from(this.agents.values());
  }
  
  /**
   * Execute a tool on an agent
   * @param agentName Name of the agent
   * @param tool Tool to execute
   * @param params Parameters to pass to the tool
   * @returns Promise that resolves with the tool's result
   */
  async executeAgentTool(agentName: string, tool: string, params: Record<string, unknown>): Promise<unknown> {
    const agent = this.getAgent(agentName);
    return await agent.executeTool(tool, params);
  }

  /**
   * @deprecated Use executeAgentTool instead
   */
  async executeAgentMode(agentName: string, mode: string, params: Record<string, unknown>): Promise<unknown> {
    return this.executeAgentTool(agentName, mode, params);
  }
  
  
  /**
   * Initialize all registered agents
   * @returns Promise that resolves when all agents are initialized
   */
  async initializeAgents(): Promise<void> {
    for (const agent of this.agents.values()) {
      await agent.initialize();
    }
  }
}
```

## services/chat/BranchService.ts

```typescript
/**
 * BranchService - Branch management for human and subagent branches
 *
 * A branch IS a conversation with parent metadata:
 * - metadata.parentConversationId: parent conversation
 * - metadata.parentMessageId: message the branch is attached to
 * - metadata.branchType: 'alternative' | 'subagent'
 *
 * Uses ConversationService as the storage backend (facade pattern).
 */

import type { Conversation, ChatMessage } from '../../types/chat/ChatTypes';
import type {
  ConversationBranch,
  BranchState,
  SubagentBranchMetadata,
  HumanBranchMetadata,
} from '../../types/branch/BranchTypes';
import type { ConversationService, IndividualConversation } from '../ConversationService';

/**
 * Dependencies for BranchService
 */
export interface BranchServiceDependencies {
  /**
   * ConversationService for branch storage (branches are conversations with parent metadata)
   */
  conversationService: ConversationService;
}

/**
 * Branch info returned by query methods
 */
export interface BranchInfo {
  branch: ConversationBranch;
  parentMessageId: string;
  /**
   * Index of parent message in conversation (for LLM context building)
   * Note: This is calculated dynamically if needed, not stored
   */
  parentMessageIndex?: number;
}

export class BranchService {
  private conversationService: ConversationService;

  constructor(dependencies: BranchServiceDependencies) {
    this.conversationService = dependencies.conversationService;
  }

  /**
   * Create a human branch (with inherited context)
   * Creates a new conversation with parent metadata
   */
  async createHumanBranch(
    conversationId: string,
    messageId: string,
    description?: string
  ): Promise<string> {
    const title = description || 'Alternative response';
    const branch = await this.conversationService.createBranchConversation(
      conversationId,
      messageId,
      'alternative',
      title
    );

    // Store inheritContext in metadata for buildLLMContext
    if (branch.metadata) {
      branch.metadata.inheritContext = true;
    }

    return branch.id;
  }

  /**
   * Create a subagent branch (fresh context)
   * Creates a new conversation with parent metadata and subagent task info
   */
  async createSubagentBranch(
    conversationId: string,
    messageId: string,
    task: string,
    subagentId: string,
    maxIterations: number = 10
  ): Promise<string> {
    console.log('[SUBAGENT-DEBUG] createSubagentBranch START', { conversationId, messageId, task, subagentId });
    const now = Date.now();
    const title = `Subagent: ${task.slice(0, 50)}${task.length > 50 ? '...' : ''}`;

    // Build subagent metadata for atomic creation (no two-phase update needed)
    const subagentMeta: SubagentBranchMetadata = {
      task,
      subagentId,
      state: 'running',
      iterations: 0,
      maxIterations,
      startedAt: now,
    };

    // Create branch with ALL metadata atomically
    const branch = await this.conversationService.createBranchConversation(
      conversationId,
      messageId,
      'subagent',
      title,
      task,
      subagentMeta  // Pass full subagent state
    );
    console.log('[SUBAGENT-DEBUG] Branch created with metadata', { branchId: branch.id, subagentMeta });

    return branch.id;
  }

  /**
   * Add a message to a branch
   * A branch IS a conversation, so this adds a message to the branch conversation
   */
  async addMessageToBranch(
    branchId: string,
    message: ChatMessage
  ): Promise<void> {
    await this.conversationService.addMessage({
      conversationId: branchId,
      id: message.id,
      role: message.role as 'user' | 'assistant' | 'tool',
      content: message.content || '',
      toolCalls: message.toolCalls,
      metadata: message.metadata,
    });
  }

  /**
   * Update a message in a branch (for streaming updates)
   * branchId IS the conversation ID
   */
  async updateMessageInBranch(
    branchId: string,
    messageId: string,
    updates: {
      content?: string;
      state?: string;
      toolCalls?: ChatMessage['toolCalls'];
      reasoning?: string;
    }
  ): Promise<void> {
    await this.conversationService.updateMessage(branchId, messageId, {
      content: updates.content,
      state: updates.state as ChatMessage['state'],
      toolCalls: updates.toolCalls,
      reasoning: updates.reasoning,
    });
  }

  /**
   * Build LLM context for a branch
   * This is the key method that handles inheritContext logic
   *
   * In the new architecture, a branch IS a conversation with parent metadata.
   * - inheritContext=true: include parent messages up to branch point
   * - inheritContext=false: only branch messages (fresh context for subagents)
   *
   * @param parentConversation The parent conversation (for inherited context)
   * @param branchId The branch conversation ID
   * @returns Array of messages to send to the LLM
   */
  async buildLLMContext(
    parentConversation: Conversation,
    branchId: string
  ): Promise<ChatMessage[]> {
    // Get the branch conversation
    const branchConversation = await this.conversationService.getConversation(branchId);
    if (!branchConversation) {
      return [];
    }

    // Convert branch messages to ChatMessage format (add conversationId)
    const branchMessages: ChatMessage[] = branchConversation.messages.map(m => ({
      ...m,
      conversationId: branchId,
    })) as ChatMessage[];

    // Check inheritContext from metadata
    const inheritContext = branchConversation.metadata?.inheritContext !== false;
    const parentMessageId = branchConversation.metadata?.parentMessageId;

    if (inheritContext && parentMessageId) {
      // Human branch: parent context (messages 0 to parent message) + branch messages
      const parentIndex = parentConversation.messages.findIndex(m => m.id === parentMessageId);
      if (parentIndex >= 0) {
        const parentContext = parentConversation.messages.slice(0, parentIndex + 1);
        return [...parentContext, ...branchMessages];
      }
    }

    // Subagent branch or parent not found: only branch messages
    return branchMessages;
  }

  /**
   * Get a branch by ID
   * In new architecture, branchId IS the conversation ID
   */
  async getBranch(
    parentConversationId: string,
    branchId: string
  ): Promise<BranchInfo | null> {
    const branchConversation = await this.conversationService.getConversation(branchId);
    if (!branchConversation) {
      return null;
    }

    // Verify this is a branch of the specified parent
    if (branchConversation.metadata?.parentConversationId !== parentConversationId) {
      return null;
    }

    const branch = this.conversationToBranch(branchConversation);

    return {
      branch,
      parentMessageId: branchConversation.metadata?.parentMessageId || '',
    };
  }

  /**
   * Convert a branch conversation to ConversationBranch format
   */
  private conversationToBranch(conversation: IndividualConversation): ConversationBranch {
    const branchType = conversation.metadata?.branchType === 'subagent' ? 'subagent' : 'human';
    const inheritContext = conversation.metadata?.inheritContext !== false;

    // Convert ConversationMessage[] to ChatMessage[] (add conversationId)
    const messages = conversation.messages.map(m => ({
      ...m,
      conversationId: conversation.id,
    })) as ChatMessage[];

    return {
      id: conversation.id,
      type: branchType,
      inheritContext,
      messages,
      metadata: branchType === 'subagent'
        ? conversation.metadata?.subagent as SubagentBranchMetadata
        : { description: conversation.title } as HumanBranchMetadata,
      created: conversation.created,
      updated: conversation.updated,
    };
  }

  /**
   * Update branch metadata (subagent state, iterations, etc.)
   * branchId IS the conversation ID
   */
  async updateBranchMetadata(
    branchId: string,
    metadata: Partial<SubagentBranchMetadata>
  ): Promise<void> {
    const branchConversation = await this.conversationService.getConversation(branchId);
    if (!branchConversation) {
      throw new Error(`Branch not found: ${branchId}`);
    }

    // Merge with existing subagent metadata
    const existingSubagent = branchConversation.metadata?.subagent || {};
    const updatedSubagent = {
      ...existingSubagent,
      ...metadata,
    };

    // Update via ConversationService
    await this.conversationService.updateConversation(branchId, {
      metadata: {
        ...branchConversation.metadata,
        subagent: updatedSubagent,
      },
    });
  }

  /**
   * Update branch state (convenience method for subagent state transitions)
   */
  async updateBranchState(
    branchId: string,
    state: BranchState,
    iterations?: number
  ): Promise<void> {
    const updates: Partial<SubagentBranchMetadata> = { state };

    if (iterations !== undefined) {
      updates.iterations = iterations;
    }

    if (state === 'complete' || state === 'cancelled' || state === 'abandoned') {
      updates.completedAt = Date.now();
    }

    await this.updateBranchMetadata(branchId, updates);
  }

  /**
   * Get all branches for a conversation
   * Uses ConversationService.getBranchConversations
   */
  async getAllBranches(conversationId: string): Promise<BranchInfo[]> {
    const branches = await this.conversationService.getBranchConversations(conversationId);
    return this.convertConversationsToBranchInfoArray(branches);
  }

  /**
   * Get all subagent branches (for UI status display)
   */
  async getSubagentBranches(conversationId: string): Promise<BranchInfo[]> {
    const allBranches = await this.conversationService.getBranchConversations(conversationId);
    const subagentBranches = allBranches.filter(b => b.metadata?.branchType === 'subagent');
    return this.convertConversationsToBranchInfoArray(subagentBranches);
  }

  /**
   * Get branches attached to a specific message
   * Note: This requires searching by parent message ID - less efficient than message-level queries
   */
  async getBranchesByMessage(parentMessageId: string): Promise<BranchInfo[]> {
    // Get all conversations and filter for branches from this message
    // This is less efficient but works with the new architecture
    const allConversations = await this.conversationService.listConversations(undefined, 200);
    const branchInfos: BranchInfo[] = [];

    for (const meta of allConversations) {
      // Need to load full conversation to check metadata
      const conversation = await this.conversationService.getConversation(meta.id);
      if (conversation?.metadata?.parentMessageId === parentMessageId) {
        branchInfos.push({
          branch: this.conversationToBranch(conversation),
          parentMessageId,
        });
      }
    }

    return branchInfos;
  }

  /**
   * Convert conversation array to BranchInfo array
   */
  private convertConversationsToBranchInfoArray(conversations: IndividualConversation[]): BranchInfo[] {
    return conversations.map(c => ({
      branch: this.conversationToBranch(c),
      parentMessageId: c.metadata?.parentMessageId || '',
    }));
  }

}

```

## services/chat/builders/AnthropicContextBuilder.ts

```typescript
/**
 * AnthropicContextBuilder - Builds conversation context for Anthropic Claude
 *
 * Anthropic format uses:
 * - tool_use blocks within assistant messages
 * - tool_result blocks within user messages
 * - Content arrays instead of simple strings for messages with tool calls
 *
 * Follows Single Responsibility Principle - only handles Anthropic format.
 */

import { IContextBuilder } from './IContextBuilder';
import { ConversationData } from '../../../types/chat/ChatTypes';

export class AnthropicContextBuilder implements IContextBuilder {
  readonly provider = 'anthropic';

  /**
   * Validate if a message should be included in LLM context
   */
  private isValidForContext(msg: any, isLastMessage: boolean): boolean {
    if (msg.state === 'invalid' || msg.state === 'streaming') return false;
    if (msg.role === 'user' && (!msg.content || !msg.content.trim())) return false;

    if (msg.role === 'assistant') {
      const hasContent = msg.content && msg.content.trim();
      const hasToolCalls = msg.toolCalls && msg.toolCalls.length > 0;

      if (!hasContent && !hasToolCalls && !isLastMessage) return false;

      if (hasToolCalls) {
        const allHaveResults = msg.toolCalls.every((tc: any) =>
          tc.result !== undefined || tc.error !== undefined
        );
        if (!allHaveResults) return false;
      }
    }

    return true;
  }

  /**
   * Build context from stored conversation
   */
  buildContext(conversation: ConversationData, systemPrompt?: string): any[] {
    const messages: any[] = [];

    if (systemPrompt) {
      messages.push({ role: 'system', content: systemPrompt });
    }

    // Filter valid messages
    const validMessages = conversation.messages.filter((msg, index) => {
      const isLastMessage = index === conversation.messages.length - 1;
      return this.isValidForContext(msg, isLastMessage);
    });

    validMessages.forEach((msg) => {
      if (msg.role === 'user') {
        if (msg.content && msg.content.trim()) {
          messages.push({ role: 'user', content: msg.content });
        }
      } else if (msg.role === 'assistant') {
        if (msg.toolCalls && msg.toolCalls.length > 0) {
          // Assistant message contains both text AND tool_use blocks
          const content: any[] = [];

          if (msg.content && msg.content.trim()) {
            content.push({ type: 'text', text: msg.content });
          }

          // Add tool_use blocks
          msg.toolCalls.forEach((toolCall: any) => {
            content.push({
              type: 'tool_use',
              id: toolCall.id,
              name: toolCall.name,
              input: toolCall.parameters || {}
            });
          });

          messages.push({ role: 'assistant', content });

          // Add tool results as user message with tool_result blocks
          const toolResultContent: any[] = msg.toolCalls.map((toolCall: any) => ({
            type: 'tool_result',
            tool_use_id: toolCall.id,
            content: toolCall.success
              ? JSON.stringify(toolCall.result || {})
              : `Error: ${toolCall.error || 'Tool execution failed'}`
          }));

          if (toolResultContent.length > 0) {
            messages.push({ role: 'user', content: toolResultContent });
          }
        } else {
          if (msg.content && msg.content.trim()) {
            messages.push({ role: 'assistant', content: msg.content });
          }
        }
      } else if (msg.role === 'tool') {
        // Handle stored tool messages - convert to tool_result blocks
        if (msg.toolCalls && msg.toolCalls.length > 0) {
          const toolResultContent: any[] = msg.toolCalls.map((toolCall: any) => ({
            type: 'tool_result',
            tool_use_id: toolCall.id,
            content: toolCall.success
              ? JSON.stringify(toolCall.result || {})
              : `Error: ${toolCall.error || 'Tool execution failed'}`
          }));

          if (toolResultContent.length > 0) {
            messages.push({ role: 'user', content: toolResultContent });
          }
        }
      }
    });

    return messages;
  }

  /**
   * Build tool continuation for pingpong pattern
   */
  buildToolContinuation(
    userPrompt: string,
    toolCalls: any[],
    toolResults: any[],
    previousMessages?: any[],
    _systemPrompt?: string
  ): any[] {
    const messages: any[] = [];

    if (previousMessages && previousMessages.length > 0) {
      messages.push(...previousMessages);
    }

    if (userPrompt) {
      messages.push({ role: 'user', content: userPrompt });
    }

    // Add assistant message with tool_use blocks
    const toolUseBlocks = toolCalls.map(tc => ({
      type: 'tool_use',
      id: tc.id,
      name: tc.function?.name || tc.name,
      input: JSON.parse(tc.function?.arguments || '{}')
    }));

    messages.push({ role: 'assistant', content: toolUseBlocks });

    // Add user message with tool_result blocks
    const toolResultBlocks = toolResults.map(result => ({
      type: 'tool_result',
      tool_use_id: result.id,
      content: result.success
        ? JSON.stringify(result.result || {})
        : `Error: ${result.error || 'Tool execution failed'}`
    }));

    messages.push({ role: 'user', content: toolResultBlocks });

    return messages;
  }

  /**
   * Append tool execution to existing history (no user message added)
   */
  appendToolExecution(
    toolCalls: any[],
    toolResults: any[],
    previousMessages: any[]
  ): any[] {
    const messages = [...previousMessages];

    // Add assistant message with tool_use blocks
    const toolUseBlocks = toolCalls.map(tc => ({
      type: 'tool_use',
      id: tc.id,
      name: tc.function?.name || tc.name,
      input: JSON.parse(tc.function?.arguments || '{}')
    }));

    messages.push({ role: 'assistant', content: toolUseBlocks });

    // Add user message with tool_result blocks
    const toolResultBlocks = toolResults.map(result => ({
      type: 'tool_result',
      tool_use_id: result.id,
      content: result.success
        ? JSON.stringify(result.result || {})
        : `Error: ${result.error || 'Tool execution failed'}`
    }));

    messages.push({ role: 'user', content: toolResultBlocks });

    return messages;
  }
}

```

## services/chat/builders/ContextBuilderFactory.ts

```typescript
/**
 * ContextBuilderFactory - Creates the appropriate context builder for a provider
 *
 * Factory pattern implementation that returns the correct IContextBuilder
 * based on the provider name and optionally model name.
 *
 * For local providers (LM Studio, Ollama), the model name determines format:
 * - Nexus/fine-tuned models: Use CustomFormatContextBuilder (<tool_call> format)
 * - Other models: Use OpenAIContextBuilder (standard tool_calls format)
 *
 * Follows Open/Closed Principle - adding new providers only requires:
 * 1. Creating a new builder class
 * 2. Adding it to this factory's mapping
 */

import { IContextBuilder } from './IContextBuilder';
import { OpenAIContextBuilder } from './OpenAIContextBuilder';
import { AnthropicContextBuilder } from './AnthropicContextBuilder';
import { GoogleContextBuilder } from './GoogleContextBuilder';
import { CustomFormatContextBuilder } from './CustomFormatContextBuilder';

// Singleton instances for each builder (they're stateless)
const openAIBuilder = new OpenAIContextBuilder();
const anthropicBuilder = new AnthropicContextBuilder();
const googleBuilder = new GoogleContextBuilder();
const customFormatBuilder = new CustomFormatContextBuilder();

/**
 * Provider categories for documentation/debugging
 */
export type ProviderCategory = 'openai-compatible' | 'anthropic' | 'google' | 'custom-format';

/**
 * Check if a model uses custom tool call format (fine-tuned with tool knowledge)
 * These models output <tool_call> or [TOOL_CALLS] instead of native tool_calls
 */
export function usesCustomToolFormat(modelId: string): boolean {
  const customFormatKeywords = ['nexus', 'tools-sft', 'claudesidian'];
  const lowerModelId = modelId.toLowerCase();
  return customFormatKeywords.some(keyword => lowerModelId.includes(keyword));
}

/**
 * Get the appropriate context builder for a provider
 *
 * @param provider - Provider name (e.g., 'openai', 'anthropic', 'google', 'openrouter')
 * @param model - Optional model name (used to determine format for local providers)
 * @returns The context builder for that provider
 */
export function getContextBuilder(provider: string, model?: string): IContextBuilder {
  const normalizedProvider = provider.toLowerCase();

  switch (normalizedProvider) {
    // Anthropic
    case 'anthropic':
      return anthropicBuilder;

    // Google
    case 'google':
      return googleBuilder;

    // Local providers: check model to determine format
    case 'lmstudio':
    case 'ollama':
      // Only use custom format for Nexus/fine-tuned models
      if (model && usesCustomToolFormat(model)) {
        return customFormatBuilder;
      }
      // Non-Nexus models use standard OpenAI format
      return openAIBuilder;

    // WebLLM always uses custom format (only runs Nexus models)
    case 'webllm':
      return customFormatBuilder;

    // OpenAI-compatible (default)
    case 'openai':
    case 'openrouter':
    case 'groq':
    case 'mistral':
    case 'requesty':
    case 'perplexity':
    default:
      return openAIBuilder;
  }
}

/**
 * Get the provider category for a given provider and model
 * Useful for debugging and logging
 *
 * @param provider - Provider name
 * @param model - Optional model name (used for local providers)
 * @returns Category string
 */
export function getProviderCategory(provider: string, model?: string): ProviderCategory {
  const normalizedProvider = provider.toLowerCase();

  switch (normalizedProvider) {
    case 'anthropic':
      return 'anthropic';
    case 'google':
      return 'google';
    case 'lmstudio':
    case 'ollama':
      // Only Nexus/fine-tuned models use custom format
      if (model && usesCustomToolFormat(model)) {
        return 'custom-format';
      }
      return 'openai-compatible';
    case 'webllm':
      return 'custom-format';
    default:
      return 'openai-compatible';
  }
}

/**
 * Check if a provider/model combination uses a specific builder type
 */
export function isOpenAICompatible(provider: string, model?: string): boolean {
  return getProviderCategory(provider, model) === 'openai-compatible';
}

export function isCustomFormat(provider: string, model?: string): boolean {
  return getProviderCategory(provider, model) === 'custom-format';
}

```

## services/chat/builders/CustomFormatContextBuilder.ts

```typescript
/**
 * CustomFormatContextBuilder - Builds conversation context for fine-tuned local LLMs
 *
 * Used by: LM Studio, Ollama, WebLLM
 *
 * Preserves the original tool call format the model used:
 * - [TOOL_CALLS][...][/TOOL_CALLS] (Mistral/bracket format)
 * - <tool_call>...</tool_call> (Qwen/XML format)
 *
 * Strict user/assistant alternation required.
 * Raw JSON tool results to match training data.
 *
 * Follows Single Responsibility Principle - only handles custom text format.
 */

import { IContextBuilder } from './IContextBuilder';
import { ConversationData, ToolCallFormat } from '../../../types/chat/ChatTypes';

export class CustomFormatContextBuilder implements IContextBuilder {
  readonly provider = 'custom';

  /**
   * Format tool calls using the format the model originally used
   * Preserves bracket format for Mistral-based, XML format for Qwen-based models
   */
  private formatToolCalls(toolCalls: any[], format?: ToolCallFormat): string {
    const toolCallObjs = toolCalls.map((tc: any) => ({
      name: tc.name,
      arguments: tc.parameters || {}
    }));

    // Default to bracket format if not specified (legacy behavior)
    const effectiveFormat = format || toolCalls[0]?.sourceFormat || 'bracket';

    if (effectiveFormat === 'xml') {
      // Qwen/XML format: <tool_call>...</tool_call>
      return toolCallObjs.map(obj =>
        `<tool_call>\n${JSON.stringify(obj, null, 2)}\n</tool_call>`
      ).join('\n');
    }

    // Bracket format: [TOOL_CALLS][...][/TOOL_CALLS]
    const jsonArray = toolCallObjs.map(obj => JSON.stringify(obj));
    return `[TOOL_CALLS][${jsonArray.join(',')}][/TOOL_CALLS]`;
  }

  /**
   * Validate if a message should be included in LLM context
   */
  private isValidForContext(msg: any, isLastMessage: boolean): boolean {
    if (msg.state === 'invalid' || msg.state === 'streaming') return false;
    if (msg.role === 'user' && (!msg.content || !msg.content.trim())) return false;

    if (msg.role === 'assistant') {
      const hasContent = msg.content && msg.content.trim();
      const hasToolCalls = msg.toolCalls && msg.toolCalls.length > 0;

      if (!hasContent && !hasToolCalls && !isLastMessage) return false;

      if (hasToolCalls) {
        const allHaveResults = msg.toolCalls.every((tc: any) =>
          tc.result !== undefined || tc.error !== undefined
        );
        if (!allHaveResults) return false;
      }
    }

    return true;
  }

  /**
   * Build context from stored conversation
   * Uses OpenAI-like format for context loading (simpler)
   */
  buildContext(conversation: ConversationData, systemPrompt?: string): any[] {
    const messages: any[] = [];

    if (systemPrompt) {
      messages.push({ role: 'system', content: systemPrompt });
    }

    // Filter valid messages
    const validMessages = conversation.messages.filter((msg, index) => {
      const isLastMessage = index === conversation.messages.length - 1;
      return this.isValidForContext(msg, isLastMessage);
    });

    validMessages.forEach((msg) => {
      if (msg.role === 'user') {
        if (msg.content && msg.content.trim()) {
          messages.push({ role: 'user', content: msg.content });
        }
      } else if (msg.role === 'assistant') {
        if (msg.toolCalls && msg.toolCalls.length > 0) {
          // Detect format from the stored tool calls
          const format = msg.toolCalls[0]?.sourceFormat;

          // Format using the model's original format
          messages.push({
            role: 'assistant',
            content: this.formatToolCalls(msg.toolCalls, format)
          });

          // Add tool results with appropriate format wrapper
          const toolResults = msg.toolCalls.map((tc: any) => ({
            success: tc.success !== false,
            result: tc.result,
            error: tc.error
          }));
          messages.push({
            role: 'user',
            content: this.formatToolResults(toolResults, format)
          });

          // If there's final content after tool execution, add it
          if (msg.content && msg.content.trim()) {
            messages.push({ role: 'assistant', content: msg.content });
          }
        } else {
          if (msg.content && msg.content.trim()) {
            messages.push({ role: 'assistant', content: msg.content });
          }
        }
      }
    });

    return messages;
  }

  /**
   * Format tool results with appropriate wrapper based on tool call format
   * XML format uses <tool_result> tags, bracket format uses raw JSON
   */
  private formatToolResults(toolResults: any[], format?: ToolCallFormat): string {
    const toolResultObjects = toolResults.map(result => {
      return result.success
        ? (result.result || {})
        : { error: result.error || 'Tool execution failed' };
    });

    const jsonContent = JSON.stringify(
      toolResultObjects.length === 1 ? toolResultObjects[0] : toolResultObjects,
      null,
      2
    );

    // For XML format, wrap results to match model's expectations
    if (format === 'xml') {
      return `<tool_result>\n${jsonContent}\n</tool_result>`;
    }

    // Bracket format uses raw JSON
    return jsonContent;
  }

  /**
   * Build tool continuation for pingpong pattern
   * LM Studio requires STRICT alternation: user/assistant/user/assistant
   */
  buildToolContinuation(
    userPrompt: string,
    toolCalls: any[],
    toolResults: any[],
    previousMessages?: any[],
    _systemPrompt?: string
  ): any[] {
    const messages: any[] = [];

    // Separate system messages from conversation messages
    const systemMessages: any[] = [];
    const conversationMessages: any[] = [];

    if (previousMessages && previousMessages.length > 0) {
      for (const msg of previousMessages) {
        if (msg.role === 'system') {
          systemMessages.push(msg);
        } else {
          conversationMessages.push(msg);
        }
      }
    }

    // Add system messages first
    messages.push(...systemMessages);

    // Check if user prompt already exists in conversation history
    const hasUserPrompt = conversationMessages.some(
      msg => msg.role === 'user' && msg.content === userPrompt
    );

    // If user prompt isn't in history, add it first (after system)
    if (!hasUserPrompt && userPrompt) {
      messages.push({ role: 'user', content: userPrompt });
    }

    // Add existing conversation history
    for (const msg of conversationMessages) {
      // Skip if this is the user prompt we already added
      if (msg.role === 'user' && msg.content === userPrompt && !hasUserPrompt) {
        continue;
      }
      messages.push(msg);
    }

    // Check last message for duplicate detection
    const lastMsg = messages[messages.length - 1];

    // Normalize tool calls for formatting
    const normalizedToolCalls = toolCalls.map(toolCall => {
      const toolName = toolCall.function?.name || toolCall.name || 'unknown';
      const args = toolCall.function?.arguments || toolCall.arguments || '{}';
      const parsedArgs = typeof args === 'string' ? JSON.parse(args) : args;
      return {
        name: toolName,
        parameters: parsedArgs,
        sourceFormat: toolCall.sourceFormat
      };
    });

    // Detect format from first tool call
    const format = normalizedToolCalls[0]?.sourceFormat;
    const assistantToolCallContent = this.formatToolCalls(normalizedToolCalls, format);

    // Only add assistant tool call if we don't already end with one
    const lastIsMatchingAssistant = lastMsg &&
      lastMsg.role === 'assistant' &&
      (lastMsg.content?.includes('[TOOL_CALLS]') || lastMsg.content?.includes('<tool_call>'));

    if (!lastIsMatchingAssistant) {
      messages.push({
        role: 'assistant',
        content: assistantToolCallContent
      });
    }

    // Add user message with tool results (formatted based on tool call format)
    messages.push({
      role: 'user',
      content: this.formatToolResults(toolResults, format)
    });

    return messages;
  }

  /**
   * Append tool execution to existing history (no user message added)
   */
  appendToolExecution(
    toolCalls: any[],
    toolResults: any[],
    previousMessages: any[]
  ): any[] {
    const messages = [...previousMessages];

    // Normalize tool calls for formatting
    const normalizedToolCalls = toolCalls.map(toolCall => {
      const toolName = toolCall.function?.name || toolCall.name || 'unknown';
      const args = toolCall.function?.arguments || toolCall.arguments || '{}';
      const parsedArgs = typeof args === 'string' ? JSON.parse(args) : args;
      return {
        name: toolName,
        parameters: parsedArgs,
        sourceFormat: toolCall.sourceFormat
      };
    });

    // Detect format from first tool call
    const format = normalizedToolCalls[0]?.sourceFormat;

    messages.push({
      role: 'assistant',
      content: this.formatToolCalls(normalizedToolCalls, format)
    });

    // Add tool results with appropriate format
    messages.push({
      role: 'user',
      content: this.formatToolResults(toolResults, format)
    });

    return messages;
  }
}

```

## services/chat/builders/GoogleContextBuilder.ts

```typescript
/**
 * GoogleContextBuilder - Builds conversation context for Google Gemini
 *
 * Google format uses:
 * - 'user' and 'model' roles (not 'assistant')
 * - 'parts' array with text, functionCall, or functionResponse objects
 * - thoughtSignature for thinking models (Gemini 3.0+)
 *
 * Follows Single Responsibility Principle - only handles Google format.
 */

import { IContextBuilder } from './IContextBuilder';
import { ConversationData } from '../../../types/chat/ChatTypes';
import { ReasoningPreserver } from '../../llm/adapters/shared/ReasoningPreserver';

export class GoogleContextBuilder implements IContextBuilder {
  readonly provider = 'google';

  /**
   * Validate if a message should be included in LLM context
   */
  private isValidForContext(msg: any, isLastMessage: boolean): boolean {
    if (msg.state === 'invalid' || msg.state === 'streaming') return false;
    if (msg.role === 'user' && (!msg.content || !msg.content.trim())) return false;

    if (msg.role === 'assistant') {
      const hasContent = msg.content && msg.content.trim();
      const hasToolCalls = msg.toolCalls && msg.toolCalls.length > 0;

      if (!hasContent && !hasToolCalls && !isLastMessage) return false;

      if (hasToolCalls) {
        const allHaveResults = msg.toolCalls.every((tc: any) =>
          tc.result !== undefined || tc.error !== undefined
        );
        if (!allHaveResults) return false;
      }
    }

    return true;
  }

  /**
   * Build context from stored conversation
   */
  buildContext(conversation: ConversationData, systemPrompt?: string): any[] {
    const messages: any[] = [];

    // Note: Google uses systemInstruction separately, not in messages
    // But we include it here for compatibility with the interface
    if (systemPrompt) {
      messages.push({ role: 'system', content: systemPrompt });
    }

    // Filter valid messages
    const validMessages = conversation.messages.filter((msg, index) => {
      const isLastMessage = index === conversation.messages.length - 1;
      return this.isValidForContext(msg, isLastMessage);
    });

    validMessages.forEach((msg) => {
      if (msg.role === 'user') {
        if (msg.content && msg.content.trim()) {
          messages.push({
            role: 'user',
            parts: [{ text: msg.content }]
          });
        }
      } else if (msg.role === 'assistant') {
        if (msg.toolCalls && msg.toolCalls.length > 0) {
          // Build model message with thought signatures preserved
          const modelMessage = ReasoningPreserver.buildGoogleModelMessageWithThinking(
            msg.toolCalls.map((tc: any) => ({
              ...tc,
              function: { name: tc.name, arguments: JSON.stringify(tc.parameters || {}) }
            }))
          );
          messages.push(modelMessage);

          // Function response parts
          const functionResponseParts = msg.toolCalls.map((tc: any) => ({
            functionResponse: {
              name: tc.name,
              response: tc.success
                ? (tc.result || {})
                : { error: tc.error || 'Tool execution failed' }
            }
          }));

          messages.push({ role: 'function', parts: functionResponseParts });

          // If there's final content after tool execution, add it
          if (msg.content && msg.content.trim()) {
            messages.push({
              role: 'model',
              parts: [{ text: msg.content }]
            });
          }
        } else {
          if (msg.content && msg.content.trim()) {
            messages.push({
              role: 'model',
              parts: [{ text: msg.content }]
            });
          }
        }
      }
    });

    return messages;
  }

  /**
   * Build tool continuation for pingpong pattern
   */
  buildToolContinuation(
    userPrompt: string,
    toolCalls: any[],
    toolResults: any[],
    previousMessages?: any[],
    _systemPrompt?: string
  ): any[] {
    const messages: any[] = [];

    // Add previous conversation history (convert to Google format if needed)
    if (previousMessages && previousMessages.length > 0) {
      for (const msg of previousMessages) {
        // Skip messages that are already in Google format
        if (msg.parts) {
          messages.push(msg);
          continue;
        }

        // Convert from simple message format
        if (msg.role === 'user' && msg.content) {
          messages.push({
            role: 'user',
            parts: [{ text: typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content) }]
          });
        } else if (msg.role === 'assistant' && msg.content) {
          messages.push({
            role: 'model',
            parts: [{ text: typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content) }]
          });
        }
      }
    }

    // Add the original user message
    if (userPrompt) {
      messages.push({
        role: 'user',
        parts: [{ text: userPrompt }]
      });
    }

    // Build model message with thought signatures preserved
    const modelMessage = ReasoningPreserver.buildGoogleModelMessageWithThinking(toolCalls);
    messages.push(modelMessage);

    // Add function response parts
    const functionResponseParts = toolResults.map(result => ({
      functionResponse: {
        name: result.name || result.function?.name,
        response: result.success
          ? (result.result || {})
          : { error: result.error || 'Tool execution failed' }
      }
    }));

    messages.push({
      role: 'user',  // Google uses 'user' role for function responses
      parts: functionResponseParts
    });

    return messages;
  }

  /**
   * Append tool execution to existing history (no user message added)
   */
  appendToolExecution(
    toolCalls: any[],
    toolResults: any[],
    previousMessages: any[]
  ): any[] {
    const messages = [...previousMessages];

    // Build model message with thought signatures preserved
    const modelMessage = ReasoningPreserver.buildGoogleModelMessageWithThinking(toolCalls);
    messages.push(modelMessage);

    // Add function response parts
    const functionResponseParts = toolResults.map(result => ({
      functionResponse: {
        name: result.name || result.function?.name,
        response: result.success
          ? (result.result || {})
          : { error: result.error || 'Tool execution failed' }
      }
    }));

    messages.push({
      role: 'user',
      parts: functionResponseParts
    });

    return messages;
  }
}

```

## services/chat/builders/IContextBuilder.ts

```typescript
/**
 * IContextBuilder - Interface for provider-specific conversation context builders
 *
 * Each provider (OpenAI, Anthropic, Google, etc.) has different message formats
 * for conversations and tool calls. This interface defines the contract that
 * all provider-specific builders must implement.
 *
 * Follows Interface Segregation Principle - focused contract for context building.
 */

import { ConversationData } from '../../../types/chat/ChatTypes';

export interface IContextBuilder {
  /**
   * Provider identifier for this builder
   */
  readonly provider: string;

  /**
   * Build LLM-ready conversation context from stored conversation data
   * Used when loading an existing conversation to continue it
   *
   * @param conversation - The stored conversation data with messages and tool calls
   * @param systemPrompt - Optional system prompt to prepend
   * @returns Properly formatted message array for the provider
   */
  buildContext(conversation: ConversationData, systemPrompt?: string): any[];

  /**
   * Build tool continuation context for streaming pingpong pattern
   * After tools are executed during streaming, this builds the continuation
   * context to send back to the LLM for the next response.
   *
   * @param userPrompt - Original user prompt
   * @param toolCalls - Tool calls that were detected and executed
   * @param toolResults - Results from tool execution
   * @param previousMessages - Previous conversation messages (optional)
   * @param systemPrompt - System prompt (optional, used by some providers)
   * @returns Continuation context as message array
   */
  buildToolContinuation(
    userPrompt: string,
    toolCalls: any[],
    toolResults: any[],
    previousMessages?: any[],
    systemPrompt?: string
  ): any[];

  /**
   * Append tool execution to existing conversation history
   * Used for accumulating conversation history during recursive tool calls.
   * Does NOT add the user message - only appends tool call and results.
   *
   * @param toolCalls - Tool calls that were executed
   * @param toolResults - Results from tool execution
   * @param previousMessages - Existing conversation history
   * @returns Updated message array with tool execution appended
   */
  appendToolExecution(
    toolCalls: any[],
    toolResults: any[],
    previousMessages: any[]
  ): any[];
}

/**
 * Helper type for message validation
 */
export interface MessageValidationContext {
  msg: any;
  isLastMessage: boolean;
}

```

## services/chat/builders/index.ts

```typescript
/**
 * Context Builders - Provider-specific conversation context formatting
 *
 * This module exports all context builder related types and utilities.
 */

// Interface
export type { IContextBuilder, MessageValidationContext } from './IContextBuilder';

// Concrete builders
export { OpenAIContextBuilder } from './OpenAIContextBuilder';
export { AnthropicContextBuilder } from './AnthropicContextBuilder';
export { GoogleContextBuilder } from './GoogleContextBuilder';
export { CustomFormatContextBuilder } from './CustomFormatContextBuilder';

// Factory
export {
  getContextBuilder,
  getProviderCategory,
  isOpenAICompatible,
  isCustomFormat,
  usesCustomToolFormat
} from './ContextBuilderFactory';

export type { ProviderCategory } from './ContextBuilderFactory';

```

## services/chat/builders/OpenAIContextBuilder.ts

```typescript
/**
 * OpenAIContextBuilder - Builds conversation context for OpenAI-compatible providers
 *
 * Used by: OpenAI, OpenRouter, Groq, Mistral, Requesty, Perplexity
 *
 * OpenAI format uses:
 * - Separate assistant + tool result messages
 * - tool_calls array in assistant messages
 * - 'tool' role for tool results with tool_call_id
 *
 * Follows Single Responsibility Principle - only handles OpenAI format.
 */

import { IContextBuilder } from './IContextBuilder';
import { ConversationData } from '../../../types/chat/ChatTypes';
import { ReasoningPreserver } from '../../llm/adapters/shared/ReasoningPreserver';

export class OpenAIContextBuilder implements IContextBuilder {
  readonly provider = 'openai';

  /**
   * Validate if a message should be included in LLM context
   */
  private isValidForContext(msg: any, isLastMessage: boolean): boolean {
    if (msg.state === 'invalid' || msg.state === 'streaming') return false;
    if (msg.role === 'user' && (!msg.content || !msg.content.trim())) return false;

    if (msg.role === 'assistant') {
      const hasContent = msg.content && msg.content.trim();
      const hasToolCalls = msg.toolCalls && msg.toolCalls.length > 0;

      if (!hasContent && !hasToolCalls && !isLastMessage) return false;

      if (hasToolCalls) {
        const allHaveResults = msg.toolCalls.every((tc: any) =>
          tc.result !== undefined || tc.error !== undefined
        );
        if (!allHaveResults) return false;
      }
    }

    return true;
  }

  /**
   * Build context from stored conversation
   */
  buildContext(conversation: ConversationData, systemPrompt?: string): any[] {
    const messages: any[] = [];

    if (systemPrompt) {
      messages.push({ role: 'system', content: systemPrompt });
    }

    // Filter valid messages
    const validMessages = conversation.messages.filter((msg, index) => {
      const isLastMessage = index === conversation.messages.length - 1;
      return this.isValidForContext(msg, isLastMessage);
    });

    validMessages.forEach((msg) => {
      if (msg.role === 'user') {
        if (msg.content && msg.content.trim()) {
          messages.push({ role: 'user', content: msg.content });
        }
      } else if (msg.role === 'assistant') {
        if (msg.toolCalls && msg.toolCalls.length > 0) {
          // Build proper OpenAI tool_calls format for continuations
          const toolCallsFormatted = msg.toolCalls.map((tc: any) => ({
            id: tc.id,
            type: 'function',
            function: {
              name: tc.function?.name || tc.name || '',
              arguments: tc.function?.arguments || JSON.stringify(tc.parameters || {})
            }
          }));

          // Assistant message with tool_calls array (content can be empty or text)
          messages.push({
            role: 'assistant',
            content: msg.content || '',
            tool_calls: toolCallsFormatted
          });

          // Add tool result messages with proper tool_call_id
          msg.toolCalls.forEach((toolCall: any) => {
            const resultContent = toolCall.success !== false
              ? JSON.stringify(toolCall.result || {})
              : JSON.stringify({ error: toolCall.error || 'Tool execution failed' });

            messages.push({
              role: 'tool',
              tool_call_id: toolCall.id,
              content: resultContent
            });
          });
        } else {
          if (msg.content && msg.content.trim()) {
            messages.push({ role: 'assistant', content: msg.content });
          }
        }
      } else if (msg.role === 'tool') {
        // Handle separately stored tool result messages (from subagent)
        // These need tool_call_id from metadata
        const toolCallId = (msg as any).metadata?.toolCallId;
        if (toolCallId) {
          messages.push({
            role: 'tool',
            tool_call_id: toolCallId,
            content: msg.content || '{}'
          });
        }
      }
    });

    return messages;
  }

  /**
   * Build tool continuation for pingpong pattern
   * IMPORTANT: Filters out system messages - they should be passed separately as systemPrompt
   */
  buildToolContinuation(
    userPrompt: string,
    toolCalls: any[],
    toolResults: any[],
    previousMessages?: any[],
    systemPrompt?: string
  ): any[] {
    const messages: any[] = [];

    // Filter out system messages - OpenAI/OpenRouter expect them in a separate systemPrompt param
    if (previousMessages && previousMessages.length > 0) {
      const nonSystemMessages = previousMessages.filter(msg => msg.role !== 'system');
      messages.push(...nonSystemMessages);
    }

    if (userPrompt) {
      messages.push({ role: 'user', content: userPrompt });
    }

    // Build assistant message with reasoning preserved using centralized utility
    const assistantMessage = ReasoningPreserver.buildAssistantMessageWithReasoning(toolCalls, null);

    messages.push(assistantMessage);

    // Add tool result messages
    toolResults.forEach((result, index) => {
      const toolCall = toolCalls[index];
      const resultContent = result.success
        ? JSON.stringify(result.result || {})
        : JSON.stringify({ error: result.error || 'Tool execution failed' });

      messages.push({
        role: 'tool',
        tool_call_id: toolCall.id,
        content: resultContent
      });
    });

    return messages;
  }

  /**
   * Append tool execution to existing history (no user message added)
   * Filters out system messages to prevent API errors
   */
  appendToolExecution(
    toolCalls: any[],
    toolResults: any[],
    previousMessages: any[]
  ): any[] {
    // Filter out system messages - they should be handled separately
    const messages = previousMessages.filter(msg => msg.role !== 'system');

    // Build assistant message with reasoning preserved using centralized utility
    const assistantMessage = ReasoningPreserver.buildAssistantMessageWithReasoning(toolCalls, null);

    messages.push(assistantMessage);

    // Add tool result messages
    toolResults.forEach((result, index) => {
      const toolCall = toolCalls[index];
      messages.push({
        role: 'tool',
        tool_call_id: toolCall.id,
        content: result.success
          ? JSON.stringify(result.result || {})
          : JSON.stringify({ error: result.error || 'Tool execution failed' })
      });
    });

    return messages;
  }
}

```

## services/chat/ChatService.ts

```typescript
/**
 * ChatService - Native chatbot with direct agent integration
 *
 * Internal chatbot that calls LLM and executes tool calls via MCPConnector.
 *
 * Flow: User message â†’ LLM â†’ Tool calls â†’ MCPConnector â†’ Agents â†’ Results â†’ LLM â†’ Response
 */

import { ConversationData, ConversationMessage, ToolCall, CreateConversationParams } from '../../types/chat/ChatTypes';
import { getErrorMessage } from '../../utils/errorUtils';
import { ToolCallService } from './ToolCallService';
import { CostTrackingService } from './CostTrackingService';
import { ConversationQueryService } from './ConversationQueryService';
import { ConversationManager } from './ConversationManager';
import { StreamingResponseService } from './StreamingResponseService';
import { ChatTraceService } from './ChatTraceService';

export interface ChatServiceOptions {
  maxToolIterations?: number;
  toolTimeout?: number;
  enableToolChaining?: boolean;
}

export interface ChatServiceDependencies {
  conversationService: any;
  llmService: any;
  vaultName: string;
  mcpConnector: any; // Required - MCPConnector for tool execution
  chatTraceService?: ChatTraceService; // Optional - for creating memory traces
}

export class ChatService {
  private toolCallService: ToolCallService;
  private costTrackingService: CostTrackingService;
  private conversationQueryService: ConversationQueryService;
  private conversationManager: ConversationManager;
  private streamingResponseService: StreamingResponseService;
  private chatTraceService?: ChatTraceService;
  private currentProvider?: string; // Track current provider for context building
  private currentSessionId?: string; // Track current session ID for tool execution
  private isInitialized: boolean = false;

  constructor(
    private dependencies: ChatServiceDependencies,
    private options: ChatServiceOptions = {}
  ) {
    this.options = {
      maxToolIterations: 10,
      toolTimeout: 30000,
      enableToolChaining: true,
      ...options
    };

    // Initialize services
    this.toolCallService = new ToolCallService(dependencies.mcpConnector);
    this.costTrackingService = new CostTrackingService(dependencies.conversationService);
    this.conversationQueryService = new ConversationQueryService(dependencies.conversationService);
    this.streamingResponseService = new StreamingResponseService({
      llmService: dependencies.llmService,
      conversationService: dependencies.conversationService,
      toolCallService: this.toolCallService,
      costTrackingService: this.costTrackingService
    });
    this.conversationManager = new ConversationManager(
      {
        conversationService: dependencies.conversationService,
        streamingGenerator: this.generateResponseStreaming.bind(this)
      },
      dependencies.vaultName
    );

    // Optional trace service for memory traces
    this.chatTraceService = dependencies.chatTraceService;
  }

  /**
   * Set the chat trace service (can be set after construction)
   */
  setChatTraceService(service: ChatTraceService): void {
    this.chatTraceService = service;
  }

  /** Set tool event callback for live UI updates */
  setToolEventCallback(callback: (messageId: string, event: 'detected' | 'updated' | 'started' | 'completed', data: any) => void): void {
    this.toolCallService.setEventCallback(callback);
  }

  /**
   * Set the DirectToolExecutor for direct tool execution
   * This enables tools on ALL platforms (desktop + mobile) without MCP
   */
  setDirectToolExecutor(executor: any): void {
    this.toolCallService.setDirectToolExecutor(executor);
  }

  /** Initialize the tool service */
  async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    await this.toolCallService.initialize();
    this.isInitialized = true;
  }

  /**
   * Create a new conversation
   */
  async createConversation(
    title: string,
    initialMessage?: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
      workspaceId?: string;
    }
  ): Promise<{
    success: boolean;
    conversationId?: string;
    sessionId?: string;
    error?: string;
  }> {
    try {
      const conversation = await this.conversationManager.createConversation({
        title,
        initialMessage,
        provider: options?.provider,
        model: options?.model,
        systemPrompt: options?.systemPrompt,
        workspaceId: options?.workspaceId
      });

      const sessionId = conversation.metadata?.chatSettings?.sessionId;
      const workspaceId = options?.workspaceId || 'default';

      // Initialize trace session if we have a workspace
      if (this.chatTraceService && workspaceId) {
        try {
          await this.chatTraceService.initializeSession(conversation.id, workspaceId, sessionId);
          await this.chatTraceService.traceConversationEvent(conversation.id, 'started', title);
        } catch (error) {
        }
      }

      // If there's an initial message, get AI response
      if (initialMessage?.trim()) {
        // Trace user message
        if (this.chatTraceService) {
          await this.chatTraceService.traceUserMessage(conversation.id, 'initial', initialMessage);
        }

        // Generate streaming response
        let completeResponse = '';
        for await (const chunk of this.generateResponseStreaming(conversation.id, initialMessage, options)) {
          completeResponse += chunk.chunk;
        }

        // Trace assistant response
        if (this.chatTraceService && completeResponse) {
          await this.chatTraceService.traceAssistantMessage(conversation.id, 'initial_response', completeResponse);
        }
      }

      return {
        success: true,
        conversationId: conversation.id,
        sessionId
      };
    } catch (error) {
      console.error('[ChatService] Failed to create conversation:', error);
      return {
        success: false,
        error: getErrorMessage(error)
      };
    }
  }

  /**
   * Add a message to a conversation
   */
  async addMessage(params: {
    conversationId: string;
    role: 'user' | 'assistant';
    content: string;
    toolCalls?: any[];
    metadata?: any;
    id?: string; // Optional: specify messageId for consistency with in-memory state
  }): Promise<{ success: boolean; messageId?: string; error?: string }> {
    try {
      await this.conversationManager.addMessage({
        conversationId: params.conversationId,
        role: params.role,
        content: params.content,
        toolCalls: params.toolCalls,
        metadata: params.metadata,
        id: params.id
      });

      return {
        success: true,
        messageId: params.id // Return the ID that was used
      };
    } catch (error) {
      console.error('Failed to add message:', error);
      return {
        success: false,
        error: getErrorMessage(error)
      };
    }
  }

  /**
   * Send a message and get AI response with iterative tool execution
   */
  async sendMessage(
    conversationId: string,
    message: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
      workspaceId?: string;
      sessionId?: string;
    }
  ): Promise<{
    success: boolean;
    messageId?: string;
    error?: string;
  }> {
    try {
      // Use streaming method and collect complete response
      let completeResponse = '';
      let messageId: string | undefined;
      for await (const chunk of this.conversationManager.sendMessage(conversationId, message, options)) {
        completeResponse += chunk.chunk;
        messageId = chunk.messageId;
      }

      return {
        success: true,
        messageId
      };
    } catch (error) {
      console.error('Failed to send message:', error);
      return {
        success: false,
        error: getErrorMessage(error)
      };
    }
  }

  /**
   * Generate AI response with streaming support
   * Yields chunks of the response as they're generated
   *
   * Delegates to StreamingResponseService for coordination
   */
  async* generateResponseStreaming(
    conversationId: string,
    userMessage: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
      workspaceId?: string;
      sessionId?: string;
      messageId?: string;
      abortSignal?: AbortSignal;
      excludeFromMessageId?: string;
      enableThinking?: boolean;
      thinkingEffort?: 'low' | 'medium' | 'high';
    }
  ): AsyncGenerator<{ chunk: string; complete: boolean; messageId: string; toolCalls?: any[]; reasoning?: string; reasoningComplete?: boolean; usage?: { promptTokens: number; completionTokens: number; totalTokens: number } }, void, unknown> {
    // Store current provider and session for backward compatibility
    if (options?.provider) {
      this.currentProvider = options.provider;
      this.streamingResponseService.setProvider(options.provider);
    }
    if (options?.sessionId) {
      this.currentSessionId = options.sessionId;
    }

    // Delegate to StreamingResponseService
    yield* this.streamingResponseService.generateResponse(conversationId, userMessage, options);
  }

  /**
   * Update conversation with new data
   */
  async updateConversation(conversation: ConversationData): Promise<{ success: boolean; error?: string }> {
    try {
      await this.conversationManager.updateConversation(conversation.id, {
        title: conversation.title,
        messages: conversation.messages
      });

      return {
        success: true
      };
    } catch (error) {
      console.error('Failed to update conversation:', error);
      return {
        success: false,
        error: getErrorMessage(error)
      };
    }
  }

  /** Get conversation by ID */
  async getConversation(
    id: string,
    paginationOptions?: { page?: number; pageSize?: number }
  ): Promise<ConversationData | null> {
    return this.conversationQueryService.getConversation(id, paginationOptions);
  }

  /** Get messages for a conversation (paginated) */
  async getMessages(
    conversationId: string,
    options?: { page?: number; pageSize?: number }
  ): Promise<any> {
    return this.conversationQueryService.getMessages(conversationId, options);
  }

  /** List conversations */
  async listConversations(options?: { limit?: number; offset?: number }): Promise<ConversationData[]> {
    return this.conversationQueryService.listConversations(options);
  }

  /**
   * Delete conversation
   */
  async deleteConversation(id: string): Promise<boolean> {
    return await this.conversationManager.deleteConversation(id);
  }

  /**
   * Update conversation title
   */
  async updateConversationTitle(id: string, newTitle: string): Promise<boolean> {
    try {
      await this.conversationManager.updateTitle(id, newTitle);
      return true;
    } catch (error) {
      console.error('Failed to update conversation title:', error);
      return false;
    }
  }

  /** Search conversations */
  async searchConversations(query: string, limit = 10): Promise<any[]> {
    const results = await this.conversationQueryService.searchConversations(query, { limit });
    return results.map(conv => ({
      id: conv.id,
      title: conv.title,
      summary: conv.messages[0]?.content.substring(0, 100) + '...',
      relevanceScore: 0.8,
      lastUpdated: conv.updated
    }));
  }

  /** Get conversation repository for branch management */
  getConversationRepository(): any {
    return this.conversationQueryService.getConversationRepository();
  }

  /** Get conversation service (alias for getConversationRepository) */
  getConversationService(): any {
    return this.conversationQueryService.getConversationService();
  }

  /**
   * Check if any LLM providers are configured and available
   */
  hasConfiguredProviders(): boolean {
    const llmService = this.dependencies.llmService;
    if (!llmService || typeof llmService.getAvailableProviders !== 'function') {
      return false;
    }
    const availableProviders = llmService.getAvailableProviders();
    return availableProviders && availableProviders.length > 0;
  }

  /**
   * Get the LLM service for direct streaming access
   * Used by subagent infrastructure for autonomous LLM calls
   */
  getLLMService(): any {
    return this.dependencies.llmService;
  }

  /**
   * Cleanup resources
   */
  async dispose(): Promise<void> {
    // Cleanup if needed
  }
}

```

## services/chat/ChatTraceService.ts

```typescript
/**
 * Location: src/services/chat/ChatTraceService.ts
 * Purpose: Bridge between chat conversations and workspace memory traces
 *
 * Responsibilities:
 * - Ensure sessions exist when conversations start with a workspace
 * - Create traces for conversation events (messages, tool calls)
 * - Scope traces to the correct workspace/session
 *
 * Design:
 * - Uses WorkspaceService for session/trace operations
 * - Tracks active sessions per conversation
 * - Emits events that can be consumed by embedding service
 */

import { WorkspaceService } from '../WorkspaceService';
import { EmbeddingService } from '../embeddings/EmbeddingService';
import { TraceMetadata } from '../../database/types/memory/MemoryTypes';

export interface TraceContext {
  workspaceId: string;
  sessionId: string;
  conversationId: string;
}

export interface ChatTraceServiceDependencies {
  workspaceService: WorkspaceService;
  embeddingService?: EmbeddingService;
}

/**
 * Service for creating memory traces from chat conversations
 */
export class ChatTraceService {
  private workspaceService: WorkspaceService;
  private embeddingService?: EmbeddingService;

  // Track active sessions per conversation
  private conversationSessions: Map<string, TraceContext> = new Map();

  // Track sessions that have been created to avoid duplicate creation
  private createdSessions: Set<string> = new Set();

  constructor(deps: ChatTraceServiceDependencies) {
    this.workspaceService = deps.workspaceService;
    this.embeddingService = deps.embeddingService;
  }

  /**
   * Set the embedding service (can be set after construction)
   */
  setEmbeddingService(embeddingService: EmbeddingService): void {
    this.embeddingService = embeddingService;
  }

  /**
   * Initialize a session for a conversation
   * Creates the session in the workspace system if it doesn't exist
   *
   * @param conversationId - The conversation ID
   * @param workspaceId - The workspace ID (defaults to 'default')
   * @param sessionId - Optional session ID (generated if not provided)
   */
  async initializeSession(
    conversationId: string,
    workspaceId: string = 'default',
    sessionId?: string
  ): Promise<TraceContext> {
    // Check if we already have a context for this conversation
    const existing = this.conversationSessions.get(conversationId);
    if (existing) {
      return existing;
    }

    // Generate session ID if not provided
    const finalSessionId = sessionId || this.generateSessionId();
    const sessionKey = `${workspaceId}:${finalSessionId}`;

    // Create session in workspace if not already created
    if (!this.createdSessions.has(sessionKey)) {
      try {
        // Check if workspace exists, create if not
        let workspace = await this.workspaceService.getWorkspace(workspaceId);
        if (!workspace) {
          // Create default workspace if it doesn't exist
          if (workspaceId === 'default') {
            workspace = await this.workspaceService.createWorkspace({
              name: 'Default Workspace',
              description: 'Default workspace for chat conversations',
              rootFolder: '/'
            });
          } else {
            throw new Error(`Workspace ${workspaceId} not found`);
          }
        }

        // Create session in workspace
        await this.workspaceService.addSession(workspaceId, {
          id: finalSessionId,
          name: `Chat Session ${new Date().toLocaleString()}`,
          description: `Session for conversation ${conversationId}`,
          startTime: Date.now(),
          isActive: true
        });

        this.createdSessions.add(sessionKey);
      } catch (error) {
        console.error(`[ChatTraceService] Failed to create session:`, error);
        // Continue anyway - traces will be created when session exists
      }
    }

    // Store context
    const context: TraceContext = {
      workspaceId,
      sessionId: finalSessionId,
      conversationId
    };
    this.conversationSessions.set(conversationId, context);

    return context;
  }

  /**
   * Record a user message as a trace
   */
  async traceUserMessage(
    conversationId: string,
    messageId: string,
    content: string
  ): Promise<void> {
    const context = this.conversationSessions.get(conversationId);
    if (!context) {
      return;
    }

    await this.addTrace(context, {
      type: 'user_message',
      content: content.slice(0, 500), // Truncate for trace storage
      metadata: {
        messageId,
        conversationId,
        fullLength: content.length
      }
    });
  }

  /**
   * Record an assistant message as a trace
   */
  async traceAssistantMessage(
    conversationId: string,
    messageId: string,
    content: string
  ): Promise<void> {
    const context = this.conversationSessions.get(conversationId);
    if (!context) {
      return;
    }

    await this.addTrace(context, {
      type: 'assistant_message',
      content: content.slice(0, 500),
      metadata: {
        messageId,
        conversationId,
        fullLength: content.length
      }
    });
  }

  /**
   * Record a tool call as a trace
   */
  async traceToolCall(
    conversationId: string,
    toolName: string,
    args: Record<string, any>,
    result?: any
  ): Promise<void> {
    const context = this.conversationSessions.get(conversationId);
    if (!context) {
      return;
    }

    const content = `Tool: ${toolName}\nArgs: ${JSON.stringify(args).slice(0, 300)}`;

    await this.addTrace(context, {
      type: 'tool_call',
      content,
      metadata: {
        toolName,
        conversationId,
        hasResult: !!result
      }
    });
  }

  /**
   * Record a conversation event (start, end, etc.)
   */
  async traceConversationEvent(
    conversationId: string,
    eventType: 'started' | 'ended' | 'title_changed' | 'workspace_changed',
    details?: string
  ): Promise<void> {
    const context = this.conversationSessions.get(conversationId);
    if (!context) {
      return;
    }

    await this.addTrace(context, {
      type: 'conversation_event',
      content: `${eventType}: ${details || conversationId}`,
      metadata: {
        eventType,
        conversationId
      }
    });
  }

  /**
   * End a session (mark as inactive)
   */
  async endSession(conversationId: string): Promise<void> {
    const context = this.conversationSessions.get(conversationId);
    if (!context) {
      return;
    }

    try {
      await this.workspaceService.updateSession(context.workspaceId, context.sessionId, {
        endTime: Date.now(),
        isActive: false
      });
    } catch (error) {
      console.error(`[ChatTraceService] Failed to end session:`, error);
    }

    this.conversationSessions.delete(conversationId);
  }

  /**
   * Get the trace context for a conversation
   */
  getContext(conversationId: string): TraceContext | undefined {
    return this.conversationSessions.get(conversationId);
  }

  /**
   * Internal: Add a trace and optionally embed it
   */
  private async addTrace(
    context: TraceContext,
    traceData: {
      type: string;
      content: string;
      metadata?: Record<string, any>;
    }
  ): Promise<void> {
    try {
      // Chat traces use simplified metadata that doesn't match the full TraceMetadata schema.
      // Cast through unknown since this is an intentional structural mismatch.
      const trace = await this.workspaceService.addMemoryTrace(
        context.workspaceId,
        context.sessionId,
        {
          type: traceData.type,
          content: traceData.content,
          metadata: traceData.metadata as unknown as TraceMetadata,
          timestamp: Date.now()
        }
      );

      // Embed the trace if embedding service is available
      if (this.embeddingService && this.embeddingService.isServiceEnabled()) {
        try {
          await this.embeddingService.embedTrace(
            trace.id,
            context.workspaceId,
            context.sessionId,
            traceData.content
          );
        } catch (error) {
          console.error(`[ChatTraceService] Failed to embed trace:`, error);
        }
      }
    } catch (error) {
      console.error(`[ChatTraceService] Failed to add trace:`, error);
    }
  }

  /**
   * Generate a session ID
   */
  private generateSessionId(): string {
    const now = new Date();
    const dateStr = now.toISOString().slice(0, 10).replace(/-/g, '');
    const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, '');
    return `s-${dateStr}${timeStr}`;
  }
}

```

## services/chat/ContextCompactionService.ts

```typescript
/**
 * ContextCompactionService
 *
 * Handles automatic context compaction for token-limited models.
 * When context approaches the limit, this service:
 * 1. Extracts a summary from older messages
 * 2. Truncates old messages while preserving atomic units
 * 3. Returns summary for injection into system prompt as <previous_context>
 *
 * Design decisions:
 * - Fully programmatic (no LLM calls for summary)
 * - Preserves atomic message units (never splits user/assistant/tool sequences)
 * - Simple heuristic-based summary extraction
 * - Can be enhanced later to use createState tool for richer context
 */

import { ConversationMessage, ConversationData } from '../../types/chat/ChatTypes';

/**
 * Summary of compacted conversation context
 */
export interface CompactedContext {
  /** Human-readable summary of truncated conversation */
  summary: string;
  /** Number of messages removed */
  messagesRemoved: number;
  /** Number of messages kept */
  messagesKept: number;
  /** Files mentioned in truncated conversation */
  filesReferenced: string[];
  /** Key topics/tasks extracted from truncated portion */
  topics: string[];
  /** Timestamp of compaction */
  compactedAt: number;
}

/**
 * Options for compaction behavior
 */
export interface CompactionOptions {
  /** Number of complete exchanges to keep (default: 2) */
  exchangesToKeep?: number;
  /** Maximum length for extracted summary (default: 500 chars) */
  maxSummaryLength?: number;
  /** Include file references in summary (default: true) */
  includeFileReferences?: boolean;
}

const DEFAULT_OPTIONS: Required<CompactionOptions> = {
  exchangesToKeep: 2,
  maxSummaryLength: 500,
  includeFileReferences: true,
};

/**
 * Represents an atomic message unit that should not be split
 */
interface AtomicUnit {
  messages: ConversationMessage[];
  type: 'user' | 'assistant' | 'system';
  startIndex: number;
  endIndex: number;
}

export class ContextCompactionService {
  /**
   * Compact a conversation by extracting summary and truncating old messages
   *
   * @param conversation The conversation to compact (modified in place)
   * @param options Compaction options
   * @returns Summary of the compacted content
   */
  compact(
    conversation: ConversationData,
    options: CompactionOptions = {}
  ): CompactedContext {
    const opts = { ...DEFAULT_OPTIONS, ...options };
    const messages = conversation.messages;

    if (messages.length === 0) {
      return {
        summary: '',
        messagesRemoved: 0,
        messagesKept: 0,
        filesReferenced: [],
        topics: [],
        compactedAt: Date.now(),
      };
    }

    // 1. Identify atomic message units
    const units = this.identifyAtomicUnits(messages);

    // 2. Calculate how many units to keep (from the end)
    const unitsToKeep = Math.min(opts.exchangesToKeep * 2, units.length); // 2 units per exchange (user + assistant)
    const unitsToRemove = Math.max(0, units.length - unitsToKeep);

    if (unitsToRemove === 0) {
      return {
        summary: '',
        messagesRemoved: 0,
        messagesKept: messages.length,
        filesReferenced: [],
        topics: [],
        compactedAt: Date.now(),
      };
    }

    // 3. Get messages to remove (oldest units)
    const removedUnits = units.slice(0, unitsToRemove);
    const removedMessages: ConversationMessage[] = [];
    for (const unit of removedUnits) {
      removedMessages.push(...unit.messages);
    }

    // 4. Extract summary from removed messages
    const summary = this.extractSummary(removedMessages, opts);
    const filesReferenced = opts.includeFileReferences
      ? this.extractFileReferences(removedMessages)
      : [];
    const topics = this.extractTopics(removedMessages);

    // 5. Calculate kept messages
    const keptUnits = units.slice(unitsToRemove);
    const keptMessages: ConversationMessage[] = [];
    for (const unit of keptUnits) {
      keptMessages.push(...unit.messages);
    }

    // 6. Update conversation messages in place
    conversation.messages = keptMessages;

    return {
      summary,
      messagesRemoved: removedMessages.length,
      messagesKept: keptMessages.length,
      filesReferenced,
      topics,
      compactedAt: Date.now(),
    };
  }

  /**
   * Identify atomic message units that should not be split
   * - User message = 1 unit
   * - Assistant message (possibly with tool calls) = 1 unit
   * - System message = 1 unit
   */
  private identifyAtomicUnits(messages: ConversationMessage[]): AtomicUnit[] {
    const units: AtomicUnit[] = [];
    let i = 0;

    while (i < messages.length) {
      const msg = messages[i];

      if (msg.role === 'user') {
        units.push({
          messages: [msg],
          type: 'user',
          startIndex: i,
          endIndex: i,
        });
        i++;
      } else if (msg.role === 'assistant') {
        // Assistant message might have tool calls followed by tool results
        const unitMessages: ConversationMessage[] = [msg];
        let endIndex = i;

        // If this assistant message has tool calls, include subsequent tool results
        if (msg.toolCalls && msg.toolCalls.length > 0) {
          // Look ahead for tool role messages
          let j = i + 1;
          while (j < messages.length && messages[j].role === 'tool') {
            unitMessages.push(messages[j]);
            endIndex = j;
            j++;
          }
        }

        units.push({
          messages: unitMessages,
          type: 'assistant',
          startIndex: i,
          endIndex,
        });
        i = endIndex + 1;
      } else if (msg.role === 'system') {
        units.push({
          messages: [msg],
          type: 'system',
          startIndex: i,
          endIndex: i,
        });
        i++;
      } else {
        // Tool messages should be included with their assistant message
        // If we encounter one standalone, include it as its own unit
        units.push({
          messages: [msg],
          type: 'assistant', // Treat as assistant unit
          startIndex: i,
          endIndex: i,
        });
        i++;
      }
    }

    return units;
  }

  /**
   * Extract a summary from removed messages
   */
  private extractSummary(
    messages: ConversationMessage[],
    opts: Required<CompactionOptions>
  ): string {
    if (messages.length === 0) return '';

    const parts: string[] = [];

    // Find the first user message to understand the initial request
    const firstUserMsg = messages.find((m) => m.role === 'user');
    if (firstUserMsg) {
      const truncatedContent = this.truncateText(firstUserMsg.content, 150);
      parts.push(`Initial request: "${truncatedContent}"`);
    }

    // Find key tasks from assistant messages
    const assistantMessages = messages.filter((m) => m.role === 'assistant');
    const tasks: string[] = [];

    for (const msg of assistantMessages) {
      // Extract task-like statements (simplified heuristic)
      if (msg.toolCalls && msg.toolCalls.length > 0) {
        const toolNames = msg.toolCalls
          .map((tc: any) => tc.function?.name || tc.name || 'tool')
          .slice(0, 3);
        tasks.push(`Used tools: ${toolNames.join(', ')}`);
      }
    }

    if (tasks.length > 0) {
      parts.push(`Activities: ${tasks.slice(0, 3).join('; ')}`);
    }

    // Find the last exchange to understand where we left off
    const lastUserMsg = [...messages].reverse().find((m) => m.role === 'user');
    const lastAssistantMsg = [...messages].reverse().find((m) => m.role === 'assistant');

    if (lastUserMsg && lastUserMsg !== firstUserMsg) {
      const truncatedContent = this.truncateText(lastUserMsg.content, 100);
      parts.push(`Last discussed: "${truncatedContent}"`);
    }

    if (lastAssistantMsg) {
      const truncatedContent = this.truncateText(lastAssistantMsg.content, 100);
      parts.push(`Assistant was: "${truncatedContent}"`);
    }

    const summary = parts.join(' | ');
    return this.truncateText(summary, opts.maxSummaryLength);
  }

  /**
   * Extract file references from messages (wikilinks and paths)
   */
  private extractFileReferences(messages: ConversationMessage[]): string[] {
    const files = new Set<string>();

    for (const msg of messages) {
      if (!msg.content) continue;

      // Match [[wikilinks]]
      const wikiLinks = msg.content.match(/\[\[([^\]]+)\]\]/g);
      if (wikiLinks) {
        for (const link of wikiLinks) {
          const name = link.slice(2, -2).split('|')[0]; // Handle [[link|alias]]
          files.add(name);
        }
      }

      // Match common file paths (simplified)
      const pathMatches = msg.content.match(/(?:^|[\s"'`])([a-zA-Z0-9_/-]+\.(?:md|txt|json|ts|js|py))/g);
      if (pathMatches) {
        for (const path of pathMatches) {
          files.add(path.trim());
        }
      }
    }

    return Array.from(files).slice(0, 10); // Limit to 10 files
  }

  /**
   * Extract key topics/tasks from messages (simple keyword extraction)
   */
  private extractTopics(messages: ConversationMessage[]): string[] {
    const topics = new Set<string>();

    for (const msg of messages) {
      if (msg.role !== 'user' || !msg.content) continue;

      // Look for task-like phrases
      const content = msg.content.toLowerCase();

      // Common task verbs
      const taskVerbs = ['create', 'write', 'update', 'fix', 'add', 'remove', 'edit', 'search', 'find', 'implement', 'refactor'];
      for (const verb of taskVerbs) {
        if (content.includes(verb)) {
          // Extract a short phrase after the verb
          const regex = new RegExp(`${verb}\\s+([a-zA-Z0-9\\s]{3,30})`, 'i');
          const match = msg.content.match(regex);
          if (match) {
            topics.add(`${verb} ${match[1].trim()}`.slice(0, 40));
          }
        }
      }
    }

    return Array.from(topics).slice(0, 5); // Limit to 5 topics
  }

  /**
   * Truncate text to max length, adding ellipsis if truncated
   */
  private truncateText(text: string, maxLength: number): string {
    if (!text) return '';
    if (text.length <= maxLength) return text;
    return text.slice(0, maxLength - 3).trim() + '...';
  }

  /**
   * Check if compaction is recommended based on message count
   * (Supplement to token-based check in ContextTokenTracker)
   */
  shouldCompactByMessageCount(conversation: ConversationData, maxMessages: number = 20): boolean {
    return conversation.messages.length > maxMessages;
  }
}

```

## services/chat/ContextPreservationService.ts

```typescript
/**
 * ContextPreservationService
 *
 * Forces the LLM to save important context via createState tool before compaction.
 * This is a subprocess that runs at 90% context threshold.
 *
 * Flow:
 * 1. Swap system prompt to one that REQUIRES createState tool use
 * 2. Send conversation to LLM with this special prompt
 * 3. Wait for createState tool call
 * 4. Validate tool was called correctly
 * 5. Retry up to MAX_RETRIES times if validation fails
 * 6. Return saved state content for injection into previous_context
 */

import { ConversationMessage } from '../../types/chat/ChatTypes';
import type { IAgent } from '../../agents/interfaces/IAgent';

/**
 * System prompt that forces the model to use createState
 */
const SAVE_STATE_SYSTEM_PROMPT = `You are about to reach your context limit. You MUST use the createState tool to save important context from this conversation before it is compacted.

CRITICAL: You MUST call the createState tool. Do not respond with text - only use the tool.

Include in your state:
- The user's overall goal/task
- Key decisions made so far
- Important files/paths discussed
- Current status/progress
- Any constraints or preferences the user mentioned
- Critical context needed to continue the conversation

Call the createState tool NOW with a descriptive id and comprehensive content.`;

/**
 * Result of a preservation attempt
 */
export interface PreservationResult {
  success: boolean;
  stateId?: string;
  stateContent?: string;
  error?: string;
  attempts: number;
}

/**
 * Options for the preservation service
 */
export interface PreservationOptions {
  maxRetries?: number;
  timeout?: number;
}

const DEFAULT_OPTIONS: Required<PreservationOptions> = {
  maxRetries: 2,
  timeout: 30000,
};

/**
 * Tool call format from LLM response
 */
interface ToolCall {
  id?: string;
  function?: {
    name: string;
    arguments: string;
  };
  name?: string;
  params?: any;
  parameters?: any;
  input?: any;
}

/**
 * DirectToolCall format for executor
 */
interface DirectToolCall {
  id: string;
  type: 'function';
  function: {
    name: string;
    arguments: string;
  };
}

/**
 * Dependencies for the preservation service
 */
export interface PreservationDependencies {
  /** LLM service for generating responses */
  llmService: {
    generateResponseStream: (
      messages: ConversationMessage[],
      options: {
        provider?: string;
        model?: string;
        systemPrompt?: string;
        tools?: any[];
      }
    ) => AsyncGenerator<{
      chunk: string;
      complete: boolean;
      toolCalls?: ToolCall[];
    }>;
  };
  /** Agent provider for getting tool schemas */
  getAgent: (name: string) => IAgent | null;
  /** Tool executor for running createState */
  executeToolCalls: (
    toolCalls: DirectToolCall[],
    context?: { sessionId?: string; workspaceId?: string }
  ) => Promise<Array<{ success: boolean; result?: any; error?: string }>>;
}

export class ContextPreservationService {
  private deps: PreservationDependencies;
  private options: Required<PreservationOptions>;

  constructor(
    deps: PreservationDependencies,
    options: PreservationOptions = {}
  ) {
    this.deps = deps;
    this.options = { ...DEFAULT_OPTIONS, ...options };
  }

  /**
   * Get createState tool schema in OpenAI format
   */
  private getCreateStateToolSchema(): any | null {
    const memoryManager = this.deps.getAgent('memoryManager');
    if (!memoryManager) {
      return null;
    }

    const createStateTool = memoryManager.getTool('createState');
    if (!createStateTool) {
      return null;
    }

    return {
      type: 'function',
      function: {
        name: 'createState',
        description: createStateTool.description,
        parameters: createStateTool.getParameterSchema(),
      },
    };
  }

  /**
   * Force the LLM to save conversation state via createState tool
   *
   * @param messages Current conversation messages
   * @param llmOptions Provider/model options for the LLM call
   * @param contextOptions Workspace/session context for tool execution
   * @returns PreservationResult with saved state content or error
   */
  async forceStateSave(
    messages: ConversationMessage[],
    llmOptions: {
      provider?: string;
      model?: string;
    },
    contextOptions: {
      workspaceId?: string;
      sessionId?: string;
    }
  ): Promise<PreservationResult> {
    // Get createState tool schema
    const createStateSchema = this.getCreateStateToolSchema();
    if (!createStateSchema) {
      return {
        success: false,
        error: 'createState tool not found in memoryManager',
        attempts: 0,
      };
    }

    let attempts = 0;
    let currentMessages = [...messages];

    while (attempts < this.options.maxRetries) {
      attempts++;

      try {
        const result = await this.attemptStateSave(
          currentMessages,
          llmOptions,
          contextOptions,
          createStateSchema
        );

        if (result.success) {
          return { ...result, attempts };
        }

        // If we got a response but no valid tool call, retry with stronger prompt
        if (attempts < this.options.maxRetries) {
          // Add a reminder message for retry
          // Get conversationId from first message (all messages in a conversation share this)
          const conversationId = currentMessages[0]?.conversationId || 'context_save';
          currentMessages = [
            ...currentMessages,
            {
              id: `retry_${attempts}`,
              role: 'user' as const,
              content: 'You did not call the createState tool. You MUST call it now to save the conversation context.',
              timestamp: Date.now(),
              conversationId,
            },
          ];
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);

        if (attempts >= this.options.maxRetries) {
          return {
            success: false,
            error: `Failed after ${attempts} attempts: ${errorMessage}`,
            attempts,
          };
        }
      }
    }

    return {
      success: false,
      error: `Failed to get valid createState call after ${attempts} attempts`,
      attempts,
    };
  }

  /**
   * Single attempt to get the LLM to save state
   */
  private async attemptStateSave(
    messages: ConversationMessage[],
    llmOptions: {
      provider?: string;
      model?: string;
    },
    contextOptions: {
      workspaceId?: string;
      sessionId?: string;
    },
    createStateSchema: any
  ): Promise<Omit<PreservationResult, 'attempts'>> {
    // Stream response from LLM with save state prompt
    let toolCalls: ToolCall[] = [];

    try {
      for await (const chunk of this.deps.llmService.generateResponseStream(
        messages,
        {
          provider: llmOptions.provider,
          model: llmOptions.model,
          systemPrompt: SAVE_STATE_SYSTEM_PROMPT,
          tools: [createStateSchema],
        }
      )) {
        if (chunk.toolCalls && chunk.toolCalls.length > 0) {
          toolCalls = chunk.toolCalls;
        }
      }
    } catch (error) {
      return {
        success: false,
        error: `LLM generation failed: ${error instanceof Error ? error.message : String(error)}`,
      };
    }

    // Validate we got a createState tool call
    const createStateCall = toolCalls.find((tc) => {
      const name = tc.function?.name || tc.name || '';
      return name === 'createState' || name.includes('createState');
    });

    if (!createStateCall) {
      return {
        success: false,
        error: 'No createState tool call in response',
      };
    }

    // Extract and validate parameters
    const params = this.extractToolParams(createStateCall);
    if (!params.id || !params.content) {
      return {
        success: false,
        error: 'createState call missing required id or content',
      };
    }

    // Format as DirectToolCall for executor
    const directToolCall: DirectToolCall = {
      id: createStateCall.id || `createState_${Date.now()}`,
      type: 'function',
      function: {
        name: 'memoryManager.createState', // Full tool path for DirectToolExecutor
        arguments: JSON.stringify(params),
      },
    };

    // Execute the tool call
    try {
      const results = await this.deps.executeToolCalls(
        [directToolCall],
        contextOptions
      );

      const result = results[0];
      if (result?.success) {
        return {
          success: true,
          stateId: params.id,
          stateContent: params.content,
        };
      } else {
        return {
          success: false,
          error: result?.error || 'createState execution failed',
        };
      }
    } catch (error) {
      return {
        success: false,
        error: `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`,
      };
    }
  }

  /**
   * Extract parameters from a tool call (handles different formats)
   */
  private extractToolParams(toolCall: ToolCall): { id?: string; content?: string } {
    // Try function.arguments format (OpenAI style)
    if (toolCall.function?.arguments) {
      try {
        const args =
          typeof toolCall.function.arguments === 'string'
            ? JSON.parse(toolCall.function.arguments)
            : toolCall.function.arguments;
        return { id: args.id, content: args.content };
      } catch {
        // Fall through
      }
    }

    // Try direct params/parameters/input format
    const params = toolCall.params || toolCall.parameters || toolCall.input || {};
    return { id: params.id, content: params.content };
  }
}

```

## services/chat/ContextTokenTracker.ts

```typescript
/**
 * ContextTokenTracker
 *
 * Tracks token usage for context-limited models (especially Nexus/WebLLM).
 * Uses hybrid approach:
 * - Actual counts from generation usage (accurate)
 * - Estimates from gpt-tokenizer for new messages (approximate)
 *
 * Provides context status for system prompts and triggers auto-compaction.
 */

import { encode } from 'gpt-tokenizer';

export interface ContextStatus {
  usedTokens: number;
  maxTokens: number;
  percentUsed: number;
  status: 'ok' | 'warning' | 'critical';
  shouldCompact: boolean;
}

export interface TokenUsageRecord {
  promptTokens: number;
  completionTokens: number;
  timestamp: number;
}

/**
 * Thresholds for context management (as percentage of max tokens)
 * Using 90% for compaction trigger since gpt-tokenizer gives precise estimates
 */
const THRESHOLDS = {
  WARNING: 0.75,   // 75% - show warning in status
  CRITICAL: 0.90,  // 90% - trigger LLM saveState subprocess
  RESERVE: 0.05,   // 5% - reserved for compaction overhead
} as const;

export class ContextTokenTracker {
  private maxTokens: number;
  private systemPromptTokens: number = 0;
  private conversationTokens: number = 0;
  private usageHistory: TokenUsageRecord[] = [];

  constructor(maxContextWindow: number = 4096) {
    this.maxTokens = maxContextWindow;
  }

  /**
   * Estimate token count for a string using gpt-tokenizer
   * Accuracy: ~85-90% for Qwen/Nexus models
   */
  estimateTokens(text: string): number {
    if (!text) return 0;
    try {
      return encode(text).length;
    } catch {
      // Fallback: rough estimate based on character count
      return Math.ceil(text.length / 4);
    }
  }

  /**
   * Set the system prompt tokens (estimated once at session start)
   */
  setSystemPromptTokens(systemPrompt: string): void {
    this.systemPromptTokens = this.estimateTokens(systemPrompt);
  }

  /**
   * Record actual token usage from a generation response
   * This is the source of truth for consumed tokens
   */
  recordUsage(promptTokens: number, completionTokens: number): void {
    // Update running total based on actual usage
    // The promptTokens includes system prompt + conversation history
    // We use this to correct our estimates
    this.conversationTokens = promptTokens + completionTokens - this.systemPromptTokens;

    this.usageHistory.push({
      promptTokens,
      completionTokens,
      timestamp: Date.now(),
    });

    // Keep only last 20 records for memory efficiency
    if (this.usageHistory.length > 20) {
      this.usageHistory = this.usageHistory.slice(-20);
    }
  }

  /**
   * Estimate tokens for a new message (before sending)
   * Used to check if we need to compact before sending
   */
  estimateWithNewMessage(newMessage: string): number {
    const newMessageTokens = this.estimateTokens(newMessage);
    return this.getTotalUsed() + newMessageTokens;
  }

  /**
   * Get total tokens currently used
   */
  getTotalUsed(): number {
    return this.systemPromptTokens + this.conversationTokens;
  }

  /**
   * Get available tokens (accounting for reserve)
   */
  getAvailableTokens(): number {
    const reserved = Math.floor(this.maxTokens * THRESHOLDS.RESERVE);
    return this.maxTokens - reserved - this.getTotalUsed();
  }

  /**
   * Get current context status
   */
  getStatus(): ContextStatus {
    const usedTokens = this.getTotalUsed();
    const percentUsed = usedTokens / this.maxTokens;

    let status: ContextStatus['status'] = 'ok';
    if (percentUsed >= THRESHOLDS.CRITICAL) {
      status = 'critical';
    } else if (percentUsed >= THRESHOLDS.WARNING) {
      status = 'warning';
    }

    return {
      usedTokens,
      maxTokens: this.maxTokens,
      percentUsed: Math.round(percentUsed * 100),
      status,
      shouldCompact: percentUsed >= THRESHOLDS.CRITICAL,
    };
  }

  /**
   * Generate context status string for system prompt
   * Gives the model awareness of its token limits
   */
  getStatusForPrompt(): string {
    const status = this.getStatus();
    const availableTokens = this.getAvailableTokens();

    if (status.status === 'ok') {
      return `Context: ${status.percentUsed}% used (${availableTokens} tokens available)`;
    }

    if (status.status === 'warning') {
      return `Context: ${status.percentUsed}% used - approaching limit. Consider saving state with saveState tool.`;
    }

    // Critical
    return `Context: ${status.percentUsed}% CRITICAL - context nearly full. Use saveState tool immediately to preserve conversation.`;
  }

  /**
   * Check if compaction should be triggered before sending a message
   */
  shouldCompactBeforeSending(newMessage: string): boolean {
    const projectedTokens = this.estimateWithNewMessage(newMessage);
    const projectedPercent = projectedTokens / this.maxTokens;
    return projectedPercent >= THRESHOLDS.CRITICAL;
  }

  /**
   * Reset tracker (after compaction or new session)
   */
  reset(): void {
    this.conversationTokens = 0;
    this.usageHistory = [];
    // Keep systemPromptTokens - it doesn't change
  }

  /**
   * Set conversation tokens after loading a state
   * Used when restoring from a saved state
   */
  setConversationTokens(tokens: number): void {
    this.conversationTokens = tokens;
  }

  /**
   * Update max tokens (e.g., when switching models)
   */
  setMaxTokens(maxTokens: number): void {
    this.maxTokens = maxTokens;
  }

  /**
   * Get last N usage records for debugging/analytics
   */
  getUsageHistory(count: number = 10): TokenUsageRecord[] {
    return this.usageHistory.slice(-count);
  }
}

```

## services/chat/ConversationContextBuilder.ts

```typescript
/**
 * ConversationContextBuilder - Facade for provider-specific conversation context building
 *
 * This is a thin facade that delegates to provider-specific builders.
 * It maintains backwards compatibility with existing code while internally
 * using the Strategy pattern via the builders module.
 *
 * For direct access to builders, import from './builders' instead.
 *
 * Follows Facade Pattern - simple interface to complex subsystem.
 */

import { ConversationData } from '../../types/chat/ChatTypes';
import {
  getContextBuilder,
  getProviderCategory as getProviderCategoryFromFactory,
  ProviderCategory
} from './builders';

export class ConversationContextBuilder {

  /**
   * Build LLM-ready conversation context from stored conversation data
   *
   * @param conversation - The stored conversation data with tool calls
   * @param provider - LLM provider (determines format)
   * @param systemPrompt - Optional system prompt to prepend
   * @param model - Optional model name (used for local providers to determine format)
   * @returns Properly formatted conversation messages for the LLM provider
   */
  static buildContextForProvider(
    conversation: ConversationData,
    provider: string,
    systemPrompt?: string,
    model?: string
  ): any[] {
    const builder = getContextBuilder(provider, model);
    return builder.buildContext(conversation, systemPrompt);
  }

  /**
   * Build tool continuation context for streaming pingpong pattern
   *
   * After tools are executed during streaming, this builds the continuation
   * context to send back to the LLM for the next response.
   *
   * @param provider - LLM provider (determines format)
   * @param userPrompt - Original user prompt
   * @param toolCalls - Tool calls that were detected and executed
   * @param toolResults - Results from tool execution
   * @param previousMessages - Previous conversation messages (optional)
   * @param systemPrompt - System prompt for OpenAI-style providers (optional)
   * @param model - Optional model name (used for local providers to determine format)
   * @returns Continuation context (message array)
   */
  static buildToolContinuation(
    provider: string,
    userPrompt: string,
    toolCalls: any[],
    toolResults: any[],
    previousMessages?: any[],
    systemPrompt?: string,
    model?: string
  ): any[] {
    // Special case: OpenAI uses Responses API
    if (provider.toLowerCase() === 'openai') {
      throw new Error('OpenAI tool continuation should use buildResponsesAPIToolInput directly via StreamingOrchestrator');
    }

    const builder = getContextBuilder(provider, model);
    return builder.buildToolContinuation(userPrompt, toolCalls, toolResults, previousMessages, systemPrompt);
  }

  /**
   * Build Responses API tool input for OpenAI continuations
   * Converts tool results to ResponseInputItem.FunctionCallOutput format
   *
   * @param toolCalls - Tool calls that were executed
   * @param toolResults - Results from tool execution
   * @returns Array of FunctionCallOutput items for Responses API input
   */
  static buildResponsesAPIToolInput(
    toolCalls: any[],
    toolResults: any[]
  ): any[] {
    const items = toolResults.map((result, index) => {
      const toolCall = toolCalls[index];

      return {
        type: 'function_call_output',
        call_id: toolCall.id,
        output: result.success
          ? JSON.stringify(result.result || {})
          : JSON.stringify({ error: result.error || 'Tool execution failed' })
      };
    });

    // Debug: Show what tool continuation we're building
    console.log('[LLM_DEBUG] buildResponsesAPIToolInput:');
    console.log('[LLM_DEBUG]   Tool calls received:', toolCalls.length);
    toolCalls.forEach((tc, i) => {
      console.log(`[LLM_DEBUG]   [${i}] call_id=${tc.id}, name=${tc.function?.name || tc.name}`);
    });
    console.log('[LLM_DEBUG]   Output items:', JSON.stringify(items, null, 2));

    return items;
  }

  /**
   * Append tool execution to existing conversation history
   *
   * This method appends ONLY the tool call and results to previousMessages.
   * Unlike buildToolContinuation, it does NOT add the user message.
   *
   * Use this for accumulating conversation history during recursive tool calls.
   *
   * @param provider - Provider type (anthropic, google, openai-compatible)
   * @param toolCalls - Tool calls that were executed
   * @param toolResults - Results from tool execution
   * @param previousMessages - Existing conversation history (already contains user message)
   * @param model - Optional model name (used for local providers to determine format)
   * @returns Updated message array with tool execution appended
   */
  static appendToolExecution(
    provider: string,
    toolCalls: any[],
    toolResults: any[],
    previousMessages: any[],
    model?: string
  ): any[] {
    const builder = getContextBuilder(provider, model);
    return builder.appendToolExecution(toolCalls, toolResults, previousMessages);
  }

  /**
   * Get provider category for debugging/logging
   *
   * @param provider - Provider name
   * @param model - Optional model name (used for local providers)
   * @returns Category string
   */
  static getProviderCategory(provider: string, model?: string): ProviderCategory {
    return getProviderCategoryFromFactory(provider, model);
  }
}

```

## services/chat/ConversationManager.ts

```typescript
/**
 * ConversationManager - Handles conversation creation and modification
 *
 * Responsibilities:
 * - Create new conversations with optional initial message
 * - Send messages and coordinate AI responses
 * - Add messages to conversations
 * - Update conversation data
 * - Delete conversations
 *
 * Follows Single Responsibility Principle - only handles conversation write operations.
 */

import { ConversationData, CreateConversationParams } from '../../types/chat/ChatTypes';
import { generateSessionId } from '../../utils/sessionUtils';

export interface ConversationManagerDependencies {
  conversationService: any;
  streamingGenerator: (
    conversationId: string,
    userMessage: string,
    options?: any
  ) => AsyncGenerator<any, void, unknown>;
}

export class ConversationManager {
  constructor(
    private dependencies: ConversationManagerDependencies,
    private vaultName: string
  ) {}

  /**
   * Create a new conversation
   */
  async createConversation(params: CreateConversationParams): Promise<ConversationData> {
    const conversationData = {
      title: params.title,
      vault_name: this.vaultName,
      messages: [],
      metadata: {
        chatSettings: {
          providerId: params.provider,
          modelId: params.model,
          systemPrompt: params.systemPrompt,
          workspaceId: params.workspaceId,
          sessionId: params.sessionId || generateSessionId()
        }
      }
    };

    const conversation = await this.dependencies.conversationService.createConversation(conversationData);

    // Add initial message if provided
    if (params.initialMessage) {
      await this.dependencies.conversationService.addMessage({
        conversationId: conversation.id,
        role: 'user',
        content: params.initialMessage
      });
    }

    return conversation;
  }

  /**
   * Send a message and get AI response
   */
  async* sendMessage(
    conversationId: string,
    message: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
      workspaceId?: string;
      sessionId?: string;
      messageId?: string;
      abortSignal?: AbortSignal;
    }
  ): AsyncGenerator<{ chunk: string; complete: boolean; messageId: string; toolCalls?: any[] }, void, unknown> {
    // Save user message first
    await this.dependencies.conversationService.addMessage({
      conversationId,
      role: 'user',
      content: message
    });

    // Generate streaming response
    yield* this.dependencies.streamingGenerator(conversationId, message, options);
  }

  /**
   * Add a message to a conversation
   */
  async addMessage(params: {
    conversationId: string;
    role: 'user' | 'assistant' | 'system';
    content: string;
    id?: string;
    toolCalls?: any[];
    metadata?: any;
  }): Promise<void> {
    await this.dependencies.conversationService.addMessage(params);
  }

  /**
   * Update conversation metadata
   */
  async updateConversation(conversationId: string, updates: Partial<ConversationData>): Promise<void> {
    await this.dependencies.conversationService.updateConversation(conversationId, updates);
  }

  /**
   * Delete a conversation
   */
  async deleteConversation(id: string): Promise<boolean> {
    try {
      await this.dependencies.conversationService.deleteConversation(id);
      return true;
    } catch (error) {
      console.error('Failed to delete conversation:', error);
      return false;
    }
  }

  /**
   * Update conversation title
   */
  async updateTitle(conversationId: string, title: string): Promise<void> {
    await this.updateConversation(conversationId, { title });
  }

  /**
   * Set conversation workspace
   */
  async setWorkspace(conversationId: string, workspaceId: string): Promise<void> {
    // Get current conversation to preserve existing metadata
    const conversation = await this.dependencies.conversationService.getConversation(conversationId);
    if (!conversation) {
      throw new Error(`Conversation ${conversationId} not found`);
    }

    await this.updateConversation(conversationId, {
      metadata: {
        ...conversation.metadata,
        chatSettings: {
          ...conversation.metadata?.chatSettings,
          workspaceId
        }
      }
    });
  }
}

```

## services/chat/ConversationQueryService.ts

```typescript
/**
 * ConversationQueryService - Handles read operations for conversations
 *
 * Responsibilities:
 * - Get conversation by ID
 * - List conversations with pagination
 * - Search conversations
 * - Repository access for advanced queries
 *
 * Follows Single Responsibility Principle - only handles read operations.
 */

import { ConversationData } from '../../types/chat/ChatTypes';
import { PaginationParams, PaginatedResult } from '../../types/pagination/PaginationTypes';

export class ConversationQueryService {
  constructor(
    private conversationService: any
  ) {}

  /**
   * Get a conversation by ID
   *
   * @param id - Conversation ID
   * @param paginationOptions - Optional pagination parameters for message loading
   * @returns Conversation data with paginated messages
   */
  async getConversation(
    id: string,
    paginationOptions?: PaginationParams
  ): Promise<ConversationData | null> {
    try {
      return await this.conversationService.getConversation(id, paginationOptions);
    } catch (error) {
      console.error('Failed to get conversation:', error);
      return null;
    }
  }

  /**
   * Get messages for a conversation (paginated)
   *
   * Allows fetching messages without loading full conversation metadata.
   * Useful for lazy loading and infinite scroll implementations.
   *
   * @param conversationId - Conversation ID
   * @param options - Pagination parameters
   * @returns Paginated result containing messages
   */
  async getMessages(
    conversationId: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<any>> {
    try {
      return await this.conversationService.getMessages(conversationId, options);
    } catch (error) {
      console.error('Failed to get messages:', error);
      return {
        items: [],
        page: 0,
        pageSize: options?.pageSize ?? 50,
        totalItems: 0,
        totalPages: 0,
        hasNextPage: false,
        hasPreviousPage: false
      };
    }
  }

  /**
   * List all conversations
   */
  async listConversations(options?: {
    limit?: number;
    offset?: number;
    sortBy?: string;
    sortOrder?: 'asc' | 'desc';
  }): Promise<ConversationData[]> {
    try {
      // ConversationService.listConversations expects (vaultName?: string, limit?: number)
      // We pass undefined for vaultName to get all conversations, and extract limit from options
      const metadataList = await this.conversationService.listConversations(undefined, options?.limit);

      // Convert ConversationMetadata to ConversationData format
      // Note: messages array is empty since we're only using the index (lightweight)
      return metadataList.map((metadata: any) => ({
        id: metadata.id,
        title: metadata.title,
        messages: [], // Empty for list view - messages loaded when conversation is selected
        created: metadata.created,
        updated: metadata.updated,
        metadata: {
          vault_name: metadata.vault_name,
          message_count: metadata.message_count
        }
      }));
    } catch (error) {
      console.error('Failed to list conversations:', error);
      return [];
    }
  }

  /**
   * Search conversations by query
   */
  async searchConversations(query: string, options?: {
    limit?: number;
    fields?: string[];
  }): Promise<ConversationData[]> {
    try {
      const metadataList = await this.conversationService.searchConversations(query, options?.limit);

      // Convert ConversationMetadata to ConversationData format
      return metadataList.map((metadata: any) => ({
        id: metadata.id,
        title: metadata.title,
        messages: [], // Empty for search results - messages loaded when conversation is selected
        created: metadata.created,
        updated: metadata.updated,
        metadata: {
          vault_name: metadata.vault_name,
          message_count: metadata.message_count
        }
      }));
    } catch (error) {
      console.error('Failed to search conversations:', error);
      return [];
    }
  }

  /**
   * Get conversation repository for advanced queries
   */
  getConversationRepository(): any {
    return this.conversationService.getRepository?.() || this.conversationService;
  }

  /**
   * Get underlying conversation service
   */
  getConversationService(): any {
    return this.conversationService;
  }

  /**
   * Count total conversations
   */
  async countConversations(): Promise<number> {
    try {
      return await this.conversationService.count?.() || 0;
    } catch (error) {
      console.error('Failed to count conversations:', error);
      return 0;
    }
  }

  /**
   * Check if conversation exists
   */
  async conversationExists(id: string): Promise<boolean> {
    const conversation = await this.getConversation(id);
    return conversation !== null;
  }
}

```

## services/chat/CostTrackingService.ts

```typescript
/**
 * CostTrackingService - Manages usage tracking and cost calculation for chat messages
 *
 * Responsibilities:
 * - Track token usage from LLM responses
 * - Calculate costs from usage data
 * - Persist usage and cost to messages
 * - Update conversation-level cost aggregation
 * - Handle async usage updates (OpenRouter streaming)
 * - Prevent double-counting of costs
 *
 * Follows Single Responsibility Principle - only handles cost tracking.
 */

import { CostCalculator } from '../llm/adapters/CostCalculator';

export interface UsageData {
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
  source?: string;
}

export interface CostData {
  totalCost: number;
  currency: string;
}

export class CostTrackingService {
  constructor(
    private conversationService: any
  ) {}

  /**
   * Calculate cost from usage data
   */
  calculateCost(provider: string, model: string, usage: UsageData): CostData | null {
    const costBreakdown = CostCalculator.calculateCost(
      provider,
      model,
      {
        inputTokens: usage.promptTokens,
        outputTokens: usage.completionTokens,
        totalTokens: usage.totalTokens,
        source: (usage.source as 'provider_api' | 'fallback_tokenizer') || 'provider_api'
      }
    );

    if (!costBreakdown) {
      return null;
    }

    return {
      totalCost: costBreakdown.totalCost,
      currency: costBreakdown.currency
    };
  }

  /**
   * Update message with usage and cost data (async callback handler)
   * Used for delayed usage updates from providers like OpenRouter
   */
  async updateMessageCost(
    conversationId: string,
    messageId: string,
    usage: any,
    cost: any
  ): Promise<void> {
    try {
      // Load conversation, find message, update it, save back
      const conversation = await this.conversationService.getConversation(conversationId);
      if (!conversation) {
        console.error('[CostTrackingService] Conversation not found for async usage update');
        return;
      }

      // Find the message by ID
      const message = conversation.messages.find((m: any) => m.id === messageId);
      if (!message) {
        console.error('[CostTrackingService] Message not found for async usage update:', messageId);
        return;
      }

      // Check if message already has cost (to prevent double-counting)
      const hadCost = !!message.cost;

      // Update message with usage and cost
      message.usage = usage;
      if (cost) {
        message.cost = cost;
      }

      // Save updated conversation
      await this.conversationService.updateConversation(conversation.id, { messages: conversation.messages });

      // Update conversation-level cost aggregation
      // Only add to conversation cost if we didn't already count this message
      if (!hadCost && cost) {
        await this.updateConversationCost(conversationId, cost);
      }

    } catch (error) {
      console.error('[CostTrackingService] Failed to update message with async usage:', error);
    }
  }

  /**
   * Update conversation-level cost aggregation
   */
  async updateConversationCost(conversationId: string, messageCost: CostData): Promise<void> {
    try {
      const conversation = await this.conversationService.getConversation(conversationId);
      if (!conversation) {
        console.error('[CostTrackingService] Conversation not found for cost update');
        return;
      }

      // Initialize conversation cost if not present
      if (!conversation.cost) {
        conversation.cost = {
          totalCost: 0,
          currency: messageCost.currency
        };
      }

      // Add message cost to conversation total
      conversation.cost.totalCost += messageCost.totalCost;

      // Save updated conversation (pass ID and updates separately)
      await this.conversationService.updateConversation(conversationId, { cost: conversation.cost });

    } catch (error) {
      console.error('[CostTrackingService] Failed to update conversation cost:', error);
    }
  }

  /**
   * Create async usage callback for streaming
   * Returns a callback function that can be passed to LLM streaming options
   */
  createUsageCallback(conversationId: string, messageId: string): (usage: any, cost: any) => Promise<void> {
    return async (usage: any, cost: any) => {
      await this.updateMessageCost(conversationId, messageId, usage, cost);
    };
  }

  /**
   * Track usage and cost for a message (synchronous, from final streaming chunk)
   */
  async trackMessageUsage(
    conversationId: string,
    messageId: string,
    provider: string,
    model: string,
    usage: UsageData
  ): Promise<CostData | null> {
    // Calculate cost from usage
    const cost = this.calculateCost(provider, model, usage);

    if (!cost) {
      return null;
    }

    // Update conversation-level cost
    await this.updateConversationCost(conversationId, cost);

    return cost;
  }

  /**
   * Extract usage data from streaming chunk or final usage object
   */
  extractUsage(usageObject: any): UsageData | null {
    if (!usageObject) return null;

    // Handle different usage formats
    const promptTokens = usageObject.promptTokens || usageObject.prompt_tokens || usageObject.inputTokens || 0;
    const completionTokens = usageObject.completionTokens || usageObject.completion_tokens || usageObject.outputTokens || 0;
    const totalTokens = usageObject.totalTokens || usageObject.total_tokens || (promptTokens + completionTokens);

    if (promptTokens === 0 && completionTokens === 0) {
      return null;
    }

    return {
      promptTokens,
      completionTokens,
      totalTokens,
      source: 'provider_api'
    };
  }
}

```

## services/chat/DirectToolExecutor.ts

```typescript
/**
 * DirectToolExecutor - Executes tools directly via AgentExecutionManager
 *
 * This service enables tool execution without MCP protocol dependency,
 * allowing tools to work identically on both desktop and mobile platforms.
 *
 * Architecture:
 * - Desktop + Mobile (Nexus Chat): LLM â†’ DirectToolExecutor â†’ AgentExecutionManager â†’ Agent
 * - Claude Desktop (external): Claude Desktop â†’ MCP Protocol â†’ connector.ts â†’ Agent
 *
 * The MCP server/connector is ONLY needed for external clients (Claude Desktop).
 * The native chat UI uses this direct executor on ALL platforms.
 */

import { AgentExecutionManager } from '../../server/execution/AgentExecutionManager';
import { AgentRegistry } from '../../server/services/AgentRegistry';
import { SessionContextManager } from '../SessionContextManager';
import { ToolListService } from '../../handlers/services/ToolListService';
import { IAgent } from '../../agents/interfaces/IAgent';

/**
 * Map of bare tool names to their correct full format
 * Used for helpful "did you mean X?" error messages
 */
const TOOL_SUGGESTIONS: Record<string, string> = {
    // toolManager
    getTools: 'toolManager_getTools',
    useTool: 'toolManager_useTools',
    useTools: 'toolManager_useTools',
    // promptManager
    listModels: 'promptManager_listModels',
    executePrompts: 'promptManager_executePrompts',
    createPrompt: 'promptManager_createPrompt',
    updatePrompt: 'promptManager_updatePrompt',
    archivePrompt: 'promptManager_archivePrompt',
    listPrompts: 'promptManager_listPrompts',
    getPrompt: 'promptManager_getPrompt',
    generateImage: 'promptManager_generateImage',
    // contentManager
    readContent: 'contentManager_readContent',
    createContent: 'contentManager_createContent',
    appendContent: 'contentManager_appendContent',
    prependContent: 'contentManager_prependContent',
    replaceContent: 'contentManager_replaceContent',
    replaceByLine: 'contentManager_replaceByLine',
    deleteContent: 'contentManager_deleteContent',
    findReplaceContent: 'contentManager_findReplaceContent',
    // commandManager
    listCommands: 'commandManager_listCommands',
    executeCommand: 'commandManager_executeCommand',
    // storageManager
    list: 'storageManager_list',
    createFolder: 'storageManager_createFolder',
    move: 'storageManager_move',
    copy: 'storageManager_copy',
    archive: 'storageManager_archive',
    open: 'storageManager_open',
    // searchManager
    searchContent: 'searchManager_searchContent',
    searchDirectory: 'searchManager_searchDirectory',
    searchMemory: 'searchManager_searchMemory',
    // memoryManager (9 tools: 5 workspace + 4 state)
    createWorkspace: 'memoryManager_createWorkspace',
    listWorkspaces: 'memoryManager_listWorkspaces',
    loadWorkspace: 'memoryManager_loadWorkspace',
    updateWorkspace: 'memoryManager_updateWorkspace',
    archiveWorkspace: 'memoryManager_archiveWorkspace',
    createState: 'memoryManager_createState',
    listStates: 'memoryManager_listStates',
    loadState: 'memoryManager_loadState',
};

export interface DirectToolCall {
    id: string;
    function: {
        name: string;
        arguments: string;
    };
}

export interface DirectToolResult {
    id: string;
    name?: string;
    success: boolean;
    result?: any;
    error?: string;
    executionTime?: number;
}

/**
 * Interface for agent providers - both AgentRegistry and AgentRegistrationService can fulfill this
 */
export interface AgentProvider {
    getAllAgents(): Map<string, IAgent> | IAgent[];
    getAgent?(name: string): IAgent | null;
    hasAgent?(name: string): boolean;
    agentSupportsMode?(agentName: string, modeName: string): boolean;
}

export interface DirectToolExecutorConfig {
    /** Agent provider - can be AgentRegistry, AgentRegistrationService, or any compatible provider */
    agentProvider: AgentProvider;
    sessionContextManager?: SessionContextManager;
}

/**
 * Direct tool execution service - bypasses MCP for native chat
 * Works identically on desktop and mobile platforms
 */
export class DirectToolExecutor {
    private executionManager: AgentExecutionManager;
    private toolListService: ToolListService;
    private agentProvider: AgentProvider;
    private internalRegistry: AgentRegistry;
    private cachedTools: any[] | null = null;

    constructor(config: DirectToolExecutorConfig) {
        this.agentProvider = config.agentProvider;

        // Create internal AgentRegistry for AgentExecutionManager
        // (AgentExecutionManager requires the specific AgentRegistry type)
        this.internalRegistry = new AgentRegistry();

        // Populate internal registry from provider
        const agents = this.getAgentsAsArray();
        for (const agent of agents) {
            try {
                this.internalRegistry.registerAgent(agent);
            } catch {
                // Agent may already be registered (e.g., if provider is an AgentRegistry)
            }
        }

        this.executionManager = new AgentExecutionManager(
            this.internalRegistry,
            config.sessionContextManager
        );
        this.toolListService = new ToolListService();
    }

    /**
     * Get agents as an array (handles both Map and array return types)
     */
    private getAgentsAsArray(): IAgent[] {
        const result = this.agentProvider.getAllAgents();
        if (result instanceof Map) {
            return Array.from(result.values());
        }
        return result;
    }

    /**
     * Get available tools in OpenAI format - Two-Tool Architecture
     * Returns only toolManager_getTools and toolManager_useTools
     *
     * This is the new two-tool architecture that replaces the old 50+ tool surface.
     * LLMs discover tools via getTools (which lists all available agents/tools in its description),
     * then execute tools via useTools with unified context.
     */
    async getAvailableTools(): Promise<unknown[]> {
        // Get toolManager agent from the registry
        const toolManagerAgent = this.getAgentByName('toolManager');

        if (!toolManagerAgent) {
            console.error('[DirectToolExecutor] ToolManager agent not found - returning empty tools list');
            return [];
        }

        // Get tools from toolManager (getTools and useTools)
        const tools = toolManagerAgent.getTools();

        // Convert to OpenAI format
        // Tool names are just getTools and useTools (no prefix)
        return tools.map(tool => ({
            type: 'function',
            function: {
                name: tool.slug,
                description: tool.description,
                parameters: tool.getParameterSchema()
            }
        }));
    }

    /**
     * Get an agent by name from the registry
     */
    private getAgentByName(name: string): IAgent | null {
        const result = this.agentProvider.getAllAgents();
        if (result instanceof Map) {
            return result.get(name) || null;
        }
        return result.find(a => a.name === name) || null;
    }

    /**
     * Get all tool schemas (internal - used when get_tools is called)
     */
    private async getAllToolSchemas(): Promise<any[]> {
        // Use cached tools if available
        if (this.cachedTools) {
            return this.cachedTools;
        }

        try {
            // Get agents from provider
            const agents = this.getAgentsAsArray();
            const agentMap = new Map<string, IAgent>();

            for (const agent of agents) {
                agentMap.set(agent.name, agent);
            }

            // Generate tool list using existing service
            const { tools } = await this.toolListService.generateToolList(
                agentMap,
                true // isVaultEnabled - always true for native chat
            );

            // Convert to OpenAI format
            this.cachedTools = tools.map(tool => ({
                type: 'function',
                function: {
                    name: tool.name,
                    description: tool.description,
                    parameters: tool.inputSchema
                }
            }));

            return this.cachedTools;
        } catch (error) {
            console.error('[DirectToolExecutor] Failed to get available tools:', error);
            return [];
        }
    }

    /**
     * Invalidate cached tools (call when agents change)
     */
    invalidateToolCache(): void {
        this.cachedTools = null;
    }

    /**
     * Execute a tool call directly via AgentExecutionManager
     * This is the core method that bypasses MCP
     */
    async executeTool(
        toolName: string,
        params: Record<string, unknown>,
        context?: { sessionId?: string; workspaceId?: string }
    ): Promise<unknown> {
        try {
            // Two-tool architecture: getTools and useTool
            if (toolName === 'getTools' || toolName === 'get_tools') {
                return await this.handleGetTools(params, context);
            }

            // Accept both singular and plural forms
            if (toolName === 'useTool' || toolName === 'useTools' || toolName === 'use_tools') {
                return await this.handleUseTool(params, context);
            }

            // Legacy/direct tool calls: "agentName_toolName" format
            let agentName: string;
            let modeName: string;
            const paramsTyped = params as Record<string, unknown> & { mode?: string; context?: Record<string, unknown> };

            if (paramsTyped.mode) {
                // Alternative format: agent name with tool in params.mode
                agentName = toolName;
                modeName = paramsTyped.mode;
            } else if (toolName.includes('_')) {
                // Standard format: agentName_toolName
                const parts = toolName.split('_');
                agentName = parts[0];
                modeName = parts.slice(1).join('_');
            } else {
                // Unknown tool name
                throw new Error(
                    `Unknown tool "${toolName}". Expected "getTools", "useTool", or "agentName_toolName" format.`
                );
            }

            // Determine sessionId and workspaceId with priority:
            // 1. External context (from chat settings/workspace selection)
            // 2. LLM-provided params.context
            // 3. Generate default if neither exists
            const effectiveSessionId = context?.sessionId
                || (paramsTyped.context?.sessionId as string | undefined)
                || `session_${Date.now()}`;
            const effectiveWorkspaceId = context?.workspaceId
                || (paramsTyped.context?.workspaceId as string | undefined)
                || 'default';

            const paramsWithContext = {
                ...params,
                context: {
                    ...paramsTyped.context,
                    sessionId: effectiveSessionId,
                    workspaceId: effectiveWorkspaceId
                }
            };

            // Execute via AgentExecutionManager
            const result = await this.executionManager.executeAgentModeWithValidation(
                agentName,
                modeName,
                paramsWithContext
            );

            return result;
        } catch (error) {
            console.error(`[DirectToolExecutor] Tool execution failed for ${toolName}:`, error);
            throw error;
        }
    }

    /**
     * Handle the get_tools meta-tool call
     * Returns tool schemas for requested agents
     */
    private async handleGetTools(
        params: Record<string, any>,
        context?: { sessionId?: string; workspaceId?: string }
    ): Promise<any> {
        const requestedTools = params.tools as string[] | undefined;
        const sessionId = context?.sessionId || 'session_' + Date.now();
        const workspaceId = context?.workspaceId || 'default';

        // No tools requested - remind to specify which tools
        if (!requestedTools || requestedTools.length === 0) {
            return {
                success: false,
                error: 'Please specify which agent tools you need. Example: get_tools({ tools: ["contentManager", "searchManager"] })',
                availableAgents: ['contentManager', 'storageManager', 'searchManager', 'memoryManager', 'commandManager', 'promptManager']
            };
        }

        // Get schemas for requested tools
        const allTools = await this.getAllToolSchemas();
        const matchedTools: any[] = [];
        const notFound: string[] = [];

        for (const toolName of requestedTools) {
            const tool = allTools.find(t => t.function.name === toolName);
            if (tool) {
                matchedTools.push(tool);
            } else {
                notFound.push(toolName);
            }
        }

        return {
            success: true,
            tools: matchedTools,
            count: matchedTools.length,
            notFound: notFound.length > 0 ? notFound : undefined,
            reminder: `Use sessionId: "${sessionId}" and workspaceId: "${workspaceId}" in context for all tool calls.`
        };
    }

    /**
     * Handle useTool calls (two-tool architecture)
     * Executes the calls array and returns results
     */
    private async handleUseTool(
        params: Record<string, any>,
        context?: { sessionId?: string; workspaceId?: string }
    ): Promise<any> {
        // Get toolManager agent to use its useTool implementation
        const toolManagerAgent = this.getAgentByName('toolManager');
        if (!toolManagerAgent) {
            return {
                success: false,
                error: 'ToolManager agent not found'
            };
        }

        const useToolsTool = toolManagerAgent.getTool('useTools');
        if (!useToolsTool) {
            return {
                success: false,
                error: 'useTools tool not found in ToolManager'
            };
        }

        // Merge context from params and external context
        const paramsContext = params.context || {};
        const mergedParams = {
            ...params,
            context: {
                ...paramsContext,
                sessionId: context?.sessionId || paramsContext.sessionId || `session_${Date.now()}`,
                workspaceId: context?.workspaceId || paramsContext.workspaceId || 'default'
            }
        };

        // Execute via toolManager's useTools
        return await useToolsTool.execute(mergedParams);
    }

    /**
     * Execute multiple tool calls
     * Matches the interface expected by MCPToolExecution
     */
    async executeToolCalls(
        toolCalls: DirectToolCall[],
        context?: { sessionId?: string; workspaceId?: string },
        onToolEvent?: (event: 'started' | 'completed', data: any) => void
    ): Promise<DirectToolResult[]> {
        const results: DirectToolResult[] = [];

        for (const toolCall of toolCalls) {
            const startTime = Date.now();

            try {
                // Parse arguments
                let parameters: any = {};
                const argumentsStr = toolCall.function.arguments || '{}';

                try {
                    parameters = JSON.parse(argumentsStr);
                } catch (parseError) {
                    throw new Error(`Invalid tool arguments: ${parseError instanceof Error ? parseError.message : 'Unknown parsing error'}`);
                }

                // Notify tool started
                onToolEvent?.('started', {
                    id: toolCall.id,
                    name: toolCall.function.name,
                    parameters: parameters
                });

                // Execute the tool
                const rawResult = await this.executeTool(
                    toolCall.function.name,
                    parameters,
                    context
                );

                // Cast result to expected shape
                const result = rawResult as { success?: boolean; error?: string } | null;
                const isSuccess = result?.success !== false;
                const errorMessage = result?.success === false ? (result?.error || 'Tool execution failed') : undefined;

                const executionTime = Date.now() - startTime;

                results.push({
                    id: toolCall.id,
                    name: toolCall.function.name,
                    success: isSuccess,
                    result: isSuccess ? rawResult : undefined,
                    error: errorMessage,
                    executionTime
                });

                // Notify tool completed
                onToolEvent?.('completed', {
                    toolId: toolCall.id,
                    result: isSuccess ? rawResult : undefined,
                    success: isSuccess,
                    error: errorMessage
                });

            } catch (error) {
                const executionTime = Date.now() - startTime;

                results.push({
                    id: toolCall.id,
                    name: toolCall.function.name,
                    success: false,
                    error: error instanceof Error ? error.message : 'Unknown error',
                    executionTime
                });

                // Notify tool completed (with error)
                onToolEvent?.('completed', {
                    toolId: toolCall.id,
                    result: undefined,
                    success: false,
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
            }
        }

        return results;
    }

    /**
     * Check if tool execution is available
     * Always returns true since this doesn't depend on MCP
     */
    isAvailable(): boolean {
        return true;
    }

    /**
     * Get execution manager for advanced operations
     */
    getExecutionManager(): AgentExecutionManager {
        return this.executionManager;
    }
}

```

## services/chat/index.ts

```typescript
/**
 * Chat Services Index - Export all chat-related services
 * 
 * Provides centralized access to the complete chat infrastructure:
 * - Repository layer for CRUD operations (database services)
 * - Business logic services for chat operations
 * - Tool execution and message processing services
 * - MCP protocol integration services
 */

// Database layer services (from database/services/chat/)
// Note: Chat database services removed in simplify-search-architecture
// Chat data now stored in simplified JSON format

// Business logic services (from services/chat/)
export * from './ChatService';
export * from './BranchService';
export * from './MessageQueueService';
export * from './SubagentExecutor';
```

## services/chat/MessageQueueService.ts

```typescript
/**
 * MessageQueueService - Async message queue with priority handling
 *
 * Responsibilities:
 * - Queue messages during active generation
 * - Process queue when generation completes
 * - User messages get priority over subagent results
 * - Emit events for UI updates
 *
 * Follows Single Responsibility Principle - only handles message queuing.
 */

import { EventEmitter } from 'events';
import type { QueuedMessage, MessageQueueEvents } from '../../types/branch/BranchTypes';

export interface MessageQueueServiceEvents extends MessageQueueEvents {}

export class MessageQueueService extends EventEmitter {
  private queue: QueuedMessage[] = [];
  private isGenerating: boolean = false;
  private processMessageFn: ((message: QueuedMessage) => Promise<void>) | null = null;

  constructor() {
    super();
  }

  /**
   * Set the message processor function
   * This function is called for each message when processing the queue
   */
  setMessageProcessor(fn: (message: QueuedMessage) => Promise<void>): void {
    this.processMessageFn = fn;
  }

  /**
   * Alias for setMessageProcessor (for compatibility with MessageManager)
   */
  setProcessor(fn: (message: QueuedMessage) => Promise<void>): void {
    this.setMessageProcessor(fn);
  }

  /**
   * Enqueue a message
   * - If not generating, process immediately
   * - If generating, add to queue (user messages get priority)
   */
  async enqueue(message: QueuedMessage): Promise<void> {
    console.log('[MessageQueue] enqueue:', { type: message.type, isGenerating: this.isGenerating });
    if (this.isGenerating) {
      this.addToQueue(message);
      console.log('[MessageQueue] Queued for later, length:', this.queue.length);
      this.emit('message:queued', { count: this.queue.length, message });
    } else {
      console.log('[MessageQueue] Processing immediately');
      await this.processMessage(message);
    }
  }

  /**
   * Add message to queue with priority handling
   * User messages go to front (after other user messages)
   * Subagent results and system messages go to back
   */
  private addToQueue(message: QueuedMessage): void {
    if (message.type === 'user') {
      // User messages go to front, after any existing user messages
      const lastUserIndex = this.findLastUserMessageIndex();
      this.queue.splice(lastUserIndex + 1, 0, message);
    } else {
      // Subagent results and system messages go to back
      this.queue.push(message);
    }
  }

  /**
   * Find the index of the last user message in the queue
   */
  private findLastUserMessageIndex(): number {
    for (let i = this.queue.length - 1; i >= 0; i--) {
      if (this.queue[i].type === 'user') {
        return i;
      }
    }
    return -1;
  }

  /**
   * Called when generation starts
   * Queue mode is activated - messages will be queued instead of processed
   */
  onGenerationStart(): void {
    this.isGenerating = true;
  }

  /**
   * Called when generation completes
   * Processes all queued messages in order
   */
  async onGenerationComplete(): Promise<void> {
    this.isGenerating = false;
    await this.processQueue();
  }

  /**
   * Process all messages in the queue
   */
  private async processQueue(): Promise<void> {
    while (this.queue.length > 0 && !this.isGenerating) {
      const message = this.queue.shift()!;
      await this.processMessage(message);
    }

    if (this.queue.length === 0) {
      this.emit('queue:empty');
    }
  }

  /**
   * Process a single message
   */
  private async processMessage(message: QueuedMessage): Promise<void> {
    console.log('[SUBAGENT-DEBUG] MessageQueue.processMessage start:', { type: message.type, hasProcessor: !!this.processMessageFn });
    if (!this.processMessageFn) {
      console.error('[SUBAGENT-DEBUG] No message processor set!');
      return;
    }

    this.emit('message:processing', { message });

    try {
      await this.processMessageFn(message);
      console.log('[SUBAGENT-DEBUG] MessageQueue.processMessage complete');
    } catch (error) {
      console.error('[SUBAGENT-DEBUG] MessageQueue error processing:', error);
    }
  }

  /**
   * Get current queue length
   */
  getQueueLength(): number {
    return this.queue.length;
  }

  /**
   * Get queued messages (for UI display)
   */
  getQueuedMessages(): QueuedMessage[] {
    return [...this.queue];
  }

  /**
   * Check if currently in generation mode
   */
  isInGenerationMode(): boolean {
    return this.isGenerating;
  }

  /**
   * Clear the queue
   */
  clearQueue(): void {
    this.queue = [];
    this.emit('queue:empty');
  }

  /**
   * Remove a specific message from the queue by ID
   */
  removeFromQueue(messageId: string): boolean {
    const index = this.queue.findIndex(m => m.id === messageId);
    if (index !== -1) {
      this.queue.splice(index, 1);
      return true;
    }
    return false;
  }

  /**
   * Check if a message is in the queue
   */
  isInQueue(messageId: string): boolean {
    return this.queue.some(m => m.id === messageId);
  }

  /**
   * Get the position of a message in the queue (0-indexed)
   */
  getQueuePosition(messageId: string): number {
    return this.queue.findIndex(m => m.id === messageId);
  }
}

```

## services/chat/StreamingResponseService.ts

```typescript
/**
 * StreamingResponseService - Manages streaming response generation
 *
 * Responsibilities:
 * - Coordinate LLM streaming with tool execution
 * - Handle progressive tool call detection
 * - Integrate cost tracking during streaming
 * - Persist messages and usage data
 * - Build LLM context with conversation history
 * - Manage streaming lifecycle (start, chunk, complete, abort)
 *
 * This is the core streaming coordination layer that brings together:
 * - ToolCallService (tool detection/events)
 * - CostTrackingService (usage/cost calculation)
 * - LLMService (actual streaming)
 * - ConversationService (persistence)
 *
 * Follows Single Responsibility Principle - only handles streaming coordination.
 */

import { ConversationData } from '../../types/chat/ChatTypes';
import { ConversationContextBuilder } from './ConversationContextBuilder';
import { ToolCallService } from './ToolCallService';
import { CostTrackingService } from './CostTrackingService';
import type { MessageQueueService } from './MessageQueueService';

export interface StreamingOptions {
  provider?: string;
  model?: string;
  systemPrompt?: string;
  workspaceId?: string;
  sessionId?: string;
  messageId?: string;
  abortSignal?: AbortSignal;
  excludeFromMessageId?: string; // Exclude this message and everything after from context (for retry)
  enableThinking?: boolean;
  thinkingEffort?: 'low' | 'medium' | 'high';
  temperature?: number; // 0.0-1.0, controls randomness
}

export interface StreamingChunk {
  chunk: string;
  complete: boolean;
  messageId: string;
  toolCalls?: any[];
  // Reasoning/thinking support (Claude, GPT-5, Gemini, etc.)
  reasoning?: string;           // Incremental reasoning text
  reasoningComplete?: boolean;  // True when reasoning finished
  // Token usage (available on complete chunk)
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
}

export interface StreamingDependencies {
  llmService: any;
  conversationService: any;
  toolCallService: ToolCallService;
  costTrackingService: CostTrackingService;
  messageQueueService?: MessageQueueService; // Optional: for subagent result queueing
}

export class StreamingResponseService {
  private currentProvider?: string;

  constructor(
    private dependencies: StreamingDependencies
  ) {}

  /**
   * Generate streaming response with full coordination
   *
   * Always loads conversation from storage to ensure fresh data with tool calls
   */
  async* generateResponse(
    conversationId: string,
    userMessage: string,
    options?: StreamingOptions
  ): AsyncGenerator<StreamingChunk, void, unknown> {
    // Notify queue service that generation is starting (pauses processing)
    this.dependencies.messageQueueService?.onGenerationStart?.();

    try {
      const messageId = options?.messageId || `msg_${Date.now()}_ai`;
      let accumulatedContent = '';

      // Get defaults from LLMService if user didn't select provider/model
      const defaultModel = this.dependencies.llmService.getDefaultModel();

      // Check if message already exists (retry case)
      const existingConv = await this.dependencies.conversationService.getConversation(conversationId);
      const messageExists = existingConv?.messages.some((m: any) => m.id === messageId);

      // Only create placeholder if message doesn't exist (prevents duplicate during retry)
      if (!messageExists) {
        await this.dependencies.conversationService.addMessage({
          conversationId,
          role: 'assistant',
          content: '', // Will be updated as streaming progresses
          id: messageId
        });
      }

      // Get provider for context building
      const provider = options?.provider || defaultModel.provider;
      this.currentProvider = provider; // Store for context building

      // ALWAYS load conversation from storage to get complete history including tool calls
      const conversation = await this.dependencies.conversationService.getConversation(conversationId);

      // Filter conversation for retry: exclude message being retried and everything after
      let filteredConversation = conversation;
      if (conversation && options?.excludeFromMessageId) {
        const excludeIndex = conversation.messages.findIndex((m: any) => m.id === options.excludeFromMessageId);
        if (excludeIndex >= 0) {
          filteredConversation = {
            ...conversation,
            messages: conversation.messages.slice(0, excludeIndex)
          };
        }
      }

      // Build conversation context for LLM with provider-specific formatting
      // NOTE: buildLLMMessages includes ALL messages from storage, including the user message
      // that was just saved by sendMessage(), so we DON'T add it again here
      const messages = filteredConversation ?
        this.buildLLMMessages(filteredConversation, provider, options?.systemPrompt) : [];

      // Add system prompt if provided and not already added by buildLLMMessages
      if (options?.systemPrompt && !messages.some(m => m.role === 'system')) {
        messages.unshift({ role: 'system', content: options.systemPrompt });
      }

      // Only add user message if it's NOT already in the filtered conversation
      // (happens on first message when conversation is empty, or during retry)
      if (!filteredConversation || !filteredConversation.messages.some((m: any) => m.content === userMessage && m.role === 'user')) {
        messages.push({ role: 'user', content: userMessage });
      }

      // Get tools from ToolCallService in OpenAI format
      // NOTE: WebLLM/Nexus models are fine-tuned with tool knowledge baked in
      // They don't need tool schemas passed - they generate [TOOL_CALLS] naturally
      const isWebLLM = provider === 'webllm';
      const openAITools = isWebLLM ? [] : this.dependencies.toolCallService.getAvailableTools();

      // Prepare LLM options with converted tools
      // NOTE: systemPrompt is already in the messages array from buildLLMMessages()
      // Do NOT pass it again here - this caused duplicate system prompts
      const llmOptions: any = {
        provider: options?.provider || defaultModel.provider,
        model: options?.model || defaultModel.model,
        // systemPrompt intentionally omitted - already in messages array
        tools: openAITools,
        toolChoice: openAITools.length > 0 ? 'auto' : undefined,
        abortSignal: options?.abortSignal,
        sessionId: options?.sessionId,
        workspaceId: options?.workspaceId,
        conversationId, // CRITICAL: Required for OpenAI Responses API response ID tracking
        enableThinking: options?.enableThinking,
        thinkingEffort: options?.thinkingEffort,
        temperature: options?.temperature,
        // Responses API (OpenAI/LM Studio): Load persisted ID for conversation continuity
        responsesApiId: filteredConversation?.metadata?.responsesApiId
      };

      // Add tool event callback for live UI updates (delegates to ToolCallService)
      llmOptions.onToolEvent = (event: 'started' | 'completed', data: any) => {
        this.dependencies.toolCallService.fireToolEvent(messageId, event, data);
      };

      // Add usage callback for async cost calculation (e.g., OpenRouter streaming)
      llmOptions.onUsageAvailable = this.dependencies.costTrackingService.createUsageCallback(conversationId, messageId);

      // Responses API: Persist ID when first captured (for conversation continuity across restarts)
      llmOptions.onResponsesApiId = async (id: string) => {
        try {
          const conv = await this.dependencies.conversationService.getConversation(conversationId);
          if (conv) {
            await this.dependencies.conversationService.updateConversation(conversationId, {
              metadata: { ...conv.metadata, responsesApiId: id }
            });
            console.log('[LLM_DEBUG] Persisted responsesApiId to conversation metadata:', id);
          }
        } catch (err) {
          console.error('[StreamingResponseService] Failed to persist responsesApiId:', err);
        }
      };

      // Stream the response from LLM service with MCP tools
      let toolCalls: any[] | undefined = undefined;
      this.dependencies.toolCallService.resetDetectedTools(); // Reset tool detection state for new message

      // Track usage and cost for conversation tracking
      let finalUsage: any = undefined;
      let finalCost: any = undefined;

      for await (const chunk of this.dependencies.llmService.generateResponseStream(messages, llmOptions)) {
        // Check if aborted FIRST before processing chunk
        if (options?.abortSignal?.aborted) {
          throw new DOMException('Generation aborted by user', 'AbortError');
        }

        accumulatedContent += chunk.chunk;

        // Extract usage for cost calculation
        if (chunk.usage) {
          finalUsage = chunk.usage;
        }

        // Extract tool calls when available and handle progressive display
        if (chunk.toolCalls) {
          toolCalls = chunk.toolCalls;

      // Handle progressive tool call detection (fires 'detected' and 'updated' events)
      if (toolCalls) {
        // Only emit once we have non-empty argument content to reduce duplicate spam
        const hasMeaningfulArgs = toolCalls.some((tc: any) => {
          const args = tc.function?.arguments || tc.arguments || '';
          return typeof args === 'string' ? args.trim().length > 0 : true;
        });
        if (hasMeaningfulArgs) {
          this.dependencies.toolCallService.handleToolCallDetection(
            messageId,
            toolCalls,
            chunk.toolCallsReady || false,
            conversationId
          );
        }
      }
        }

        // Save to database BEFORE yielding final chunk to ensure persistence
        if (chunk.complete) {
          // Calculate cost from final usage using CostTrackingService
          if (finalUsage) {
            const usageData = this.dependencies.costTrackingService.extractUsage(finalUsage);
            if (usageData) {
              finalCost = await this.dependencies.costTrackingService.trackMessageUsage(
                conversationId,
                messageId,
                provider,
                llmOptions.model,
                usageData
              );
            }
          }

          // Update the placeholder message with final content
          const conv = await this.dependencies.conversationService.getConversation(conversationId);
          if (conv) {
            const msg = conv.messages.find((m: any) => m.id === messageId);
            if (msg) {
              // Update existing placeholder message
              msg.content = accumulatedContent;
              msg.state = 'complete';
              if (toolCalls) {
                msg.toolCalls = toolCalls;
              }

              // Only update cost/usage if we have values (don't overwrite with undefined)
              // This prevents overwriting async updates from OpenRouter's generation API
              if (finalCost) {
                msg.cost = finalCost;
              }
              if (finalUsage) {
                msg.usage = finalUsage;
              }

              msg.provider = provider;
              msg.model = llmOptions.model;

              // Save updated conversation
              await this.dependencies.conversationService.updateConversation(conversationId, {
                messages: conv.messages,
                metadata: conv.metadata
              });
            }
          }

          // Handle tool calls - if present, add separate message for pingpong response
          if (toolCalls && toolCalls.length > 0) {
            // Had tool calls - the placeholder is the tool call message, add pingpong response separately
            // No separate message needed; placeholder already holds tool calls and final content
          }
        }

        yield {
          chunk: chunk.chunk,
          complete: chunk.complete,
          messageId,
          toolCalls: toolCalls,
          // Pass through reasoning for UI display
          reasoning: chunk.reasoning,
          reasoningComplete: chunk.reasoningComplete,
          // Pass through usage for context tracking
          usage: chunk.complete ? finalUsage : undefined
        };

        if (chunk.complete) {
          break;
        }
      }

    } catch (error) {
      console.error('Error in generateResponse:', error);
      throw error;
    } finally {
      // Notify queue service that generation is complete (resumes processing)
      this.dependencies.messageQueueService?.onGenerationComplete?.();
    }
  }

  /**
   * Build message history for LLM context using provider-specific formatting
   *
   * This method uses ConversationContextBuilder to properly reconstruct
   * conversation history with tool calls in the correct format for each provider.
   *
   * NOTE: For Google, we return simple {role, content} format because
   * StreamingOrchestrator will convert to Google format ({role, parts})
   */
  private buildLLMMessages(conversation: ConversationData, provider?: string, systemPrompt?: string): any[] {
    const currentProvider = provider || this.getCurrentProvider();

    // For Google, return simple format - StreamingOrchestrator handles Google conversion
    if (currentProvider === 'google') {
      const messages: any[] = [];

      // Add system prompt if provided
      if (systemPrompt) {
        messages.push({ role: 'system', content: systemPrompt });
      }

      // Add conversation messages in simple format
      for (const msg of conversation.messages) {
        if (msg.role === 'user' && msg.content && msg.content.trim()) {
          messages.push({ role: 'user', content: msg.content });
        } else if (msg.role === 'assistant' && msg.content && msg.content.trim()) {
          messages.push({ role: 'assistant', content: msg.content });
        }
      }

      return messages;
    }

    // For other providers, use ConversationContextBuilder
    return ConversationContextBuilder.buildContextForProvider(
      conversation,
      currentProvider,
      systemPrompt
    );
  }

  /**
   * Get current provider for context building
   */
  private getCurrentProvider(): string {
    return this.currentProvider || this.dependencies.llmService.getDefaultModel().provider;
  }

  /**
   * Set current provider (for context building)
   */
  setProvider(provider: string): void {
    this.currentProvider = provider;
  }
}

```

## services/chat/SubagentExecutor.ts

```typescript
/**
 * SubagentExecutor - Orchestrates autonomous subagent execution
 *
 * Uses SAME infrastructure as main chat:
 * - LLMService.generateResponseStream handles tool pingpong internally
 * - ToolContinuationService executes tools automatically during streaming
 * - SubagentExecutor just provides initial context and saves final result
 *
 * Responsibilities:
 * - Create subagent branches with initial context (system prompt + task)
 * - Stream response using existing LLM infrastructure
 * - Save final assistant message to branch
 * - Support cancellation via AbortController
 * - Queue results back to parent conversation
 * - Track agent status for UI display
 *
 * Follows Single Responsibility Principle - orchestration only, no tool execution.
 */

import type { ChatMessage, ToolCall } from '../../types/chat/ChatTypes';
import type {
  SubagentParams,
  SubagentResult,
  SubagentExecutorEvents,
  AgentStatusItem,
  BranchState,
  QueuedMessage,
  SubagentToolCall,
  ToolSchemaInfo,
} from '../../types/branch/BranchTypes';
import type { BranchService } from './BranchService';
import type { MessageQueueService } from './MessageQueueService';
import type { DirectToolExecutor } from './DirectToolExecutor';

export interface SubagentExecutorDependencies {
  branchService: BranchService;
  messageQueueService: MessageQueueService;
  directToolExecutor: DirectToolExecutor;
  // Streaming generator for branch conversations
  streamingGenerator: (
    messages: ChatMessage[],
    options: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
      abortSignal?: AbortSignal;
      workspaceId?: string;
      sessionId?: string;
    }
  ) => AsyncGenerator<{
    chunk: string;
    complete: boolean;
    toolCalls?: SubagentToolCall[];
    reasoning?: string;
  }, void, unknown>;
  // Tool list service for pre-fetching schemas
  getToolSchemas?: (agentName: string, toolSlugs: string[]) => Promise<ToolSchemaInfo[]>;
}

export class SubagentExecutor {
  private activeSubagents: Map<string, AbortController> = new Map();
  private agentStatus: Map<string, AgentStatusItem> = new Map();
  private subagentBranches: Map<string, string> = new Map(); // subagentId -> branchId
  private events: Partial<SubagentExecutorEvents> = {};

  // In-memory streaming state for active branches
  // This allows UI to render directly from memory without storage
  private streamingBranchMessages: Map<string, ChatMessage[]> = new Map(); // branchId -> messages

  constructor(private dependencies: SubagentExecutorDependencies) {
    // Validate critical dependencies
    if (!dependencies.branchService) {
      console.error('[SubagentExecutor] Missing branchService dependency');
    }
    if (!dependencies.streamingGenerator) {
      console.error('[SubagentExecutor] Missing streamingGenerator dependency');
    }
  }

  /**
   * Set event handlers
   */
  setEventHandlers(events: Partial<SubagentExecutorEvents>): void {
    this.events = events;
  }

  /**
   * Execute subagent - runs async, returns immediately with IDs
   * Result delivered via events + message queue
   */
  async executeSubagent(params: SubagentParams): Promise<{ subagentId: string; branchId: string }> {
    const subagentId = `subagent_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
    console.log('[SUBAGENT-DEBUG] executeSubagent START', { subagentId, task: params.task });

    const abortController = new AbortController();
    this.activeSubagents.set(subagentId, abortController);

    // Create the branch
    let branchId: string;
    try {
      branchId = await this.dependencies.branchService.createSubagentBranch(
        params.parentConversationId,
        params.parentMessageId,
        params.task,
        subagentId,
        params.maxIterations ?? 10
      );
      console.log('[SUBAGENT-DEBUG] Branch created', { subagentId, branchId });
    } catch (error) {
      console.error('[SUBAGENT-DEBUG] Failed to create branch:', error);
      throw error;
    }

    this.subagentBranches.set(subagentId, branchId);

    // Initialize status tracking
    const statusItem: AgentStatusItem = {
      subagentId,
      branchId,
      conversationId: params.parentConversationId,
      parentMessageId: params.parentMessageId,
      task: params.task,
      state: 'running',
      iterations: 0,
      maxIterations: params.maxIterations ?? 10,
      startedAt: Date.now(),
    };
    this.agentStatus.set(subagentId, statusItem);
    console.log('[SUBAGENT-DEBUG] Status set to RUNNING', { subagentId, agentStatusSize: this.agentStatus.size });

    // Fire started event
    this.events.onSubagentStarted?.(subagentId, params.task, branchId);
    console.log('[SUBAGENT-DEBUG] onSubagentStarted fired');

    // Fire and forget - don't await
    this.runSubagentLoop(subagentId, branchId, params, abortController.signal)
      .then(result => {
        console.log('[SUBAGENT-DEBUG] runSubagentLoop COMPLETED', { subagentId, success: result.success });
        this.activeSubagents.delete(subagentId);
        this.updateStatus(subagentId, { state: result.success ? 'complete' : 'max_iterations' });
        this.events.onSubagentComplete?.(subagentId, result);
        this.queueResultToParent(params, result);
      })
      .catch(error => {
        console.error('[SUBAGENT-DEBUG] runSubagentLoop FAILED', { subagentId, error });
        this.activeSubagents.delete(subagentId);
        const errorMessage = error instanceof Error ? error.message : String(error);
        this.updateStatus(subagentId, { state: 'cancelled' });
        this.events.onSubagentError?.(subagentId, errorMessage);
      });

    console.log('[SUBAGENT-DEBUG] executeSubagent RETURNING (loop running in background)', { subagentId, branchId });
    return { subagentId, branchId };
  }

  /**
   * Cancel a running subagent by ID
   */
  cancelSubagent(subagentId: string): boolean {
    const controller = this.activeSubagents.get(subagentId);
    if (controller) {
      controller.abort();
      this.activeSubagents.delete(subagentId);
      this.updateStatus(subagentId, { state: 'cancelled' });
      return true;
    }
    return false;
  }

  /**
   * Cancel a subagent by branch ID
   */
  cancelSubagentByBranch(branchId: string): boolean {
    for (const [subagentId, controller] of this.activeSubagents.entries()) {
      if (this.subagentBranches.get(subagentId) === branchId) {
        controller.abort();
        this.activeSubagents.delete(subagentId);
        this.updateStatus(subagentId, { state: 'cancelled' });
        return true;
      }
    }
    return false;
  }

  /**
   * Get all active subagent IDs
   */
  getActiveSubagents(): string[] {
    return Array.from(this.activeSubagents.keys());
  }

  /**
   * Check if a subagent is running
   */
  isSubagentRunning(subagentId: string): boolean {
    return this.activeSubagents.has(subagentId);
  }

  /**
   * Get agent status list for UI
   */
  getAgentStatusList(): AgentStatusItem[] {
    return Array.from(this.agentStatus.values()).sort((a, b) => {
      // Running first, then by start time
      if (a.state === 'running' && b.state !== 'running') return -1;
      if (b.state === 'running' && a.state !== 'running') return 1;
      return b.startedAt - a.startedAt;
    });
  }

  /**
   * Get subagent state (for already-finished subagents)
   */
  getSubagentState(subagentId: string): BranchState | null {
    const status = this.agentStatus.get(subagentId);
    return status?.state ?? null;
  }

  /**
   * Clear agent status list (call when switching conversations)
   * Also triggers a status change event for UI updates
   */
  clearAgentStatus(): void {
    this.agentStatus.clear();
    this.subagentBranches.clear();
    this.streamingBranchMessages.clear();
  }

  /**
   * Get in-memory messages for a streaming branch
   * Returns null if branch is not actively streaming
   * UI can use this to render directly from memory without storage read
   */
  getStreamingBranchMessages(branchId: string): ChatMessage[] | null {
    return this.streamingBranchMessages.get(branchId) || null;
  }

  /**
   * Check if a branch is actively streaming
   */
  isBranchStreaming(branchId: string): boolean {
    return this.streamingBranchMessages.has(branchId);
  }

  /**
   * Core execution loop
   */
  private async runSubagentLoop(
    subagentId: string,
    branchId: string,
    params: SubagentParams,
    abortSignal: AbortSignal
  ): Promise<SubagentResult> {
    // 1. Pre-fetch tool schemas FIRST (if parent specified tools to hand off)
    let toolSchemasText = '';
    if (params.tools && Object.keys(params.tools).length > 0 && this.dependencies.getToolSchemas) {
      const schemas = await this.prefetchToolSchemas(params.tools);
      if (schemas.length > 0) {
        toolSchemasText = this.formatToolSchemas(schemas);
      }
    }

    // 2. Read context files if provided (inherited from parent + tool params)
    // These go into the SYSTEM PROMPT so the subagent has full context
    let contextFilesContent = '';
    if (params.contextFiles?.length) {
      contextFilesContent = await this.readContextFiles(params.contextFiles);
    }

    // 3. Build system prompt WITH tool schemas + context files included
    const systemPrompt = await this.buildSystemPrompt(params, toolSchemasText, contextFilesContent);

    // 4. Build initial user message (just task + any additional context string)
    const initialMessage = this.buildInitialMessage(params.task, params.context || '');

    // 5. Add initial messages to branch
    const systemMessage: ChatMessage = {
      id: `msg_${Date.now()}_system`,
      role: 'system',
      content: systemPrompt,
      timestamp: Date.now(),
      conversationId: params.parentConversationId,
      state: 'complete',
    };

    const userMessage: ChatMessage = {
      id: `msg_${Date.now()}_user`,
      role: 'user',
      content: initialMessage,
      timestamp: Date.now(),
      conversationId: params.parentConversationId,
      state: 'complete',
    };

    await this.dependencies.branchService.addMessageToBranch(branchId, systemMessage);
    await this.dependencies.branchService.addMessageToBranch(branchId, userMessage);

    // 6. Stream response - LLMService handles ALL tool pingpong internally
    // The streaming generator (via LLMService â†’ StreamingOrchestrator â†’ ToolContinuationService)
    // already executes all tool calls and continues until the LLM responds with no more tool calls.
    // We just need to collect the response and save it.

    // Check abort signal FIRST
    if (abortSignal.aborted) {
      await this.dependencies.branchService.updateBranchState(branchId, 'cancelled', 0);
      // Clear from in-memory map if cancelled before streaming started
      this.streamingBranchMessages.delete(branchId);
      return {
        success: false,
        content: '',
        branchId,
        conversationId: params.parentConversationId,
        iterations: 0,
        error: 'Cancelled by user',
      };
    }

    // Get branch messages for context
    const branchInfo = await this.dependencies.branchService.getBranch(
      params.parentConversationId,
      branchId
    );

    if (!branchInfo) {
      throw new Error('Branch not found');
    }

    // Generate response - streaming handles tool pingpong automatically
    let responseContent = '';
    let toolCalls: SubagentToolCall[] | undefined;
    let reasoning = '';
    let toolIterations = 0;
    let lastToolUsed: string | undefined;

    const streamMessages = branchInfo.branch.messages;

    // Create streaming placeholder assistant message
    const assistantMessageId = `msg_${Date.now()}_assistant`;
    const streamingAssistantMessage: ChatMessage = {
      id: assistantMessageId,
      role: 'assistant',
      content: '',
      timestamp: Date.now(),
      conversationId: params.parentConversationId,
      state: 'streaming',
    };

    // ADD the assistant message to branch storage (like parent chat does)
    // This allows updateMessageInBranch to work later
    await this.dependencies.branchService.addMessageToBranch(branchId, streamingAssistantMessage);

    // Build in-memory messages array (system + user from storage, plus streaming assistant)
    const inMemoryMessages: ChatMessage[] = [
      ...streamMessages,
      streamingAssistantMessage,
    ];

    // Store in map so UI can access when navigating to this branch
    this.streamingBranchMessages.set(branchId, inMemoryMessages);

    for await (const chunk of this.dependencies.streamingGenerator(streamMessages, {
      abortSignal,
      workspaceId: params.workspaceId,
      sessionId: params.sessionId,
      provider: params.provider,
      model: params.model,
    })) {
      // Check abort during streaming
      if (abortSignal.aborted) {
        await this.dependencies.branchService.updateBranchState(branchId, 'cancelled', toolIterations);
        // Clear from in-memory map on cancellation
        this.streamingBranchMessages.delete(branchId);
        return {
          success: false,
          content: responseContent,
          branchId,
          conversationId: params.parentConversationId,
          iterations: toolIterations,
          error: 'Cancelled by user',
        };
      }

      responseContent += chunk.chunk;
      if (chunk.toolCalls) {
        // These are ALREADY-EXECUTED tool calls (with results)
        // They accumulate across all pingpong iterations
        toolCalls = chunk.toolCalls;
        toolIterations = chunk.toolCalls.length; // Approximate iteration count

        // Track the last tool used for UI display
        const latestTool = chunk.toolCalls[chunk.toolCalls.length - 1];
        if (latestTool?.function?.name) {
          lastToolUsed = latestTool.function.name;
          this.updateStatus(subagentId, { iterations: toolIterations, lastToolUsed });
        }
      }
      if (chunk.reasoning) {
        reasoning += chunk.reasoning;
      }

      // Update IN-MEMORY message (like parent chat does) - NO storage writes during streaming
      const convertedToolCalls: ToolCall[] | undefined = toolCalls?.map(tc => ({
        ...tc,
        type: tc.type || 'function',
      }));
      streamingAssistantMessage.content = responseContent;
      streamingAssistantMessage.toolCalls = convertedToolCalls;
      streamingAssistantMessage.reasoning = reasoning || undefined;

      // Emit tool calls event - SAME as parent chat does
      // This allows ToolEventCoordinator to dynamically create/update tool bubbles
      if (convertedToolCalls && convertedToolCalls.length > 0) {
        this.events.onToolCallsDetected?.(branchId, assistantMessageId, convertedToolCalls);
      }

      // Emit progress
      this.events.onSubagentProgress?.(subagentId, responseContent, toolIterations);

      // Emit INCREMENTAL chunk (like parent chat) - chunk.chunk is already the new piece
      // This allows StreamingController to append efficiently without re-rendering
      this.events.onStreamingUpdate?.(
        branchId,
        assistantMessageId,
        chunk.chunk,  // Just the NEW chunk, not full content
        chunk.complete,
        responseContent  // Full content for finalization
      );
    }

    // Update status with final count
    this.updateStatus(subagentId, { iterations: toolIterations || 1, lastToolUsed });

    // Convert tool calls for storage
    const finalToolCalls: ToolCall[] | undefined = toolCalls?.map(tc => ({
      ...tc,
      type: tc.type || 'function',
    }));

    // Update the placeholder message in storage with final content
    await this.dependencies.branchService.updateMessageInBranch(branchId, assistantMessageId, {
      content: responseContent,
      state: 'complete',
      toolCalls: finalToolCalls,
      reasoning: reasoning || undefined,
    });

    // Streaming completed = LLM is done (all tool calls already handled internally)
    await this.dependencies.branchService.updateBranchState(branchId, 'complete', toolIterations || 1);

    // Clear from in-memory map now that streaming is complete and saved
    this.streamingBranchMessages.delete(branchId);

    return {
      success: true,
      content: responseContent,
      branchId,
      conversationId: params.parentConversationId,
      iterations: toolIterations || 1,
    };
  }

  /**
   * Build system prompt for subagent
   * @param params Subagent parameters
   * @param toolSchemas Pre-fetched tool schemas to include (optional)
   * @param contextFilesContent Content from context files to include (optional)
   */
  private async buildSystemPrompt(
    params: SubagentParams,
    toolSchemas?: string,
    contextFilesContent?: string
  ): Promise<string> {
    // Determine if tools were pre-loaded by parent
    const hasPreloadedTools = toolSchemas && toolSchemas.length > 0;

    // Start with inherited agent prompt if available
    let promptParts: string[] = [];

    // 1. Add inherited agent persona/prompt if parent had a custom agent selected
    if (params.agentPrompt) {
      promptParts.push(`## Inherited Agent Context\n${params.agentPrompt}`);
    } else if (params.agentName) {
      promptParts.push(`[Agent persona: ${params.agentName}]`);
    } else if (params.agent) {
      promptParts.push(`[Agent persona: ${params.agent}]`);
    }

    // 2. Add core subagent instructions
    promptParts.push(`## Subagent Instructions

You are an AUTONOMOUS subagent. You MUST complete tasks independently using tools.

### Your Task
${params.task}

### CRITICAL RULES

1. **NEVER ask questions or seek clarification** - You are autonomous. Make reasonable assumptions and proceed.

2. **ALWAYS use tools** - Your first response MUST include tool calls.

3. **Text-only response = Task complete** - Only respond with plain text (no tool calls) when you have FINISHED the task and are reporting results.

4. **Make decisions independently** - If details are ambiguous, choose sensible defaults. Do not ask the user.

5. **Use thinking/reasoning internally** - Deliberate in your thinking, not in your text output.`);

    // 3. Add workspace context if available
    if (params.workspaceData) {
      const workspaceContext = this.formatWorkspaceData(params.workspaceData);
      if (workspaceContext) {
        promptParts.push(`## Workspace Context\n${workspaceContext}`);
      }
    }

    // 4. Add context files content if available (from parent's notes + tool params)
    if (contextFilesContent) {
      promptParts.push(`## Reference Files\nThe following files have been provided as context:\n\n${contextFilesContent}`);
    }

    // 5. Add tool section based on whether tools were pre-loaded
    if (hasPreloadedTools) {
      promptParts.push(`## Pre-loaded Tools (Ready to Use)

The parent agent has equipped you with these specific tools. Use them via toolManager_useTool:

${toolSchemas}

**To call a tool**, use toolManager_useTool with:
\`\`\`json
{
  "context": {
    "workspaceId": "${params.workspaceId || 'default'}",
    "sessionId": "${params.sessionId || 'subagent'}",
    "memory": "Subagent working on: ${params.task.substring(0, 50)}...",
    "goal": "Complete the assigned task"
  },
  "calls": [
    { "agent": "agentName", "tool": "toolName", "params": { ... } }
  ]
}
\`\`\`

BEGIN - Use the pre-loaded tools above to complete the task.`);
    } else {
      promptParts.push(`## Available Tools

Call toolManager_getTools first to discover available tools, then toolManager_useTool to execute them.

Example flow:
1. Call getTools to see what's available
2. Call useTool with the appropriate agent/tool/params
3. Continue until task is complete
4. Respond with final results (no tool calls)

BEGIN - Start by calling getTools to discover available tools.`);
    }

    return promptParts.join('\n\n');
  }

  /**
   * Format workspace data for inclusion in system prompt
   * Uses shared utility for consistency with SystemPromptBuilder
   */
  private formatWorkspaceData(workspaceData: any): string {
    // Import dynamically to avoid circular dependencies
    const { formatWorkspaceDataForPrompt } = require('../../utils/WorkspaceDataFormatter');
    return formatWorkspaceDataForPrompt(workspaceData, { maxStates: 3 });
  }

  /**
   * Build initial user message with task and context
   * Tool schemas are now in the system prompt, not here
   */
  private buildInitialMessage(task: string, context: string): string {
    let message = `Execute this task:\n\n${task}`;

    if (context) {
      message += `\n\n## Additional Context\n${context}`;
    }

    return message;
  }

  /**
   * Pre-fetch tool schemas based on params.tools
   */
  private async prefetchToolSchemas(tools: Record<string, string[]>): Promise<ToolSchemaInfo[]> {
    if (!this.dependencies.getToolSchemas) return [];

    const schemas: ToolSchemaInfo[] = [];

    for (const [agentName, toolSlugs] of Object.entries(tools)) {
      try {
        const agentSchemas = await this.dependencies.getToolSchemas(agentName, toolSlugs);
        schemas.push(...agentSchemas);
      } catch {
        // Tool not found - skip silently
      }
    }

    return schemas;
  }

  /**
   * Format tool schemas for inclusion in message
   */
  private formatToolSchemas(schemas: ToolSchemaInfo[]): string {
    return schemas
      .map(schema => {
        const name = schema.name || `${schema.agent}.${schema.slug}`;
        const desc = schema.description || '';
        const params = schema.parameters
          ? `\nParameters:\n\`\`\`json\n${JSON.stringify(schema.parameters, null, 2)}\n\`\`\``
          : '';
        return `### ${name}\n${desc}${params}`;
      })
      .join('\n\n');
  }

  /**
   * Read context files
   */
  private async readContextFiles(files: string[]): Promise<string> {
    const contents: string[] = [];

    for (const file of files) {
      try {
        const results = await this.dependencies.directToolExecutor.executeToolCalls([{
          id: `ctx_${Date.now()}`,
          function: {
            name: 'contentManager.readContent',
            arguments: JSON.stringify({ filePath: file }),
          },
        }]);
        const result = results[0];

        if (result?.success && (result.result as { content?: string })?.content) {
          contents.push(`--- ${file} ---\n${(result.result as { content: string }).content}`);
        } else {
          contents.push(`--- ${file} --- (failed to read)`);
        }
      } catch {
        contents.push(`--- ${file} --- (error reading file)`);
      }
    }

    return contents.join('\n\n');
  }

  /**
   * Queue result back to parent conversation
   */
  private queueResultToParent(params: SubagentParams, result: SubagentResult): void {
    const message: QueuedMessage = {
      id: `subagent_result_${Date.now()}`,
      type: 'subagent_result',
      content: JSON.stringify({
        success: result.success,
        task: params.task,
        status: result.success ? 'complete' : (result.error === 'Max iterations reached' ? 'max_iterations' : 'error'),
        iterations: result.iterations,
        result: result.content,
        error: result.error,
      }),
      metadata: {
        subagentId: result.branchId.replace('branch_subagent_', 'subagent_'),
        subagentTask: params.task,
        branchId: result.branchId,
        conversationId: result.conversationId,
        parentMessageId: params.parentMessageId,
      },
      queuedAt: Date.now(),
    };

    this.dependencies.messageQueueService.enqueue(message);
  }

  /**
   * Update agent status
   */
  private updateStatus(subagentId: string, updates: Partial<AgentStatusItem>): void {
    const status = this.agentStatus.get(subagentId);
    if (status) {
      Object.assign(status, updates);
      if (updates.state && updates.state !== 'running') {
        status.completedAt = Date.now();
      }
    }
  }
}

```

## services/chat/ToolCallService.ts

```typescript
/**
 * ToolCallService - Manages tool calls, events, and execution for chat conversations
 *
 * Responsibilities:
 * - Tool initialization from DirectToolExecutor (or legacy MCPConnector)
 * - OpenAI format tool schemas
 * - Tool event callbacks (detected/updated/started/completed)
 * - Progressive tool call display coordination
 * - Tool execution via DirectToolExecutor
 * - Session/workspace context injection
 *
 * Architecture Note:
 * This service now uses DirectToolExecutor by default, which works on BOTH
 * desktop and mobile. MCPConnector is only needed for external clients
 * (Claude Desktop) and is kept for backward compatibility during migration.
 *
 * Follows Single Responsibility Principle - only handles tool management.
 */

import { ToolCall } from '../../types/chat/ChatTypes';
import { getToolNameMetadata } from '../../utils/toolNameUtils';
import { DirectToolExecutor } from './DirectToolExecutor';

export interface ToolEventCallback {
  (messageId: string, event: 'detected' | 'updated' | 'started' | 'completed', data: any): void;
}

export interface ToolExecutionContext {
  sessionId?: string;
  workspaceId?: string;
}

export class ToolCallService {
  private availableTools: any[] = [];
  private toolCallHistory = new Map<string, ToolCall[]>();
  private toolEventCallback?: ToolEventCallback;
  private detectedToolIds = new Set<string>(); // Track which tools have been detected already
  private directToolExecutor?: DirectToolExecutor;

  constructor(
    private mcpConnector?: any // Now optional - only for legacy/Claude Desktop
  ) {}

  /**
   * Set the DirectToolExecutor for direct tool execution
   * This enables tools on ALL platforms (desktop + mobile)
   */
  setDirectToolExecutor(executor: DirectToolExecutor): void {
    this.directToolExecutor = executor;
    // Invalidate cached tools to force refresh
    this.availableTools = [];
  }

  /**
   * Get the DirectToolExecutor (for use by MCPToolExecution)
   */
  getDirectToolExecutor(): DirectToolExecutor | undefined {
    return this.directToolExecutor;
  }

  /**
   * Initialize available tools
   * Uses DirectToolExecutor (preferred) or falls back to MCPConnector (legacy)
   */
  async initialize(): Promise<void> {
    try {
      // Prefer DirectToolExecutor - works on ALL platforms
      if (this.directToolExecutor) {
        this.availableTools = await this.directToolExecutor.getAvailableTools();
        return;
      }

      // Fallback to MCPConnector (legacy - only works on desktop)
      if (this.mcpConnector && typeof this.mcpConnector.getAvailableTools === 'function') {
        this.availableTools = this.mcpConnector.getAvailableTools();
        return;
      }

      this.availableTools = [];
    } catch (error) {
      console.error('[ToolCallService] Failed to initialize tools:', error);
      this.availableTools = [];
    }
  }

  /**
   * Get available tools in OpenAI format
   */
  getAvailableTools(): any[] {
    return this.convertMCPToolsToOpenAIFormat(this.availableTools);
  }

  /**
   * Convert MCP tools (with inputSchema) to OpenAI format (with parameters)
   * Handles both MCP format and already-converted OpenAI format
   */
  private convertMCPToolsToOpenAIFormat(mcpTools: any[]): any[] {
    return mcpTools.map(tool => {
      // Check if already in OpenAI format (has type: 'function' and function object)
      if (tool.type === 'function' && tool.function) {
        return tool; // Already converted, return as-is
      }

      // Convert from MCP format (name, description, inputSchema) to OpenAI format
      return {
        type: 'function',
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.inputSchema // MCP's inputSchema maps to OpenAI's parameters
        }
      };
    });
  }

  /**
   * Set tool event callback for live UI updates
   */
  setEventCallback(callback: ToolEventCallback): void {
    this.toolEventCallback = callback;
  }

  /**
   * Fire tool event callback if registered
   */
  fireToolEvent(messageId: string, event: 'detected' | 'updated' | 'started' | 'completed', data: any): void {
    try {
      this.toolEventCallback?.(messageId, event, data);
    } catch (error) {
      console.error(`Tool event callback failed for ${event}:`, error);
    }
  }

  /**
   * Handle progressive tool call detection during streaming
   * Fires 'detected' event for new tools, 'updated' event for subsequent chunks
   */
  handleToolCallDetection(
    messageId: string,
    toolCalls: any[],
    isComplete: boolean,
    conversationId: string
  ): void {
    if (!this.toolEventCallback || !toolCalls) return;

    for (const tc of toolCalls) {
      const toolId = tc.id;

      // Determine if this is the first time we've seen this tool call
      const isFirstDetection = !this.detectedToolIds.has(toolId);

      const nameMetadata = getToolNameMetadata(
        tc.function?.name || tc.name
      );

      // Build tool data for event
      const toolData = {
        conversationId,
        toolCall: tc,
        isComplete: isComplete,
        displayName: nameMetadata.displayName,
        technicalName: nameMetadata.technicalName,
        agentName: nameMetadata.agentName,
        actionName: nameMetadata.actionName
      };

      if (isFirstDetection) {
        // First time seeing this tool - fire 'detected' event
        this.fireToolEvent(messageId, 'detected', toolData);
        this.detectedToolIds.add(toolId);
      } else if (isComplete) {
        // Subsequent update with complete parameters - fire 'updated' event
        this.fireToolEvent(messageId, 'updated', toolData);
      }
      // Skip incomplete intermediate chunks (they would spam the UI)
    }
  }

  /**
   * Reset detected tool IDs (call when starting new message)
   */
  resetDetectedTools(): void {
    this.detectedToolIds.clear();
  }

  /**
   * Execute tool calls via MCPConnector
   * @deprecated Use LLMService streaming with tool execution instead
   */
  async executeToolCalls(
    toolCalls: any[],
    context?: ToolExecutionContext
  ): Promise<ToolCall[]> {
    const executedCalls: ToolCall[] = [];

    for (const toolCall of toolCalls) {
      const nameMetadata = getToolNameMetadata(
        toolCall.function?.name || toolCall.name
      );
      try {

        // Fire 'started' event
        if (this.toolEventCallback) {
          this.fireToolEvent('', 'started', {
            toolCall,
            sessionId: context?.sessionId,
            workspaceId: context?.workspaceId,
            displayName: nameMetadata.displayName,
            technicalName: nameMetadata.technicalName,
            agentName: nameMetadata.agentName,
            actionName: nameMetadata.actionName
          });
        }

        // Extract parameters
        const args = typeof toolCall.function?.arguments === 'string'
          ? JSON.parse(toolCall.function.arguments)
          : (toolCall.function?.arguments || {});

        // Enrich with context
        const enrichedArgs = this.enrichWithContext(args, context);

        // Execute via MCP
        const result = await this.mcpConnector.executeTool(
          toolCall.function?.name || toolCall.name,
          enrichedArgs
        );

        const executed: ToolCall = {
          id: toolCall.id,
          type: 'function',
          name: nameMetadata.displayName || toolCall.function?.name || toolCall.name,
          displayName: nameMetadata.displayName,
          technicalName: nameMetadata.technicalName,
          function: {
            name: toolCall.function?.name || toolCall.name,
            arguments: JSON.stringify(enrichedArgs)
          },
          parameters: enrichedArgs,
          result: result,
          success: true
        };

        executedCalls.push(executed);

        // Fire 'completed' event
        if (this.toolEventCallback) {
          this.fireToolEvent('', 'completed', {
            toolCall: executed,
            result,
            displayName: nameMetadata.displayName,
            technicalName: nameMetadata.technicalName,
            agentName: nameMetadata.agentName,
            actionName: nameMetadata.actionName
          });
        }

      } catch (error) {
        console.error(`Tool execution failed for ${toolCall.function?.name || toolCall.name}:`, error);

        const failed: ToolCall = {
          id: toolCall.id,
          type: 'function',
          name: nameMetadata.displayName || toolCall.function?.name || toolCall.name,
          displayName: nameMetadata.displayName,
          technicalName: nameMetadata.technicalName,
          function: {
            name: toolCall.function?.name || toolCall.name,
            arguments: toolCall.function?.arguments || JSON.stringify({})
          },
          parameters: typeof toolCall.function?.arguments === 'string'
            ? JSON.parse(toolCall.function.arguments)
            : (toolCall.function?.arguments || {}),
          error: error instanceof Error ? error.message : String(error),
          success: false
        };

        executedCalls.push(failed);

        if (this.toolEventCallback) {
          this.fireToolEvent('', 'completed', {
            toolCall: failed,
            result: failed.error,
            displayName: nameMetadata.displayName,
            technicalName: nameMetadata.technicalName,
            agentName: nameMetadata.agentName,
            actionName: nameMetadata.actionName,
            success: false,
            error: failed.error
          });
        }
      }
    }

    return executedCalls;
  }

  /**
   * Enrich tool parameters with session and workspace context
   */
  private enrichWithContext(params: any, context?: ToolExecutionContext): any {
    if (!context) return params;

    const enriched = { ...params };

    // Inject sessionId if available and not already present
    if (context.sessionId && !enriched.sessionId) {
      enriched.sessionId = context.sessionId;
    }

    // Inject workspaceId if available and not already present
    if (context.workspaceId && !enriched.workspaceId) {
      enriched.workspaceId = context.workspaceId;
    }

    return enriched;
  }

  /**
   * Get tool call history for a message
   */
  getToolCallHistory(messageId: string): ToolCall[] | undefined {
    return this.toolCallHistory.get(messageId);
  }

  /**
   * Store tool call history for a message
   */
  setToolCallHistory(messageId: string, toolCalls: ToolCall[]): void {
    this.toolCallHistory.set(messageId, toolCalls);
  }

  /**
   * Clear tool call history
   */
  clearHistory(): void {
    this.toolCallHistory.clear();
  }

  /**
   * Dispose resources
   */
  dispose(): void {
    this.availableTools = [];
    this.toolCallHistory.clear();
    this.toolEventCallback = undefined;
    this.detectedToolIds.clear();
  }
}

```

## services/ConversationService.ts

```typescript
// Location: src/services/ConversationService.ts
// Conversation management service with hybrid storage support
// Used by: ChatService, ConversationManager, UI components
// Dependencies: FileSystemService + IndexManager (legacy) OR IStorageAdapter (new)
//
// MIGRATION NOTE: This service supports both storage backends:
// - Legacy: FileSystemService + IndexManager (JSON files + index)
// - New: IStorageAdapter (JSONL + SQLite hybrid storage)
// The adapter is prioritized if available, otherwise falls back to legacy.

import { Plugin } from 'obsidian';
import { FileSystemService } from './storage/FileSystemService';
import { IndexManager } from './storage/IndexManager';
import { IndividualConversation, ConversationMetadata as LegacyConversationMetadata, ConversationMessage } from '../types/storage/StorageTypes';

// Re-export for consumers
export type { IndividualConversation, ConversationMessage } from '../types/storage/StorageTypes';
import { IStorageAdapter } from '../database/interfaces/IStorageAdapter';
import { ConversationMetadata, MessageData } from '../types/storage/HybridStorageTypes';
import { PaginationParams, PaginatedResult, calculatePaginationMetadata } from '../types/pagination/PaginationTypes';
import type { ConversationBranch, SubagentBranchMetadata, HumanBranchMetadata } from '../types/branch/BranchTypes';

export class ConversationService {
  constructor(
    private plugin: Plugin,
    private fileSystem: FileSystemService,
    private indexManager: IndexManager,
    private storageAdapter?: IStorageAdapter
  ) {}

  /**
   * List conversations (uses index only - lightweight and fast)
   */
  async listConversations(vaultName?: string, limit?: number): Promise<LegacyConversationMetadata[]> {
    // Use adapter if available
    if (this.storageAdapter) {
      const result = await this.storageAdapter.getConversations({
        filter: vaultName ? { vaultName } : undefined,
        pageSize: limit ?? 100,
        page: 0,
        sortBy: 'updated',
        sortOrder: 'desc'
      });
      // Convert new format to legacy format
      return result.items.map(this.convertToLegacyMetadata);
    }

    // Fall back to legacy storage
    const index = await this.indexManager.loadConversationIndex();
    let conversations = Object.values(index.conversations);

    // Filter by vault if specified
    if (vaultName) {
      conversations = conversations.filter(conv => conv.vault_name === vaultName);
    }

    // Sort by updated timestamp (most recent first)
    conversations.sort((a, b) => b.updated - a.updated);

    // Apply limit if specified
    if (limit) {
      conversations = conversations.slice(0, limit);
    }

    return conversations;
  }

  /**
   * Get full conversation with messages (loads individual file or queries from adapter)
   *
   * KEY IMPROVEMENT: With adapter, messages are paginated from SQLite instead of loading all
   *
   * @param id - Conversation ID
   * @param paginationOptions - Optional pagination parameters for message loading
   * @returns Conversation with paginated messages (or all messages if no pagination specified)
   */
  async getConversation(
    id: string,
    paginationOptions?: PaginationParams
  ): Promise<IndividualConversation | null> {
    // Use adapter if available
    if (this.storageAdapter) {
      const metadata = await this.storageAdapter.getConversation(id);
      if (!metadata) {
        return null;
      }

      // Apply pagination or load all messages (default: first 1000 for backward compatibility)
      const messagesResult = await this.storageAdapter.getMessages(id, {
        page: paginationOptions?.page ?? 0,
        pageSize: paginationOptions?.pageSize ?? 1000
      });

      // Convert to legacy format
      const conversation = this.convertToLegacyConversation(metadata, messagesResult.items);

      // Populate message.branches from branch storage (unified model)
      // Branch conversations have parentConversationId and parentMessageId in metadata
      await this.populateMessageBranches(id, conversation.messages);

      // Attach pagination metadata if pagination was requested
      if (paginationOptions) {
        // Convert MessageData pagination to ConversationMessage pagination
        conversation.messagePagination = {
          ...messagesResult,
          items: conversation.messages // Already converted by convertToLegacyConversation
        };
      }

      return conversation;
    }

    // Fall back to legacy storage
    const conversation = await this.fileSystem.readConversation(id);

    if (!conversation) {
      return null;
    }

    // Migration: Add state field to messages that don't have it
    if (conversation.messages && conversation.messages.length > 0) {
      conversation.messages = conversation.messages.map(msg => {
        if (!msg.state) {
          // Default existing messages to 'complete' state
          // They were saved, so they must be complete
          msg.state = 'complete';
        }
        return msg;
      });
    }

    // Note: Old alternatives[] migration removed - unified branch model uses
    // separate conversations with parent metadata, not embedded branches

    // If pagination was requested for legacy storage, slice the messages array
    if (paginationOptions) {
      const page = paginationOptions.page ?? 0;
      const pageSize = paginationOptions.pageSize ?? 50;
      const totalMessages = conversation.messages.length;
      const startIndex = page * pageSize;
      const endIndex = startIndex + pageSize;

      const paginatedMessages = conversation.messages.slice(startIndex, endIndex);
      const paginationMetadata = calculatePaginationMetadata(page, pageSize, totalMessages);

      // Store original messages count but return paginated subset
      conversation.messagePagination = {
        ...paginationMetadata,
        items: paginatedMessages
      };
      conversation.messages = paginatedMessages;
    }

    return conversation;
  }

  /**
   * Get messages for a conversation (paginated)
   *
   * This method allows fetching messages without loading the full conversation metadata.
   * Useful for lazy loading messages in UI components.
   *
   * @param conversationId - Conversation ID
   * @param options - Pagination parameters
   * @returns Paginated result containing messages
   */
  async getMessages(
    conversationId: string,
    options?: PaginationParams
  ): Promise<PaginatedResult<any>> {
    // Use adapter if available
    if (this.storageAdapter) {
      const messagesResult = await this.storageAdapter.getMessages(conversationId, {
        page: options?.page ?? 0,
        pageSize: options?.pageSize ?? 50
      });

      // Convert MessageData to legacy message format
      return {
        ...messagesResult,
        items: messagesResult.items.map(msg => ({
          id: msg.id,
          role: msg.role as 'user' | 'assistant' | 'tool',
          content: msg.content || '',
          timestamp: msg.timestamp,
          state: msg.state,
          toolCalls: msg.toolCalls?.map(tc => {
            // Handle both formats:
            // 1. Standard OpenAI format: { function: { name, arguments } }
            // 2. Result format from buildToolMetadata: { name, result, success, error }
            const hasFunction = tc.function && typeof tc.function === 'object';
            const name = (hasFunction ? tc.function.name : tc.name) || 'unknown_tool';
            const parameters = hasFunction && tc.function.arguments
              ? (typeof tc.function.arguments === 'string'
                  ? JSON.parse(tc.function.arguments)
                  : tc.function.arguments)
              : tc.parameters;
            return {
              id: tc.id,
              type: tc.type || 'function',
              name,
              function: tc.function || { name, arguments: JSON.stringify(parameters || {}) },
              parameters: parameters || {},
              result: tc.result,
              success: tc.success,
              error: tc.error
            };
          }),
          reasoning: msg.reasoning,
          metadata: msg.metadata,
          // Branching support
          alternatives: msg.alternatives,
          activeAlternativeIndex: msg.activeAlternativeIndex
        }))
      };
    }

    // Fall back to legacy storage - load full conversation and slice messages
    const conversation = await this.fileSystem.readConversation(conversationId);
    if (!conversation) {
      return {
        items: [],
        page: 0,
        pageSize: options?.pageSize ?? 50,
        totalItems: 0,
        totalPages: 0,
        hasNextPage: false,
        hasPreviousPage: false
      };
    }

    const page = options?.page ?? 0;
    const pageSize = options?.pageSize ?? 50;
    const totalMessages = conversation.messages.length;
    const startIndex = page * pageSize;
    const endIndex = startIndex + pageSize;

    const paginatedMessages = conversation.messages.slice(startIndex, endIndex);
    const paginationMetadata = calculatePaginationMetadata(page, pageSize, totalMessages);

    return {
      ...paginationMetadata,
      items: paginatedMessages
    };
  }

  /**
   * Get all conversations with full data (expensive - avoid if possible)
   */
  async getAllConversations(): Promise<IndividualConversation[]> {
    const conversationIds = await this.fileSystem.listConversationIds();
    const conversations: IndividualConversation[] = [];

    for (const id of conversationIds) {
      const conversation = await this.fileSystem.readConversation(id);
      if (conversation) {
        conversations.push(conversation);
      }
    }

    return conversations;
  }

  /**
   * Create new conversation (writes to adapter or legacy storage)
   */
  async createConversation(data: Partial<IndividualConversation>): Promise<IndividualConversation> {
    const id = data.id || `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // Use adapter if available
    if (this.storageAdapter) {
      const conversationId = await this.storageAdapter.createConversation({
        title: data.title || 'Untitled Conversation',
        created: data.created ?? Date.now(),
        updated: data.updated ?? Date.now(),
        vaultName: data.vault_name || this.plugin.app.vault.getName(),
        workspaceId: data.metadata?.chatSettings?.workspaceId,
        sessionId: data.metadata?.chatSettings?.sessionId,
        metadata: data.metadata  // Pass full metadata for branch support (parentConversationId, branchType, etc.)
      });

      // Get created conversation
      const metadata = await this.storageAdapter.getConversation(conversationId);
      if (!metadata) {
        throw new Error('Failed to retrieve created conversation');
      }

      // Convert to legacy format
      return this.convertToLegacyConversation(metadata, []);
    }

    // Fall back to legacy storage
    const conversation: IndividualConversation = {
      id,
      title: data.title || 'Untitled Conversation',
      created: data.created || Date.now(),
      updated: data.updated || Date.now(),
      vault_name: data.vault_name || this.plugin.app.vault.getName(),
      message_count: data.messages?.length || 0,
      messages: data.messages || [],
      metadata: data.metadata // âš ï¸ CRITICAL: Preserve metadata including sessionId!
    };

    // Write conversation file
    await this.fileSystem.writeConversation(id, conversation);

    // Update index
    await this.indexManager.updateConversationInIndex(conversation);

    return conversation;
  }

  /**
   * Update conversation (updates adapter or legacy storage)
   */
  async updateConversation(id: string, updates: Partial<IndividualConversation>): Promise<void> {
    // Use adapter if available
    if (this.storageAdapter) {
      // Merge existing metadata so we don't lose chat settings when only cost is updated
      const existing = await this.storageAdapter.getConversation(id);
      const existingMetadata = existing?.metadata || {};

      // IMPORTANT: Preserve ALL existing metadata fields (parentConversationId, parentMessageId, branchType, etc.)
      // Then apply updates on top, with special handling for nested chatSettings
      const mergedMetadata = {
        ...existingMetadata,
        ...updates.metadata,
        chatSettings: {
          ...(existingMetadata.chatSettings || {}),
          ...(updates.metadata?.chatSettings || {}),
          workspaceId: updates.metadata?.chatSettings?.workspaceId ?? existingMetadata.chatSettings?.workspaceId,
          sessionId: updates.metadata?.chatSettings?.sessionId ?? existingMetadata.chatSettings?.sessionId
        },
        cost: updates.cost || updates.metadata?.cost || existingMetadata.cost
      };

      // If messages are provided, persist message-level updates through the adapter
      if (updates.messages && updates.messages.length > 0) {
        // Update each message's persisted content/state/reasoning
        for (const msg of updates.messages) {
          const convertedToolCalls = msg.toolCalls?.map(tc => ({
            id: tc.id,
            type: 'function' as const,
            function: tc.function || {
              name: tc.name || 'unknown_tool',
              arguments: JSON.stringify(tc.parameters || {})
            },
            result: tc.result,
            success: tc.success,
            error: tc.error,
            executionTime: tc.executionTime
          }));

          await this.storageAdapter.updateMessage(id, msg.id, {
            content: msg.content ?? null,
            state: msg.state,
            reasoning: msg.reasoning,
            toolCalls: convertedToolCalls,
            toolCallId: msg.toolCallId,
            // Branching support - cast needed due to type differences between storage layers
            alternatives: msg.alternatives as unknown as import('../types/storage/HybridStorageTypes').AlternativeMessage[] | undefined,
            activeAlternativeIndex: msg.activeAlternativeIndex
          });
        }

        // Also bump the conversation's updated timestamp to keep listings fresh
        await this.storageAdapter.updateConversation(id, {
          title: updates.title,
          updated: updates.updated ?? Date.now(),
          workspaceId: updates.metadata?.chatSettings?.workspaceId,
          sessionId: updates.metadata?.chatSettings?.sessionId,
          metadata: mergedMetadata
        });
      } else {
        // Metadata-only update
        await this.storageAdapter.updateConversation(id, {
          title: updates.title,
          updated: updates.updated ?? Date.now(),
          workspaceId: updates.metadata?.chatSettings?.workspaceId,
          sessionId: updates.metadata?.chatSettings?.sessionId,
          metadata: mergedMetadata
        });
      }
      return;
    }

    // Fall back to legacy storage
    // Load existing conversation
    const conversation = await this.fileSystem.readConversation(id);

    if (!conversation) {
      throw new Error(`Conversation ${id} not found`);
    }

    // Apply updates
    const updatedConversation: IndividualConversation = {
      ...conversation,
      ...updates,
      id, // Preserve ID
      updated: Date.now(),
      message_count: updates.messages?.length ?? conversation.message_count
    };

    // Write updated conversation
    await this.fileSystem.writeConversation(id, updatedConversation);

    // Update index
    await this.indexManager.updateConversationInIndex(updatedConversation);
  }

  /**
   * Delete conversation (deletes from adapter or legacy storage)
   */
  async deleteConversation(id: string): Promise<void> {
    // Use adapter if available
    if (this.storageAdapter) {
      await this.storageAdapter.deleteConversation(id);
      return;
    }

    // Fall back to legacy storage
    // Delete conversation file
    await this.fileSystem.deleteConversation(id);

    // Remove from index
    await this.indexManager.removeConversationFromIndex(id);
  }

  /**
   * Update conversation metadata only (for chat settings persistence)
   */
  async updateConversationMetadata(id: string, metadata: any): Promise<void> {
    await this.updateConversation(id, { metadata });
  }

  /**
   * Add message to conversation
   *
   * KEY IMPROVEMENT: With adapter, messages are streamed via addMessage() instead of rewriting entire file
   */
  async addMessage(params: {
    conversationId: string;
    role: 'user' | 'assistant' | 'tool';
    content: string;
    toolCalls?: any[];
    cost?: { totalCost: number; currency: string };
    usage?: { promptTokens: number; completionTokens: number; totalTokens: number };
    provider?: string;
    model?: string;
    id?: string; // Optional: specify messageId for placeholder messages
    metadata?: any;
  }): Promise<{ success: boolean; messageId?: string; error?: string }> {
    try {
      // Use adapter if available
      if (this.storageAdapter) {
        // Determine initial state based on role and content
        let initialState: 'draft' | 'complete' = 'complete';
        if (params.role === 'assistant' && (!params.content || params.content.trim() === '')) {
          // Empty assistant messages are placeholders for streaming
          initialState = 'draft';
        }

        const messageId = await this.storageAdapter.addMessage(params.conversationId, {
          id: params.id,
          role: params.role,
          content: params.content,
          timestamp: Date.now(),
          state: initialState,
          toolCalls: params.toolCalls,
          metadata: params.metadata
        });

        return {
          success: true,
          messageId
        };
      }

      // Fall back to legacy storage
      // Load conversation
      const conversation = await this.fileSystem.readConversation(params.conversationId);

      if (!conversation) {
        return {
          success: false,
          error: `Conversation ${params.conversationId} not found`
        };
      }

      // Create message (use provided ID if available, otherwise generate new one)
      const messageId = params.id || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

      // Determine initial state based on role and content
      let initialState: 'draft' | 'complete' = 'complete';
      if (params.role === 'assistant' && (!params.content || params.content.trim() === '')) {
        // Empty assistant messages are placeholders for streaming
        initialState = 'draft';
      }

      const message = {
        id: messageId,
        role: params.role,
        content: params.content,
        timestamp: Date.now(),
        state: initialState,
        toolCalls: params.toolCalls || undefined,
        cost: params.cost,
        usage: params.usage,
        provider: params.provider,
        model: params.model,
        metadata: params.metadata
      };

      // Append message
      conversation.messages.push(message);
      conversation.message_count = conversation.messages.length;
      conversation.updated = Date.now();

      // Update conversation-level cost summary
      if (params.cost) {
        conversation.metadata = conversation.metadata || {};
        conversation.metadata.totalCost = (conversation.metadata.totalCost || 0) + params.cost.totalCost;
        conversation.metadata.currency = params.cost.currency;
      }

      if (params.usage) {
        conversation.metadata = conversation.metadata || {};
        conversation.metadata.totalTokens = (conversation.metadata.totalTokens || 0) + params.usage.totalTokens;
      }

      // Save conversation
      await this.fileSystem.writeConversation(params.conversationId, conversation);

      // Update index metadata
      await this.indexManager.updateConversationInIndex(conversation);

      return {
        success: true,
        messageId
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Update an existing message in a conversation
   * Used for streaming updates, state changes, and adding tool results
   */
  async updateMessage(
    conversationId: string,
    messageId: string,
    updates: {
      content?: string;
      state?: 'draft' | 'streaming' | 'complete' | 'aborted' | 'invalid';
      toolCalls?: any[];
      reasoning?: string;
    }
  ): Promise<{ success: boolean; error?: string }> {
    try {
      if (this.storageAdapter) {
        await this.storageAdapter.updateMessage(conversationId, messageId, updates);
        return { success: true };
      }

      // Fall back to legacy storage
      const conversation = await this.fileSystem.readConversation(conversationId);
      if (!conversation) {
        return { success: false, error: `Conversation ${conversationId} not found` };
      }

      const messageIndex = conversation.messages.findIndex(m => m.id === messageId);
      if (messageIndex === -1) {
        return { success: false, error: `Message ${messageId} not found` };
      }

      // Apply updates
      const message = conversation.messages[messageIndex];
      if (updates.content !== undefined) message.content = updates.content;
      if (updates.state !== undefined) message.state = updates.state;
      if (updates.toolCalls !== undefined) message.toolCalls = updates.toolCalls;
      if (updates.reasoning !== undefined) message.reasoning = updates.reasoning;

      conversation.updated = Date.now();

      await this.fileSystem.writeConversation(conversationId, conversation);
      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Search conversations (uses adapter FTS or legacy index)
   */
  async searchConversations(query: string, limit?: number): Promise<LegacyConversationMetadata[]> {
    if (!query) {
      return this.listConversations(undefined, limit);
    }

    // Use adapter if available
    if (this.storageAdapter) {
      const results = await this.storageAdapter.searchConversations(query);
      // Convert and apply limit
      const converted = results.map(this.convertToLegacyMetadata);
      return limit ? converted.slice(0, limit) : converted;
    }

    // Fall back to legacy storage
    const index = await this.indexManager.loadConversationIndex();
    const words = query.toLowerCase().split(/\s+/).filter(word => word.length > 2);
    const matchedIds = new Set<string>();

    // Search title and content indices
    for (const word of words) {
      // Search titles
      if (index.byTitle[word]) {
        index.byTitle[word].forEach(id => matchedIds.add(id));
      }

      // Search content
      if (index.byContent[word]) {
        index.byContent[word].forEach(id => matchedIds.add(id));
      }
    }

    // Get metadata for matched conversations
    const results = Array.from(matchedIds)
      .map(id => index.conversations[id])
      .filter(conv => conv !== undefined)
      .sort((a, b) => b.updated - a.updated);

    // Apply limit
    const limited = limit ? results.slice(0, limit) : results;

    return limited;
  }

  /**
   * Get conversations by vault (uses index)
   */
  async getConversationsByVault(vaultName: string): Promise<LegacyConversationMetadata[]> {
    return this.listConversations(vaultName);
  }

  /**
   * Search conversations by date range (uses index)
   */
  async searchConversationsByDateRange(startDate: number, endDate: number): Promise<LegacyConversationMetadata[]> {
    const index = await this.indexManager.loadConversationIndex();
    const matchedIds = new Set<string>();

    // Check each date range bucket
    for (const bucket of index.byDateRange) {
      // If bucket overlaps with search range, add its conversations
      if (bucket.start <= endDate && bucket.end >= startDate) {
        bucket.conversationIds.forEach(id => matchedIds.add(id));
      }
    }

    // Get metadata and filter by exact date range
    const results = Array.from(matchedIds)
      .map(id => index.conversations[id])
      .filter(conv => conv && conv.created >= startDate && conv.created <= endDate)
      .sort((a, b) => b.created - a.created);

    return results;
  }

  /**
   * Get recent conversations (uses index)
   */
  async getRecentConversations(limit: number = 10): Promise<LegacyConversationMetadata[]> {
    return this.listConversations(undefined, limit);
  }

  /**
   * Get conversation stats (uses index)
   */
  async getConversationStats(): Promise<{
    totalConversations: number;
    totalMessages: number;
    vaultCounts: Record<string, number>;
    oldestConversation?: number;
    newestConversation?: number;
  }> {
    const index = await this.indexManager.loadConversationIndex();
    const conversations = Object.values(index.conversations);

    const stats = {
      totalConversations: conversations.length,
      totalMessages: 0,
      vaultCounts: {} as Record<string, number>,
      oldestConversation: undefined as number | undefined,
      newestConversation: undefined as number | undefined
    };

    if (conversations.length === 0) {
      return stats;
    }

    let oldest = Infinity;
    let newest = 0;

    for (const conv of conversations) {
      stats.totalMessages += conv.message_count || 0;

      // Count by vault
      const vault = conv.vault_name || 'Unknown';
      stats.vaultCounts[vault] = (stats.vaultCounts[vault] || 0) + 1;

      // Track date range
      if (conv.created < oldest) oldest = conv.created;
      if (conv.created > newest) newest = conv.created;
    }

    stats.oldestConversation = oldest === Infinity ? undefined : oldest;
    stats.newestConversation = newest === 0 ? undefined : newest;

    return stats;
  }

  // ============================================================================
  // Type Conversion Helpers (New Format <-> Legacy Format)
  // ============================================================================

  /**
   * Convert new ConversationMetadata to legacy format
   */
  private convertToLegacyMetadata = (metadata: ConversationMetadata): LegacyConversationMetadata => {
    return {
      id: metadata.id,
      title: metadata.title,
      created: metadata.created,
      updated: metadata.updated,
      vault_name: metadata.vaultName,
      message_count: metadata.messageCount
    };
  };

  /**
   * Populate message.branches from unified branch storage
   *
   * With unified model, branches are separate conversations with parentConversationId
   * and parentMessageId in metadata. This method queries those and converts them
   * to the embedded ConversationBranch format for UI compatibility.
   *
   * Required for MessageBranchNavigator to show branch navigation on messages.
   * Works for both human branches and subagent branches.
   */
  private async populateMessageBranches(
    conversationId: string,
    messages: ConversationMessage[]
  ): Promise<void> {
    // Get all branch conversations for this parent
    const allBranchConversations = await this.getBranchConversations(conversationId);

    if (allBranchConversations.length === 0) {
      return;
    }

    // Group branches by parent message ID
    const branchesByMessage = new Map<string, IndividualConversation[]>();
    for (const branch of allBranchConversations) {
      const parentMessageId = branch.metadata?.parentMessageId;
      if (parentMessageId) {
        const existing = branchesByMessage.get(parentMessageId) || [];
        existing.push(branch);
        branchesByMessage.set(parentMessageId, existing);
      }
    }

    // Attach branches to their parent messages
    for (const message of messages) {
      const branchConversations = branchesByMessage.get(message.id);

      if (branchConversations && branchConversations.length > 0) {
        // Convert each branch conversation to embedded ConversationBranch format
        const branches: ConversationBranch[] = branchConversations.map(bc =>
          this.convertToConversationBranch(bc)
        );

        message.branches = branches;
        // Initialize activeAlternativeIndex if not set (0 = original message)
        if (message.activeAlternativeIndex === undefined) {
          message.activeAlternativeIndex = 0;
        }
      }
    }
  }

  /**
   * Convert a branch conversation to embedded ConversationBranch format
   * Used for UI compatibility with message.branches[]
   */
  private convertToConversationBranch(branchConversation: IndividualConversation): ConversationBranch {
    const meta = branchConversation.metadata || {};
    const branchType = meta.branchType === 'subagent' ? 'subagent' : 'human';

    // Extract subagent-specific metadata if present
    const subagentMeta = meta.subagent as SubagentBranchMetadata | undefined;

    return {
      id: branchConversation.id,
      type: branchType,
      inheritContext: meta.inheritContext ?? (branchType === 'human'),
      messages: branchConversation.messages.map(m => ({
        id: m.id,
        role: m.role,
        content: m.content,
        timestamp: m.timestamp,
        conversationId: branchConversation.id,
        state: m.state,
        toolCalls: m.toolCalls as any, // Type compatibility between storage and chat types
        reasoning: m.reasoning,
      })),
      created: branchConversation.created,
      updated: branchConversation.updated,
      metadata: branchType === 'subagent' && subagentMeta
        ? subagentMeta
        : { description: branchConversation.title } as HumanBranchMetadata,
    };
  }

  /**
   * Convert new ConversationMetadata + MessageData[] to legacy IndividualConversation
   */
  private convertToLegacyConversation(
    metadata: ConversationMetadata,
    messages: MessageData[]
  ): IndividualConversation {
    const meta = metadata.metadata || {};
    const resolvedCost = meta.cost || (meta.totalCost !== undefined ? { totalCost: meta.totalCost, currency: meta.currency || 'USD' } : undefined);
    return {
      id: metadata.id,
      title: metadata.title,
      created: metadata.created,
      updated: metadata.updated,
      vault_name: metadata.vaultName,
      message_count: metadata.messageCount,
      messages: messages.map(msg => ({
        id: msg.id,
        role: msg.role as 'user' | 'assistant' | 'tool',
        content: msg.content || '',
        timestamp: msg.timestamp,
        state: msg.state,
        toolCalls: msg.toolCalls?.map(tc => {
          // Handle both formats:
          // 1. Standard OpenAI format: { function: { name, arguments } }
          // 2. Result format from buildToolMetadata: { name, result, success, error }
          const hasFunction = tc.function && typeof tc.function === 'object';
          const name = (hasFunction ? tc.function.name : tc.name) || 'unknown_tool';
          const parameters = hasFunction && tc.function.arguments
            ? (typeof tc.function.arguments === 'string'
                ? JSON.parse(tc.function.arguments)
                : tc.function.arguments)
            : tc.parameters;
          return {
            id: tc.id,
            type: tc.type || 'function',
            name,
            function: tc.function || { name, arguments: JSON.stringify(parameters || {}) },
            parameters: parameters || {},
            result: tc.result,
            success: tc.success,
            error: tc.error
          };
        }),
        reasoning: msg.reasoning,
        metadata: msg.metadata,
        // Branching support - cast needed due to AlternativeMessage vs ConversationMessage type differences
        alternatives: msg.alternatives as unknown as import('../types/storage/StorageTypes').ConversationMessage[] | undefined,
        activeAlternativeIndex: msg.activeAlternativeIndex
      })),
      // Preserve ALL metadata from storage (parentConversationId, branchType, subagent, etc.)
      // while ensuring chatSettings structure is maintained for compatibility
      metadata: {
        ...meta,  // Spread stored metadata first (parentConversationId, branchType, subagent, etc.)
        chatSettings: {
          ...meta.chatSettings,
          workspaceId: metadata.workspaceId,
          sessionId: metadata.sessionId
        },
        cost: resolvedCost
      },
      cost: resolvedCost
    };
  }

  // ========================================
  // Branch Query Methods (Phase 1.2)
  // Branches are conversations with parentConversationId metadata
  // ========================================

  /**
   * Get all branch conversations for a parent conversation
   * @param parentConversationId - The parent conversation ID
   * @returns Array of branch conversations
   */
  async getBranchConversations(parentConversationId: string): Promise<IndividualConversation[]> {
    if (this.storageAdapter) {
      // Query for conversations with this parent (must include branches!)
      const result = await this.storageAdapter.getConversations({
        pageSize: 100,
        page: 0,
        sortBy: 'created',
        sortOrder: 'asc',
        includeBranches: true  // Required - we're specifically looking for branches
      });

      // Filter by parent metadata
      const branches: IndividualConversation[] = [];
      for (const item of result.items) {
        if (item.metadata?.parentConversationId === parentConversationId) {
          const conv = await this.getConversation(item.id);
          if (conv) branches.push(conv);
        }
      }
      return branches;
    }

    // Legacy fallback: scan all conversations
    const allConvs = await this.listConversations();
    const branches: IndividualConversation[] = [];
    for (const meta of allConvs) {
      const conv = await this.getConversation(meta.id);
      if (conv?.metadata?.parentConversationId === parentConversationId) {
        branches.push(conv);
      }
    }
    return branches;
  }

  /**
   * Get branches for a specific message in a conversation
   * @param parentConversationId - The parent conversation ID
   * @param parentMessageId - The message ID that was branched from
   * @returns Array of branch conversations for that message
   */
  async getBranchesForMessage(
    parentConversationId: string,
    parentMessageId: string
  ): Promise<IndividualConversation[]> {
    const allBranches = await this.getBranchConversations(parentConversationId);
    return allBranches.filter(b => b.metadata?.parentMessageId === parentMessageId);
  }

  /**
   * Get the parent conversation for a branch
   * @param branchConversationId - The branch conversation ID
   * @returns Parent conversation or null if not a branch
   */
  async getParentConversation(branchConversationId: string): Promise<IndividualConversation | null> {
    const branch = await this.getConversation(branchConversationId);
    if (!branch?.metadata?.parentConversationId) {
      return null;
    }
    return this.getConversation(branch.metadata.parentConversationId);
  }

  /**
   * Create a branch conversation (subagent or alternative)
   * @param parentConversationId - Parent conversation ID
   * @param parentMessageId - Message ID being branched from
   * @param branchType - Type of branch
   * @param title - Branch title
   * @param task - Optional task description for subagent branches
   * @param subagentMetadata - Optional full subagent metadata (for atomic creation)
   * @returns Created branch conversation
   */
  async createBranchConversation(
    parentConversationId: string,
    parentMessageId: string,
    branchType: 'subagent' | 'alternative',
    title: string,
    task?: string,
    subagentMetadata?: Record<string, any>
  ): Promise<IndividualConversation> {
    const branchId = `branch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const branch = await this.createConversation({
      id: branchId,
      title,
      messages: [],
      metadata: {
        parentConversationId,
        parentMessageId,
        branchType,
        subagentTask: task,
        subagent: subagentMetadata,  // Full subagent state (atomic creation)
        inheritContext: false,
      }
    });

    return branch;
  }

  /**
   * Check if a conversation is a branch
   */
  isBranch(conversation: IndividualConversation): boolean {
    return !!conversation.metadata?.parentConversationId;
  }
}

```

## services/embeddings/DESIGN.md

```markdown
# SQLite-vec Embeddings Integration Design

## Executive Summary

This document outlines a strategy for integrating vector embeddings into Nexus using:
- **`@dao-xyz/sqlite3-vec`** - Pre-built SQLite WASM with sqlite-vec (replaces sql.js)
- **Transformers.js** - Local WASM-based embedding generation
- **Note-level embeddings** - One embedding per note, no chunking
- **Trace-level embeddings** - One embedding per memory trace
- **Single database** - All data in one SQLite file with native vector search

## Key Design Decisions

### Semantic Search Flag Behavior

The `semantic: boolean` parameter is added to existing search modes (not a separate mode):

| Mode | `semantic: false` (default) | `semantic: true` |
|------|----------------------------|------------------|
| **searchContent** | Fuzzy + keyword search, returns **snippets** | Vector search, returns **ranked paths only** (no content) |
| **searchMemory** | Fuzzy/exact search, returns traces with content | Vector search, returns **ranked traces WITH content** |
| **searchDirectory** | Fuzzy path matching | âŒ Not applicable (path matching only) |

**Rationale:**
- **Notes**: Whole-note embeddings don't tell us WHERE in the note is relevant. Return paths only; LLM uses `contentManager.readContent` to get full content.
- **Traces**: No "read trace" tool exists in MemoryManager, so we must include content. Traces are small/structured, so this is acceptable.

---

## 1. Architecture

### 1.1 Single Database Approach

Replace `sql.js` with `@dao-xyz/sqlite3-vec` to get both standard SQLite features AND native vector search in one package:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   .nexus/cache.db                            â”‚
â”‚              (@dao-xyz/sqlite3-vec)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  Standard Tables (existing)     Vector Tables (new)          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ â€¢ conversations         â”‚   â”‚ â€¢ note_embeddings       â”‚  â”‚
â”‚  â”‚ â€¢ messages              â”‚   â”‚   (vec0 virtual table)  â”‚  â”‚
â”‚  â”‚ â€¢ workspaces            â”‚   â”‚                         â”‚  â”‚
â”‚  â”‚ â€¢ sessions              â”‚   â”‚ â€¢ embedding_metadata    â”‚  â”‚
â”‚  â”‚ â€¢ FTS4 search           â”‚   â”‚   (linked by rowid)     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â”‚  âœ“ JOINs work across all tables                             â”‚
â”‚  âœ“ Single file to persist/sync                              â”‚
â”‚  âœ“ Atomic transactions                                       â”‚
â”‚  âœ“ Native KNN vector search                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Why Single Database?

| Benefit | Description |
|---------|-------------|
| **JOINs** | Query embeddings + messages together in SQL |
| **Simplicity** | One file, one manager, one save cycle |
| **Atomic** | Transactions span embeddings and other data |
| **No sync issues** | Can't have embedding DB out of sync with main DB |

### 1.3 FTS5 Support

`@dao-xyz/sqlite3-vec` **supports FTS5** (wraps official `@sqlite.org/sqlite-wasm`).

**Use FTS5 for all full-text search** - better query syntax, BM25 ranking, and performance.

```typescript
import { createDatabase } from '@dao-xyz/sqlite3-vec';

const db = await createDatabase(':memory:');

db.exec(`CREATE VIRTUAL TABLE text_search USING fts5(content)`);
db.exec(`CREATE VIRTUAL TABLE vectors USING vec0(embedding float[384])`);
```

---

## 2. Package

### 2.1 Installation

```bash
npm install @dao-xyz/sqlite3-vec
```

### 2.2 Features

- SQLite + sqlite-vec **pre-compiled** into WASM
- Works in browser AND Node.js with unified API
- No custom build required
- MIT licensed
- ~5-6MB WASM bundle

### 2.3 Basic Usage (Obsidian Renderer - Current Implementation, Dec 2025)

Nexus runs sqlite3-vec in Obsidianâ€™s Electron renderer using the **WASM build** (no native Node bindings). The low-level WASM bootstrapping is encapsulated by `SQLiteCacheManager`.

```typescript
// Current approach: sqlite3-vec WASM + manual persistence (export/deserialize)
// See: src/database/storage/SQLiteCacheManager.ts
import sqlite3InitModule from '@dao-xyz/sqlite3-vec/wasm';

// sqlite3.wasm is loaded via Obsidian's vault adapter (readBinary) and passed
// to sqlite3InitModule via instantiateWasm. The DB is kept in memory and
// persisted to `.nexus/cache.db` inside the vault.
```

**Key API Notes (Current):**
- Use the sqlite3-vec **WASM** build in Obsidian (renderer-safe); do not rely on `better-sqlite3`
- Vec0 tables auto-generate `rowid` (metadata stored separately and joined by rowid)
- Bind embeddings as BLOBs (`Buffer`/`Uint8Array`) and use `vec_distance_l2()` for KNN ranking

---

## 3. Schema Design

### 3.1 New Tables for Embeddings

```sql
-- ==================== NOTE EMBEDDINGS ====================

-- Vector storage (vec0 virtual table)
-- Note: vec0 tables only store vectors + rowid, metadata goes in separate table
CREATE VIRTUAL TABLE IF NOT EXISTS note_embeddings USING vec0(
  embedding float[384]
);

-- Metadata linked to vec0 by rowid
CREATE TABLE IF NOT EXISTS embedding_metadata (
  rowid INTEGER PRIMARY KEY,  -- Matches note_embeddings rowid
  notePath TEXT NOT NULL UNIQUE,
  model TEXT NOT NULL,
  contentHash TEXT NOT NULL,
  created INTEGER NOT NULL,
  updated INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_embedding_meta_path ON embedding_metadata(notePath);
CREATE INDEX IF NOT EXISTS idx_embedding_meta_hash ON embedding_metadata(contentHash);

-- ==================== TRACE EMBEDDINGS ====================

-- Vector storage for memory traces
CREATE VIRTUAL TABLE IF NOT EXISTS trace_embeddings USING vec0(
  embedding float[384]
);

-- Metadata linked to vec0 by rowid
CREATE TABLE IF NOT EXISTS trace_embedding_metadata (
  rowid INTEGER PRIMARY KEY,  -- Matches trace_embeddings rowid
  traceId TEXT NOT NULL UNIQUE,
  workspaceId TEXT NOT NULL,
  sessionId TEXT,
  model TEXT NOT NULL,
  contentHash TEXT NOT NULL,
  created INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_trace_embed_id ON trace_embedding_metadata(traceId);
CREATE INDEX IF NOT EXISTS idx_trace_embed_workspace ON trace_embedding_metadata(workspaceId);
CREATE INDEX IF NOT EXISTS idx_trace_embed_session ON trace_embedding_metadata(sessionId);
```

### 3.2 Querying Embeddings with Metadata (Updated Dec 2025)

```sql
-- Find similar notes using vec_distance_l2 (NOT MATCH syntax)
-- Pass query embedding as Buffer parameter
SELECT
  em.notePath,
  em.model,
  vec_distance_l2(ne.embedding, ?) as distance
FROM note_embeddings ne
JOIN embedding_metadata em ON em.rowid = ne.rowid
ORDER BY distance
LIMIT 10;

-- Find notes similar to a specific note (two-step query)
-- Step 1: Get source embedding
SELECT ne.embedding FROM note_embeddings ne
JOIN embedding_metadata em ON em.rowid = ne.rowid
WHERE em.notePath = ?;

-- Step 2: Find similar notes using that embedding
SELECT
  em.notePath,
  vec_distance_l2(ne.embedding, ?) as distance
FROM note_embeddings ne
JOIN embedding_metadata em ON em.rowid = ne.rowid
WHERE em.notePath != ?
ORDER BY distance
LIMIT 10;
```

### 3.3 Hybrid Search (Vector + Keyword)

Combine semantic similarity with keyword filtering using FTS5:

```sql
-- Create FTS5 table for note content (share rowid with vec0)
CREATE VIRTUAL TABLE IF NOT EXISTS note_content_fts USING fts5(
  content,
  content=''  -- External content mode
);

-- Hybrid search: semantic similarity + keyword filter
SELECT
  em.notePath,
  ne.distance
FROM note_embeddings ne
JOIN embedding_metadata em ON em.rowid = ne.rowid
JOIN note_content_fts fts ON fts.rowid = ne.rowid
WHERE ne.embedding MATCH ?
  AND fts.content MATCH 'automation OR workflow'
ORDER BY ne.distance
LIMIT 10;
```

This enables powerful queries like "find notes semantically similar to X that also mention 'project management'".

---

## 4. Embedding Generation

### 4.1 Transformers.js with CDN Loading

Following the WebLLM pattern for Obsidian compatibility:

```typescript
// src/services/embeddings/EmbeddingEngine.ts

import type * as TransformersTypes from '@huggingface/transformers';

let transformers: typeof TransformersTypes | null = null;

async function loadTransformers(): Promise<typeof TransformersTypes> {
  if (transformers) return transformers;

  // Load from CDN (works in Electron's sandboxed renderer)
  // @ts-ignore
  const module = await import('https://esm.run/@huggingface/transformers');
  transformers = module as typeof TransformersTypes;
  return transformers;
}

export class EmbeddingEngine {
  private extractor: any = null;
  private readonly MODEL_ID = 'Xenova/all-MiniLM-L6-v2';
  private readonly DIMENSIONS = 384;

  async initialize(): Promise<void> {
    const tf = await loadTransformers();
    this.extractor = await tf.pipeline(
      'feature-extraction',
      this.MODEL_ID,
      { quantized: true }
    );
  }

  async generateEmbedding(text: string): Promise<Float32Array> {
    if (!this.extractor) await this.initialize();

    const output = await this.extractor(text, {
      pooling: 'mean',
      normalize: true
    });

    return new Float32Array(output.data);
  }

  async dispose(): Promise<void> {
    this.extractor = null;
  }
}
```

### 4.2 Model Options

| Model | Dimensions | Size | Use Case |
|-------|-----------|------|----------|
| `Xenova/all-MiniLM-L6-v2` | 384 | 23MB | **Recommended** - Good balance |
| `Xenova/bge-small-en-v1.5` | 384 | 33MB | Higher quality |
| `Xenova/gte-small` | 384 | 30MB | Good multilingual |

---

## 5. Service Implementation

### 5.1 EmbeddingService

```typescript
// src/services/embeddings/EmbeddingService.ts

export class EmbeddingService {
  constructor(
    private db: Database,  // @dao-xyz/sqlite3-vec database
    private engine: EmbeddingEngine,
    private app: App
  ) {}

  async embedNote(notePath: string): Promise<void> {
    const file = this.app.vault.getAbstractFileByPath(notePath);
    if (!file || !(file instanceof TFile)) return;

    const content = await this.app.vault.read(file);
    const contentHash = this.hashContent(content);

    // Check if already up to date
    const existing = this.db.exec(
      'SELECT rowid, contentHash FROM embedding_metadata WHERE notePath = ?',
      [notePath]
    );

    if (existing.length && existing[0].contentHash === contentHash) {
      return; // Already current
    }

    // Generate embedding
    const embedding = await this.engine.generateEmbedding(content);
    const embeddingJson = JSON.stringify(Array.from(embedding));

    // Insert or update
    if (existing.length) {
      // Update existing
      const rowid = existing[0].rowid;
      this.db.run(
        'UPDATE note_embeddings SET embedding = ? WHERE rowid = ?',
        [embeddingJson, rowid]
      );
      this.db.run(
        'UPDATE embedding_metadata SET contentHash = ?, updated = ? WHERE rowid = ?',
        [contentHash, Date.now(), rowid]
      );
    } else {
      // Insert new
      this.db.run(
        'INSERT INTO note_embeddings(embedding) VALUES (?)',
        [embeddingJson]
      );
      const rowid = this.db.exec('SELECT last_insert_rowid() as id')[0].id;
      this.db.run(
        `INSERT INTO embedding_metadata(rowid, notePath, model, contentHash, created, updated)
         VALUES (?, ?, ?, ?, ?, ?)`,
        [rowid, notePath, 'all-MiniLM-L6-v2', contentHash, Date.now(), Date.now()]
      );
    }
  }

  async findSimilarNotes(notePath: string, limit = 10): Promise<SimilarNote[]> {
    return this.db.exec(`
      SELECT em.notePath, ne.distance
      FROM embedding_metadata source
      JOIN note_embeddings ne ON ne.embedding MATCH (
        SELECT embedding FROM note_embeddings WHERE rowid = source.rowid
      )
      JOIN embedding_metadata em ON em.rowid = ne.rowid
      WHERE source.notePath = ? AND em.notePath != ?
      ORDER BY ne.distance
      LIMIT ?
    `, [notePath, notePath, limit]);
  }

  async semanticSearch(query: string, limit = 10): Promise<SimilarNote[]> {
    const queryEmbedding = await this.engine.generateEmbedding(query);
    const embeddingJson = JSON.stringify(Array.from(queryEmbedding));

    return this.db.exec(`
      SELECT em.notePath, ne.distance
      FROM note_embeddings ne
      JOIN embedding_metadata em ON em.rowid = ne.rowid
      WHERE ne.embedding MATCH ?
      ORDER BY ne.distance
      LIMIT ?
    `, [embeddingJson, limit]);
  }

  async removeEmbedding(notePath: string): Promise<void> {
    const existing = this.db.exec(
      'SELECT rowid FROM embedding_metadata WHERE notePath = ?',
      [notePath]
    );
    if (existing.length) {
      this.db.run('DELETE FROM note_embeddings WHERE rowid = ?', [existing[0].rowid]);
      this.db.run('DELETE FROM embedding_metadata WHERE rowid = ?', [existing[0].rowid]);
    }
  }

  // ==================== TRACE EMBEDDINGS ====================

  /**
   * Embed a memory trace (called on trace creation)
   * Traces are small, so this is synchronous with trace creation
   */
  async embedTrace(
    traceId: string,
    workspaceId: string,
    sessionId: string | undefined,
    content: string
  ): Promise<void> {
    const contentHash = this.hashContent(content);

    // Check if already exists
    const existing = this.db.exec(
      'SELECT rowid, contentHash FROM trace_embedding_metadata WHERE traceId = ?',
      [traceId]
    );

    if (existing.length && existing[0].contentHash === contentHash) {
      return; // Already current
    }

    // Generate embedding
    const embedding = await this.engine.generateEmbedding(content);
    const embeddingJson = JSON.stringify(Array.from(embedding));

    if (existing.length) {
      // Update existing
      const rowid = existing[0].rowid;
      this.db.run(
        'UPDATE trace_embeddings SET embedding = ? WHERE rowid = ?',
        [embeddingJson, rowid]
      );
      this.db.run(
        'UPDATE trace_embedding_metadata SET contentHash = ? WHERE rowid = ?',
        [contentHash, rowid]
      );
    } else {
      // Insert new
      this.db.run(
        'INSERT INTO trace_embeddings(embedding) VALUES (?)',
        [embeddingJson]
      );
      const rowid = this.db.exec('SELECT last_insert_rowid() as id')[0].id;
      this.db.run(
        `INSERT INTO trace_embedding_metadata(rowid, traceId, workspaceId, sessionId, model, contentHash, created)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [rowid, traceId, workspaceId, sessionId, 'all-MiniLM-L6-v2', contentHash, Date.now()]
      );
    }
  }

  /**
   * Semantic search for similar traces (returns full trace content)
   * Used by searchMemory when semantic: true
   */
  async semanticTraceSearch(
    query: string,
    workspaceId: string,
    limit = 20
  ): Promise<TraceSearchResult[]> {
    const queryEmbedding = await this.engine.generateEmbedding(query);
    const embeddingJson = JSON.stringify(Array.from(queryEmbedding));

    // Query with workspace filter
    return this.db.exec(`
      SELECT
        tem.traceId,
        tem.workspaceId,
        tem.sessionId,
        te.distance
      FROM trace_embeddings te
      JOIN trace_embedding_metadata tem ON tem.rowid = te.rowid
      WHERE te.embedding MATCH ?
        AND tem.workspaceId = ?
      ORDER BY te.distance
      LIMIT ?
    `, [embeddingJson, workspaceId, limit]);
  }

  /**
   * Remove trace embedding when trace/session/workspace deleted
   */
  async removeTraceEmbedding(traceId: string): Promise<void> {
    const existing = this.db.exec(
      'SELECT rowid FROM trace_embedding_metadata WHERE traceId = ?',
      [traceId]
    );
    if (existing.length) {
      this.db.run('DELETE FROM trace_embeddings WHERE rowid = ?', [existing[0].rowid]);
      this.db.run('DELETE FROM trace_embedding_metadata WHERE rowid = ?', [existing[0].rowid]);
    }
  }

  /**
   * Remove all trace embeddings for a workspace
   */
  async removeWorkspaceTraceEmbeddings(workspaceId: string): Promise<number> {
    const traces = this.db.exec(
      'SELECT rowid FROM trace_embedding_metadata WHERE workspaceId = ?',
      [workspaceId]
    );
    for (const trace of traces) {
      this.db.run('DELETE FROM trace_embeddings WHERE rowid = ?', [trace.rowid]);
      this.db.run('DELETE FROM trace_embedding_metadata WHERE rowid = ?', [trace.rowid]);
    }
    return traces.length;
  }

  private hashContent(content: string): string {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      hash = ((hash << 5) - hash) + content.charCodeAt(i);
      hash = hash & hash;
    }
    return hash.toString(36);
  }
}

interface TraceSearchResult {
  traceId: string;
  workspaceId: string;
  sessionId: string | null;
  distance: number;
}
```

### 5.2 EmbeddingWatcher

```typescript
// src/services/embeddings/EmbeddingWatcher.ts

export class EmbeddingWatcher {
  private debounceTimers = new Map<string, NodeJS.Timeout>();
  // 10-second debounce: prevents re-embedding on every keystroke
  // but short enough to not lose changes if vault closes unexpectedly
  private readonly DEBOUNCE_MS = 10000; // 10 seconds

  constructor(
    private embeddingService: EmbeddingService,
    private app: App
  ) {}

  start(): void {
    this.app.vault.on('modify', (file) => {
      if (file instanceof TFile && file.extension === 'md') {
        this.scheduleReembedding(file.path);
      }
    });

    this.app.vault.on('create', (file) => {
      if (file instanceof TFile && file.extension === 'md') {
        this.scheduleReembedding(file.path);
      }
    });

    this.app.vault.on('delete', (file) => {
      if (file instanceof TFile && file.extension === 'md') {
        this.embeddingService.removeEmbedding(file.path);
      }
    });

    this.app.vault.on('rename', (file, oldPath) => {
      if (file instanceof TFile && file.extension === 'md') {
        // Update path in metadata
        this.embeddingService.updatePath(oldPath, file.path);
      }
    });
  }

  private scheduleReembedding(notePath: string): void {
    const existing = this.debounceTimers.get(notePath);
    if (existing) clearTimeout(existing);

    const timer = setTimeout(async () => {
      this.debounceTimers.delete(notePath);
      await this.embeddingService.embedNote(notePath);
    }, this.DEBOUNCE_MS);

    this.debounceTimers.set(notePath, timer);
  }

  stop(): void {
    for (const timer of this.debounceTimers.values()) {
      clearTimeout(timer);
    }
    this.debounceTimers.clear();
  }
}
```

---

## 6. Implementation Path (Fresh Build - No Legacy sql.js)

### 6.1 Context: No Migration Needed

**Important:** No users are on the current sql.js implementation yet. We have the luxury of building this fresh:

```
Old JSON files (.workspaces/, .conversations/)
        â†“
    LegacyMigrator (existing)
        â†“
JSONL (.nexus/) + @dao-xyz/sqlite3-vec cache (with embeddings)
```

- **JSONL** = source of truth (syncs via Obsidian Sync)
- **SQLite cache** = rebuilt from JSONL on startup (includes embeddings)
- **Embeddings** = generated fresh from vault content

No sql.js â†’ sqlite3-vec migration code needed. Just replace sql.js entirely.

### 6.2 Implementation Steps

1. **Update package.json:**
   ```json
   {
     "dependencies": {
       "@dao-xyz/sqlite3-vec": "^x.x.x",
       "@huggingface/transformers": "^3.0.0"
     }
   }
   ```
   Remove: `"sql.js": "^1.13.0"`

2. **Replace SQLiteCacheManager:**
   - Rewrite to use `@dao-xyz/sqlite3-vec` API
   - Include embedding tables in schema from the start
   - No migration logic needed - cache rebuilds from JSONL

3. **Create EmbeddingEngine** (Transformers.js CDN loading)

4. **Create EmbeddingService** (note + trace embedding methods)

5. **Create EmbeddingWatcher** (vault change events)

6. **Create IndexingQueue** (background initial indexing with progress)

7. **Integrate with VaultLibrarian** (add `semantic` param to modes)

---

## 7. Initial Indexing & Progress Tracking

### 7.1 The Challenge

First-time users may have **thousands of notes**. We need to:
- Not freeze Obsidian
- Show progress
- Be memory-conscious
- Resume if interrupted
- Allow user to cancel

### 7.2 IndexingQueue Implementation

```typescript
// src/services/embeddings/IndexingQueue.ts

export interface IndexingProgress {
  phase: 'idle' | 'loading_model' | 'indexing' | 'complete' | 'paused' | 'error';
  totalNotes: number;
  processedNotes: number;
  currentNote: string | null;
  estimatedTimeRemaining: number | null;  // seconds
  error?: string;
}

export class IndexingQueue extends EventEmitter {
  private queue: string[] = [];
  private isRunning = false;
  private isPaused = false;
  private abortController: AbortController | null = null;

  // Tuning parameters
  private readonly BATCH_SIZE = 1;           // Process one at a time for memory
  private readonly YIELD_INTERVAL_MS = 50;   // Yield to UI between notes
  private readonly SAVE_INTERVAL = 10;       // Save DB every N notes

  private processedCount = 0;
  private totalCount = 0;
  private startTime = 0;
  private processingTimes: number[] = [];    // Rolling average for ETA

  constructor(
    private embeddingService: EmbeddingService,
    private db: Database,
    private app: App
  ) {
    super();
  }

  /**
   * Start initial indexing of all notes
   */
  async startFullIndex(): Promise<void> {
    if (this.isRunning) return;

    const allNotes = this.app.vault.getMarkdownFiles();

    // Filter to notes not already indexed (or with changed content)
    const needsIndexing = await this.filterUnindexedNotes(allNotes);

    if (needsIndexing.length === 0) {
      this.emitProgress({ phase: 'complete', totalNotes: 0, processedNotes: 0, currentNote: null, estimatedTimeRemaining: null });
      return;
    }

    this.queue = needsIndexing.map(f => f.path);
    this.totalCount = this.queue.length;
    this.processedCount = 0;
    this.startTime = Date.now();
    this.processingTimes = [];
    this.abortController = new AbortController();

    await this.processQueue();
  }

  /**
   * Filter to only notes that need (re)indexing
   */
  private async filterUnindexedNotes(notes: TFile[]): Promise<TFile[]> {
    const needsIndexing: TFile[] = [];

    for (const note of notes) {
      const content = await this.app.vault.cachedRead(note);
      const contentHash = this.hashContent(content);

      const existing = this.db.exec(
        'SELECT contentHash FROM embedding_metadata WHERE notePath = ?',
        [note.path]
      );

      // Needs indexing if: no embedding OR content changed
      if (!existing.length || existing[0].contentHash !== contentHash) {
        needsIndexing.push(note);
      }
    }

    return needsIndexing;
  }

  /**
   * Process the queue with memory-conscious batching
   */
  private async processQueue(): Promise<void> {
    this.isRunning = true;
    this.emitProgress({ phase: 'loading_model', totalNotes: this.totalCount, processedNotes: 0, currentNote: null, estimatedTimeRemaining: null });

    try {
      // Load model (one-time, ~50-100MB)
      await this.embeddingService.initialize();

      this.emitProgress({ phase: 'indexing', totalNotes: this.totalCount, processedNotes: 0, currentNote: null, estimatedTimeRemaining: null });

      while (this.queue.length > 0) {
        // Check for abort/pause
        if (this.abortController?.signal.aborted) {
          this.emitProgress({ phase: 'paused', totalNotes: this.totalCount, processedNotes: this.processedCount, currentNote: null, estimatedTimeRemaining: null });
          break;
        }

        if (this.isPaused) {
          await this.waitForResume();
          continue;
        }

        const notePath = this.queue.shift()!;
        const noteStart = Date.now();

        try {
          this.emitProgress({
            phase: 'indexing',
            totalNotes: this.totalCount,
            processedNotes: this.processedCount,
            currentNote: notePath,
            estimatedTimeRemaining: this.calculateETA()
          });

          // Process single note - memory released after each
          await this.embeddingService.embedNote(notePath);
          this.processedCount++;

          // Track timing for ETA
          const elapsed = Date.now() - noteStart;
          this.processingTimes.push(elapsed);
          if (this.processingTimes.length > 20) {
            this.processingTimes.shift(); // Keep rolling window
          }

          // Periodic DB save (embeddings are already in DB, this ensures WAL flush)
          if (this.processedCount % this.SAVE_INTERVAL === 0) {
            await this.db.save();
          }

        } catch (error) {
          console.error(`Failed to embed ${notePath}:`, error);
          // Continue with next note, don't fail entire queue
        }

        // Yield to UI - critical for responsiveness
        await new Promise(r => setTimeout(r, this.YIELD_INTERVAL_MS));
      }

      // Final save
      await this.db.save();

      this.emitProgress({
        phase: 'complete',
        totalNotes: this.totalCount,
        processedNotes: this.processedCount,
        currentNote: null,
        estimatedTimeRemaining: null
      });

    } catch (error) {
      this.emitProgress({
        phase: 'error',
        totalNotes: this.totalCount,
        processedNotes: this.processedCount,
        currentNote: null,
        estimatedTimeRemaining: null,
        error: error.message
      });
    } finally {
      this.isRunning = false;
    }
  }

  /**
   * Calculate estimated time remaining
   */
  private calculateETA(): number | null {
    if (this.processingTimes.length < 3) return null;

    const avgTime = this.processingTimes.reduce((a, b) => a + b, 0) / this.processingTimes.length;
    const remaining = this.totalCount - this.processedCount;
    return Math.round((remaining * avgTime) / 1000); // seconds
  }

  /**
   * Pause indexing (can resume later)
   */
  pause(): void {
    this.isPaused = true;
    this.emitProgress({
      phase: 'paused',
      totalNotes: this.totalCount,
      processedNotes: this.processedCount,
      currentNote: null,
      estimatedTimeRemaining: null
    });
  }

  /**
   * Resume paused indexing
   */
  resume(): void {
    this.isPaused = false;
  }

  /**
   * Cancel indexing entirely
   */
  cancel(): void {
    this.abortController?.abort();
    this.queue = [];
  }

  private async waitForResume(): Promise<void> {
    while (this.isPaused && !this.abortController?.signal.aborted) {
      await new Promise(r => setTimeout(r, 100));
    }
  }

  private emitProgress(progress: IndexingProgress): void {
    this.emit('progress', progress);
  }

  private hashContent(content: string): string {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      hash = ((hash << 5) - hash) + content.charCodeAt(i);
      hash = hash & hash;
    }
    return hash.toString(36);
  }
}
```

### 7.3 Progress UI: Status Bar Integration

Use Obsidian's status bar API for progress display with pause/resume controls.

**Note:** Status bar is NOT available on Obsidian mobile.

```typescript
// src/services/embeddings/EmbeddingStatusBar.ts

import { Plugin, Notice } from 'obsidian';

export class EmbeddingStatusBar {
  private statusBarItem: HTMLElement | null = null;
  private textEl: HTMLSpanElement | null = null;
  private controlEl: HTMLSpanElement | null = null;

  constructor(
    private plugin: Plugin,
    private indexingQueue: IndexingQueue
  ) {}

  /**
   * Initialize status bar item
   * Call in plugin onload()
   */
  init(): void {
    // Create status bar item (returns HTMLElement)
    this.statusBarItem = this.plugin.addStatusBarItem();
    this.statusBarItem.addClass('nexus-embedding-status');

    // Text display
    this.textEl = this.statusBarItem.createEl('span', {
      text: '',
      cls: 'nexus-embedding-text'
    });

    // Clickable control (pause/resume)
    this.controlEl = this.statusBarItem.createEl('span', {
      text: '',
      cls: 'nexus-embedding-control'
    });
    this.controlEl.style.cursor = 'pointer';
    this.controlEl.style.marginLeft = '4px';

    // Wire up progress events
    this.indexingQueue.on('progress', this.handleProgress.bind(this));

    // Initially hidden
    this.hide();
  }

  private handleProgress(progress: IndexingProgress): void {
    switch (progress.phase) {
      case 'loading_model':
        this.show();
        this.setText('Loading embedding model...');
        this.setControl('');
        break;

      case 'indexing':
        this.show();
        const pct = Math.round((progress.processedNotes / progress.totalNotes) * 100);
        const eta = progress.estimatedTimeRemaining
          ? `~${Math.ceil(progress.estimatedTimeRemaining / 60)}m`
          : '';
        this.setText(`Indexing: ${pct}% (${progress.processedNotes}/${progress.totalNotes}) ${eta}`);
        this.setControl('â¸', () => this.indexingQueue.pause());
        break;

      case 'paused':
        this.show();
        this.setText(`Paused: ${progress.processedNotes}/${progress.totalNotes}`);
        this.setControl('â–¶', () => this.indexingQueue.resume());
        break;

      case 'complete':
        new Notice(`Embedding complete! ${progress.processedNotes} notes indexed.`);
        this.hide();
        break;

      case 'error':
        new Notice(`Embedding error: ${progress.error}`, 5000);
        this.hide();
        break;

      case 'idle':
        this.hide();
        break;
    }
  }

  private setText(text: string): void {
    if (this.textEl) this.textEl.textContent = text;
  }

  private setControl(text: string, onClick?: () => void): void {
    if (!this.controlEl) return;
    this.controlEl.textContent = text;
    this.controlEl.onclick = onClick || null;
  }

  private show(): void {
    if (this.statusBarItem) this.statusBarItem.style.display = 'flex';
  }

  private hide(): void {
    if (this.statusBarItem) this.statusBarItem.style.display = 'none';
  }
}
```

**Usage in main plugin:**

```typescript
// In main.ts onload()
export default class NexusPlugin extends Plugin {
  private embeddingStatusBar: EmbeddingStatusBar;
  private indexingQueue: IndexingQueue;

  async onload() {
    // ... other initialization

    // Create indexing queue
    this.indexingQueue = new IndexingQueue(embeddingService, db, this.app);

    // Create status bar (desktop only)
    this.embeddingStatusBar = new EmbeddingStatusBar(this, this.indexingQueue);
    this.embeddingStatusBar.init();

    // Start background indexing after delay
    setTimeout(() => {
      this.indexingQueue.startFullIndex();
    }, 3000);
  }
}
```

**Status bar appearance:**
```
| Indexing: 45% (450/1000) ~12m â¸ |   â† Click â¸ to pause
| Paused: 450/1000 â–¶ |              â† Click â–¶ to resume
```

**Optional CSS (styles.css):**
```css
.nexus-embedding-status {
  display: flex;
  align-items: center;
  gap: 4px;
}

.nexus-embedding-control:hover {
  opacity: 0.7;
}
```

### 7.4 Memory Strategy

| Resource | Size | Strategy |
|----------|------|----------|
| Embedding model | ~50-100MB | Load once, keep in memory during indexing |
| Per-note embedding | ~1.5KB | Generate â†’ save to DB â†’ release immediately |
| Note content | Varies | Use `cachedRead()`, don't keep in memory |
| Queue | ~100 bytes/path | Keep full list (minimal memory) |

**Key principle:** Only ONE embedding in JS memory at a time. Generate â†’ SQLite â†’ GC.

### 7.5 Resumability

Indexing is **automatically resumable** because:
1. Each note's `contentHash` is stored in `embedding_metadata`
2. `filterUnindexedNotes()` checks existing hashes before queuing
3. If user closes Obsidian mid-index, next startup continues where left off

No explicit checkpoint file needed.

---

## 8. Obsidian/Electron Considerations

### 8.1 WASM Pitfalls & Electron Context

**Most browser WASM pitfalls don't apply to Obsidian (Electron):**

| Pitfall | Browser | Obsidian/Electron |
|---------|---------|-------------------|
| COOP/COEP headers | Required for SharedArrayBuffer | âŒ Not applicable - no HTTP |
| MIME types | Server must serve correctly | âŒ Local file loading |
| OPFS storage | Browser file system API | âš ï¸ Use vault adapter instead |
| Module workers | May need polyfill | âš ï¸ Use Blob URL pattern |
| Bundler config | Vite needs exclusions | âœ… Already external in esbuild |

**Key consideration: Storage location**

`@dao-xyz/sqlite3-vec` may default to OPFS or in-memory. For Obsidian, we need:
- Database in `.nexus/cache.db` (syncable with vault)
- Use Obsidian's vault adapter for persistence

```typescript
// In Nexus, SQLiteCacheManager handles vault persistence for sqlite3-vec WASM.
// See: src/database/storage/SQLiteCacheManager.ts
await sqliteCache.initialize(); // loads sqlite3.wasm + deserializes .nexus/cache.db
await sqliteCache.save();       // exports and writes .nexus/cache.db
```

**SharedArrayBuffer:** Electron typically enables this by default, but if issues arise:
```typescript
// In Electron main process (if needed)
app.commandLine.appendSwitch('enable-features', 'SharedArrayBuffer');
```

### 8.2 CDN Loading

Load Transformers.js from CDN (same pattern as WebLLM):
```typescript
const module = await import('https://esm.run/@huggingface/transformers');
```

### 8.3 Startup Sequence

```typescript
// In plugin onload()
setTimeout(async () => {
  // Don't block Obsidian startup
  const indexingQueue = new IndexingQueue(embeddingService, db, app);

  // Wire up progress UI
  indexingQueue.on('progress', updateStatusBar);

  // Start indexing (will skip already-indexed notes)
  await indexingQueue.startFullIndex();
}, 3000);
```

### 8.4 Platform Support

| Platform | Status | Notes |
|----------|--------|-------|
| macOS (Apple Silicon) | âœ… | WASM + WebGPU available |
| macOS (Intel) | âœ… | WASM works |
| Windows | âœ… | WASM works |
| Linux | âœ… | WASM works |
| Mobile (iOS/Android) | âŒ | **Disabled** - memory/battery constraints |

### 8.5 Mobile Detection & Disabling

Embeddings are **desktop-only**. Detect and skip on mobile:

```typescript
import { Platform } from 'obsidian';

export class EmbeddingService {
  private isEnabled: boolean;

  constructor(private app: App) {
    // Disable on mobile entirely
    this.isEnabled = !Platform.isMobile;
  }

  async initialize(): Promise<void> {
    if (!this.isEnabled) {
      console.log('[Embeddings] Disabled on mobile');
      return;
    }
    // ... normal initialization
  }

  async embedNote(notePath: string): Promise<void> {
    if (!this.isEnabled) return;
    // ... normal embedding
  }

  async semanticSearch(query: string): Promise<SimilarNote[]> {
    if (!this.isEnabled) return [];
    // ... normal search
  }
}
```

**In plugin initialization:**

```typescript
async onload() {
  // Skip embedding setup entirely on mobile
  if (Platform.isMobile) {
    console.log('[Nexus] Embeddings disabled on mobile');
    return;
  }

  // Desktop: initialize embeddings
  this.indexingQueue = new IndexingQueue(embeddingService, db, this.app);
  this.embeddingStatusBar = new EmbeddingStatusBar(this, this.indexingQueue);
  this.embeddingStatusBar.init();

  setTimeout(() => {
    this.indexingQueue.startFullIndex();
  }, 3000);
}
```

**Why no mobile:**
- Memory: Model requires ~50-100MB, devices are constrained
- Battery: Embedding generation is CPU-intensive
- No status bar: Can't show progress
- Sync: Desktop will generate embeddings, mobile just uses the database

---

## 9. Edge Cases & Error Handling

### 9.1 Note Content Edge Cases

| Edge Case | Behavior | Implementation |
|-----------|----------|----------------|
| **Empty notes** | Skip embedding | Check `content.trim().length === 0` before processing |
| **Very large notes** (>100KB) | Truncate to model limit | MiniLM max tokens ~512; truncate to ~2000 chars |
| **Binary/non-text** | Skip | Only process `.md` files |
| **Special characters** | Handle gracefully | Model handles Unicode; normalize whitespace |
| **Frontmatter only** | Skip or embed frontmatter | Strip YAML frontmatter, embed remaining content |
| **Embedded images/links** | Embed text portions | Strip `![[...]]` and `[[...]]` syntax, keep link text |

```typescript
function preprocessContent(content: string): string | null {
  // Strip frontmatter
  const withoutFrontmatter = content.replace(/^---[\s\S]*?---\n?/, '');

  // Strip image embeds, keep link text
  const withoutEmbeds = withoutFrontmatter
    .replace(/!\[\[.*?\]\]/g, '')           // Obsidian image embeds
    .replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, '$2')  // [[path|alias]] â†’ alias
    .replace(/\[\[([^\]]+)\]\]/g, '$1');    // [[path]] â†’ path

  // Normalize whitespace
  const normalized = withoutEmbeds.replace(/\s+/g, ' ').trim();

  // Skip if too short
  if (normalized.length < 10) return null;

  // Truncate if too long (model context limit)
  const MAX_CHARS = 2000;
  return normalized.length > MAX_CHARS
    ? normalized.slice(0, MAX_CHARS)
    : normalized;
}
```

### 9.2 File System Edge Cases

| Edge Case | Behavior | Implementation |
|-----------|----------|----------------|
| **Rename during indexing** | Handle gracefully | Use `vault.on('rename')` to update metadata |
| **Delete during indexing** | Skip missing files | Catch file-not-found errors, remove from queue |
| **Symlinks** | Follow or skip | Obsidian resolves symlinks; treat as normal files |
| **Long file paths** | Handle gracefully | SQLite supports long TEXT values |
| **Special chars in path** | Store as-is | Use parameterized queries, avoid string escaping |
| **Vault moved** | Paths remain valid | Paths are relative to vault root |

```typescript
async embedNote(notePath: string): Promise<void> {
  try {
    const file = this.app.vault.getAbstractFileByPath(notePath);
    if (!file || !(file instanceof TFile)) {
      // File was deleted or moved - remove stale embedding
      await this.removeEmbedding(notePath);
      return;
    }
    // ... continue with embedding
  } catch (error) {
    if (error.message.includes('ENOENT') || error.message.includes('not found')) {
      await this.removeEmbedding(notePath);
      return;
    }
    throw error;
  }
}
```

### 9.3 Database Edge Cases

| Edge Case | Behavior | Implementation |
|-----------|----------|----------------|
| **Corrupted database** | Rebuild from scratch | Delete `.nexus/cache.db`, re-index all notes |
| **Database locked** | Retry with backoff | Single-writer in Obsidian, shouldn't happen |
| **Disk full** | Fail gracefully, notify user | Catch write errors, pause indexing |
| **Schema mismatch** | Migrate or rebuild | Check `user_version`, run migrations |
| **Missing tables** | Create on startup | Use `CREATE TABLE IF NOT EXISTS` |
| **Orphaned embeddings** | Clean up | Periodic garbage collection |

```typescript
class EmbeddingDatabaseManager {
  private readonly SCHEMA_VERSION = 1;

  async initialize(): Promise<void> {
    // Check schema version
    const result = this.db.exec('PRAGMA user_version');
    const version = result[0]?.user_version ?? 0;

    if (version === 0) {
      // Fresh database - create tables
      await this.createTables();
      this.db.exec(`PRAGMA user_version = ${this.SCHEMA_VERSION}`);
    } else if (version < this.SCHEMA_VERSION) {
      // Run migrations
      await this.migrate(version, this.SCHEMA_VERSION);
    } else if (version > this.SCHEMA_VERSION) {
      // Database from newer version - rebuild
      console.warn('Database from newer version, rebuilding...');
      await this.rebuild();
    }
  }

  async cleanOrphanedEmbeddings(): Promise<number> {
    // Find embeddings for notes that no longer exist
    const orphans = this.db.exec(`
      SELECT em.rowid, em.notePath
      FROM embedding_metadata em
    `);

    let removed = 0;
    for (const row of orphans) {
      const exists = this.app.vault.getAbstractFileByPath(row.notePath);
      if (!exists) {
        this.db.run('DELETE FROM note_embeddings WHERE rowid = ?', [row.rowid]);
        this.db.run('DELETE FROM embedding_metadata WHERE rowid = ?', [row.rowid]);
        removed++;
      }
    }
    return removed;
  }
}
```

### 9.4 Network & Model Edge Cases

| Edge Case | Behavior | Implementation |
|-----------|----------|----------------|
| **CDN unavailable** | Retry with backoff, then fail | 3 retries, notify user |
| **Partial model download** | Transformers.js handles | Cache management built into library |
| **Model cache corrupted** | Clear and re-download | Delete HuggingFace cache dir |
| **Different model version** | Re-embed all notes | Track model version in metadata |
| **Offline after first load** | Works offline | Model cached locally |

```typescript
async loadModel(retries = 3): Promise<void> {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      await this.initialize();
      return;
    } catch (error) {
      if (attempt === retries) {
        new Notice(`Failed to load embedding model: ${error.message}`, 10000);
        throw error;
      }
      // Exponential backoff: 2s, 4s, 8s
      await new Promise(r => setTimeout(r, 2000 * Math.pow(2, attempt - 1)));
    }
  }
}

// Check model version on startup
async checkModelVersion(): Promise<boolean> {
  const stored = this.db.exec('SELECT model FROM embedding_metadata LIMIT 1');
  if (stored.length && stored[0].model !== this.MODEL_ID) {
    // Model changed - need to re-embed everything
    console.log(`Model changed from ${stored[0].model} to ${this.MODEL_ID}`);
    return false; // Trigger full re-index
  }
  return true;
}
```

### 9.5 Memory & Performance Edge Cases

| Edge Case | Behavior | Implementation |
|-----------|----------|----------------|
| **Large vault (10k+ notes)** | Batch processing | One note at a time, yield to UI |
| **Low memory** | Reduce batch size | Monitor memory if possible |
| **Very slow device** | Longer timeouts | Adaptive yield intervals |
| **User closes Obsidian mid-index** | Resume on restart | Content hash check resumes |
| **Many concurrent edits** | Debounce | 10-second debounce per file |

```typescript
// Adaptive performance based on device
class AdaptiveIndexer {
  private yieldInterval = 50; // Start conservative

  async adjustPerformance(): Promise<void> {
    // Measure time for a test embedding
    const start = performance.now();
    await this.embeddingService.generateEmbedding('test content');
    const elapsed = performance.now() - start;

    // Adjust yield interval based on embedding speed
    if (elapsed < 100) {
      this.yieldInterval = 10;  // Fast device
    } else if (elapsed < 500) {
      this.yieldInterval = 50;  // Normal device
    } else {
      this.yieldInterval = 100; // Slow device
    }
  }
}
```

### 9.6 Sync & Multi-Device Edge Cases

| Edge Case | Behavior | Implementation |
|-----------|----------|----------------|
| **Two devices open same vault** | Last write wins | No locking, accept data loss |
| **Sync conflict on cache.db** | Use latest, re-index stale | Content hash detects changes |
| **Mobile opens desktop-indexed vault** | Use existing embeddings | Read-only on mobile |
| **Desktop opens mobile-edited notes** | Re-embed changed notes | Content hash triggers update |
| **Sync deletes cache.db** | Rebuild | Normal startup behavior |

```typescript
// On startup, verify embeddings match current content
async verifyEmbeddings(): Promise<string[]> {
  const stale: string[] = [];
  const allNotes = this.app.vault.getMarkdownFiles();

  for (const note of allNotes) {
    const content = await this.app.vault.cachedRead(note);
    const currentHash = this.hashContent(content);

    const stored = this.db.exec(
      'SELECT contentHash FROM embedding_metadata WHERE notePath = ?',
      [note.path]
    );

    if (!stored.length || stored[0].contentHash !== currentHash) {
      stale.push(note.path);
    }
  }

  return stale; // Notes needing re-embedding
}
```

### 9.7 User Behavior Edge Cases

| Edge Case | Behavior | Implementation |
|-----------|----------|----------------|
| **Disable plugin mid-index** | Stop gracefully | AbortController, save progress |
| **Delete .nexus folder** | Rebuild from scratch | Normal startup creates folder/tables |
| **Change settings mid-index** | Apply after current batch | Check settings between notes |
| **Rapid enable/disable** | Debounce | Don't restart index within 5s |
| **Exclude folders from embedding** | Respect settings | Filter by path prefix |

```typescript
// Respect folder exclusions
filterExcludedNotes(notes: TFile[]): TFile[] {
  const excludedFolders = this.settings.excludeFolders || [];
  return notes.filter(note => {
    return !excludedFolders.some(folder =>
      note.path.startsWith(folder + '/')
    );
  });
}

// Graceful shutdown
async onunload(): Promise<void> {
  // Stop indexing gracefully
  this.indexingQueue?.cancel();

  // Wait for current operation to complete (max 5s)
  const timeout = Date.now() + 5000;
  while (this.indexingQueue?.isProcessing && Date.now() < timeout) {
    await new Promise(r => setTimeout(r, 100));
  }

  // Final save
  await this.db?.save();
}
```

### 9.8 Error Recovery Summary

```typescript
// Centralized error handling
class EmbeddingErrorHandler {
  async handleError(error: Error, context: string): Promise<'retry' | 'skip' | 'abort'> {
    console.error(`[Embeddings] Error in ${context}:`, error);

    // Categorize error
    if (error.message.includes('ENOENT') || error.message.includes('not found')) {
      return 'skip'; // File gone, move on
    }

    if (error.message.includes('ENOSPC') || error.message.includes('disk full')) {
      new Notice('Disk full - pausing embedding indexing', 10000);
      return 'abort';
    }

    if (error.message.includes('network') || error.message.includes('fetch')) {
      return 'retry'; // Transient network error
    }

    if (error.message.includes('memory') || error.message.includes('OOM')) {
      new Notice('Low memory - pausing embedding indexing', 10000);
      return 'abort';
    }

    // Unknown error - log and skip
    return 'skip';
  }
}
```

---

## 10. Implementation Status (Dec 16, 2025)

### Completed Components âœ…

| Component | File | Status |
|-----------|------|--------|
| **SQLiteCacheManager** | `src/database/storage/SQLiteCacheManager.ts` | âœ… sqlite3-vec WASM + vault persistence |
| **EmbeddingEngine** | `src/services/embeddings/EmbeddingEngine.ts` | âœ… Iframe sandbox (Transformers.js) |
| **EmbeddingService** | `src/services/embeddings/EmbeddingService.ts` | âœ… Note + trace embeddings |
| **EmbeddingWatcher** | `src/services/embeddings/EmbeddingWatcher.ts` | âœ… 10-second debounce |
| **IndexingQueue** | `src/services/embeddings/IndexingQueue.ts` | âœ… Background indexing with progress |
| **EmbeddingStatusBar** | `src/services/embeddings/EmbeddingStatusBar.ts` | âœ… Desktop-only progress display |
| **EmbeddingManager** | `src/services/embeddings/EmbeddingManager.ts` | âœ… High-level coordinator |
| **WASM Asset** | `sqlite3.wasm` | âœ… Bundled with plugin output |

### Pending Integration â³

| Task | Description |
|------|-------------|
| **Settings UI** | Add enable/disable toggle for embeddings |
| **Semantic trace tool** | Expose `EmbeddingService.semanticTraceSearch()` via an MCP mode (optional) |
| **Memory semantic search** | If desired, wire `searchMemory` to trace vector search (optional) |

### Key Implementation Details

1. **Renderer-safe SQLite**: sqlite3-vec WASM (`@dao-xyz/sqlite3-vec/wasm`) loaded from bundled `sqlite3.wasm`
2. **Vault persistence**: In-memory DB persisted to `.nexus/cache.db` via export/deserialize APIs
3. **Vec0 rowid quirk**: Auto-generates rowid; store metadata separately and join by rowid
4. **Buffer binding**: Bind embeddings as BLOBs (`Buffer`/`Uint8Array`)
5. **Search syntax**: Use `vec_distance_l2()` for KNN ranking (not `MATCH`)
6. **Embedding generation**: Transformers.js runs in an iframe sandbox and caches the model in IndexedDB

---

## 11. Summary

**Fresh Build Approach (No Legacy Migration):**
1. Replace `sql.js` with `@dao-xyz/sqlite3-vec` directly (no migration code)
2. Existing LegacyMigrator handles JSON â†’ JSONL conversion
3. SQLite cache (with embeddings) rebuilds from JSONL on startup
4. Use `Transformers.js` with `Xenova/all-MiniLM-L6-v2` for embeddings
5. Store vectors in `vec0` virtual tables with native KNN search
6. Watch vault changes with 10-second debounce
7. Embed traces on creation when embedding service is available (plus backfill)
8. One embedding per note (no chunking), one per trace

**Data Flow:**
```
Old JSON â†’ LegacyMigrator â†’ JSONL (source of truth)
                              â†“
                         SQLite cache (rebuilt on startup)
                              â†“
                         Embeddings (generated from vault content)
```

**Semantic Search Flag (Current):**
- `searchContent` with `semantic: true` â†’ returns ranked paths only (no content)
- `searchMemory` â†’ keyword/FTS search (semantic trace search is not exposed as a tool yet)
- `searchDirectory` â†’ no semantic option (path matching only)

**Benefits:**
- Clean implementation without legacy baggage
- Native vector search (no JS similarity calculations)
- JOINs across embeddings and existing tables
- Single database file
- Works offline, privacy-preserving
- ~50-100ms per note/trace embedding time
- Token-efficient: notes return paths only, LLM reads what it needs

---

## Sources

- [@dao-xyz/sqlite3-vec](https://www.npmjs.com/package/@dao-xyz/sqlite3-vec)
- [sqlite-vec GitHub](https://github.com/asg017/sqlite-vec)
- [sqlite-vec WASM docs](https://alexgarcia.xyz/sqlite-vec/wasm.html)
- [Transformers.js](https://huggingface.co/docs/transformers.js)
- [Xenova/all-MiniLM-L6-v2](https://huggingface.co/Xenova/all-MiniLM-L6-v2)

```

## services/embeddings/EmbeddingEngine.ts

```typescript
/**
 * Location: src/services/embeddings/EmbeddingEngine.ts
 * Purpose: Local embedding generation using iframe-sandboxed transformers.js
 *
 * Uses iframe sandbox approach to avoid Electron/Node.js environment issues.
 * The iframe loads transformers.js from CDN in a pure browser context.
 *
 * Based on Smart Connections' proven approach for Obsidian compatibility.
 */

import { EmbeddingIframe } from './EmbeddingIframe';

/**
 * Embedding engine using iframe-sandboxed Transformers.js
 *
 * Model: Xenova/all-MiniLM-L6-v2
 * - Dimensions: 384
 * - Size: ~23MB (quantized)
 * - Good balance of speed and quality for semantic search
 */
export class EmbeddingEngine {
  private iframe: EmbeddingIframe | null = null;
  private readonly MODEL_ID = 'Xenova/all-MiniLM-L6-v2';
  private readonly DIMENSIONS = 384;

  /**
   * Initialize the embedding model via iframe
   * Downloads model on first use (~23MB, cached in IndexedDB)
   */
  async initialize(): Promise<void> {
    if (this.iframe?.ready()) {
      return;
    }

    this.iframe = new EmbeddingIframe();
    await this.iframe.initialize();
  }

  /**
   * Generate embedding for text
   *
   * @param text - Text to embed (truncated to ~2000 chars in iframe)
   * @returns Float32Array of 384 dimensions
   */
  async generateEmbedding(text: string): Promise<Float32Array> {
    if (!this.iframe) {
      await this.initialize();
    }

    return this.iframe!.generateEmbedding(text);
  }

  /**
   * Generate embeddings for multiple texts (batch processing)
   *
   * @param texts - Array of texts to embed
   * @returns Array of Float32Array embeddings
   */
  async generateEmbeddings(texts: string[]): Promise<Float32Array[]> {
    if (!this.iframe) {
      await this.initialize();
    }

    return this.iframe!.generateEmbeddings(texts);
  }

  /**
   * Dispose of the engine to free memory
   */
  async dispose(): Promise<void> {
    if (this.iframe) {
      await this.iframe.dispose();
      this.iframe = null;
    }
  }

  /**
   * Check if engine is initialized
   */
  isReady(): boolean {
    return this.iframe?.ready() ?? false;
  }

  /**
   * Get model info
   */
  getModelInfo(): { id: string; dimensions: number } {
    return {
      id: this.MODEL_ID,
      dimensions: this.DIMENSIONS
    };
  }
}

```

## services/embeddings/EmbeddingIframe.ts

```typescript
/**
 * Location: src/services/embeddings/EmbeddingIframe.ts
 * Purpose: Iframe-based embedding generation using transformers.js
 *
 * This approach isolates transformers.js in a clean browser context,
 * avoiding Electron's Node.js environment pollution that causes:
 * - onnxruntime-node import errors
 * - import.meta.url undefined errors
 * - fileURLToPath scheme errors
 * - sharp module not found errors
 *
 * The iframe loads transformers.js directly from CDN in pure browser mode,
 * using IndexedDB for model caching.
 *
 * Based on Smart Connections' proven iframe sandbox approach.
 */

interface EmbeddingRequest {
  id: number;
  method: 'init' | 'embed' | 'embed_batch' | 'dispose';
  text?: string;
  texts?: string[];
}

interface EmbeddingResponse {
  id: number;
  success: boolean;
  embedding?: number[];
  embeddings?: number[][];
  error?: string;
  ready?: boolean;
}

/**
 * Iframe-based embedding engine
 *
 * Creates a sandboxed iframe that loads transformers.js from CDN,
 * completely isolated from Electron's Node.js environment.
 */
export class EmbeddingIframe {
  private iframe: HTMLIFrameElement | null = null;
  private isReady: boolean = false;
  private pendingRequests: Map<number, {
    resolve: (value: any) => void;
    reject: (error: Error) => void;
  }> = new Map();
  private requestId: number = 0;
  private initPromise: Promise<void> | null = null;
  private messageHandler: ((event: MessageEvent) => void) | null = null;

  private readonly MODEL_ID = 'Xenova/all-MiniLM-L6-v2';
  private readonly DIMENSIONS = 384;

  /**
   * Initialize the iframe and load the embedding model
   */
  async initialize(): Promise<void> {
    if (this.isReady) return;
    if (this.initPromise) return this.initPromise;

    this.initPromise = this.doInitialize();
    try {
      await this.initPromise;
    } finally {
      this.initPromise = null;
    }
  }

  private async doInitialize(): Promise<void> {
    // Create the iframe HTML that will load transformers.js
    const iframeHtml = this.createIframeHtml();

    // Create blob URL for the iframe
    const blob = new Blob([iframeHtml], { type: 'text/html' });
    const blobUrl = URL.createObjectURL(blob);

    // Create and configure iframe
    this.iframe = document.createElement('iframe');
    this.iframe.className = 'nexus-embedding-iframe-hidden';
    this.iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');

    // Set up message listener before loading iframe
    this.messageHandler = (event: MessageEvent) => {
      if (event.source !== this.iframe?.contentWindow) return;
      this.handleMessage(event.data);
    };
    window.addEventListener('message', this.messageHandler);

    // Wait for iframe to load and initialize
    await new Promise<void>((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Iframe initialization timeout (60s)'));
      }, 60000);

      // Store the resolve for when we get the ready message
      this.pendingRequests.set(-1, {
        resolve: () => {
          clearTimeout(timeout);
          resolve();
        },
        reject: (err) => {
          clearTimeout(timeout);
          reject(err);
        }
      });

      this.iframe!.src = blobUrl;
      document.body.appendChild(this.iframe!);
    });
  }

  /**
   * Create the HTML content for the iframe
   */
  private createIframeHtml(): string {
    return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script type="module">
    // Load transformers.js from CDN - pure browser mode
    import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';

    // Configure for browser mode
    env.useBrowserCache = true;
    env.allowLocalModels = false;
    env.allowRemoteModels = true;
    // Disable web workers - they fail in sandboxed iframe context
    env.backends.onnx.wasm.numThreads = 1;

    let extractor = null;
    const MODEL_ID = '${this.MODEL_ID}';

    // Initialize the model
    async function initModel() {
      extractor = await pipeline('feature-extraction', MODEL_ID, { quantized: true });
      return true;
    }

    // Generate embedding for single text
    async function embed(text) {
      if (!extractor) throw new Error('Model not initialized');
      const truncated = text.length > 2000 ? text.slice(0, 2000) : text;
      const output = await extractor(truncated, { pooling: 'mean', normalize: true });
      return Array.from(output.data);
    }

    // Generate embeddings for batch of texts
    async function embedBatch(texts) {
      const results = [];
      for (const text of texts) {
        results.push(await embed(text));
      }
      return results;
    }

    // Message handler
    window.addEventListener('message', async (event) => {
      const { id, method, text, texts } = event.data;

      try {
        let result;
        switch (method) {
          case 'init':
            await initModel();
            result = { success: true };
            break;
          case 'embed':
            result = { success: true, embedding: await embed(text) };
            break;
          case 'embed_batch':
            result = { success: true, embeddings: await embedBatch(texts) };
            break;
          case 'dispose':
            extractor = null;
            result = { success: true };
            break;
          default:
            result = { success: false, error: 'Unknown method: ' + method };
        }
        parent.postMessage({ id, ...result }, '*');
      } catch (error) {
        parent.postMessage({ id, success: false, error: error.message }, '*');
      }
    });

    // Initialize and notify parent when ready
    initModel()
      .then(() => parent.postMessage({ id: -1, ready: true, success: true }, '*'))
      .catch(err => parent.postMessage({ id: -1, ready: false, success: false, error: err.message }, '*'));
  </script>
</head>
<body></body>
</html>`;
  }

  /**
   * Handle messages from the iframe
   */
  private handleMessage(data: EmbeddingResponse): void {
    const { id, success, ready, error } = data;

    // Handle initialization ready message
    if (id === -1) {
      const pending = this.pendingRequests.get(-1);
      if (pending) {
        this.pendingRequests.delete(-1);
        if (ready && success) {
          this.isReady = true;
          pending.resolve(undefined);
        } else {
          pending.reject(new Error(error || 'Iframe initialization failed'));
        }
      }
      return;
    }

    // Handle regular request responses
    const pending = this.pendingRequests.get(id);
    if (pending) {
      this.pendingRequests.delete(id);
      if (success) {
        pending.resolve(data);
      } else {
        pending.reject(new Error(error || 'Unknown error'));
      }
    }
  }

  /**
   * Send a request to the iframe and wait for response
   */
  private async sendRequest(request: Omit<EmbeddingRequest, 'id'>): Promise<EmbeddingResponse> {
    if (!this.iframe?.contentWindow) {
      throw new Error('Iframe not initialized');
    }

    const id = ++this.requestId;

    return new Promise((resolve, reject) => {
      this.pendingRequests.set(id, { resolve, reject });
      this.iframe!.contentWindow!.postMessage({ id, ...request }, '*');

      // Timeout after 30 seconds
      setTimeout(() => {
        if (this.pendingRequests.has(id)) {
          this.pendingRequests.delete(id);
          reject(new Error('Request timeout'));
        }
      }, 30000);
    });
  }

  /**
   * Generate embedding for text
   */
  async generateEmbedding(text: string): Promise<Float32Array> {
    if (!this.isReady) {
      await this.initialize();
    }

    const response = await this.sendRequest({ method: 'embed', text });
    return new Float32Array(response.embedding!);
  }

  /**
   * Generate embeddings for multiple texts
   */
  async generateEmbeddings(texts: string[]): Promise<Float32Array[]> {
    if (!this.isReady) {
      await this.initialize();
    }

    const response = await this.sendRequest({ method: 'embed_batch', texts });
    return response.embeddings!.map(e => new Float32Array(e));
  }

  /**
   * Dispose of the iframe
   */
  async dispose(): Promise<void> {
    // Remove window message listener
    if (this.messageHandler) {
      window.removeEventListener('message', this.messageHandler);
      this.messageHandler = null;
    }

    if (this.iframe) {
      try {
        await this.sendRequest({ method: 'dispose' });
      } catch (e) {
        // Ignore errors during disposal
      }
      this.iframe.remove();
      this.iframe = null;
    }
    this.isReady = false;
    this.pendingRequests.clear();
  }

  /**
   * Check if ready
   */
  ready(): boolean {
    return this.isReady;
  }

  /**
   * Get model info
   */
  getModelInfo(): { id: string; dimensions: number } {
    return {
      id: this.MODEL_ID,
      dimensions: this.DIMENSIONS
    };
  }
}

```

## services/embeddings/EmbeddingManager.ts

```typescript
/**
 * Location: src/services/embeddings/EmbeddingManager.ts
 * Purpose: High-level manager for embedding system initialization and coordination
 *
 * Features:
 * - Desktop-only (disabled on mobile)
 * - Lazy initialization (3-second delay on startup)
 * - Coordinates EmbeddingEngine, EmbeddingService, EmbeddingWatcher, IndexingQueue, and StatusBar
 * - Graceful shutdown with cleanup
 *
 * Relationships:
 * - Called by PluginLifecycleManager for initialization
 * - Manages all embedding system components
 */

import { App, Plugin, Platform } from 'obsidian';
import { EmbeddingEngine } from './EmbeddingEngine';
import { EmbeddingService } from './EmbeddingService';
import { EmbeddingWatcher } from './EmbeddingWatcher';
import { IndexingQueue } from './IndexingQueue';
import { EmbeddingStatusBar } from './EmbeddingStatusBar';
import type { SQLiteCacheManager } from '../../database/storage/SQLiteCacheManager';

/**
 * Embedding system manager
 *
 * Desktop-only - automatically disabled on mobile platforms
 */
export class EmbeddingManager {
  private app: App;
  private plugin: Plugin;
  private db: SQLiteCacheManager;

  private engine: EmbeddingEngine | null = null;
  private service: EmbeddingService | null = null;
  private watcher: EmbeddingWatcher | null = null;
  private queue: IndexingQueue | null = null;
  private statusBar: EmbeddingStatusBar | null = null;

  private isEnabled: boolean;
  private isInitialized: boolean = false;

  constructor(
    app: App,
    plugin: Plugin,
    db: SQLiteCacheManager
  ) {
    this.app = app;
    this.plugin = plugin;
    this.db = db;

    // Disable on mobile entirely
    this.isEnabled = !Platform.isMobile;
  }

  /**
   * Initialize the embedding system
   * Should be called after a delay from plugin startup (e.g., 3 seconds)
   */
  async initialize(): Promise<void> {
    if (!this.isEnabled || this.isInitialized) {
      return;
    }

    try {
      // Create components
      this.engine = new EmbeddingEngine();
      this.service = new EmbeddingService(this.app, this.db, this.engine);
      this.watcher = new EmbeddingWatcher(this.app, this.service);
      this.queue = new IndexingQueue(this.app, this.service, this.db);
      this.statusBar = new EmbeddingStatusBar(this.plugin, this.queue);

      // Initialize status bar (desktop only)
      this.statusBar.init();

      // Start watching vault events
      this.watcher.start();

      // Start background indexing after a brief delay
      // This ensures the plugin is fully loaded before we start heavy processing
      setTimeout(async () => {
        if (this.queue) {
          // Phase 1: Index all notes
          await this.queue.startFullIndex();

          // Phase 2: Backfill existing traces (from migration)
          await this.queue.startTraceIndex();
        }
      }, 3000); // 3-second delay

      this.isInitialized = true;

    } catch (error) {
      console.error('[EmbeddingManager] Initialization failed:', error);
      // Don't throw - embeddings are optional functionality
    }
  }

  /**
   * Shutdown the embedding system
   * Called during plugin unload
   */
  async shutdown(): Promise<void> {
    if (!this.isEnabled) {
      return;
    }

    try {
      // Cancel any ongoing indexing
      if (this.queue) {
        this.queue.cancel();
      }

      // Stop watching vault events
      if (this.watcher) {
        this.watcher.stop();
      }

      // Clean up status bar
      if (this.statusBar) {
        this.statusBar.destroy();
      }

      // Dispose of embedding engine
      if (this.engine) {
        await this.engine.dispose();
      }

      this.isInitialized = false;

    } catch (error) {
      console.error('[EmbeddingManager] Shutdown failed:', error);
    }
  }

  /**
   * Get the embedding service (for external use)
   */
  getService(): EmbeddingService | null {
    return this.service;
  }

  /**
   * Get the indexing queue (for external use)
   */
  getQueue(): IndexingQueue | null {
    return this.queue;
  }

  /**
   * Check if embedding system is enabled
   */
  isEmbeddingEnabled(): boolean {
    return this.isEnabled && this.isInitialized;
  }

  /**
   * Get statistics about the embedding system
   */
  async getStats(): Promise<{
    enabled: boolean;
    initialized: boolean;
    noteCount: number;
    traceCount: number;
    indexingInProgress: boolean;
  }> {
    if (!this.isEnabled || !this.service) {
      return {
        enabled: false,
        initialized: false,
        noteCount: 0,
        traceCount: 0,
        indexingInProgress: false
      };
    }

    const stats = await this.service.getStats();

    return {
      enabled: this.isEnabled,
      initialized: this.isInitialized,
      noteCount: stats.noteCount,
      traceCount: stats.traceCount,
      indexingInProgress: this.queue?.isIndexing() ?? false
    };
  }
}

```

## services/embeddings/EmbeddingService.ts

```typescript
/**
 * Location: src/services/embeddings/EmbeddingService.ts
 * Purpose: Manage note and trace embeddings with sqlite-vec storage
 *
 * Features:
 * - Note-level embeddings (one per note, no chunking)
 * - Trace-level embeddings (one per memory trace)
 * - Content hash for change detection
 * - Content preprocessing (strip frontmatter, normalize whitespace)
 * - Desktop-only (disabled on mobile)
 *
 * Relationships:
 * - Uses EmbeddingEngine for generating embeddings
 * - Uses SQLiteCacheManager for vector storage
 * - Used by EmbeddingWatcher and IndexingQueue
 */

import { App, TFile, Notice, Platform } from 'obsidian';
import { EmbeddingEngine } from './EmbeddingEngine';
import type { SQLiteCacheManager } from '../../database/storage/SQLiteCacheManager';

export interface SimilarNote {
  notePath: string;
  distance: number;
}

export interface TraceSearchResult {
  traceId: string;
  workspaceId: string;
  sessionId: string | null;
  distance: number;
}

/**
 * Embedding service for notes and traces
 *
 * Desktop-only - check Platform.isMobile before using
 */
export class EmbeddingService {
  private app: App;
  private db: SQLiteCacheManager;
  private engine: EmbeddingEngine;
  private isEnabled: boolean;

  constructor(
    app: App,
    db: SQLiteCacheManager,
    engine: EmbeddingEngine
  ) {
    this.app = app;
    this.db = db;
    this.engine = engine;

    // Disable on mobile entirely
    this.isEnabled = !Platform.isMobile;
  }

  /**
   * Initialize the service (loads embedding model)
   */
  async initialize(): Promise<void> {
    if (!this.isEnabled) {
      return;
    }

    try {
      await this.engine.initialize();
    } catch (error) {
      console.error('[EmbeddingService] Initialization failed:', error);
      new Notice('Failed to load embedding model. Vector search will be unavailable.');
      this.isEnabled = false;
    }
  }

  // ==================== NOTE EMBEDDINGS ====================

  /**
   * Embed a single note (or update if content changed)
   *
   * @param notePath - Path to the note
   */
  async embedNote(notePath: string): Promise<void> {
    if (!this.isEnabled) return;

    try {
      const file = this.app.vault.getAbstractFileByPath(notePath);
      if (!file || !(file instanceof TFile)) {
        // File doesn't exist - remove stale embedding
        await this.removeEmbedding(notePath);
        return;
      }

      // Only process markdown files
      if (file.extension !== 'md') {
        return;
      }

      const content = await this.app.vault.read(file);
      const processedContent = this.preprocessContent(content);

      // Skip empty notes
      if (!processedContent) {
        return;
      }

      const contentHash = this.hashContent(processedContent);

      // Check if already up to date
      const existing = await this.db.queryOne<{ rowid: number; contentHash: string }>(
        'SELECT rowid, contentHash FROM embedding_metadata WHERE notePath = ?',
        [notePath]
      );

      if (existing && existing.contentHash === contentHash) {
        return; // Already current
      }

      // Generate embedding
      const embedding = await this.engine.generateEmbedding(processedContent);
      // Convert Float32Array to Buffer for SQLite BLOB binding
      const embeddingBuffer = Buffer.from(embedding.buffer);

      const now = Date.now();
      const modelInfo = this.engine.getModelInfo();

      // Insert or update
      if (existing) {
        // Update existing - vec0 tables need direct buffer, no vec_f32() function
        await this.db.run(
          'UPDATE note_embeddings SET embedding = ? WHERE rowid = ?',
          [embeddingBuffer, existing.rowid]
        );
        await this.db.run(
          'UPDATE embedding_metadata SET contentHash = ?, updated = ?, model = ? WHERE rowid = ?',
          [contentHash, now, modelInfo.id, existing.rowid]
        );
      } else {
        // Insert new - vec0 auto-generates rowid, we get it after insert
        await this.db.run(
          'INSERT INTO note_embeddings(embedding) VALUES (?)',
          [embeddingBuffer]
        );
        const result = await this.db.queryOne<{ id: number }>('SELECT last_insert_rowid() as id');
        const rowid = result?.id ?? 0;

        await this.db.run(
          `INSERT INTO embedding_metadata(rowid, notePath, model, contentHash, created, updated)
           VALUES (?, ?, ?, ?, ?, ?)`,
          [rowid, notePath, modelInfo.id, contentHash, now, now]
        );
      }
    } catch (error) {
      console.error(`[EmbeddingService] Failed to embed note ${notePath}:`, error);
      throw error;
    }
  }

  /**
   * Find notes similar to a given note
   *
   * @param notePath - Path to the reference note
   * @param limit - Maximum number of results (default: 10)
   * @returns Array of similar notes with distance scores
   */
  async findSimilarNotes(notePath: string, limit = 10): Promise<SimilarNote[]> {
    if (!this.isEnabled) return [];

    try {
      // First get the embedding for the source note
      const sourceEmbed = await this.db.queryOne<{ embedding: Buffer }>(
        `SELECT ne.embedding FROM note_embeddings ne
         JOIN embedding_metadata em ON em.rowid = ne.rowid
         WHERE em.notePath = ?`,
        [notePath]
      );

      if (!sourceEmbed) {
        return [];
      }

      // Then find similar notes using vec_distance_l2
      const results = await this.db.query<SimilarNote>(`
        SELECT
          em.notePath,
          vec_distance_l2(ne.embedding, ?) as distance
        FROM note_embeddings ne
        JOIN embedding_metadata em ON em.rowid = ne.rowid
        WHERE em.notePath != ?
        ORDER BY distance
        LIMIT ?
      `, [sourceEmbed.embedding, notePath, limit]);

      return results;
    } catch (error) {
      console.error('[EmbeddingService] Failed to find similar notes:', error);
      return [];
    }
  }

  /**
   * Semantic search for notes by query text
   * Applies heuristic re-ranking (Recency + Title Match)
   *
   * @param query - Search query
   * @param limit - Maximum number of results (default: 10)
   * @returns Array of matching notes with distance scores
   */
  async semanticSearch(query: string, limit = 10): Promise<SimilarNote[]> {
    if (!this.isEnabled) return [];

    try {
      // Generate query embedding
      const queryEmbedding = await this.engine.generateEmbedding(query);
      const queryBuffer = Buffer.from(queryEmbedding.buffer);

      // 1. FETCH CANDIDATES
      // Fetch 3x the limit to allow for re-ranking
      // We also need the 'updated' timestamp for recency scoring
      const candidateLimit = limit * 3;
      
      const candidates = await this.db.query<{ notePath: string; distance: number; updated: number }>(`
        SELECT
          em.notePath,
          em.updated,
          vec_distance_l2(ne.embedding, ?) as distance
        FROM note_embeddings ne
        JOIN embedding_metadata em ON em.rowid = ne.rowid
        ORDER BY distance
        LIMIT ?
      `, [queryBuffer, candidateLimit]);

      // 2. RE-RANKING LOGIC
      const now = Date.now();
      const oneDayMs = 1000 * 60 * 60 * 24;
      const queryLower = query.toLowerCase();
      const queryTerms = queryLower.split(/\s+/).filter(t => t.length > 2);

      const ranked = candidates.map(item => {
        let score = item.distance;

        // --- A. Recency Boost ---
        // Boost notes modified in the last 30 days
        const daysSinceUpdate = (now - item.updated) / oneDayMs;
        if (daysSinceUpdate < 30) {
          // Linear decay: 0 days = 15% boost, 30 days = 0% boost
          const recencyBoost = 0.15 * (1 - (daysSinceUpdate / 30));
          score = score * (1 - recencyBoost);
        }

        // --- B. Title/Path Boost ---
        // If query terms appear in the file path, give a significant boost
        const pathLower = item.notePath.toLowerCase();
        
        // Exact filename match (strongest)
        if (pathLower.includes(queryLower)) {
          score = score * 0.8; // 20% boost
        } 
        // Partial term match
        else if (queryTerms.some(term => pathLower.includes(term))) {
          score = score * 0.9; // 10% boost
        }

        return {
          notePath: item.notePath,
          distance: score,
          originalDistance: item.distance // Keep for debugging if needed
        };
      });

      // 3. SORT & SLICE
      ranked.sort((a, b) => a.distance - b.distance);

      return ranked.slice(0, limit);
    } catch (error) {
      console.error('[EmbeddingService] Semantic search failed:', error);
      return [];
    }
  }

  /**
   * Remove embedding for a note
   *
   * @param notePath - Path to the note
   */
  async removeEmbedding(notePath: string): Promise<void> {
    if (!this.isEnabled) return;

    try {
      const existing = await this.db.queryOne<{ rowid: number }>(
        'SELECT rowid FROM embedding_metadata WHERE notePath = ?',
        [notePath]
      );

      if (existing) {
        await this.db.run('DELETE FROM note_embeddings WHERE rowid = ?', [existing.rowid]);
        await this.db.run('DELETE FROM embedding_metadata WHERE rowid = ?', [existing.rowid]);
      }
    } catch (error) {
      console.error(`[EmbeddingService] Failed to remove embedding for ${notePath}:`, error);
    }
  }

  /**
   * Update note path (for rename operations)
   *
   * @param oldPath - Old note path
   * @param newPath - New note path
   */
  async updatePath(oldPath: string, newPath: string): Promise<void> {
    if (!this.isEnabled) return;

    try {
      await this.db.run(
        'UPDATE embedding_metadata SET notePath = ? WHERE notePath = ?',
        [newPath, oldPath]
      );
    } catch (error) {
      console.error(`[EmbeddingService] Failed to update path ${oldPath} -> ${newPath}:`, error);
    }
  }

  // ==================== TRACE EMBEDDINGS ====================

  /**
   * Embed a memory trace (called on trace creation)
   *
   * @param traceId - Unique trace ID
   * @param workspaceId - Workspace ID
   * @param sessionId - Session ID (optional)
   * @param content - Trace content to embed
   */
  async embedTrace(
    traceId: string,
    workspaceId: string,
    sessionId: string | undefined,
    content: string
  ): Promise<void> {
    if (!this.isEnabled) return;

    try {
      const processedContent = this.preprocessContent(content);
      if (!processedContent) {
        return;
      }

      const contentHash = this.hashContent(processedContent);

      // Check if already exists
      const existing = await this.db.queryOne<{ rowid: number; contentHash: string }>(
        'SELECT rowid, contentHash FROM trace_embedding_metadata WHERE traceId = ?',
        [traceId]
      );

      if (existing && existing.contentHash === contentHash) {
        return; // Already current
      }

      // Generate embedding
      const embedding = await this.engine.generateEmbedding(processedContent);
      // Convert Float32Array to Buffer for SQLite BLOB binding
      const embeddingBuffer = Buffer.from(embedding.buffer);

      const now = Date.now();
      const modelInfo = this.engine.getModelInfo();

      // Insert or update
      if (existing) {
        // Update existing - vec0 tables need direct buffer
        await this.db.run(
          'UPDATE trace_embeddings SET embedding = ? WHERE rowid = ?',
          [embeddingBuffer, existing.rowid]
        );
        await this.db.run(
          'UPDATE trace_embedding_metadata SET contentHash = ?, model = ? WHERE rowid = ?',
          [contentHash, modelInfo.id, existing.rowid]
        );
      } else {
        // Insert new - vec0 auto-generates rowid
        await this.db.run(
          'INSERT INTO trace_embeddings(embedding) VALUES (?)',
          [embeddingBuffer]
        );
        const result = await this.db.queryOne<{ id: number }>('SELECT last_insert_rowid() as id');
        const rowid = result?.id ?? 0;

        await this.db.run(
          `INSERT INTO trace_embedding_metadata(rowid, traceId, workspaceId, sessionId, model, contentHash, created)
           VALUES (?, ?, ?, ?, ?, ?, ?)`,
          [rowid, traceId, workspaceId, sessionId || null, modelInfo.id, contentHash, now]
        );
      }
    } catch (error) {
      console.error(`[EmbeddingService] Failed to embed trace ${traceId}:`, error);
    }
  }

  /**
   * Semantic search for traces by query text
   * Applies heuristic re-ranking (Recency)
   *
   * @param query - Search query
   * @param workspaceId - Filter by workspace
   * @param limit - Maximum number of results (default: 20)
   * @returns Array of matching traces with distance scores
   */
  async semanticTraceSearch(
    query: string,
    workspaceId: string,
    limit = 20
  ): Promise<TraceSearchResult[]> {
    if (!this.isEnabled) return [];

    try {
      // Generate query embedding
      const queryEmbedding = await this.engine.generateEmbedding(query);
      const queryBuffer = Buffer.from(queryEmbedding.buffer);

      // 1. FETCH CANDIDATES
      // Fetch 3x limit for re-ranking
      const candidateLimit = limit * 3;

      // Use vec_distance_l2 for KNN search with vec0 tables
      const candidates = await this.db.query<{ 
        traceId: string; 
        workspaceId: string; 
        sessionId: string | null; 
        distance: number;
        created: number;
      }>(`
        SELECT
          tem.traceId,
          tem.workspaceId,
          tem.sessionId,
          tem.created,
          vec_distance_l2(te.embedding, ?) as distance
        FROM trace_embeddings te
        JOIN trace_embedding_metadata tem ON tem.rowid = te.rowid
        WHERE tem.workspaceId = ?
        ORDER BY distance
        LIMIT ?
      `, [queryBuffer, workspaceId, candidateLimit]);

      // 2. RE-RANKING LOGIC
      const now = Date.now();
      const oneDayMs = 1000 * 60 * 60 * 24;

      const ranked = candidates.map(item => {
        let score = item.distance;

        // Recency Boost for Traces
        // Traces are memories; recent ones are often more relevant context
        const daysOld = (now - item.created) / oneDayMs;
        
        if (daysOld < 14) { // Boost last 2 weeks
           // Linear decay: 0 days = 20% boost
           const recencyBoost = 0.20 * (1 - (daysOld / 14));
           score = score * (1 - recencyBoost);
        }

        return {
          traceId: item.traceId,
          workspaceId: item.workspaceId,
          sessionId: item.sessionId,
          distance: score
        };
      });

      // 3. SORT & SLICE
      ranked.sort((a, b) => a.distance - b.distance);

      return ranked.slice(0, limit);
    } catch (error) {
      console.error('[EmbeddingService] Semantic trace search failed:', error);
      return [];
    }
  }

  /**
   * Remove trace embedding
   *
   * @param traceId - Trace ID
   */
  async removeTraceEmbedding(traceId: string): Promise<void> {
    if (!this.isEnabled) return;

    try {
      const existing = await this.db.queryOne<{ rowid: number }>(
        'SELECT rowid FROM trace_embedding_metadata WHERE traceId = ?',
        [traceId]
      );

      if (existing) {
        await this.db.run('DELETE FROM trace_embeddings WHERE rowid = ?', [existing.rowid]);
        await this.db.run('DELETE FROM trace_embedding_metadata WHERE rowid = ?', [existing.rowid]);
      }
    } catch (error) {
      console.error(`[EmbeddingService] Failed to remove trace embedding ${traceId}:`, error);
    }
  }

  /**
   * Remove all trace embeddings for a workspace
   *
   * @param workspaceId - Workspace ID
   * @returns Number of traces removed
   */
  async removeWorkspaceTraceEmbeddings(workspaceId: string): Promise<number> {
    if (!this.isEnabled) return 0;

    try {
      const traces = await this.db.query<{ rowid: number }>(
        'SELECT rowid FROM trace_embedding_metadata WHERE workspaceId = ?',
        [workspaceId]
      );

      for (const trace of traces) {
        await this.db.run('DELETE FROM trace_embeddings WHERE rowid = ?', [trace.rowid]);
        await this.db.run('DELETE FROM trace_embedding_metadata WHERE rowid = ?', [trace.rowid]);
      }

      return traces.length;
    } catch (error) {
      console.error(`[EmbeddingService] Failed to remove workspace traces ${workspaceId}:`, error);
      return 0;
    }
  }

  // ==================== UTILITIES ====================

  /**
   * Preprocess content before embedding
   * - Strips frontmatter
   * - Removes image embeds
   * - Normalizes whitespace
   * - Truncates if too long
   *
   * @param content - Raw content
   * @returns Processed content or null if empty
   */
  private preprocessContent(content: string): string | null {
    // Strip frontmatter
    let processed = content.replace(/^---[\s\S]*?---\n?/, '');

    // Strip image embeds, keep link text
    processed = processed
      .replace(/!\[\[.*?\]\]/g, '')                           // Obsidian image embeds
      .replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, '$2')          // [[path|alias]] â†’ alias
      .replace(/\[\[([^\]]+)\]\]/g, '$1');                    // [[path]] â†’ path

    // Normalize whitespace
    processed = processed.replace(/\s+/g, ' ').trim();

    // Skip if too short
    if (processed.length < 10) {
      return null;
    }

    // Truncate if too long (model context limit)
    const MAX_CHARS = 2000;
    return processed.length > MAX_CHARS
      ? processed.slice(0, MAX_CHARS)
      : processed;
  }

  /**
   * Hash content for change detection
   *
   * @param content - Content to hash
   * @returns Hash string
   */
  private hashContent(content: string): string {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      hash = ((hash << 5) - hash) + content.charCodeAt(i);
      hash = hash & hash; // Convert to 32bit integer
    }
    return hash.toString(36);
  }

  /**
   * Check if service is enabled
   */
  isServiceEnabled(): boolean {
    return this.isEnabled;
  }

  /**
   * Get embedding statistics
   */
  async getStats(): Promise<{
    noteCount: number;
    traceCount: number;
  }> {
    if (!this.isEnabled) {
      return { noteCount: 0, traceCount: 0 };
    }

    try {
      const noteResult = await this.db.queryOne<{ count: number }>(
        'SELECT COUNT(*) as count FROM embedding_metadata'
      );
      const traceResult = await this.db.queryOne<{ count: number }>(
        'SELECT COUNT(*) as count FROM trace_embedding_metadata'
      );

      return {
        noteCount: noteResult?.count ?? 0,
        traceCount: traceResult?.count ?? 0
      };
    } catch (error) {
      console.error('[EmbeddingService] Failed to get stats:', error);
      return { noteCount: 0, traceCount: 0 };
    }
  }
}

```

## services/embeddings/EmbeddingStatusBar.ts

```typescript
/**
 * Location: src/services/embeddings/EmbeddingStatusBar.ts
 * Purpose: Status bar progress display for embedding indexing (desktop only)
 *
 * Features:
 * - Shows progress percentage and ETA
 * - Pause/resume controls
 * - Desktop-only (status bar not available on mobile)
 * - Auto-hides when idle or complete
 *
 * Relationships:
 * - Listens to IndexingQueue progress events
 * - Uses Obsidian Plugin API for status bar
 */

import { Plugin, Notice, Platform, setIcon } from 'obsidian';
import { IndexingQueue, IndexingProgress } from './IndexingQueue';

/**
 * Status bar for embedding progress
 *
 * Desktop-only - status bar is not available on mobile
 */
export class EmbeddingStatusBar {
  private plugin: Plugin;
  private indexingQueue: IndexingQueue;
  private statusBarItem: HTMLElement | null = null;
  private textEl: HTMLSpanElement | null = null;
  private controlEl: HTMLSpanElement | null = null;
  private currentIconName: string | null = null;
  private isEnabled: boolean;

  constructor(
    plugin: Plugin,
    indexingQueue: IndexingQueue
  ) {
    this.plugin = plugin;
    this.indexingQueue = indexingQueue;

    // Disable on mobile (status bar not available)
    this.isEnabled = !Platform.isMobile;
  }

  /**
   * Initialize status bar item
   * Call in plugin onload()
   */
  init(): void {
    if (!this.isEnabled) {
      return;
    }

    this.currentIconName = null;

    // Create status bar item (returns HTMLElement)
    this.statusBarItem = this.plugin.addStatusBarItem();
    this.statusBarItem.addClass('nexus-embedding-status');

    // Text display
    this.textEl = this.statusBarItem.createEl('span', {
      text: '',
      cls: 'nexus-embedding-text'
    });

    // Clickable control (pause/resume)
    this.controlEl = this.statusBarItem.createEl('span', {
      text: '',
      cls: 'nexus-embedding-control'
    });
    this.controlEl.addClass('nexus-embedding-control-interactive');

    // Wire up progress events
    this.indexingQueue.on('progress', this.handleProgress.bind(this));

    // Initially hidden
    this.hide();
  }

  /**
   * Handle progress event from IndexingQueue
   */
  private handleProgress(progress: IndexingProgress): void {
    if (!this.isEnabled) {
      return;
    }

    switch (progress.phase) {
      case 'loading_model':
        this.show();
        this.setText('Loading embedding model...');
        this.setControlIcon('');
        break;

      case 'indexing':
        this.show();
        this.setText(
          `Indexing: ${progress.processedNotes}/${progress.totalNotes}`
        );
        this.setControlIcon('pause', () => this.indexingQueue.pause());
        break;

      case 'paused':
        this.show();
        this.setText(
          `Paused: ${progress.processedNotes}/${progress.totalNotes}`
        );
        this.setControlIcon('play', () => this.indexingQueue.resume());
        break;

      case 'complete':
        if (progress.processedNotes > 0) {
          new Notice(`Embedding complete! ${progress.processedNotes} notes indexed.`);
        }
        this.hide();
        break;

      case 'error':
        new Notice(`Embedding error: ${progress.error}`, 5000);
        this.hide();
        break;

      case 'idle':
        this.hide();
        break;
    }
  }

  /**
   * Set text content
   */
  private setText(text: string): void {
    if (this.textEl) {
      this.textEl.textContent = text;
    }
  }

  /**
   * Set control button with Obsidian icon
   */
  private setControlIcon(iconName: string, onClick?: () => void): void {
    if (!this.controlEl) return;

    // Optimization: Don't update if icon hasn't changed
    // This prevents DOM thrashing which can break click events
    if (this.currentIconName === iconName) {
      return;
    }
    this.currentIconName = iconName;

    // Clear existing content
    this.controlEl.empty();

    // Set icon using Obsidian's setIcon
    if (iconName) {
      setIcon(this.controlEl, iconName);
    }

    // Remove old event listener by cloning the node
    const newControlEl = this.controlEl.cloneNode(true) as HTMLSpanElement;
    this.controlEl.parentNode?.replaceChild(newControlEl, this.controlEl);
    this.controlEl = newControlEl;

    if (onClick) {
      this.plugin.registerDomEvent(this.controlEl, 'click', onClick);
    }
  }

  /**
   * Show status bar
   */
  private show(): void {
    if (this.statusBarItem) {
      this.statusBarItem.removeClass('nexus-embedding-status-hidden');
      this.statusBarItem.addClass('nexus-embedding-status-visible');
    }
  }

  /**
   * Hide status bar
   */
  private hide(): void {
    if (this.statusBarItem) {
      this.statusBarItem.removeClass('nexus-embedding-status-visible');
      this.statusBarItem.addClass('nexus-embedding-status-hidden');
    }
  }

  /**
   * Clean up (called on plugin unload)
   */
  destroy(): void {
    if (this.statusBarItem) {
      this.statusBarItem.remove();
      this.statusBarItem = null;
      this.textEl = null;
      this.controlEl = null;
      this.currentIconName = null;
    }
  }
}

```

## services/embeddings/EmbeddingWatcher.ts

```typescript
/**
 * Location: src/services/embeddings/EmbeddingWatcher.ts
 * Purpose: Watch vault file events and trigger re-embedding
 *
 * Features:
 * - Watches for create, modify, delete, rename events
 * - 10-second debounce to prevent excessive re-embedding
 * - Only processes .md files
 *
 * Relationships:
 * - Uses EmbeddingService to perform embeddings
 * - Registered with Obsidian vault events
 */

import { App, TFile } from 'obsidian';
import { EmbeddingService } from './EmbeddingService';

/**
 * Vault watcher for embedding updates
 *
 * Debounces file changes to avoid re-embedding on every keystroke.
 * 10 seconds is short enough to not lose changes on unexpected vault close,
 * but long enough to avoid excessive work during active editing.
 */
export class EmbeddingWatcher {
  private app: App;
  private embeddingService: EmbeddingService;
  private debounceTimers = new Map<string, NodeJS.Timeout>();

  // 10-second debounce: prevents re-embedding on every keystroke
  // but short enough to not lose changes if vault closes unexpectedly
  private readonly DEBOUNCE_MS = 10000; // 10 seconds

  constructor(
    app: App,
    embeddingService: EmbeddingService
  ) {
    this.app = app;
    this.embeddingService = embeddingService;
  }

  /**
   * Start watching vault events
   */
  start(): void {
    // File modified
    this.app.vault.on('modify', (file) => {
      if (file instanceof TFile && file.extension === 'md') {
        this.scheduleReembedding(file.path);
      }
    });

    // File created
    this.app.vault.on('create', (file) => {
      if (file instanceof TFile && file.extension === 'md') {
        this.scheduleReembedding(file.path);
      }
    });

    // File deleted
    this.app.vault.on('delete', (file) => {
      if (file instanceof TFile && file.extension === 'md') {
        // Cancel any pending re-embedding
        const existing = this.debounceTimers.get(file.path);
        if (existing) {
          clearTimeout(existing);
          this.debounceTimers.delete(file.path);
        }

        // Remove embedding immediately
        this.embeddingService.removeEmbedding(file.path);
      }
    });

    // File renamed
    this.app.vault.on('rename', (file, oldPath) => {
      if (file instanceof TFile && file.extension === 'md') {
        // Cancel any pending re-embedding for old path
        const existing = this.debounceTimers.get(oldPath);
        if (existing) {
          clearTimeout(existing);
          this.debounceTimers.delete(oldPath);
        }

        // Update path in metadata
        this.embeddingService.updatePath(oldPath, file.path);
      }
    });
  }

  /**
   * Stop watching vault events
   */
  stop(): void {
    // Clear all pending timers
    for (const timer of this.debounceTimers.values()) {
      clearTimeout(timer);
    }
    this.debounceTimers.clear();
  }

  /**
   * Schedule re-embedding with debounce
   *
   * @param notePath - Path to the note
   */
  private scheduleReembedding(notePath: string): void {
    // Clear existing timer if any
    const existing = this.debounceTimers.get(notePath);
    if (existing) {
      clearTimeout(existing);
    }

    // Schedule new timer
    const timer = setTimeout(async () => {
      this.debounceTimers.delete(notePath);

      try {
        await this.embeddingService.embedNote(notePath);
      } catch (error) {
        console.error(`[EmbeddingWatcher] Failed to re-embed ${notePath}:`, error);
      }
    }, this.DEBOUNCE_MS);

    this.debounceTimers.set(notePath, timer);
  }

  /**
   * Force immediate re-embedding of a note (bypasses debounce)
   *
   * @param notePath - Path to the note
   */
  async forceReembed(notePath: string): Promise<void> {
    // Cancel any pending timer
    const existing = this.debounceTimers.get(notePath);
    if (existing) {
      clearTimeout(existing);
      this.debounceTimers.delete(notePath);
    }

    // Embed immediately
    await this.embeddingService.embedNote(notePath);
  }

  /**
   * Get number of pending re-embeddings
   */
  getPendingCount(): number {
    return this.debounceTimers.size;
  }
}

```

## services/embeddings/index.ts

```typescript
/**
 * Location: src/services/embeddings/index.ts
 * Purpose: Barrel exports for embedding system
 */

export { EmbeddingEngine } from './EmbeddingEngine';
export { EmbeddingService } from './EmbeddingService';
export { EmbeddingWatcher } from './EmbeddingWatcher';
export { IndexingQueue } from './IndexingQueue';
export { EmbeddingStatusBar } from './EmbeddingStatusBar';
export { EmbeddingManager } from './EmbeddingManager';

export type { SimilarNote, TraceSearchResult } from './EmbeddingService';
export type { IndexingProgress } from './IndexingQueue';

```

## services/embeddings/IndexingQueue.ts

```typescript
/**
 * Location: src/services/embeddings/IndexingQueue.ts
 * Purpose: Background initial indexing queue with progress tracking
 *
 * Features:
 * - Processes one note at a time (memory conscious)
 * - Yields to UI between notes (50ms)
 * - Progress events with ETA calculation
 * - Pause/resume/cancel controls
 * - Resumable via content hash comparison
 * - Saves DB every 10 notes
 *
 * Relationships:
 * - Uses EmbeddingService for embedding notes
 * - Uses SQLiteCacheManager for periodic saves
 * - Emits progress events for UI updates
 */

import { App, TFile } from 'obsidian';
import { EventEmitter } from 'events';
import { EmbeddingService } from './EmbeddingService';
import type { SQLiteCacheManager } from '../../database/storage/SQLiteCacheManager';

export interface IndexingProgress {
  phase: 'idle' | 'loading_model' | 'indexing' | 'complete' | 'paused' | 'error';
  totalNotes: number;
  processedNotes: number;
  currentNote: string | null;
  estimatedTimeRemaining: number | null;  // seconds
  error?: string;
}

/**
 * Background indexing queue for notes
 *
 * Processes notes one at a time with UI yielding to keep Obsidian responsive.
 * Emits 'progress' events that can be consumed by UI components.
 */
export class IndexingQueue extends EventEmitter {
  private app: App;
  private embeddingService: EmbeddingService;
  private db: SQLiteCacheManager;

  private queue: string[] = [];
  private isRunning = false;
  private isPaused = false;
  private abortController: AbortController | null = null;

  // Tuning parameters
  private readonly BATCH_SIZE = 1;           // Process one at a time for memory
  private readonly YIELD_INTERVAL_MS = 50;   // Yield to UI between notes
  private readonly SAVE_INTERVAL = 10;       // Save DB every N notes

  private processedCount = 0;
  private totalCount = 0;
  private startTime = 0;
  private processingTimes: number[] = [];    // Rolling average for ETA

  constructor(
    app: App,
    embeddingService: EmbeddingService,
    db: SQLiteCacheManager
  ) {
    super();
    this.app = app;
    this.embeddingService = embeddingService;
    this.db = db;
  }

  /**
   * Start initial indexing of all notes
   */
  async startFullIndex(): Promise<void> {
    if (this.isRunning) {
      return;
    }

    if (!this.embeddingService.isServiceEnabled()) {
      this.emitProgress({
        phase: 'complete',
        totalNotes: 0,
        processedNotes: 0,
        currentNote: null,
        estimatedTimeRemaining: null
      });
      return;
    }

    const allNotes = this.app.vault.getMarkdownFiles();

    // Filter to notes not already indexed (or with changed content)
    const needsIndexing = await this.filterUnindexedNotes(allNotes);

    if (needsIndexing.length === 0) {
      this.emitProgress({
        phase: 'complete',
        totalNotes: 0,
        processedNotes: 0,
        currentNote: null,
        estimatedTimeRemaining: null
      });
      return;
    }

    this.queue = needsIndexing.map(f => f.path);
    this.totalCount = this.queue.length;
    this.processedCount = 0;
    this.startTime = Date.now();
    this.processingTimes = [];
    this.abortController = new AbortController();

    await this.processQueue();
  }

  /**
   * Filter to only notes that need (re)indexing
   */
  private async filterUnindexedNotes(notes: TFile[]): Promise<TFile[]> {
    const needsIndexing: TFile[] = [];

    for (const note of notes) {
      try {
        const content = await this.app.vault.cachedRead(note);
        const contentHash = this.hashContent(this.preprocessContent(content));

        const existing = await this.db.queryOne<{ contentHash: string }>(
          'SELECT contentHash FROM embedding_metadata WHERE notePath = ?',
          [note.path]
        );

        // Needs indexing if: no embedding OR content changed
        if (!existing || existing.contentHash !== contentHash) {
          needsIndexing.push(note);
        }
      } catch {
        // Include in indexing queue anyway
        needsIndexing.push(note);
      }
    }

    return needsIndexing;
  }

  /**
   * Process the queue with memory-conscious batching
   */
  private async processQueue(): Promise<void> {
    this.isRunning = true;
    this.emitProgress({
      phase: 'loading_model',
      totalNotes: this.totalCount,
      processedNotes: 0,
      currentNote: null,
      estimatedTimeRemaining: null
    });

    try {
      // Load model (one-time, ~50-100MB)
      await this.embeddingService.initialize();

      this.emitProgress({
        phase: 'indexing',
        totalNotes: this.totalCount,
        processedNotes: 0,
        currentNote: null,
        estimatedTimeRemaining: null
      });

      while (this.queue.length > 0) {
        // Check for abort/pause
        if (this.abortController?.signal.aborted) {
          this.emitProgress({
            phase: 'paused',
            totalNotes: this.totalCount,
            processedNotes: this.processedCount,
            currentNote: null,
            estimatedTimeRemaining: null
          });
          break;
        }

        if (this.isPaused) {
          await this.waitForResume();
          continue;
        }

        const notePath = this.queue.shift()!;
        const noteStart = Date.now();

        try {
          this.emitProgress({
            phase: 'indexing',
            totalNotes: this.totalCount,
            processedNotes: this.processedCount,
            currentNote: notePath,
            estimatedTimeRemaining: this.calculateETA()
          });

          // Process single note - memory released after each
          await this.embeddingService.embedNote(notePath);
          this.processedCount++;

          // Track timing for ETA
          const elapsed = Date.now() - noteStart;
          this.processingTimes.push(elapsed);
          if (this.processingTimes.length > 20) {
            this.processingTimes.shift(); // Keep rolling window
          }

          // Periodic DB save (embeddings are already in DB, this ensures WAL flush)
          if (this.processedCount % this.SAVE_INTERVAL === 0) {
            await this.db.save();
          }

        } catch (error) {
          console.error(`[IndexingQueue] Failed to embed ${notePath}:`, error);
          // Continue with next note, don't fail entire queue
        }

        // Yield to UI - critical for responsiveness
        await new Promise(r => setTimeout(r, this.YIELD_INTERVAL_MS));
      }

      // Final save
      await this.db.save();

      this.emitProgress({
        phase: 'complete',
        totalNotes: this.totalCount,
        processedNotes: this.processedCount,
        currentNote: null,
        estimatedTimeRemaining: null
      });

    } catch (error: any) {
      console.error('[IndexingQueue] Processing failed:', error);
      this.emitProgress({
        phase: 'error',
        totalNotes: this.totalCount,
        processedNotes: this.processedCount,
        currentNote: null,
        estimatedTimeRemaining: null,
        error: error.message
      });
    } finally {
      this.isRunning = false;
    }
  }

  /**
   * Calculate estimated time remaining
   */
  private calculateETA(): number | null {
    if (this.processingTimes.length < 3) return null;

    const avgTime = this.processingTimes.reduce((a, b) => a + b, 0) / this.processingTimes.length;
    const remaining = this.totalCount - this.processedCount;
    return Math.round((remaining * avgTime) / 1000); // seconds
  }

  /**
   * Pause indexing (can resume later)
   */
  pause(): void {
    if (!this.isRunning) return;

    this.isPaused = true;
    this.emitProgress({
      phase: 'paused',
      totalNotes: this.totalCount,
      processedNotes: this.processedCount,
      currentNote: null,
      estimatedTimeRemaining: null
    });
  }

  /**
   * Resume paused indexing
   */
  resume(): void {
    if (!this.isRunning || !this.isPaused) return;
    this.isPaused = false;
  }

  /**
   * Cancel indexing entirely
   */
  cancel(): void {
    if (!this.isRunning) return;
    this.abortController?.abort();
    this.queue = [];
  }

  /**
   * Wait for resume signal
   */
  private async waitForResume(): Promise<void> {
    while (this.isPaused && !this.abortController?.signal.aborted) {
      await new Promise(r => setTimeout(r, 100));
    }
  }

  /**
   * Emit progress event
   */
  private emitProgress(progress: IndexingProgress): void {
    this.emit('progress', progress);
  }

  /**
   * Preprocess content (same as EmbeddingService)
   */
  private preprocessContent(content: string): string {
    // Strip frontmatter
    let processed = content.replace(/^---[\s\S]*?---\n?/, '');

    // Strip image embeds, keep link text
    processed = processed
      .replace(/!\[\[.*?\]\]/g, '')
      .replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, '$2')
      .replace(/\[\[([^\]]+)\]\]/g, '$1');

    // Normalize whitespace
    processed = processed.replace(/\s+/g, ' ').trim();

    return processed;
  }

  /**
   * Hash content (same as EmbeddingService)
   */
  private hashContent(content: string): string {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      hash = ((hash << 5) - hash) + content.charCodeAt(i);
      hash = hash & hash;
    }
    return hash.toString(36);
  }

  /**
   * Check if indexing is currently running
   */
  isIndexing(): boolean {
    return this.isRunning;
  }

  /**
   * Check if indexing is paused
   */
  isIndexingPaused(): boolean {
    return this.isPaused;
  }

  /**
   * Get current progress
   */
  getProgress(): IndexingProgress {
    if (!this.isRunning) {
      return {
        phase: 'idle',
        totalNotes: 0,
        processedNotes: 0,
        currentNote: null,
        estimatedTimeRemaining: null
      };
    }

    return {
      phase: this.isPaused ? 'paused' : 'indexing',
      totalNotes: this.totalCount,
      processedNotes: this.processedCount,
      currentNote: this.queue.length > 0 ? this.queue[0] : null,
      estimatedTimeRemaining: this.calculateETA()
    };
  }

  // ==================== TRACE INDEXING ====================

  /**
   * Start indexing of all memory traces (backfill existing traces)
   * This is separate from note indexing and processes workspace traces
   */
  async startTraceIndex(): Promise<void> {
    if (this.isRunning) {
      return;
    }

    if (!this.embeddingService.isServiceEnabled()) {
      return;
    }

    // Query all traces from the database
    const allTraces = await this.db.query<{
      id: string;
      workspaceId: string;
      sessionId: string | null;
      content: string;
    }>('SELECT id, workspaceId, sessionId, content FROM memory_traces');

    // Filter to traces not already embedded
    const needsIndexing: typeof allTraces = [];

    for (const trace of allTraces) {
      const existing = await this.db.queryOne<{ traceId: string }>(
        'SELECT traceId FROM trace_embedding_metadata WHERE traceId = ?',
        [trace.id]
      );
      if (!existing) {
        needsIndexing.push(trace);
      }
    }

    if (needsIndexing.length === 0) {
      return;
    }

    this.isRunning = true;
    this.totalCount = needsIndexing.length;
    this.processedCount = 0;
    this.startTime = Date.now();
    this.processingTimes = [];
    this.abortController = new AbortController();

    this.emitProgress({
      phase: 'indexing',
      totalNotes: this.totalCount,
      processedNotes: 0,
      currentNote: 'traces',
      estimatedTimeRemaining: null
    });

    try {
      for (const trace of needsIndexing) {
        if (this.abortController?.signal.aborted) {
          break;
        }

        if (this.isPaused) {
          await this.waitForResume();
          continue;
        }

        try {
          await this.embeddingService.embedTrace(
            trace.id,
            trace.workspaceId,
            trace.sessionId ?? undefined,
            trace.content
          );
          this.processedCount++;

          // Periodic DB save
          if (this.processedCount % this.SAVE_INTERVAL === 0) {
            await this.db.save();
          }

        } catch (error) {
          console.error(`[IndexingQueue] Failed to embed trace ${trace.id}:`, error);
        }

        // Yield to UI
        await new Promise(r => setTimeout(r, this.YIELD_INTERVAL_MS));
      }

      // Final save
      await this.db.save();

    } catch (error: any) {
      console.error('[IndexingQueue] Trace processing failed:', error);
    } finally {
      this.isRunning = false;
      this.emitProgress({
        phase: 'complete',
        totalNotes: this.totalCount,
        processedNotes: this.processedCount,
        currentNote: null,
        estimatedTimeRemaining: null
      });
    }
  }
}

```

## services/embeddings/README.md

```markdown
# Embeddings (Semantic Search)

This folder contains Nexusâ€™s local embedding system used for semantic search and related â€œfind by meaningâ€ features.

## Runtime Behavior

- **Desktop-only**: disabled on mobile via `Platform.isMobile`
- **Local model execution**: embeddings are generated via a sandboxed iframe (`EmbeddingIframe`) that loads Transformers.js from a CDN; the model is cached locally (IndexedDB) after first download
- **Local vector storage**: embeddings are stored in `.nexus/cache.db` via `SQLiteCacheManager` (sqlite3-vec WASM + sqlite-vec `vec0`)

## Key Components

- `EmbeddingManager`: lifecycle coordinator (created by `PluginLifecycleManager`, exposed as `plugin.embeddingManager`)
- `EmbeddingService`: APIs for note + trace embeddings (`embedNote`, `semanticSearch`, `embedTrace`, â€¦)
- `IndexingQueue`: background indexing (notes) + trace backfill
- `EmbeddingWatcher`: vault event watcher (debounced re-embedding)
- `EmbeddingStatusBar`: status bar progress + pause/resume controls

## Integration Points

- `searchManager.searchContent` uses `EmbeddingService.semanticSearch()` when `semantic: true`
- `ChatTraceService` can embed newly-created traces when given an `EmbeddingService` via `setEmbeddingService()`

## Troubleshooting

- Verify `sqlite3.wasm` exists in the plugin folder (`.obsidian/plugins/nexus/sqlite3.wasm` or legacy `.obsidian/plugins/claudesidian-mcp/sqlite3.wasm`)
- Check Obsidian console logs prefixed with `[EmbeddingManager]`, `[EmbeddingEngine]`, `[IndexingQueue]`, `[SQLiteCacheManager]`


```

## services/llm/adapters/anthropic/AnthropicAdapter.ts

```typescript
/**
 * Anthropic Claude Adapter with true streaming support
 * Implements Anthropic's SSE streaming protocol
 * Based on official Anthropic streaming documentation
 */

import Anthropic from '@anthropic-ai/sdk';
import type {
  MessageStartEvent,
  ContentBlockStartEvent,
  ContentBlockDeltaEvent,
  ContentBlockStopEvent,
  MessageDeltaEvent
} from '@anthropic-ai/sdk/resources/messages';
import { BaseAdapter } from '../BaseAdapter';
import {
  GenerateOptions,
  StreamChunk,
  LLMResponse,
  ModelInfo,
  ProviderCapabilities,
  ModelPricing
} from '../types';
import { ANTHROPIC_MODELS, ANTHROPIC_DEFAULT_MODEL } from './AnthropicModels';
import { ThinkingEffortMapper } from '../../utils/ThinkingEffortMapper';
import { MCPToolExecution } from '../shared/ToolExecutionUtils';

export class AnthropicAdapter extends BaseAdapter {
  readonly name = 'anthropic';
  readonly baseUrl = 'https://api.anthropic.com';

  private client: Anthropic;

  constructor(apiKey: string, model?: string) {
    super(apiKey, model || ANTHROPIC_DEFAULT_MODEL);

    this.client = new Anthropic({
      apiKey: this.apiKey,
      baseURL: this.baseUrl,
      dangerouslyAllowBrowser: true
    });

    this.initializeCache();
  }

  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    return this.withRetry(async () => {
      try {
        // Tool execution requires streaming - use generateStreamAsync instead
        if (options?.tools && options.tools.length > 0) {
          throw new Error('Tool execution requires streaming. Use generateStreamAsync() instead.');
        }

        // Use basic message generation
        return await this.generateWithBasicMessages(prompt, options);
      } catch (error) {
        this.handleError(error, 'generation');
      }
    });
  }

  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      // Build messages - use conversation history if provided (for tool continuations)
      let messages: any[];
      if (options?.conversationHistory && options.conversationHistory.length > 0) {
        // Use provided conversation history for tool continuations
        messages = options.conversationHistory;
      } else {
        // Build simple messages for initial request
        messages = this.buildMessages(prompt, options?.systemPrompt);
      }

      const requestParams: any = {
        model: this.normalizeModelId(options?.model || this.currentModel),
        max_tokens: options?.maxTokens || 4096,
        messages: messages.filter(msg => msg.role !== 'system'),
        temperature: options?.temperature,
        stream: true
      };

      // Add system message if provided (either from messages or from options)
      const systemMessage = messages.find(msg => msg.role === 'system');
      if (systemMessage) {
        requestParams.system = systemMessage.content;
      } else if (options?.systemPrompt) {
        requestParams.system = options.systemPrompt;
      }

      // Extended thinking mode for Claude 4 models
      if (options?.enableThinking && this.supportsThinking(options?.model || this.currentModel)) {
        const effort = options?.thinkingEffort || 'medium';
        const thinkingParams = ThinkingEffortMapper.getAnthropicParams({ enabled: true, effort });
        requestParams.thinking = {
          type: 'enabled',
          budget_tokens: thinkingParams?.budget_tokens || 16000
        };
      }

      // Add tools if provided
      if (options?.tools && options.tools.length > 0) {
        requestParams.tools = this.convertTools(options.tools);
      }

      // Add web search tool if requested
      if (options?.webSearch) {
        requestParams.tools = requestParams.tools || [];
        requestParams.tools.push({
          type: 'web_search_20250305',
          name: 'web_search',
          max_uses: 5
        });
      }

      // Add beta headers if model requires them (for 1M context window)
      const modelSpec = ANTHROPIC_MODELS.find(m => m.apiName === this.normalizeModelId(options?.model || this.currentModel));
      if (modelSpec?.betaHeaders && modelSpec.betaHeaders.length > 0) {
        requestParams.betas = modelSpec.betaHeaders;
      }

      const stream = this.client.messages.stream(requestParams);

      let usage: any = undefined;
      const toolCalls: Map<number, any> = new Map();
      let thinkingBlockIndex: number | null = null;  // Track thinking block for completion

      for await (const event of stream) {
        if ('type' in event) {
          switch (event.type) {
            case 'message_start': {
              const msgStartEvent = event as MessageStartEvent;
              usage = msgStartEvent.message.usage;
              break;
            }

            case 'content_block_start': {
              const startEvent = event as ContentBlockStartEvent;
              if (startEvent.content_block?.type === 'tool_use') {
                // Initialize tool call tracking
                const index = startEvent.index;
                toolCalls.set(index, {
                  id: startEvent.content_block.id,
                  type: 'function',
                  function: {
                    name: startEvent.content_block.name,
                    arguments: ''
                  }
                });
              } else if (startEvent.content_block?.type === 'thinking') {
                // Track thinking block index for completion signaling
                thinkingBlockIndex = startEvent.index;
              }
              break;
            }

            case 'content_block_delta': {
              const deltaEvent = event as ContentBlockDeltaEvent;
              const delta = deltaEvent.delta;
              const deltaIndex = deltaEvent.index;

              if (delta.type === 'text_delta' && 'text' in delta) {
                yield {
                  content: delta.text,
                  complete: false
                };
              } else if (delta.type === 'thinking_delta' && 'thinking' in delta) {
                // Stream thinking content as reasoning (displayed in Reasoning accordion)
                yield {
                  content: '',  // Don't mix with regular content
                  reasoning: delta.thinking,
                  reasoningComplete: false,
                  complete: false
                };
              } else if (delta.type === 'input_json_delta' && 'partial_json' in delta) {
                // Accumulate tool input JSON
                const toolCall = toolCalls.get(deltaIndex);
                if (toolCall) {
                  toolCall.function.arguments += delta.partial_json;
                }
              }
              break;
            }

            case 'message_delta': {
              const msgDeltaEvent = event as MessageDeltaEvent;
              if (msgDeltaEvent.usage) {
                usage = msgDeltaEvent.usage;
              }
              break;
            }

            case 'message_stop':
              // Convert accumulated tool calls to array
              const finalToolCalls = toolCalls.size > 0 ? Array.from(toolCalls.values()) : undefined;

              yield {
                content: '',
                complete: true,
                usage: this.extractUsage({ usage }),
                toolCalls: finalToolCalls,
                toolCallsReady: finalToolCalls ? true : undefined
              };
              break;

            case 'content_block_stop': {
              // Check if this is the thinking block completing
              const stopEvent = event as ContentBlockStopEvent;
              if (thinkingBlockIndex !== null && stopEvent.index === thinkingBlockIndex) {
                yield {
                  content: '',
                  reasoning: '',  // No new content, just signaling completion
                  reasoningComplete: true,
                  complete: false
                };
                thinkingBlockIndex = null;  // Reset for potential next thinking block
              }
              // Tool call blocks already tracked in our map
              break;
            }

            default: {
              // Handle ping, error, and other events not covered by the switch
              // Use type assertion since TypeScript sees this as 'never' after exhaustive switch
              const unknownEvent = event as { type: string; error?: { message: string } };
              if (unknownEvent.type === 'ping') {
                // Ignore ping events
              } else if (unknownEvent.type === 'error' && unknownEvent.error) {
                console.error('[AnthropicAdapter] Stream error:', unknownEvent.error);
                throw new Error(`Anthropic stream error: ${unknownEvent.error.message}`);
              }
              break;
            }
          }
        }
      }
    } catch (error) {
      console.error('[AnthropicAdapter] Streaming error:', error);
      throw error;
    }
  }

  async listModels(): Promise<ModelInfo[]> {
    try {
      return ANTHROPIC_MODELS.map(model => ({
        // For 1M context models, append :1m to make ID unique
        id: model.contextWindow >= 1000000 ? `${model.apiName}:1m` : model.apiName,
        name: model.name,
        contextWindow: model.contextWindow,
        maxOutputTokens: model.maxTokens,
        supportsJSON: model.capabilities.supportsJSON,
        supportsImages: model.capabilities.supportsImages,
        supportsFunctions: model.capabilities.supportsFunctions,
        supportsStreaming: model.capabilities.supportsStreaming,
        supportsThinking: model.capabilities.supportsThinking,
        costPer1kTokens: {
          input: model.inputCostPerMillion / 1000,
          output: model.outputCostPerMillion / 1000
        },
        pricing: {
          inputPerMillion: model.inputCostPerMillion,
          outputPerMillion: model.outputCostPerMillion,
          currency: 'USD',
          lastUpdated: new Date().toISOString()
        }
      }));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }

  getCapabilities(): ProviderCapabilities {
    return {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsThinking: true,
      maxContextWindow: 200000,
      supportedFeatures: [
        'messages',
        'extended_thinking',
        'function_calling',
        'web_search',
        'computer_use',
        'vision',
        'streaming'
      ]
    };
  }

  /**
   * Generate using basic message API without tools
   */
  private async generateWithBasicMessages(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    const messages = this.buildMessages(prompt, options?.systemPrompt);
    
    const requestParams: any = {
      model: options?.model || this.currentModel,
      max_tokens: options?.maxTokens || 4096,
      messages: messages.filter(msg => msg.role !== 'system'),
      temperature: options?.temperature,
      stop_sequences: options?.stopSequences
    };

    // Add system message if provided
    const systemMessage = messages.find(msg => msg.role === 'system');
    if (systemMessage) {
      requestParams.system = systemMessage.content;
    }

    // Extended thinking mode for Claude 4 models
    if (options?.enableThinking && this.supportsThinking(options?.model || this.currentModel)) {
      const effort = options?.thinkingEffort || 'medium';
      const thinkingParams = ThinkingEffortMapper.getAnthropicParams({ enabled: true, effort });
      requestParams.thinking = {
        type: 'enabled',
        budget_tokens: thinkingParams?.budget_tokens || 16000
      };
    }

    // Add tools if provided
    if (options?.tools && options.tools.length > 0) {
      requestParams.tools = this.convertTools(options.tools);
    }

    // Special tools
    if (options?.webSearch) {
      requestParams.tools = requestParams.tools || [];
      requestParams.tools.push({
        type: 'web_search_20250305',
        name: 'web_search',
        max_uses: 5
      });
    }

    // Add beta headers if model requires them (for 1M context window)
    const modelSpec = ANTHROPIC_MODELS.find(m => m.apiName === this.normalizeModelId(options?.model || this.currentModel));
    if (modelSpec?.betaHeaders && modelSpec.betaHeaders.length > 0) {
      requestParams.betas = modelSpec.betaHeaders;
    }

    const response = await this.client.messages.create(requestParams);
    
    const extractedUsage = this.extractUsage(response);
    const finishReason = this.mapStopReason(response.stop_reason);
    const toolCalls = this.extractToolCalls(response.content);
    const metadata = {
      thinking: this.extractThinking(response),
      stopSequence: response.stop_sequence
    };

    return await this.buildLLMResponse(
      this.extractTextFromContent(response.content),
      response.model,
      extractedUsage,
      metadata,
      finishReason,
      toolCalls
    );
  }

  // Private methods

  /**
   * Normalize model ID by removing :1m suffix to match against apiName
   * The :1m suffix is used to distinguish the 1M context variant in the UI,
   * but both variants use the same API name with different beta headers
   */
  private normalizeModelId(modelId: string): string {
    return modelId.replace(':1m', '');
  }

  private supportsThinking(modelId: string): boolean {
    const model = ANTHROPIC_MODELS.find(m => m.apiName === this.normalizeModelId(modelId));
    return model?.capabilities.supportsThinking || false;
  }

  private convertTools(tools: any[]): any[] {
    return tools.map(tool => {
      if (tool.type === 'function') {
        // Handle both nested (Chat Completions) and flat (Responses API) formats
        const toolDef = tool.function || tool;
        return {
          name: toolDef.name,
          description: toolDef.description,
          input_schema: toolDef.parameters || toolDef.input_schema
        };
      }
      return tool;
    });
  }

  private extractTextFromContent(content: any[]): string {
    return content
      .filter(block => block.type === 'text')
      .map(block => block.text)
      .join('');
  }

  private extractToolCalls(content: any[]): any[] {
    return content
      .filter(block => block.type === 'tool_use')
      .map(block => ({
        id: block.id,
        type: 'function',
        function: {
          name: block.name,
          arguments: JSON.stringify(block.input)
        }
      }));
  }

  private extractThinking(response: any): string | undefined {
    // Extract thinking process from response if available
    const thinkingBlocks = response.content?.filter((block: any) => block.type === 'thinking') || [];
    if (thinkingBlocks.length > 0) {
      return thinkingBlocks.map((block: any) => block.thinking).join('\n');
    }
    return undefined;
  }

  private mapStopReason(reason: string | null): 'stop' | 'length' | 'tool_calls' | 'content_filter' {
    if (!reason) return 'stop';
    
    const reasonMap: Record<string, 'stop' | 'length' | 'tool_calls' | 'content_filter'> = {
      'end_turn': 'stop',
      'max_tokens': 'length',
      'tool_use': 'tool_calls',
      'stop_sequence': 'stop'
    };
    return reasonMap[reason] || 'stop';
  }

  protected extractUsage(response: any): any {
    if (response.usage) {
      return {
        promptTokens: response.usage.input_tokens || 0,
        completionTokens: response.usage.output_tokens || 0,
        totalTokens: (response.usage.input_tokens || 0) + (response.usage.output_tokens || 0)
      };
    }
    return undefined;
  }

  private getCostPer1kTokens(modelId: string): { input: number; output: number } | undefined {
    const model = ANTHROPIC_MODELS.find(m => m.apiName === this.normalizeModelId(modelId));
    if (!model) return undefined;

    return {
      input: model.inputCostPerMillion / 1000,
      output: model.outputCostPerMillion / 1000
    };
  }

  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    const costs = this.getCostPer1kTokens(modelId);
    if (!costs) return null;
    
    return {
      rateInputPerMillion: costs.input * 1000,
      rateOutputPerMillion: costs.output * 1000,
      currency: 'USD'
    };
  }
}
```

## services/llm/adapters/anthropic/AnthropicModels.ts

```typescript
/**
 * Anthropic Model Specifications
 * Updated June 17, 2025 with latest Claude releases
 */

import { ModelSpec } from '../modelTypes';

export const ANTHROPIC_MODELS: ModelSpec[] = [
  // Claude models
  {
    provider: 'anthropic',
    name: 'Claude 4.5 Haiku',
    apiName: 'claude-haiku-4-5-20251001',
    contextWindow: 200000,
    maxTokens: 64000,
    inputCostPerMillion: 1.00,
    outputCostPerMillion: 5.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },

  // Claude 4.5 Opus
  {
    provider: 'anthropic',
    name: 'Claude 4.5 Opus',
    apiName: 'claude-opus-4-5-20251101',
    contextWindow: 200000,
    maxTokens: 32000,
    inputCostPerMillion: 5.00,
    outputCostPerMillion: 25.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },

  // Claude 4 models - All Claude 4+ models support extended thinking per Anthropic docs
  {
    provider: 'anthropic',
    name: 'Claude 4 Opus',
    apiName: 'claude-opus-4-0',
    contextWindow: 200000,
    maxTokens: 32000,
    inputCostPerMillion: 15.00,
    outputCostPerMillion: 75.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'anthropic',
    name: 'Claude 4 Sonnet',
    apiName: 'claude-sonnet-4-0',
    contextWindow: 200000,
    maxTokens: 64000,
    inputCostPerMillion: 3.00,
    outputCostPerMillion: 15.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'anthropic',
    name: 'Claude 4.5 Sonnet',
    apiName: 'claude-sonnet-4-5-20250929',
    contextWindow: 200000,
    maxTokens: 64000,
    inputCostPerMillion: 3.00,
    outputCostPerMillion: 15.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'anthropic',
    name: 'Claude 4.5 Sonnet (1M)',
    apiName: 'claude-sonnet-4-5-20250929',
    contextWindow: 1000000,
    maxTokens: 64000,
    inputCostPerMillion: 3.00,
    outputCostPerMillion: 15.00,
    betaHeaders: ['context-1m-2025-08-07'],
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  }
];

export const ANTHROPIC_DEFAULT_MODEL = 'claude-haiku-4-5-20251001';
```

## services/llm/adapters/BaseAdapter.ts

```typescript
/**
 * Base LLM Adapter
 * Abstract class that all provider adapters extend
 * Based on patterns from services/llm/BaseLLMProvider.ts
 *
 * MOBILE COMPATIBILITY (Dec 2025):
 * - Removed Node.js crypto import
 * - Uses simple djb2 hash for cache keys (not cryptographic, but sufficient)
 */

import {
  GenerateOptions,
  StreamChunk,
  LLMResponse,
  ModelInfo,
  LLMProviderError,
  ProviderConfig,
  ProviderCapabilities,
  TokenUsage,
  CostDetails,
  ModelPricing
} from './types';
import { BaseCache, CacheManager } from '../utils/CacheManager';
import { LLMCostCalculator } from '../utils/LLMCostCalculator';
import { TokenUsageExtractor } from '../utils/TokenUsageExtractor';
import { SchemaValidator } from '../utils/SchemaValidator';
import { SSEStreamProcessor } from '../streaming/SSEStreamProcessor';
import { StreamChunkProcessor } from '../streaming/StreamChunkProcessor';

// Browser-compatible hash function (djb2 algorithm)
// Not cryptographically secure but sufficient for cache keys
function generateHash(input: string): string {
  let hash = 5381;
  for (let i = 0; i < input.length; i++) {
    hash = ((hash << 5) + hash) + input.charCodeAt(i);
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash).toString(16);
}

export abstract class BaseAdapter {
  abstract readonly name: string;
  abstract readonly baseUrl: string;
  
  protected apiKey: string;
  protected currentModel: string;
  protected config: ProviderConfig;
  protected cache!: BaseCache<LLMResponse>;

  constructor(apiKey: string, defaultModel: string, baseUrl?: string, requiresApiKey: boolean = true) {
    this.apiKey = apiKey || '';
    this.currentModel = defaultModel;

    this.config = {
      apiKey: this.apiKey,
      baseUrl: baseUrl || ''
    };
  }

  protected initializeCache(cacheConfig?: any): void {
    const cacheName = `${this.name}-responses`;
    // getLRUCache creates a new cache if it doesn't exist
    this.cache = CacheManager.getLRUCache<LLMResponse>(cacheName, {
      maxSize: cacheConfig?.maxSize || 1000,
      defaultTTL: cacheConfig?.defaultTTL || 3600000, // 1 hour
      ...cacheConfig
    });
  }

  // Abstract methods that each provider must implement
  abstract generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse>;
  abstract generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown>;
  abstract listModels(): Promise<ModelInfo[]>;
  abstract getCapabilities(): ProviderCapabilities;
  abstract getModelPricing(modelId: string): Promise<ModelPricing | null>;

  /**
   * Centralized SSE streaming processor using eventsource-parser
   * Delegates to SSEStreamProcessor for actual processing
   */
  protected async* processSSEStream(
    response: Response,
    options: {
      extractContent: (parsed: any) => string | null;
      extractToolCalls: (parsed: any) => any[] | null;
      extractFinishReason: (parsed: any) => string | null;
      extractUsage?: (parsed: any) => any;
      onParseError?: (error: Error, rawData: string) => void;
      debugLabel?: string;
      // Tool call accumulation settings
      accumulateToolCalls?: boolean;
      toolCallThrottling?: {
        initialYield: boolean;
        progressInterval: number; // Yield every N characters of arguments
      };
    }
  ): AsyncGenerator<StreamChunk, void, unknown> {
    yield* SSEStreamProcessor.processSSEStream(response, options);
  }

  /**
   * Process streaming responses with automatic tool call accumulation
   * Supports both SDK streams (OpenAI, Groq, Mistral) and SSE streams (Requesty, Perplexity, OpenRouter)
   *
   * This unified method handles:
   * - Text content streaming
   * - Tool call accumulation (incremental delta.tool_calls)
   * - Usage/metadata extraction
   * - Finish reason detection
   *
   * Used by: OpenAI, Groq, Mistral, Requesty, Perplexity, OpenRouter
   */
  protected async* processStream(
    stream: AsyncIterable<any> | Response,
    options: {
      extractContent: (chunk: any) => string | null;
      extractToolCalls: (chunk: any) => any[] | null;
      extractFinishReason: (chunk: any) => string | null;
      extractUsage?: (chunk: any) => any;
      // Reasoning/thinking extraction for models that support it
      extractReasoning?: (parsed: any) => { text: string; complete: boolean } | null;
      debugLabel?: string;
    }
  ): AsyncGenerator<StreamChunk, void, unknown> {
    const debugLabel = options.debugLabel || 'Stream';

    // Determine if this is SDK stream or SSE Response
    const isSdkStream = Symbol.iterator in Object(stream) || Symbol.asyncIterator in Object(stream);

    if (isSdkStream) {
      // Process SDK stream (OpenAI SDK, Groq, Mistral)
      const toolCallsAccumulator: Map<number, any> = new Map();
      let usage: any = undefined;

      for await (const chunk of stream as AsyncIterable<any>) {
        yield* this.processStreamChunk(chunk, options, toolCallsAccumulator, usage);

        // Update usage reference if extracted
        if (options.extractUsage) {
          const extractedUsage = options.extractUsage(chunk);
          if (extractedUsage) {
            usage = extractedUsage;
          }
        }
      }

      // Yield final completion with accumulated tool calls
      const finalToolCalls = toolCallsAccumulator.size > 0
        ? Array.from(toolCallsAccumulator.values())
        : undefined;

      const finalUsage = usage ? {
        promptTokens: usage.prompt_tokens || usage.promptTokens || 0,
        completionTokens: usage.completion_tokens || usage.completionTokens || 0,
        totalTokens: usage.total_tokens || usage.totalTokens || 0
      } : undefined;

      yield {
        content: '',
        complete: true,
        usage: finalUsage,
        toolCalls: finalToolCalls,
        toolCallsReady: finalToolCalls && finalToolCalls.length > 0 ? true : undefined
      };
    } else {
      // Process SSE stream (Requesty, Perplexity, OpenRouter via Response object)
      yield* this.processSSEStream(stream as Response, {
        ...options,
        accumulateToolCalls: true,
        toolCallThrottling: {
          initialYield: true,
          progressInterval: 50
        }
      });
    }
  }

  /**
   * Process individual stream chunk with tool call accumulation
   * Delegates to StreamChunkProcessor for actual processing
   */
  private* processStreamChunk(
    chunk: any,
    options: {
      extractContent: (chunk: any) => string | null;
      extractToolCalls: (chunk: any) => any[] | null;
      extractFinishReason: (chunk: any) => string | null;
      extractUsage?: (chunk: any) => any;
    },
    toolCallsAccumulator: Map<number, any>,
    usageRef: any
  ): Generator<StreamChunk, void, unknown> {
    yield* StreamChunkProcessor.processStreamChunk(chunk, options, toolCallsAccumulator, usageRef);
  }

  // Cached generate method
  async generate(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    // Skip cache if explicitly disabled or for streaming
    if (options?.disableCache) {
      return this.generateUncached(prompt, options);
    }

    const cacheKey = this.generateCacheKey(prompt, options);
    
    // Try cache first
    const cached = await this.cache.get(cacheKey);
    if (cached) {
      return {
        ...cached,
        metadata: {
          ...cached.metadata,
          cached: true,
          cacheHit: true
        }
      };
    }

    // Generate new response
    const response = await this.generateUncached(prompt, options);
    
    // Cache the response
    await this.cache.set(cacheKey, response, options?.cacheTTL);
    
    return {
      ...response,
      metadata: {
        ...response.metadata,
        cached: false,
        cacheHit: false
      }
    };
  }

  // Common implementations
  async generateJSON(prompt: string, schema?: any, options?: GenerateOptions): Promise<any> {
    try {
      const response = await this.generate(prompt, { 
        ...options, 
        jsonMode: true 
      });
      
      const parsed = JSON.parse(response.text);
      
      // Basic schema validation if provided
      if (schema && !this.validateSchema(parsed, schema)) {
        throw new LLMProviderError(
          'Response does not match expected schema',
          this.name,
          'SCHEMA_VALIDATION_ERROR'
        );
      }
      
      return parsed;
    } catch (error) {
      if (error instanceof SyntaxError) {
        throw new LLMProviderError(
          `Invalid JSON response: ${error.message}`,
          this.name,
          'JSON_PARSE_ERROR',
          error
        );
      }
      throw error;
    }
  }

  // Cache management methods
  protected generateCacheKey(prompt: string, options?: GenerateOptions): string {
    const cacheData = {
      prompt,
      model: options?.model || this.currentModel,
      temperature: options?.temperature || 0.7,
      maxTokens: options?.maxTokens || 2000,
      topP: options?.topP,
      frequencyPenalty: options?.frequencyPenalty,
      presencePenalty: options?.presencePenalty,
      stopSequences: options?.stopSequences,
      systemPrompt: options?.systemPrompt,
      jsonMode: options?.jsonMode
    };

    const serialized = JSON.stringify(cacheData);
    return generateHash(serialized);
  }

  async clearCache(): Promise<void> {
    await this.cache.clear();
  }

  getCacheMetrics() {
    return this.cache.getMetrics();
  }

  async isAvailable(): Promise<boolean> {
    if (!this.apiKey) {
      return false;
    }
    
    try {
      await this.listModels();
      return true;
    } catch (error) {
      return false;
    }
  }

  setModel(model: string): void {
    this.currentModel = model;
  }

  getCurrentModel(): string {
    return this.currentModel;
  }

  getApiKey(): string {
    return this.apiKey ? '***' + this.apiKey.slice(-4) : 'NOT_SET';
  }

  // Helper methods
  protected validateConfiguration(): void {
    if (!this.apiKey) {
      throw new LLMProviderError(
        `API key not configured for ${this.name}`,
        this.name,
        'MISSING_API_KEY'
      );
    }
  }

  protected buildHeaders(additionalHeaders?: Record<string, string>): Record<string, string> {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      'User-Agent': 'Synaptic-Lab-Kit/1.0.0',
      ...additionalHeaders
    };

    return headers;
  }

  /**
   * Retry operation with exponential backoff
   * Used for handling OpenAI Responses API race conditions (previous_response_not_found)
   * @param operation - Async operation to retry
   * @param maxRetries - Maximum number of retry attempts (default: 3)
   * @param initialDelayMs - Initial delay in milliseconds (default: 50)
   * @returns Result of successful operation
   */
  protected async retryWithBackoff<T>(
    operation: () => Promise<T>,
    maxRetries: number = 3,
    initialDelayMs: number = 50
  ): Promise<T> {
    let lastError: any;
    let delay = initialDelayMs;

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error: any) {
        lastError = error;

        // Only retry on specific "previous_response_not_found" error
        const isPreviousResponseNotFound =
          error?.status === 400 &&
          error?.error?.message?.includes('previous_response_not_found');

        if (!isPreviousResponseNotFound || attempt === maxRetries - 1) {
          throw error;
        }

        await new Promise(resolve => setTimeout(resolve, delay));
        delay *= 2; // Exponential backoff: 50ms, 100ms, 200ms
      }
    }

    throw lastError;
  }

  protected handleError(error: any, operation: string): never {
    if (error instanceof LLMProviderError) {
      throw error;
    }

    if (error.response) {
      // HTTP error
      const status = error.response.status;
      const message = error.response.data?.error?.message || error.message;
      
      let errorCode = 'HTTP_ERROR';
      if (status === 401) errorCode = 'AUTHENTICATION_ERROR';
      if (status === 403) errorCode = 'PERMISSION_ERROR';
      if (status === 429) errorCode = 'RATE_LIMIT_ERROR';
      if (status >= 500) errorCode = 'SERVER_ERROR';

      throw new LLMProviderError(
        `${operation} failed: ${message}`,
        this.name,
        errorCode,
        error
      );
    }

    throw new LLMProviderError(
      `${operation} failed: ${error.message}`,
      this.name,
      'UNKNOWN_ERROR',
      error
    );
  }

  protected validateSchema(data: any, schema: any): boolean {
    return SchemaValidator.validateSchema(data, schema);
  }

  protected buildMessages(prompt: string, systemPrompt?: string): any[] {
    const messages: any[] = [];
    
    if (systemPrompt) {
      messages.push({ role: 'system', content: systemPrompt });
    }
    
    messages.push({ role: 'user', content: prompt });
    
    return messages;
  }

  protected extractUsage(response: any): TokenUsage | undefined {
    return TokenUsageExtractor.extractUsage(response);
  }

  // Cost calculation methods
  protected async calculateCost(usage: TokenUsage, model: string): Promise<CostDetails | null> {
    const modelPricing = await this.getModelPricing(model);
    return LLMCostCalculator.calculateCost(usage, model, modelPricing);
  }

  /**
   * Get caching discount multiplier for a model
   * Delegates to LLMCostCalculator
   */
  protected getCachingDiscount(model: string): number {
    return LLMCostCalculator.getCachingDiscount(model);
  }

  protected async buildLLMResponse(
    content: string,
    model: string,
    usage?: TokenUsage,
    metadata?: Record<string, any>,
    finishReason?: 'stop' | 'length' | 'tool_calls' | 'content_filter',
    toolCalls?: any[]
  ): Promise<LLMResponse> {
    const response: LLMResponse = {
      text: content,
      model,
      provider: this.name,
      usage: usage || { promptTokens: 0, completionTokens: 0, totalTokens: 0 },
      metadata: metadata || {},
      finishReason: finishReason || 'stop',
      toolCalls: toolCalls || []
    };

    // Extract webSearchResults from metadata if present
    if (metadata?.webSearchResults) {
      response.webSearchResults = metadata.webSearchResults;
    }

    // Calculate cost if usage is available
    if (usage) {
      const cost = await this.calculateCost(usage, model);
      if (cost) {
        response.cost = cost;
      }
    }

    return response;
  }

  // Rate limiting and retry logic
  protected async withRetry<T>(
    operation: () => Promise<T>,
    maxRetries = 3,
    baseDelay = 1000
  ): Promise<T> {
    let lastError: Error;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error as Error;
        
        // Don't retry on certain errors
        if (error instanceof LLMProviderError) {
          if (['AUTHENTICATION_ERROR', 'PERMISSION_ERROR', 'MISSING_API_KEY'].includes(error.code || '')) {
            throw error;
          }
        }

        if (attempt < maxRetries) {
          const delay = baseDelay * Math.pow(2, attempt);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    throw lastError!;
  }
}

```

## services/llm/adapters/BaseImageAdapter.ts

```typescript
/**
 * Base Image Generation Adapter
 * Abstract class that image generation adapters extend
 * Provides common functionality for image generation while extending BaseAdapter
 */

import { BaseAdapter } from './BaseAdapter';
import { 
  ImageGenerationParams, 
  ImageGenerationResponse, 
  ImageGenerationResult,
  ImageValidationResult,
  ImageCostDetails,
  ImageGenerationError,
  ImageProvider,
  ImageModel,
  ImageUsage
} from '../types/ImageTypes';
import { ProviderCapabilities, ModelInfo, CostDetails } from './types';

export abstract class BaseImageAdapter extends BaseAdapter {
  abstract readonly supportedModels: ImageModel[];
  abstract readonly supportedSizes: string[];
  abstract readonly supportedFormats: string[];

  constructor(
    apiKey: string, 
    defaultModel: string, 
    baseUrl?: string
  ) {
    super(
      apiKey,
      defaultModel,
      baseUrl,
      true // requiresApiKey
    );
  }

  // Abstract methods that each image provider must implement
  abstract generateImage(params: ImageGenerationParams): Promise<ImageGenerationResponse>;
  abstract validateImageParams(params: ImageGenerationParams): ImageValidationResult;
  abstract getImageCapabilities(): ProviderCapabilities;
  abstract getSupportedImageSizes(): string[];
  abstract getImageModelPricing(model: string): Promise<CostDetails | null>;

  /**
   * Generate image with comprehensive validation and error handling
   */
  async generateImageSafely(params: ImageGenerationParams): Promise<ImageGenerationResult> {
    const startTime = Date.now();

    try {
      // Validate parameters first
      const validation = this.validateImageParams(params);
      if (!validation.isValid) {
        return {
          success: false,
          error: `Parameter validation failed: ${validation.errors.join(', ')}`,
          validationErrors: validation.errors
        };
      }

      // Use adjusted parameters if provided
      const finalParams = { ...params, ...validation.adjustedParams };

      // Generate the image with timeout
      const response = await Promise.race([
        this.generateImage(finalParams),
        this.createTimeoutPromise(120000) // 2 minute timeout
      ]);

      const generationTime = Date.now() - startTime;

      // Calculate costs
      const cost = await this.calculateImageCost(response, finalParams.model || this.currentModel);

      return {
        success: true,
        data: {
          imagePath: finalParams.savePath,
          prompt: finalParams.prompt,
          revisedPrompt: response.revisedPrompt,
          model: finalParams.model || this.currentModel,
          provider: this.name as ImageProvider,
          dimensions: response.dimensions,
          fileSize: response.imageData.length,
          format: response.format,
          cost: cost || undefined,
          usage: response.usage,
          metadata: {
            ...response.metadata,
            generationTimeMs: generationTime
          }
        }
      };
    } catch (error) {
      const generationTime = Date.now() - startTime;
      console.error(`[${this.name}] Image generation failed after ${generationTime}ms:`, error);
      
      if (error instanceof ImageGenerationError) {
        return {
          success: false,
          error: error.message
        };
      }

      // Handle timeout specifically
      if (error instanceof Error && error.message === 'Image generation timed out') {
        return {
          success: false,
          error: `Image generation timed out after ${Math.round(generationTime / 1000)}s. This can happen with complex prompts or high server load. Please try again with a simpler prompt.`
        };
      }

      return {
        success: false,
        error: `Image generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Create a timeout promise that rejects after specified milliseconds
   */
  private createTimeoutPromise(timeoutMs: number): Promise<never> {
    return new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error('Image generation timed out'));
      }, timeoutMs);
    });
  }

  /**
   * Check if the adapter is available for image generation
   */
  async isImageGenerationAvailable(): Promise<boolean> {
    if (!this.apiKey) {
      return false;
    }

    try {
      const capabilities = this.getImageCapabilities();
      return capabilities.supportsImageGeneration || false;
    } catch (error) {
      return false;
    }
  }

  /**
   * Get all supported models with their capabilities
   */
  async getImageModels(): Promise<ModelInfo[]> {
    const models = await this.listModels();
    return models.filter(model => model.supportsImageGeneration);
  }

  /**
   * Calculate image generation cost
   */
  protected async calculateImageCost(
    response: ImageGenerationResponse, 
    model: string
  ): Promise<ImageCostDetails | null> {
    try {
      const pricing = await this.getImageModelPricing(model);
      if (!pricing) {
        return null;
      }

      const usage = response.usage;
      if (!usage) {
        return null;
      }

      // For image generation, we typically have a per-image cost
      const totalCost = pricing.totalCost * usage.imagesGenerated;

      return {
        inputCost: 0, // Images don't have input tokens in the traditional sense
        outputCost: totalCost,
        totalCost,
        currency: pricing.currency,
        ratePerImage: pricing.totalCost,
        resolution: usage.resolution,
        imagesGenerated: usage.imagesGenerated
      };
    } catch (error) {
      return null;
    }
  }

  /**
   * Validate common image parameters
   */
  protected validateCommonParams(params: ImageGenerationParams): ImageValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Validate prompt
    if (!params.prompt || params.prompt.trim().length === 0) {
      errors.push('Prompt is required');
    }

    // Validate save path
    if (!params.savePath || params.savePath.trim().length === 0) {
      errors.push('Save path is required');
    }

    // Check if path is trying to escape vault
    if (params.savePath?.includes('..') || params.savePath?.startsWith('/')) {
      errors.push('Save path must be relative to vault root');
    }

    // Validate model if specified
    if (params.model && !this.supportedModels.includes(params.model as ImageModel)) {
      errors.push(`Model ${params.model} not supported. Supported models: ${this.supportedModels.join(', ')}`);
    }

    // Validate size if specified
    if (params.size && !this.supportedSizes.includes(params.size)) {
      errors.push(`Size ${params.size} not supported. Supported sizes: ${this.supportedSizes.join(', ')}`);
    }

    // Format validation removed - Google Imagen only outputs PNG

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  /**
   * Build image usage tracking object
   */
  protected buildImageUsage(
    imagesGenerated: number, 
    resolution: string, 
    model: string
  ): ImageUsage {
    return {
      imagesGenerated,
      resolution,
      model,
      provider: this.name
    };
  }

  /**
   * Handle image-specific errors
   */
  protected handleImageError(error: any, operation: string, params?: ImageGenerationParams): never {
    if (error instanceof ImageGenerationError) {
      throw error;
    }

    if (error.response) {
      const status = error.response.status;
      const message = error.response.data?.error?.message || error.message;
      
      let errorCode = 'HTTP_ERROR';
      if (status === 401) errorCode = 'AUTHENTICATION_ERROR';
      if (status === 403) errorCode = 'CONTENT_FILTER_ERROR';
      if (status === 429) errorCode = 'RATE_LIMIT_ERROR';
      if (status === 400) errorCode = 'INVALID_REQUEST';

      throw new ImageGenerationError(
        `${operation} failed: ${message}`,
        this.name,
        errorCode,
        error,
        params
      );
    }

    throw new ImageGenerationError(
      `${operation} failed: ${error.message || 'Unknown error'}`,
      this.name,
      'UNKNOWN_ERROR',
      error,
      params
    );
  }

  // Required BaseAdapter methods (stub implementations for image-only adapters)
  async generateUncached(): Promise<any> {
    throw new Error('Use generateImage() for image generation. This adapter only supports image generation.');
  }

  async generateStream(): Promise<any> {
    throw new Error('Streaming not supported for image generation');
  }

  getCapabilities(): ProviderCapabilities {
    return this.getImageCapabilities();
  }

  async getModelPricing(modelId: string): Promise<CostDetails | null> {
    return await this.getImageModelPricing(modelId);
  }
}
```

## services/llm/adapters/CostCalculator.ts

```typescript
/**
 * Cost Calculation and Token Counting System
 * 
 * This module provides comprehensive cost calculation with proper token counting
 * using provider APIs when available, with fallback tokenization for accuracy.
 * 
 * Features:
 * - Provider-specific token counting APIs
 * - Fallback tokenization for all providers
 * - Detailed cost breakdown and tracking
 * - Usage analytics and reporting
 */

import { ModelRegistry } from './ModelRegistry';

/**
 * OpenAI tokenize API response
 */
interface OpenAITokenizeResponse {
  token_count?: number;
}

/**
 * Google countTokens API response
 */
interface GoogleCountTokensResponse {
  totalTokens?: number;
}

/**
 * Anthropic count tokens API response
 */
interface AnthropicCountTokensResponse {
  input_tokens?: number;
}

/**
 * OpenAI-style usage object (used by OpenAI, OpenRouter, Requesty)
 */
interface OpenAIUsage {
  input_tokens?: number;
  prompt_tokens?: number;
  output_tokens?: number;
  completion_tokens?: number;
  total_tokens?: number;
  input_tokens_details?: {
    cachedTokens?: number;
    audioTokens?: number;
    textTokens?: number;
  };
  output_tokens_details?: {
    reasoningTokens?: number;
    audioTokens?: number;
    textTokens?: number;
  };
}

/**
 * Google Gemini usage metadata
 */
interface GoogleUsageMetadata {
  promptTokenCount?: number;
  candidatesTokenCount?: number;
  totalTokenCount?: number;
}

/**
 * Anthropic Claude usage object
 */
interface AnthropicUsage {
  input_tokens?: number;
  output_tokens?: number;
}

/**
 * Generic provider response that might contain usage information
 */
interface ProviderResponse {
  usage?: OpenAIUsage | AnthropicUsage;
  usageMetadata?: GoogleUsageMetadata;
}

/**
 * Detailed token usage information from provider APIs or fallback tokenization
 */
export interface DetailedTokenUsage {
  inputTokens: number;
  outputTokens: number;
  totalTokens: number;
  inputTokensDetails?: {
    cachedTokens?: number;
    audioTokens?: number;
    textTokens?: number;
  };
  outputTokensDetails?: {
    reasoningTokens?: number;
    audioTokens?: number;
    textTokens?: number;
  };
  source: 'provider_api' | 'fallback_tokenizer';
}

/**
 * Detailed cost breakdown
 */
export interface CostBreakdown {
  inputCost: number;
  outputCost: number;
  totalCost: number;
  currency: string;
  model: string;
  provider: string;
  tokenUsage: DetailedTokenUsage;
  costPerInputToken: number;
  costPerOutputToken: number;
  timestamp: string;
}

/**
 * Cost tracking for analytics
 */
export interface CostTracker {
  totalRequests: number;
  totalInputTokens: number;
  totalOutputTokens: number;
  totalCost: number;
  costByProvider: Record<string, number>;
  costByModel: Record<string, number>;
  averageCostPerRequest: number;
  currency: string;
  lastUpdated: string;
}

/**
 * Provider-specific token counting functions
 */
export class TokenCounter {
  /**
   * Count tokens using OpenAI's token counting API
   */
  static async countTokensOpenAI(text: string, model: string): Promise<number> {
    try {
      // Use OpenAI's token counting endpoint if available
      const response = await fetch('https://api.openai.com/v1/tokenize', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: model,
          text: text
        })
      });

      if (response.ok) {
        const data = await response.json() as OpenAITokenizeResponse;
        return data.token_count || 0;
      }
    } catch (error) {
    }

    return this.fallbackTokenCount(text);
  }

  /**
   * Count tokens using Google's token counting API
   */
  static async countTokensGoogle(text: string, model: string): Promise<number> {
    try {
      // Google's countTokens API
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:countTokens?key=${process.env.GOOGLE_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          contents: [{
            parts: [{ text: text }]
          }]
        })
      });

      if (response.ok) {
        const data = await response.json() as GoogleCountTokensResponse;
        return data.totalTokens || 0;
      }
    } catch (error) {
    }

    return this.fallbackTokenCount(text);
  }

  /**
   * Count tokens using Anthropic's token counting API
   */
  static async countTokensAnthropic(text: string, model: string): Promise<number> {
    try {
      // Anthropic's count tokens endpoint
      const response = await fetch('https://api.anthropic.com/v1/messages/count_tokens', {
        method: 'POST',
        headers: {
          'x-api-key': process.env.ANTHROPIC_API_KEY!,
          'Content-Type': 'application/json',
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model: model,
          messages: [{ role: 'user', content: text }]
        })
      });

      if (response.ok) {
        const data = await response.json() as AnthropicCountTokensResponse;
        return data.input_tokens || 0;
      }
    } catch (error) {
    }

    return this.fallbackTokenCount(text);
  }

  /**
   * Fallback token counting using simple heuristics
   * Based on OpenAI's general rule: ~4 characters per token for English text
   */
  static fallbackTokenCount(text: string): number {
    if (!text) return 0;
    
    // More sophisticated estimation
    const words = text.split(/\s+/).length;
    const chars = text.length;
    
    // Estimate based on multiple factors
    const charBasedEstimate = Math.ceil(chars / 4);
    const wordBasedEstimate = Math.ceil(words * 1.3); // ~1.3 tokens per word on average
    
    // Use the more conservative (higher) estimate
    return Math.max(charBasedEstimate, wordBasedEstimate);
  }

  /**
   * Count tokens for any provider with fallback
   */
  static async countTokens(text: string, provider: string, model: string): Promise<DetailedTokenUsage> {
    let tokenCount = 0;
    let source: 'provider_api' | 'fallback_tokenizer' = 'fallback_tokenizer';

    try {
      switch (provider) {
        case 'openai':
          tokenCount = await this.countTokensOpenAI(text, model);
          source = 'provider_api';
          break;
        case 'google':
          tokenCount = await this.countTokensGoogle(text, model);
          source = 'provider_api';
          break;
        case 'anthropic':
          tokenCount = await this.countTokensAnthropic(text, model);
          source = 'provider_api';
          break;
        default:
          tokenCount = this.fallbackTokenCount(text);
          break;
      }
    } catch (error) {
      tokenCount = this.fallbackTokenCount(text);
    }

    return {
      inputTokens: tokenCount,
      outputTokens: 0,
      totalTokens: tokenCount,
      source
    };
  }
}

/**
 * Main cost calculation engine
 */
export class CostCalculator {
  /**
   * Calculate cost from token usage and model pricing
   */
  static calculateCost(
    provider: string,
    model: string,
    tokenUsage: DetailedTokenUsage
  ): CostBreakdown | null {
    const modelSpec = ModelRegistry.findModel(provider, model);
    if (!modelSpec) {
      return null;
    }

    const costPerInputToken = modelSpec.inputCostPerMillion / 1_000_000;
    const costPerOutputToken = modelSpec.outputCostPerMillion / 1_000_000;

    const inputCost = tokenUsage.inputTokens * costPerInputToken;
    const outputCost = tokenUsage.outputTokens * costPerOutputToken;
    const totalCost = inputCost + outputCost;

    return {
      inputCost,
      outputCost,
      totalCost,
      currency: 'USD',
      model,
      provider,
      tokenUsage,
      costPerInputToken,
      costPerOutputToken,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Type guard to check if usage object is OpenAI format
   */
  private static isOpenAIUsage(usage: OpenAIUsage | AnthropicUsage): usage is OpenAIUsage {
    return 'prompt_tokens' in usage || 'completion_tokens' in usage || 'total_tokens' in usage;
  }

  /**
   * Type guard to check if usage object is Anthropic format
   */
  private static isAnthropicUsage(usage: OpenAIUsage | AnthropicUsage): usage is AnthropicUsage {
    return !this.isOpenAIUsage(usage);
  }

  /**
   * Extract token usage from provider response objects
   */
  static extractTokenUsage(response: ProviderResponse, provider: string): DetailedTokenUsage | null {
    try {
      switch (provider) {
        case 'openai':
          // OpenAI Responses API and Chat Completions format
          if (response.usage && this.isOpenAIUsage(response.usage)) {
            return {
              inputTokens: response.usage.input_tokens || response.usage.prompt_tokens || 0,
              outputTokens: response.usage.output_tokens || response.usage.completion_tokens || 0,
              totalTokens: response.usage.total_tokens || 0,
              inputTokensDetails: response.usage.input_tokens_details,
              outputTokensDetails: response.usage.output_tokens_details,
              source: 'provider_api'
            };
          }
          break;

        case 'google':
          // Google Gemini format
          if (response.usageMetadata) {
            return {
              inputTokens: response.usageMetadata.promptTokenCount || 0,
              outputTokens: response.usageMetadata.candidatesTokenCount || 0,
              totalTokens: response.usageMetadata.totalTokenCount || 0,
              source: 'provider_api'
            };
          }
          break;

        case 'anthropic':
          // Anthropic Claude format
          if (response.usage && this.isAnthropicUsage(response.usage)) {
            return {
              inputTokens: response.usage.input_tokens || 0,
              outputTokens: response.usage.output_tokens || 0,
              totalTokens: (response.usage.input_tokens || 0) + (response.usage.output_tokens || 0),
              source: 'provider_api'
            };
          }
          break;

        case 'openrouter':
        case 'requesty':
          // OpenRouter/Requesty typically pass through OpenAI format
          if (response.usage && this.isOpenAIUsage(response.usage)) {
            return {
              inputTokens: response.usage.prompt_tokens || 0,
              outputTokens: response.usage.completion_tokens || 0,
              totalTokens: response.usage.total_tokens || 0,
              source: 'provider_api'
            };
          }
          break;
      }
    } catch (error) {
    }

    return null;
  }

  /**
   * Calculate cost with automatic token counting if usage not provided
   */
  static async calculateCostWithTokenCounting(
    provider: string,
    model: string,
    inputText: string,
    outputText: string,
    providedUsage?: DetailedTokenUsage
  ): Promise<CostBreakdown | null> {
    let tokenUsage: DetailedTokenUsage;

    if (providedUsage) {
      tokenUsage = providedUsage;
    } else {
      // Count tokens for input and output
      const inputUsage = await TokenCounter.countTokens(inputText, provider, model);
      const outputUsage = await TokenCounter.countTokens(outputText, provider, model);
      
      tokenUsage = {
        inputTokens: inputUsage.inputTokens,
        outputTokens: outputUsage.inputTokens, // Output counting uses same method
        totalTokens: inputUsage.inputTokens + outputUsage.inputTokens,
        source: inputUsage.source
      };
    }

    return this.calculateCost(provider, model, tokenUsage);
  }

  /**
   * Compare costs across multiple providers/models
   */
  static compareCosts(
    providers: Array<{ provider: string; model: string }>,
    tokenUsage: DetailedTokenUsage
  ): Array<CostBreakdown> {
    return providers
      .map(({ provider, model }) => this.calculateCost(provider, model, tokenUsage))
      .filter(Boolean)
      .sort((a, b) => a!.totalCost - b!.totalCost) as Array<CostBreakdown>;
  }
}

/**
 * Cost tracking and analytics
 */
export class CostAnalyzer {
  private tracker: CostTracker = {
    totalRequests: 0,
    totalInputTokens: 0,
    totalOutputTokens: 0,
    totalCost: 0,
    costByProvider: {},
    costByModel: {},
    averageCostPerRequest: 0,
    currency: 'USD',
    lastUpdated: new Date().toISOString()
  };

  addUsage(costBreakdown: CostBreakdown): void {
    this.tracker.totalRequests++;
    this.tracker.totalInputTokens += costBreakdown.tokenUsage.inputTokens;
    this.tracker.totalOutputTokens += costBreakdown.tokenUsage.outputTokens;
    this.tracker.totalCost += costBreakdown.totalCost;
    
    this.tracker.costByProvider[costBreakdown.provider] = 
      (this.tracker.costByProvider[costBreakdown.provider] || 0) + costBreakdown.totalCost;
    
    const modelKey = `${costBreakdown.provider}/${costBreakdown.model}`;
    this.tracker.costByModel[modelKey] = 
      (this.tracker.costByModel[modelKey] || 0) + costBreakdown.totalCost;
    
    this.tracker.averageCostPerRequest = this.tracker.totalCost / this.tracker.totalRequests;
    this.tracker.lastUpdated = new Date().toISOString();
  }

  getReport(): CostTracker {
    return { ...this.tracker };
  }

  getMostExpensive(): { provider: string; model: string; cost: number } | null {
    const entries = Object.entries(this.tracker.costByModel);
    if (entries.length === 0) return null;

    const [model, cost] = entries.reduce((max, entry) => 
      entry[1] > max[1] ? entry : max
    );

    const [provider, modelName] = model.split('/');
    return { provider: provider || 'unknown', model: modelName || model, cost };
  }

  getCheapest(): { provider: string; model: string; cost: number } | null {
    const entries = Object.entries(this.tracker.costByModel);
    if (entries.length === 0) return null;

    const [model, cost] = entries.reduce((min, entry) => 
      entry[1] < min[1] ? entry : min
    );

    const [provider, modelName] = model.split('/');
    return { provider: provider || 'unknown', model: modelName || model, cost };
  }

  getCostByProvider(): Record<string, { cost: number; percentage: number }> {
    const result: Record<string, { cost: number; percentage: number }> = {};
    
    for (const [provider, cost] of Object.entries(this.tracker.costByProvider)) {
      result[provider] = {
        cost,
        percentage: this.tracker.totalCost > 0 ? (cost / this.tracker.totalCost) * 100 : 0
      };
    }
    
    return result;
  }

  reset(): void {
    this.tracker = {
      totalRequests: 0,
      totalInputTokens: 0,
      totalOutputTokens: 0,
      totalCost: 0,
      costByProvider: {},
      costByModel: {},
      averageCostPerRequest: 0,
      currency: 'USD',
      lastUpdated: new Date().toISOString()
    };
  }

  exportData(): string {
    return JSON.stringify(this.tracker, null, 2);
  }

  importData(data: string): void {
    try {
      const imported = JSON.parse(data);
      this.tracker = { ...this.tracker, ...imported };
    } catch (error) {
      console.error('Failed to import cost tracking data:', error);
    }
  }
}

/**
 * Global cost analyzer instance for easy access
 */
export const globalCostAnalyzer = new CostAnalyzer();
```

## services/llm/adapters/google/GeminiImageAdapter.ts

```typescript
/**
 * Google Gemini Image Generation Adapter
 * Supports Google's Nano Banana models for image generation
 * - gemini-2.5-flash-image (Nano Banana) - fast generation
 * - gemini-3-pro-image-preview (Nano Banana Pro) - advanced with reference images
 *
 * Uses generateContent() API with responseModalities: ['TEXT', 'IMAGE']
 *
 * MOBILE COMPATIBILITY (Dec 2025):
 * The @google/genai SDK uses gaxios which requires Node.js 'os' module.
 * SDK import is now lazy (dynamic) to avoid bundling Node.js dependencies.
 */

import { TFile, Vault } from 'obsidian';

// Type-only import for TypeScript (doesn't affect bundling)
import type { GoogleGenAI as GoogleGenAIType } from '@google/genai';
import { BaseImageAdapter } from '../BaseImageAdapter';
import {
  ImageGenerationParams,
  ImageGenerationResponse,
  ImageValidationResult,
  ImageModel,
  ImageUsage,
  AspectRatio,
  NanoBananaImageSize
} from '../../types/ImageTypes';
import {
  ProviderConfig,
  ProviderCapabilities,
  ModelInfo,
  CostDetails
} from '../types';

// Type definitions for Google GenAI response structure
interface InlineData {
  mimeType: string;
  data: string;
}

interface ContentPart {
  inlineData?: InlineData;
  text?: string;
}

interface Content {
  parts?: ContentPart[];
}

interface Candidate {
  content?: Content;
}

interface GenerateContentResponseType {
  candidates?: Candidate[];
}

export class GeminiImageAdapter extends BaseImageAdapter {

  // Image adapters don't support streaming in the same way as text
  async* generateStreamAsync(): AsyncGenerator<never, void, unknown> {
    throw new Error('Image generation does not support streaming');
  }

  readonly name = 'gemini-image';
  readonly baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
  readonly supportedModels: ImageModel[] = ['gemini-2.5-flash-image', 'gemini-3-pro-image-preview'];
  readonly supportedSizes: string[] = ['1024x1024', '1536x1024', '1024x1536', '1792x1024', '1024x1792'];
  readonly supportedFormats: string[] = ['png', 'jpeg', 'webp'];

  private client: GoogleGenAIType | null = null;
  private clientPromise: Promise<GoogleGenAIType> | null = null;
  private vault: Vault | null = null;
  private readonly defaultModel = 'gemini-2.5-flash-image';

  // Max reference images per model (per Google docs Dec 2025)
  private readonly maxReferenceImages = {
    'gemini-2.5-flash-image': 3,
    'gemini-3-pro-image-preview': 14
  };

  // Supported aspect ratios for Nano Banana models
  private readonly nanoBananaAspectRatios = [
    '1:1', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '9:16', '16:9', '21:9'
  ];

  constructor(config?: ProviderConfig & { vault?: Vault }) {
    const apiKey = config?.apiKey || '';
    super(apiKey, 'gemini-2.5-flash-image', config?.baseUrl);

    if (config?.vault) {
      this.vault = config.vault;
    }

    this.initializeCache();
  }

  /**
   * Lazy-load the Google GenAI SDK to avoid bundling Node.js dependencies
   */
  private async getClient(): Promise<GoogleGenAIType> {
    if (this.client) {
      return this.client;
    }

    if (!this.clientPromise) {
      this.clientPromise = (async () => {
        const { GoogleGenAI } = await import('@google/genai');
        this.client = new GoogleGenAI({ apiKey: this.apiKey });
        return this.client;
      })();
    }

    return this.clientPromise;
  }

  /**
   * Set vault for reading reference images
   */
  setVault(vault: Vault): void {
    this.vault = vault;
  }

  /**
   * Generate images using Google's Nano Banana models
   * Uses generateContent() API with responseModalities: ['TEXT', 'IMAGE']
   */
  async generateImage(params: ImageGenerationParams): Promise<ImageGenerationResponse> {
    try {
      this.validateConfiguration();

      const model = params.model || this.defaultModel;

      const response = await this.withRetry(async () => {
        // Build contents array with prompt and reference images
        const contents: any[] = [{ text: params.prompt }];

        // Add reference images if provided
        if (params.referenceImages && params.referenceImages.length > 0) {
          const referenceImageParts = await this.loadReferenceImages(params.referenceImages);
          contents.push(...referenceImageParts);
        }

        // Build config
        const config: any = {
          responseModalities: ['TEXT', 'IMAGE'],
        };

        // Add image config if aspect ratio or size specified
        const imageConfig: Record<string, string> = {};
        if (params.aspectRatio) {
          imageConfig.aspectRatio = params.aspectRatio;
        }
        if (params.imageSize) {
          imageConfig.imageSize = params.imageSize;
        }
        if (Object.keys(imageConfig).length > 0) {
          config.imageConfig = imageConfig;
        }

        // Call generateContent API
        const client = await this.getClient();
        const result = await client.models.generateContent({
          model: model,
          contents: contents,
          config: config
        });

        return result;
      }, 2);

      return this.buildImageResponse(response, params);
    } catch (error) {
      this.handleImageError(error, 'image generation', params);
    }
  }

  /**
   * Load reference images from vault and convert to base64
   */
  private async loadReferenceImages(paths: string[]): Promise<any[]> {
    if (!this.vault) {
      throw new Error('Vault not configured - cannot load reference images');
    }

    const parts: any[] = [];

    for (const path of paths) {
      try {
        const file = this.vault.getAbstractFileByPath(path);
        if (!file) {
          throw new Error(`Reference image not found: ${path}`);
        }

        // Type guard: ensure file is a TFile (not a TFolder)
        if (!(file instanceof TFile)) {
          throw new Error(`Reference path is not a file: ${path}`);
        }

        // Read file as binary
        const arrayBuffer = await this.vault.readBinary(file);
        const buffer = Buffer.from(arrayBuffer);
        const base64 = buffer.toString('base64');

        // Determine MIME type from extension
        const mimeType = this.getMimeType(path);

        parts.push({
          inlineData: {
            mimeType: mimeType,
            data: base64
          }
        });
      } catch (error) {
        throw new Error(`Failed to load reference image ${path}: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }

    return parts;
  }

  /**
   * Get MIME type from file extension
   */
  private getMimeType(path: string): string {
    const ext = path.toLowerCase().split('.').pop() || '';
    const mimeTypes: Record<string, string> = {
      'png': 'image/png',
      'jpg': 'image/jpeg',
      'jpeg': 'image/jpeg',
      'gif': 'image/gif',
      'webp': 'image/webp',
      'bmp': 'image/bmp'
    };
    return mimeTypes[ext] || 'image/png';
  }

  /**
   * Validate Nano Banana-specific image generation parameters
   */
  validateImageParams(params: ImageGenerationParams): ImageValidationResult {
    // Start with common validation
    const baseValidation = this.validateCommonParams(params);
    if (!baseValidation.isValid) {
      return baseValidation;
    }

    const errors: string[] = [...baseValidation.errors];
    const warnings: string[] = [...(baseValidation.warnings || [])];
    const adjustedParams: Partial<ImageGenerationParams> = {};

    // Validate model
    const model = params.model || this.defaultModel;
    if (!this.supportedModels.includes(model as ImageModel)) {
      errors.push(`Invalid model. Supported models: ${this.supportedModels.join(', ')}`);
    }

    // Validate aspect ratio
    if (params.aspectRatio && !this.nanoBananaAspectRatios.includes(params.aspectRatio)) {
      errors.push(`Invalid aspect ratio. Supported ratios: ${this.nanoBananaAspectRatios.join(', ')}`);
    }

    // Validate image size
    if (params.imageSize) {
      const imageSize = params.imageSize;
      const validSizes = ['1K', '2K', '4K'];
      if (!validSizes.includes(imageSize)) {
        errors.push('imageSize must be "1K", "2K", or "4K"');
      }
      // 4K only available for Pro model
      if (imageSize === '4K' && model !== 'gemini-3-pro-image-preview') {
        errors.push('4K resolution is only available for gemini-3-pro-image-preview model');
      }
    }

    // Validate number of images
    if (params.numberOfImages && (params.numberOfImages < 1 || params.numberOfImages > 4)) {
      errors.push('numberOfImages must be between 1 and 4');
    }

    // Validate reference images
    if (params.referenceImages && params.referenceImages.length > 0) {
      const maxRefs = this.maxReferenceImages[model as keyof typeof this.maxReferenceImages] || 6;
      if (params.referenceImages.length > maxRefs) {
        errors.push(`Too many reference images. ${model} supports max ${maxRefs} reference images`);
      }

      // Validate image extensions
      const validExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.bmp'];
      for (const path of params.referenceImages) {
        const ext = '.' + (path.toLowerCase().split('.').pop() || '');
        if (!validExtensions.includes(ext)) {
          errors.push(`Invalid reference image format: ${path}. Supported formats: ${validExtensions.join(', ')}`);
        }
      }
    }

    // Set default model if not specified
    if (!params.model) {
      adjustedParams.model = this.defaultModel;
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      adjustedParams
    };
  }

  /**
   * Get Nano Banana capabilities
   */
  getImageCapabilities(): ProviderCapabilities {
    return {
      supportsStreaming: false,
      supportsJSON: false,
      supportsImages: true, // Supports reference images
      supportsFunctions: false,
      supportsThinking: false,
      supportsImageGeneration: true,
      maxContextWindow: 32000, // Higher limit for Nano Banana
      supportedFeatures: [
        'text_to_image',
        'image_to_image',
        'multi_reference_images',
        'aspect_ratio_control',
        'high_quality_output',
        'enhanced_text_rendering',
        '4k_resolution'
      ]
    };
  }

  /**
   * Get supported aspect ratios
   */
  getSupportedAspectRatios(): AspectRatio[] {
    return [
      AspectRatio.SQUARE,
      AspectRatio.PORTRAIT_2_3,
      AspectRatio.LANDSCAPE_3_2,
      AspectRatio.PORTRAIT_3_4,
      AspectRatio.LANDSCAPE_4_3,
      AspectRatio.PORTRAIT_4_5,
      AspectRatio.LANDSCAPE_5_4,
      AspectRatio.PORTRAIT_9_16,
      AspectRatio.LANDSCAPE_16_9,
      AspectRatio.ULTRAWIDE_21_9
    ];
  }

  /**
   * Get supported image sizes
   */
  getSupportedImageSizes(): string[] {
    return [...this.supportedSizes];
  }

  /**
   * Get pricing for Nano Banana models (2025 pricing)
   */
  async getImageModelPricing(model: string = 'gemini-2.5-flash-image'): Promise<CostDetails> {
    const pricing: Record<string, number> = {
      'gemini-2.5-flash-image': 0.039,      // Nano Banana
      'gemini-3-pro-image-preview': 0.08    // Nano Banana Pro (estimate)
    };

    const basePrice = pricing[model] || 0.039;

    return {
      inputCost: 0,
      outputCost: basePrice,
      totalCost: basePrice,
      currency: 'USD',
      rateInputPerMillion: 0,
      rateOutputPerMillion: basePrice * 1_000_000
    };
  }

  /**
   * List available Nano Banana image models
   */
  async listModels(): Promise<ModelInfo[]> {
    return [
      {
        id: 'gemini-2.5-flash-image',
        name: 'Nano Banana (Fast)',
        contextWindow: 32000,
        maxOutputTokens: 0,
        supportsJSON: false,
        supportsImages: true,
        supportsFunctions: false,
        supportsStreaming: false,
        supportsThinking: false,
        supportsImageGeneration: true,
        pricing: {
          inputPerMillion: 0,
          outputPerMillion: 0,
          imageGeneration: 0.039,
          currency: 'USD',
          lastUpdated: '2025-12-07'
        }
      },
      {
        id: 'gemini-3-pro-image-preview',
        name: 'Nano Banana Pro (Advanced)',
        contextWindow: 32000,
        maxOutputTokens: 0,
        supportsJSON: false,
        supportsImages: true,
        supportsFunctions: false,
        supportsStreaming: false,
        supportsThinking: false,
        supportsImageGeneration: true,
        pricing: {
          inputPerMillion: 0,
          outputPerMillion: 0,
          imageGeneration: 0.08,
          currency: 'USD',
          lastUpdated: '2025-12-07'
        }
      }
    ];
  }

  // Private helper methods

  private buildImageResponse(
    response: GenerateContentResponseType,
    params: ImageGenerationParams
  ): ImageGenerationResponse {
    // Handle generateContent response format
    // Response structure: { candidates: [{ content: { parts: [{ inlineData: { mimeType, data } }] } }] }

    if (!response.candidates || response.candidates.length === 0) {
      throw new Error('No response candidates received from Google');
    }

    const candidate = response.candidates[0];
    if (!candidate.content || !candidate.content.parts) {
      throw new Error('No content parts in Google response');
    }

    // Find the image part in the response
    const imagePart = candidate.content.parts.find((part: ContentPart) => part.inlineData);
    if (!imagePart || !imagePart.inlineData) {
      throw new Error('No image data found in Google response');
    }

    // Convert base64 to buffer
    const buffer = Buffer.from(imagePart.inlineData.data, 'base64');

    // Determine format from MIME type
    const mimeType = imagePart.inlineData.mimeType || 'image/png';
    const format = mimeType.split('/')[1] as 'png' | 'jpeg' | 'webp' || 'png';

    // Extract dimensions from aspectRatio
    let width = 1024, height = 1024;
    let aspectRatio: AspectRatio = params.aspectRatio || AspectRatio.SQUARE;

    // Map aspect ratios to typical dimensions
    const aspectRatioToDimensions: Record<string, [number, number]> = {
      '1:1': [1024, 1024],
      '2:3': [768, 1152],
      '3:2': [1152, 768],
      '3:4': [896, 1152],
      '4:3': [1152, 896],
      '4:5': [896, 1120],
      '5:4': [1120, 896],
      '9:16': [576, 1024],
      '16:9': [1024, 576],
      '21:9': [1344, 576]
    };

    if (params.aspectRatio && aspectRatioToDimensions[params.aspectRatio]) {
      [width, height] = aspectRatioToDimensions[params.aspectRatio];
    }

    const usage: ImageUsage = this.buildImageUsage(1, `${width}x${height}`, params.model || this.defaultModel);

    return {
      imageData: buffer,
      format: format,
      dimensions: { width, height },
      metadata: {
        aspectRatio,
        model: params.model || this.defaultModel,
        provider: this.name,
        generatedAt: new Date().toISOString(),
        originalPrompt: params.prompt,
        referenceImagesCount: params.referenceImages?.length || 0,
        synthidWatermarking: true // Nano Banana adds SynthID watermarking
      },
      usage
    };
  }
}

```

## services/llm/adapters/google/GoogleAdapter.ts

```typescript
/**
 * Google Gemini Adapter with true streaming support
 * Implements Google Gemini streaming protocol using generateContentStream
 * Based on official Google Gemini JavaScript SDK documentation
 *
 * MOBILE COMPATIBILITY (Dec 2025):
 * The @google/genai SDK uses gaxios which requires Node.js 'os' module.
 * SDK import is now lazy (dynamic) to avoid bundling Node.js dependencies.
 * This allows the plugin to load on mobile, but Google provider won't work there.
 */

import { BaseAdapter } from '../BaseAdapter';
import {
  GenerateOptions,
  StreamChunk,
  LLMResponse,
  ModelInfo,
  ProviderCapabilities,
  ModelPricing,
  SearchResult
} from '../types';
import { GOOGLE_MODELS, GOOGLE_DEFAULT_MODEL } from './GoogleModels';
import { WebSearchUtils } from '../../utils/WebSearchUtils';
import { ReasoningPreserver } from '../shared/ReasoningPreserver';
import { SchemaValidator } from '../../utils/SchemaValidator';
import { ThinkingEffortMapper } from '../../utils/ThinkingEffortMapper';
import { MCPToolExecution } from '../shared/ToolExecutionUtils';

// Type-only import for TypeScript (doesn't affect bundling)
import type { GoogleGenAI as GoogleGenAIType } from '@google/genai';

export class GoogleAdapter extends BaseAdapter {
  readonly name = 'google';
  readonly baseUrl = 'https://generativelanguage.googleapis.com/v1';

  private client: GoogleGenAIType | null = null;
  private clientPromise: Promise<GoogleGenAIType> | null = null;

  constructor(apiKey: string, model?: string) {
    super(apiKey, model || GOOGLE_DEFAULT_MODEL);
    this.initializeCache();
  }

  /**
   * Lazy-load the Google GenAI SDK to avoid bundling Node.js dependencies
   * This allows the plugin to load on mobile (though Google won't work there)
   */
  private async getClient(): Promise<GoogleGenAIType> {
    if (this.client) {
      return this.client;
    }

    if (!this.clientPromise) {
      this.clientPromise = (async () => {
        const { GoogleGenAI } = await import('@google/genai');
        this.client = new GoogleGenAI({ apiKey: this.apiKey });
        return this.client;
      })();
    }

    return this.clientPromise;
  }

  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    return this.withRetry(async () => {
      try {
        // Tool execution requires streaming - use generateStreamAsync instead
        if (options?.tools && options.tools.length > 0) {
          throw new Error('Tool execution requires streaming. Use generateStreamAsync() instead.');
        }

        // Use basic message generation
        return await this.generateWithBasicMessages(prompt, options);
      } catch (error) {
        this.handleError(error, 'generation');
      }
    });
  }

  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    let request: any;
    try {
      // Validate web search support
      if (options?.webSearch) {
        WebSearchUtils.validateWebSearchRequest('google', options.webSearch);
      }

      // Build contents - use conversation history if provided (for tool continuations)
      let contents: any[];
      if (options?.conversationHistory && options.conversationHistory.length > 0) {
        contents = options.conversationHistory;
      } else {
        // Ensure prompt is not empty
        if (!prompt || !prompt.trim()) {
          prompt = 'Continue the conversation';
        }
        contents = [{
          role: 'user',
          parts: [{ text: prompt }]
        }];
      }

      // Determine thinking budget based on options or tools
      const effort = options?.thinkingEffort || 'medium';
      const googleThinkingParams = ThinkingEffortMapper.getGoogleParams({ enabled: true, effort });
      const thinkingBudget = googleThinkingParams?.thinkingBudget || 8192;

      // Build config object with all generation settings
      const config: any = {
        generationConfig: {
          // Use temperature 0 when tools are provided for more deterministic function calling
          temperature: (options?.tools && options.tools.length > 0) ? 0 : (options?.temperature ?? 0.7),
          maxOutputTokens: options?.maxTokens || 4096,
          topK: 40,
          topP: 0.95,
          // Enable thinking mode when tools are present or explicitly requested
          // Gemini 2.5 Flash supports 0-24576 token thinking budget
          ...((options?.enableThinking || (options?.tools && options.tools.length > 0)) && {
            thinkingBudget
          })
        }
      };

      // Add system instruction if provided (inside config)
      if (options?.systemPrompt) {
        config.systemInstruction = {
          parts: [{ text: options.systemPrompt }]
        };
      }

      // Add web search grounding if requested (must be before other tools)
      if (options?.webSearch) {
        config.tools = config.tools || [];
        config.tools.push({ googleSearch: {} });
      }

      // Add tools if provided (inside config)
      if (options?.tools && options.tools.length > 0) {
        const convertedTools = this.convertTools(options.tools);

        // Merge with existing tools array if web search was added
        if (config.tools && config.tools.length > 0) {
          config.tools.push(...convertedTools);
        } else {
          config.tools = convertedTools;
        }

        // Validate each tool schema before sending to Google
        let validationFailures = 0;
        for (const toolWrapper of config.tools) {
          const functionDeclarations = toolWrapper.functionDeclarations;
          if (functionDeclarations) {
            for (const tool of functionDeclarations) {
              const validation = SchemaValidator.validateGoogleSchema(tool.parameters, tool.name);
              if (!validation.valid) {
                validationFailures++;
                console.error(`[Google Adapter] âš ï¸ Schema validation failed for tool "${tool.name}":`);
                console.error(`[Google Adapter]    ${validation.error}`);
                console.error(`[Google Adapter]    This may cause MALFORMED_FUNCTION_CALL errors`);
              }
            }
          }
        }

        if (validationFailures > 0) {
          console.error(`[Google Adapter] âŒ ${validationFailures} tool(s) have schema validation issues`);
        }

        // Add function calling config - let model decide when to use tools
        config.toolConfig = {
          functionCallingConfig: {
            mode: 'AUTO' // Model decides when tools are appropriate
          }
        };

      }

      // Build final request with config wrapper
      const request: any = {
        model: options?.model || this.currentModel,
        contents: contents,
        config: config
      };

      let response;
      try {
        const client = await this.getClient();
        response = await client.models.generateContentStream(request);
      } catch (error: any) {
        throw error;
      }

      let usage: any = undefined;
      const toolCallAccumulator: Map<string, any> = new Map();

      for await (const chunk of response) {
        // Extract text from parts
        const parts = chunk.candidates?.[0]?.content?.parts || [];
        const finishReason = chunk.candidates?.[0]?.finishReason;

        // Handle malformed function call
        if (finishReason === 'MALFORMED_FUNCTION_CALL') {
          console.error('[Google Adapter] âŒ MALFORMED_FUNCTION_CALL detected!');
          console.error('[Google Adapter] This means one or more tool schemas violate Google\'s JSON Schema requirements');
          console.error('[Google Adapter] Common causes:');
          console.error('[Google Adapter]   1. Schema contains "default", "examples", "minLength", "maxLength", "pattern", or other unsupported properties');
          console.error('[Google Adapter]   2. Schema is too deeply nested (max depth: 10 levels)');
          console.error('[Google Adapter]   3. "required" array references properties that don\'t exist in "properties"');
          console.error('[Google Adapter]   4. Too many tools provided (Google recommends max 10-20)');
          console.error('[Google Adapter] Check schema validation warnings above for specific issues');
          console.error('[Google Adapter] Full response:', JSON.stringify(chunk, null, 2));

          // Provide helpful error message to user
          yield {
            content: '\n\nâš ï¸ **Google Gemini Schema Error**\n\nGoogle returned `MALFORMED_FUNCTION_CALL` - this means one or more tool schemas contain unsupported properties.\n\nCheck the console for detailed validation errors. Common issues:\n- Tool schemas contain `default` values (not supported by Google)\n- Schemas use `minLength`, `maxLength`, or `pattern` properties\n- Too many tools provided at once\n\nThe schemas have been automatically sanitized, but some tools may need schema updates.',
            complete: true
          };
          return;
        }

        for (const part of parts) {
          // Handle thinking/reasoning content (Gemini 2.0+ with thinking enabled)
          if (part.thought || part.thinking) {
            const thinkingText = part.thought || part.thinking;
            yield {
              content: '',
              complete: false,
              reasoning: thinkingText,
              reasoningComplete: false
            };
          }

          if (part.text) {
            yield {
              content: part.text,
              complete: false
            };
          }

          // Accumulate function calls with thought signature preservation (Gemini 3.0+)
          if (part.functionCall) {
            const toolId = part.functionCall.name + '_' + Date.now();
            const toolCall: any = {
              id: toolId,
              type: 'function',
              function: {
                name: part.functionCall.name,
                arguments: JSON.stringify(part.functionCall.args || {})
              }
            };

            // Preserve thought signature using centralized utility
            const thoughtSignature = ReasoningPreserver.extractThoughtSignatureFromPart(part);
            if (thoughtSignature) {
              toolCall.thought_signature = thoughtSignature;
            }

            toolCallAccumulator.set(toolId, toolCall);
          }
        }

        // Extract usage information if available
        if (chunk.usageMetadata) {
          usage = chunk.usageMetadata;
        }
      }

      // Final chunk with usage information and tool calls
      const finalToolCalls = toolCallAccumulator.size > 0
        ? Array.from(toolCallAccumulator.values())
        : undefined;

      yield {
        content: '',
        complete: true,
        usage: this.extractUsage({ usageMetadata: usage }),
        toolCalls: finalToolCalls,
        toolCallsReady: finalToolCalls && finalToolCalls.length > 0 ? true : undefined
      };
    } catch (error: any) {
      console.error('[Google Adapter] âŒâŒâŒ STREAMING ERROR:', error);
      console.error('[Google Adapter] Error details:', {
        name: error?.name,
        message: error?.message,
        stack: error?.stack
      });
      throw error;
    }
  }

  async listModels(): Promise<ModelInfo[]> {
    try {
      return GOOGLE_MODELS.map(model => ({
        id: model.apiName,
        name: model.name,
        contextWindow: model.contextWindow,
        maxOutputTokens: model.maxTokens,
        supportsJSON: model.capabilities.supportsJSON,
        supportsImages: model.capabilities.supportsImages,
        supportsFunctions: model.capabilities.supportsFunctions,
        supportsStreaming: model.capabilities.supportsStreaming,
        supportsThinking: model.capabilities.supportsThinking,
        costPer1kTokens: {
          input: model.inputCostPerMillion / 1000,
          output: model.outputCostPerMillion / 1000
        },
        pricing: {
          inputPerMillion: model.inputCostPerMillion,
          outputPerMillion: model.outputCostPerMillion,
          currency: 'USD',
          lastUpdated: new Date().toISOString()
        }
      }));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }

  getCapabilities(): ProviderCapabilities {
    return {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsThinking: true,
      maxContextWindow: 2097152,
      supportedFeatures: [
        'messages',
        'function_calling',
        'vision',
        'streaming',
        'json_mode',
        'thinking_mode'
      ]
    };
  }

  /**
   * Generate using basic message API without tools
   */
  private async generateWithBasicMessages(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    // Validate web search support
    if (options?.webSearch) {
      WebSearchUtils.validateWebSearchRequest('google', options.webSearch);
    }

    const request: any = {
      model: options?.model || this.currentModel,
      contents: [{
        role: 'user',
        parts: [{ text: prompt }]
      }],
      generationConfig: {
        temperature: options?.temperature,
        maxOutputTokens: options?.maxTokens,
        topK: 40,
        topP: 0.95
      }
    };

    // Add system instruction if provided
    if (options?.systemPrompt) {
      request.systemInstruction = {
        parts: [{ text: options.systemPrompt }]
      };
    }

    // Add web search grounding if requested
    // Google Search grounding uses special googleSearch tool, not a function
    if (options?.webSearch) {
      request.tools = [{ googleSearch: {} }];
    }

    const client = await this.getClient();
    const response = await client.models.generateContent(request);

    const extractedUsage = this.extractUsage(response);
    const finishReason = this.mapFinishReason(response.candidates?.[0]?.finishReason);
    const toolCalls = this.extractToolCalls(response);

    // Extract web search results if web search was enabled
    const webSearchResults = options?.webSearch
      ? this.extractGoogleSources(response)
      : undefined;

    const textContent = this.extractTextFromParts(response.candidates?.[0]?.content?.parts || []);

    return await this.buildLLMResponse(
      textContent,
      options?.model || this.currentModel,
      extractedUsage,
      { webSearchResults },
      finishReason,
      toolCalls
    );
  }

  // Private methods
  private convertTools(tools: any[]): any[] {
    // Gemini uses functionDeclarations wrapper (NOT OpenAI's flat array)
    return [{
      functionDeclarations: tools.map(tool => {
        if (tool.type === 'function') {
          // Handle both nested (Chat Completions) and flat (Responses API) formats
          const toolDef = tool.function || tool;
          return {
            name: toolDef.name,
            description: toolDef.description,
            parameters: this.sanitizeSchemaForGoogle(toolDef.parameters || toolDef.input_schema)
          };
        }
        return tool;
      })
    }];
  }

  /**
   * Sanitize JSON Schema for Google's simplified schema format
   * Delegates to SchemaValidator utility
   */
  private sanitizeSchemaForGoogle(schema: any): any {
    return SchemaValidator.sanitizeSchemaForGoogle(schema);
  }

  private extractToolCalls(response: any): any[] {
    // Extract from response.candidates[0].content.parts
    const parts = response.candidates?.[0]?.content?.parts || [];
    const toolCalls: any[] = [];

    for (const part of parts) {
      if (part.functionCall) {
        toolCalls.push({
          id: part.functionCall.name + '_' + Date.now(),
          type: 'function',
          function: {
            name: part.functionCall.name,
            arguments: JSON.stringify(part.functionCall.args || {})
          }
        });
      }
    }

    return toolCalls;
  }

  private extractTextFromParts(parts: any[]): string {
    return parts
      .filter(part => part.text)
      .map(part => part.text)
      .join('');
  }

  /**
   * Extract search results from Google response
   * Google may include sources in grounding chunks or tool results
   */
  private extractGoogleSources(response: any): SearchResult[] {
    try {
      const sources: SearchResult[] = [];

      // Check for grounding metadata (Google's web search citations)
      if (response.groundingMetadata?.webSearchQueries) {
        const groundingChunks = response.groundingMetadata.groundingChunks || [];
        for (const chunk of groundingChunks) {
          const result = WebSearchUtils.validateSearchResult({
            title: chunk.title || 'Unknown Source',
            url: chunk.web?.uri || chunk.uri,
            date: chunk.publishedDate
          });
          if (result) sources.push(result);
        }
      }

      // Check for function call results (if google_search tool was used)
      const functionCalls = response.functionCalls || [];
      for (const call of functionCalls) {
        if (call.name === 'google_search' && call.response) {
          try {
            const searchData = call.response;
            if (searchData.results && Array.isArray(searchData.results)) {
              const extractedSources = WebSearchUtils.extractSearchResults(searchData.results);
              sources.push(...extractedSources);
            }
          } catch (error) {
          }
        }
      }

      return sources;
    } catch (error) {
      return [];
    }
  }

  private mapFinishReason(reason: string | null): 'stop' | 'length' | 'tool_calls' | 'content_filter' {
    if (!reason) return 'stop';
    
    const reasonMap: Record<string, 'stop' | 'length' | 'tool_calls' | 'content_filter'> = {
      'STOP': 'stop',
      'MAX_TOKENS': 'length',
      'SAFETY': 'content_filter',
      'RECITATION': 'content_filter',
      'OTHER': 'stop'
    };
    return reasonMap[reason] || 'stop';
  }

  protected extractUsage(response: any): any {
    const usage = response.usageMetadata || response.usage;
    if (usage) {
      return {
        promptTokens: usage.promptTokenCount || usage.inputTokens || 0,
        completionTokens: usage.candidatesTokenCount || usage.outputTokens || 0,
        totalTokens: usage.totalTokenCount || usage.totalTokens || 0
      };
    }
    return undefined;
  }

  private getCostPer1kTokens(modelId: string): { input: number; output: number } | undefined {
    const model = GOOGLE_MODELS.find(m => m.apiName === modelId);
    if (!model) return undefined;
    
    return {
      input: model.inputCostPerMillion / 1000,
      output: model.outputCostPerMillion / 1000
    };
  }

  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    const costs = this.getCostPer1kTokens(modelId);
    if (!costs) return null;
    
    return {
      rateInputPerMillion: costs.input * 1000,
      rateOutputPerMillion: costs.output * 1000,
      currency: 'USD'
    };
  }
}
```

## services/llm/adapters/google/GoogleModels.ts

```typescript
/**
 * Google Model Specifications
 * Updated December 18, 2025 with Gemini 3 Flash release
 */

import { ModelSpec } from '../modelTypes';

export const GOOGLE_MODELS: ModelSpec[] = [
  // Gemini 3.0 models (latest)
  {
    provider: 'google',
    name: 'Gemini 3.0 Pro Preview',
    apiName: 'gemini-3-pro-preview',
    contextWindow: 1048576,
    maxTokens: 8192,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 12.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'google',
    name: 'Gemini 3.0 Flash Preview',
    apiName: 'gemini-3-flash-preview',
    contextWindow: 1048576,
    maxTokens: 65536,
    inputCostPerMillion: 0.50,
    outputCostPerMillion: 3.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  // Gemini 2.5 models
  {
    provider: 'google',
    name: 'Gemini 2.5 Pro',
    apiName: 'gemini-2.5-pro',
    contextWindow: 2000000,
    maxTokens: 8192,
    inputCostPerMillion: 1.25,
    outputCostPerMillion: 10.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'google',
    name: 'Gemini 2.5 Flash',
    apiName: 'gemini-2.5-flash',
    contextWindow: 1048576,
    maxTokens: 65536,
    inputCostPerMillion: 0.15,
    outputCostPerMillion: 0.60,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true  // Updated: 2.5 Flash now supports thinking mode
    }
  }
];

export const GOOGLE_DEFAULT_MODEL = 'gemini-3-pro-preview';
```

## services/llm/adapters/groq/GroqAdapter.ts

```typescript
/**
 * Groq Adapter with true streaming support and Ultra-Fast Inference
 * Leverages Groq's high-performance LLM serving infrastructure
 * Uses OpenAI-compatible streaming API with extended usage metrics
 * Based on official Groq SDK streaming documentation
 */

import Groq from 'groq-sdk';
import type { ChatCompletion, ChatCompletionChunk, ChatCompletionMessageToolCall, ChatCompletionMessageParam } from 'groq-sdk/resources/chat/completions';
import type { CompletionUsage } from 'groq-sdk/resources/completions';
import { BaseAdapter } from '../BaseAdapter';
import {
  GenerateOptions,
  StreamChunk,
  LLMResponse,
  ModelInfo,
  ProviderCapabilities,
  ModelPricing,
  Tool,
  TokenUsage
} from '../types';
import { GROQ_MODELS, GROQ_DEFAULT_MODEL } from './GroqModels';
import { MCPToolExecution } from '../shared/ToolExecutionUtils';

/**
 * Extended Groq chunk type with x_groq metadata
 * x_groq contains timing information (queue_time, prompt_time, completion_time)
 */
interface GroqChatCompletionChunk extends ChatCompletionChunk {
  usage?: CompletionUsage;
  x_groq?: {
    id?: string;
    error?: string;
    usage?: CompletionUsage;
  };
}

export class GroqAdapter extends BaseAdapter {
  readonly name = 'groq';
  readonly baseUrl = 'https://api.groq.com/openai/v1';

  private client: Groq;

  constructor(apiKey: string, model?: string) {
    super(apiKey, model || GROQ_DEFAULT_MODEL);

    this.client = new Groq({
      apiKey: this.apiKey,
      dangerouslyAllowBrowser: true
    });
    this.initializeCache();
  }

  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    try {
      const model = options?.model || this.currentModel;
      
      // Tool execution requires streaming - use generateStreamAsync instead
      if (options?.tools && options.tools.length > 0) {
        throw new Error('Tool execution requires streaming. Use generateStreamAsync() instead.');
      }

      // Use basic chat completions
      return await this.generateWithChatCompletions(prompt, options);
    } catch (error) {
      throw this.handleError(error, 'generation');
    }
  }

  /**
   * Generate streaming response using async generator
   * Uses unified stream processing with automatic tool call accumulation
   */
  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      const stream = await this.client.chat.completions.create({
        model: options?.model || this.currentModel,
        messages: this.buildMessages(prompt, options?.systemPrompt),
        temperature: options?.temperature,
        max_completion_tokens: options?.maxTokens,
        top_p: options?.topP,
        stop: options?.stopSequences,
        tools: options?.tools ? this.convertTools(options.tools) : undefined,
        response_format: options?.jsonMode ? { type: 'json_object' } : undefined,
        stream: true
      });

      // Use unified stream processing with automatic tool call accumulation
      yield* this.processStream(stream, {
        debugLabel: 'Groq',
        extractContent: (chunk) => chunk.choices[0]?.delta?.content || null,
        extractToolCalls: (chunk) => chunk.choices[0]?.delta?.tool_calls || null,
        extractFinishReason: (chunk) => chunk.choices[0]?.finish_reason || null,
        extractUsage: (chunk) => {
          // Groq has both standard usage and x_groq metadata
          const groqChunk = chunk as GroqChatCompletionChunk;
          if (groqChunk.usage || groqChunk.x_groq) {
            return {
              usage: groqChunk.usage,
              x_groq: groqChunk.x_groq
            };
          }
          return null;
        }
      });
    } catch (error) {
      console.error('[GroqAdapter] Streaming error:', error);
      throw error;
    }
  }

  async listModels(): Promise<ModelInfo[]> {
    try {
      return GROQ_MODELS.map(model => ({
        id: model.apiName,
        name: model.name,
        contextWindow: model.contextWindow,
        maxOutputTokens: model.maxTokens,
        supportsJSON: model.capabilities.supportsJSON,
        supportsImages: model.capabilities.supportsImages,
        supportsFunctions: model.capabilities.supportsFunctions,
        supportsStreaming: model.capabilities.supportsStreaming,
        supportsThinking: false,
        costPer1kTokens: {
          input: model.inputCostPerMillion / 1000,
          output: model.outputCostPerMillion / 1000
        },
        pricing: {
          inputPerMillion: model.inputCostPerMillion,
          outputPerMillion: model.outputCostPerMillion,
          currency: 'USD',
          lastUpdated: new Date().toISOString()
        }
      }));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }

  getCapabilities(): ProviderCapabilities {
    const baseCapabilities = {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsThinking: false,
      maxContextWindow: 128000,
      supportedFeatures: [
        'messages',
        'function_calling',
        'vision',
        'streaming',
        'json_mode',
        'ultra_fast_inference',
        'extended_metrics'
      ]
    };

    return baseCapabilities;
  }

  /**
   * Generate using standard chat completions
   */
  private async generateWithChatCompletions(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    const model = options?.model || this.currentModel;

    interface ChatCompletionParams {
      model: string;
      messages: ChatCompletionMessageParam[];
      temperature?: number;
      max_completion_tokens?: number;
      top_p?: number;
      stop?: string[];
      response_format?: { type: 'json_object' };
      tools?: Array<{ type: 'function'; function: { name: string; description: string; parameters: Record<string, any> } }>;
    }

    const chatParams: ChatCompletionParams = {
      model,
      // Safe cast: buildMessages creates objects compatible with ChatCompletionMessageParam
      messages: this.buildMessages(prompt, options?.systemPrompt) as ChatCompletionMessageParam[],
      temperature: options?.temperature,
      max_completion_tokens: options?.maxTokens,
      top_p: options?.topP,
      stop: options?.stopSequences,
      response_format: options?.jsonMode ? { type: 'json_object' } : undefined
    };

    // Add tools if provided
    if (options?.tools) {
      chatParams.tools = this.convertTools(options.tools);
    }

    const response = await this.client.chat.completions.create(chatParams);
    const choice = response.choices[0];
    
    if (!choice) {
      throw new Error('No response from Groq');
    }
    
    let text = choice.message?.content || '';
    const usage = this.extractUsage(response);
    const finishReason = this.mapFinishReason(choice.finish_reason);

    // If tools were provided and we got tool calls, we need to handle them
    // For now, just return the response as-is since tool execution is complex
    if (options?.tools && choice.message?.tool_calls && choice.message.tool_calls.length > 0) {
      text = text || '[AI requested tool calls but tool execution not available]';
    }

    return this.buildLLMResponse(
      text,
      model,
      usage,
      undefined,
      finishReason
    );
  }

  // Private methods
  private convertTools(tools: Tool[]): Array<{ type: 'function'; function: { name: string; description: string; parameters: Record<string, any> } }> {
    return tools.map(tool => {
      if (tool.type === 'function' && tool.function) {
        return {
          type: 'function' as const,
          function: {
            name: tool.function.name,
            description: tool.function.description,
            parameters: tool.function.parameters
          }
        };
      }
      // Fallback for malformed tools - should not happen with proper Tool type
      throw new Error(`Unsupported tool type: ${tool.type}`);
    });
  }

  private extractToolCalls(message: ChatCompletion['choices'][0]['message']): ChatCompletionMessageToolCall[] {
    return message?.tool_calls || [];
  }

  private mapFinishReason(reason: string | null): 'stop' | 'length' | 'tool_calls' | 'content_filter' {
    if (!reason) return 'stop';
    
    const reasonMap: Record<string, 'stop' | 'length' | 'tool_calls' | 'content_filter'> = {
      'stop': 'stop',
      'length': 'length',
      'tool_calls': 'tool_calls',
      'content_filter': 'content_filter'
    };
    return reasonMap[reason] || 'stop';
  }

  protected extractUsage(response: ChatCompletion | GroqChatCompletionChunk): TokenUsage | undefined {
    const usage = response?.usage;
    if (usage) {
      const groqResponse = response as GroqChatCompletionChunk;
      return {
        promptTokens: usage.prompt_tokens || 0,
        completionTokens: usage.completion_tokens || 0,
        totalTokens: usage.total_tokens || 0,
        // Groq-specific extended metrics (queue_time, prompt_time, completion_time)
        // These are available directly on CompletionUsage from Groq SDK
        ...(usage.queue_time !== undefined && { queueTime: usage.queue_time }),
        ...(usage.prompt_time !== undefined && { promptTime: usage.prompt_time }),
        ...(usage.completion_time !== undefined && { completionTime: usage.completion_time })
      } as TokenUsage & { queueTime?: number; promptTime?: number; completionTime?: number };
    }
    return undefined;
  }

  private getCostPer1kTokens(modelId: string): { input: number; output: number } | undefined {
    const model = GROQ_MODELS.find(m => m.apiName === modelId);
    if (!model) return undefined;
    
    return {
      input: model.inputCostPerMillion / 1000,
      output: model.outputCostPerMillion / 1000
    };
  }

  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    const costs = this.getCostPer1kTokens(modelId);
    if (!costs) return null;
    
    return {
      rateInputPerMillion: costs.input * 1000,
      rateOutputPerMillion: costs.output * 1000,
      currency: 'USD'
    };
  }
}
```

## services/llm/adapters/groq/GroqModels.ts

```typescript
/**
 * Groq Model Specifications
 * Updated June 17, 2025 with latest Groq model releases
 * 
 * Groq provides ultra-fast inference with OpenAI-compatible API
 * Specializes in high-performance LLM serving with extended usage metrics
 */

import { ModelSpec } from '../modelTypes';

export const GROQ_MODELS: ModelSpec[] = [
  // Current Production Models (January 2025)
  
  // Llama 3.1 models - Text generation
  {
    provider: 'groq',
    name: 'Llama 3.1 70B Versatile',
    apiName: 'llama-3.1-70b-versatile',
    contextWindow: 131072,
    maxTokens: 8192,
    inputCostPerMillion: 0.59,
    outputCostPerMillion: 0.79,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'groq',
    name: 'Llama 3.1 8B Instant',
    apiName: 'llama-3.1-8b-instant',
    contextWindow: 131072,
    maxTokens: 8192,
    inputCostPerMillion: 0.05,
    outputCostPerMillion: 0.08,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Llama 3.3 models
  {
    provider: 'groq',
    name: 'Llama 3.3 70B Versatile',
    apiName: 'llama-3.3-70b-versatile',
    contextWindow: 128000,
    maxTokens: 32768,
    inputCostPerMillion: 0.59,
    outputCostPerMillion: 0.79,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Gemma models
  {
    provider: 'groq',
    name: 'Gemma 2 9B IT',
    apiName: 'gemma2-9b-it',
    contextWindow: 8192,
    maxTokens: 8192,
    inputCostPerMillion: 0.20,
    outputCostPerMillion: 0.20,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // New Llama 4 models
  {
    provider: 'groq',
    name: 'Llama 4 Scout',
    apiName: 'llama-4-scout-17bx16e',
    contextWindow: 128000,
    maxTokens: 8192,
    inputCostPerMillion: 0.11,
    outputCostPerMillion: 0.34,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'groq',
    name: 'Llama 4 Maverick',
    apiName: 'llama-4-maverick-17bx128e',
    contextWindow: 128000,
    maxTokens: 8192,
    inputCostPerMillion: 0.20,
    outputCostPerMillion: 0.60,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Content moderation model
  {
    provider: 'groq',
    name: 'Llama Guard 4 12B',
    apiName: 'meta-llama/llama-guard-4-12b',
    contextWindow: 131072,
    maxTokens: 128,
    inputCostPerMillion: 0.20,
    outputCostPerMillion: 0.20,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // OpenAI models on Groq
  {
    provider: 'groq',
    name: 'GPT OSS 20B',
    apiName: 'openai/gpt-oss-20b',
    contextWindow: 131072,
    maxTokens: 32768,
    inputCostPerMillion: 0.10,
    outputCostPerMillion: 0.50,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'groq',
    name: 'GPT OSS 120B',
    apiName: 'openai/gpt-oss-120b',
    contextWindow: 131072,
    maxTokens: 32766,
    inputCostPerMillion: 0.149,
    outputCostPerMillion: 0.769,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },

  // Preview models
  {
    provider: 'groq',
    name: 'DeepSeek R1 Distill Llama 70B',
    apiName: 'deepseek-r1-distill-llama-70b',
    contextWindow: 128000,
    maxTokens: 8192,
    inputCostPerMillion: 0.75,
    outputCostPerMillion: 0.99,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'groq',
    name: 'Qwen 3 32B',
    apiName: 'qwen/qwen3-32b',
    contextWindow: 128000,
    maxTokens: 16384,
    inputCostPerMillion: 0.29,
    outputCostPerMillion: 0.59,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  }
];

export const GROQ_DEFAULT_MODEL = 'llama-3.1-70b-versatile';

/**
 * Groq-specific model categories for easier selection
 */
export const GROQ_MODEL_CATEGORIES = {
  // Ultra-fast text generation
  FAST_TEXT: [
    'llama-3.1-8b-instant',
    'gemma2-9b-it'
  ],
  
  // High-quality text generation
  QUALITY_TEXT: [
    'llama-3.1-70b-versatile',
    'llama-3.3-70b-versatile',
    'llama-4-maverick-17bx128e'
  ],
  
  // New Llama 4 models
  LLAMA_4: [
    'llama-4-scout-17bx16e',
    'llama-4-maverick-17bx128e'
  ],
  
  // Reasoning-optimized
  REASONING: [
    'deepseek-r1-distill-llama-70b'
  ],
  
  // Content moderation
  MODERATION: [
    'meta-llama/llama-guard-4-12b'
  ],
  
  // Preview/experimental models
  PREVIEW: [
    'deepseek-r1-distill-llama-70b',
    'qwen/qwen3-32b'
  ]
};

/**
 * Get models by category
 */
export function getGroqModelsByCategory(category: keyof typeof GROQ_MODEL_CATEGORIES): ModelSpec[] {
  const modelNames = GROQ_MODEL_CATEGORIES[category];
  return GROQ_MODELS.filter(model => modelNames.includes(model.apiName));
}

/**
 * Check if a model supports specific capabilities
 */
export function getGroqModelCapabilities(modelName: string): ModelSpec['capabilities'] | null {
  const model = GROQ_MODELS.find(m => m.apiName === modelName);
  return model?.capabilities || null;
}
```

## services/llm/adapters/lmstudio/LMStudioAdapter.ts

```typescript
/**
 * LM Studio Adapter
 * Provides local LLM models via LM Studio's OpenAI-compatible API
 * Supports model auto-discovery, streaming, and function calling
 *
 * Uses the standard /v1/chat/completions API for reliable conversation handling.
 * Supports multiple tool calling formats (native tool_calls, [TOOL_CALLS], XML, etc.)
 * via ToolCallContentParser.
 */

import { requestUrl } from 'obsidian';
import { BaseAdapter } from '../BaseAdapter';
import {
  GenerateOptions,
  StreamChunk,
  LLMResponse,
  ModelInfo,
  ProviderCapabilities,
  ModelPricing,
  TokenUsage,
  LLMProviderError
} from '../types';
import { ToolCallContentParser } from './ToolCallContentParser';
import { usesCustomToolFormat } from '../../../chat/builders/ContextBuilderFactory';

export class LMStudioAdapter extends BaseAdapter {
  readonly name = 'lmstudio';
  readonly baseUrl: string;

  private serverUrl: string;

  constructor(serverUrl: string) {
    // LM Studio doesn't need an API key - set requiresApiKey to false
    super('', '', serverUrl, false);

    this.serverUrl = serverUrl;
    this.baseUrl = serverUrl;

    this.initializeCache();
  }

  /**
   * Generate response without caching using /v1/chat/completions
   * Uses Obsidian's requestUrl to bypass CORS
   */
  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    const model = options?.model || this.currentModel;

    let messages: any[];
    if (options?.conversationHistory && options.conversationHistory.length > 0) {
      messages = options.conversationHistory;
    } else {
      messages = this.buildMessages(prompt, options?.systemPrompt);
    }

    const requestBody: any = {
      model: model,
      messages: messages,
      stream: false,
      temperature: options?.temperature,
      max_tokens: options?.maxTokens,
      top_p: options?.topP,
      frequency_penalty: options?.frequencyPenalty,
      presence_penalty: options?.presencePenalty,
      stop: options?.stopSequences
    };

    const skipToolSchemas = LMStudioAdapter.usesToolCallsContentFormat(model);
    if (options?.tools && options.tools.length > 0 && !skipToolSchemas) {
      requestBody.tools = this.convertTools(options.tools);
    }

    if (options?.jsonMode) {
      requestBody.response_format = { type: 'json_object' };
    }

    Object.keys(requestBody).forEach(key => {
      if (requestBody[key] === undefined) {
        delete requestBody[key];
      }
    });

    const response = await requestUrl({
      url: `${this.serverUrl}/v1/chat/completions`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody)
    });

    if (response.status !== 200) {
      throw new LLMProviderError(
        `LM Studio API error: ${response.status} - ${response.text || 'Unknown error'}`,
        'generation',
        'API_ERROR'
      );
    }

    const data = response.json;

    if (!data.choices || !data.choices[0]) {
      throw new LLMProviderError(
        'Invalid response format from LM Studio API: missing choices',
        'generation',
        'INVALID_RESPONSE'
      );
    }

    const choice = data.choices[0];
    let content = choice.message?.content || '';
    let toolCalls = choice.message?.tool_calls || [];

    if (ToolCallContentParser.hasToolCallsFormat(content)) {
      const parsed = ToolCallContentParser.parse(content);
      if (parsed.hasToolCalls) {
        if (toolCalls.length === 0) {
          toolCalls = parsed.toolCalls;
        }
        content = parsed.cleanContent;
      }
    }

    const usage: TokenUsage = {
      promptTokens: data.usage?.prompt_tokens || 0,
      completionTokens: data.usage?.completion_tokens || 0,
      totalTokens: data.usage?.total_tokens || 0
    };

    return await this.buildLLMResponse(
      content,
      model,
      usage,
      { cached: false, model: data.model, id: data.id },
      toolCalls.length > 0 ? 'tool_calls' : this.mapFinishReason(choice.finish_reason),
      toolCalls
    );
  }

  /**
   * Generate streaming response using /v1/chat/completions
   * Supports multiple tool calling formats via ToolCallContentParser
   */
  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    const model = options?.model || this.currentModel;

    // Check for pre-built conversation history (tool continuations)
    let messages: any[];
    if (options?.conversationHistory && options.conversationHistory.length > 0) {
      messages = options.conversationHistory;
    } else {
      messages = this.buildMessages(prompt, options?.systemPrompt);
    }

    const requestBody: any = {
      model: model,
      messages: messages,
      stream: true,
      temperature: options?.temperature,
      max_tokens: options?.maxTokens,
      top_p: options?.topP,
      frequency_penalty: options?.frequencyPenalty,
      presence_penalty: options?.presencePenalty,
      stop: options?.stopSequences
    };

    // Add tools if provided
    const skipToolSchemas = LMStudioAdapter.usesToolCallsContentFormat(model);
    if (options?.tools && options.tools.length > 0 && !skipToolSchemas) {
      requestBody.tools = this.convertTools(options.tools);
    }

    // Remove undefined values
    Object.keys(requestBody).forEach(key => {
      if (requestBody[key] === undefined) {
        delete requestBody[key];
      }
    });

    const response = await fetch(`${this.serverUrl}/v1/chat/completions`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new LLMProviderError(
        `LM Studio API error: ${response.status} - ${errorText}`,
        'streaming',
        'API_ERROR'
      );
    }

    let accumulatedContent = '';
    let hasToolCallsFormat = false;

    for await (const chunk of this.processSSEStream(response, {
      debugLabel: 'LM Studio (legacy)',
      extractContent: (parsed) => parsed.choices?.[0]?.delta?.content || null,
      extractToolCalls: (parsed) => parsed.choices?.[0]?.delta?.tool_calls || null,
      extractFinishReason: (parsed) => parsed.choices?.[0]?.finish_reason || null,
      extractUsage: (parsed) => parsed.usage,
      accumulateToolCalls: true
    })) {
      if (chunk.content) {
        accumulatedContent += chunk.content;
      }

      if (!hasToolCallsFormat && ToolCallContentParser.hasToolCallsFormat(accumulatedContent)) {
        hasToolCallsFormat = true;
      }

      if (hasToolCallsFormat) {
        if (chunk.complete) {
          const parsed = ToolCallContentParser.parse(accumulatedContent);
          yield {
            content: parsed.cleanContent,
            complete: true,
            toolCalls: parsed.hasToolCalls ? parsed.toolCalls : undefined,
            toolCallsReady: parsed.hasToolCalls,
            usage: chunk.usage
          };
        }
      } else {
        yield chunk;
      }
    }
  }

  /**
   * Convert tools to Responses API format
   */
  private convertToolsForResponsesApi(tools: any[]): any[] {
    return tools.map((tool: any) => {
      if (tool.function) {
        return {
          type: 'function',
          name: tool.function.name,
          description: tool.function.description,
          parameters: tool.function.parameters
        };
      }
      return tool;
    });
  }

  /**
   * Convert Chat Completions format messages to Responses API input
   *
   * Chat Completions format:
   * - { role: 'user', content: '...' }
   * - { role: 'assistant', content: '...', tool_calls: [...] }
   * - { role: 'tool', tool_call_id: '...', content: '...' }
   *
   * Responses API input:
   * - { role: 'user', content: '...' }
   * - { role: 'assistant', content: '...' } OR function_call items
   * - { type: 'function_call_output', call_id: '...', output: '...' }
   */
  private convertChatCompletionsToResponsesInput(messages: any[], systemPrompt?: string): any[] {
    const input: any[] = [];

    // Add system prompt first if provided
    if (systemPrompt) {
      input.push({ role: 'system', content: systemPrompt });
    }

    for (const msg of messages) {
      if (msg.role === 'user') {
        input.push({ role: 'user', content: msg.content || '' });
      } else if (msg.role === 'assistant') {
        if (msg.tool_calls && msg.tool_calls.length > 0) {
          // Add text content if present
          if (msg.content && msg.content.trim()) {
            input.push({ role: 'assistant', content: msg.content });
          }
          // Convert tool_calls to function_call items
          for (const tc of msg.tool_calls) {
            input.push({
              type: 'function_call',
              call_id: tc.id,
              name: tc.function?.name || '',
              arguments: tc.function?.arguments || '{}'
            });
          }
        } else {
          // Plain assistant message
          input.push({ role: 'assistant', content: msg.content || '' });
        }
      } else if (msg.role === 'tool') {
        // Convert tool result to function_call_output
        input.push({
          type: 'function_call_output',
          call_id: msg.tool_call_id,
          output: msg.content || '{}'
        });
      } else if (msg.role === 'system') {
        // System messages (shouldn't be here but handle gracefully)
        input.push({ role: 'system', content: msg.content || '' });
      }
    }

    return input;
  }

  /**
   * List available models by querying LM Studio's /v1/models endpoint
   * Discovers loaded models dynamically
   */
  async listModels(): Promise<ModelInfo[]> {
    try {
      // Use Obsidian's requestUrl to bypass CORS
      const response = await requestUrl({
        url: `${this.serverUrl}/v1/models`,
        method: 'GET'
      });

      if (response.status !== 200) {
        // Server returned error - silently return empty (server may not be ready)
        return [];
      }

      const data = response.json;

      if (!data.data || !Array.isArray(data.data)) {
        // Unexpected response format - silently return empty
        return [];
      }

      return data.data.map((model: any) => {
        const modelId = model.id;
        const isVisionModel = this.detectVisionSupport(modelId);
        const supportsTools = this.detectToolSupport(modelId);

        return {
          id: modelId,
          name: modelId,
          contextWindow: model.context_length || 4096,
          maxOutputTokens: model.max_tokens || 2048,
          supportsJSON: true, // Most models support JSON mode
          supportsImages: isVisionModel,
          supportsFunctions: supportsTools,
          supportsStreaming: true,
          supportsThinking: false,
          pricing: {
            inputPerMillion: 0, // Local models are free
            outputPerMillion: 0,
            currency: 'USD',
            lastUpdated: new Date().toISOString()
          }
        };
      });
    } catch {
      // Server not reachable - silently return empty (app probably not running)
      return [];
    }
  }

  getCapabilities(): ProviderCapabilities {
    return {
      supportsStreaming: true,
      supportsJSON: true, // Most models support JSON mode
      supportsImages: false, // Depends on specific model
      supportsFunctions: true, // Many models support function calling via OpenAI-compatible API
      supportsThinking: false,
      maxContextWindow: 128000, // Varies by model, reasonable default
      supportedFeatures: ['streaming', 'function_calling', 'json_mode', 'local', 'privacy']
    };
  }

  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    // Local models are free - zero rates
    const pricing: ModelPricing = {
      rateInputPerMillion: 0,
      rateOutputPerMillion: 0,
      currency: 'USD'
    };

    return pricing;
  }

  async isAvailable(): Promise<boolean> {
    try {
      const response = await requestUrl({
        url: `${this.serverUrl}/v1/models`,
        method: 'GET'
      });
      return response.status === 200;
    } catch (error) {
      return false;
    }
  }

  /**
   * Convert tools from Chat Completions format to ensure compatibility
   * Handles both flat and nested tool formats
   */
  private convertTools(tools: any[]): any[] {
    return tools.map((tool: any) => {
      // If already in flat format {type, name, description, parameters}, return as-is
      if (tool.name && !tool.function) {
        return tool;
      }

      // If in nested format {type, function: {name, description, parameters}}, flatten it
      if (tool.function) {
        return {
          type: 'function',
          function: {
            name: tool.function.name,
            description: tool.function.description,
            parameters: tool.function.parameters
          }
        };
      }

      return tool;
    });
  }

  /**
   * Detect if a model supports vision based on name patterns
   */
  private detectVisionSupport(modelId: string): boolean {
    const visionKeywords = ['vision', 'llava', 'bakllava', 'cogvlm', 'yi-vl', 'moondream'];
    const lowerModelId = modelId.toLowerCase();
    return visionKeywords.some(keyword => lowerModelId.includes(keyword));
  }

  /**
   * Detect if a model supports tool/function calling based on name patterns
   * Many newer models support function calling
   *
   * Note: Models with "nexus" or "tools" in the name likely use [TOOL_CALLS] format
   * which is automatically parsed by this adapter
   */
  private detectToolSupport(modelId: string): boolean {
    const toolSupportedKeywords = [
      'gpt', 'mistral', 'mixtral', 'hermes', 'nous', 'qwen',
      'deepseek', 'dolphin', 'functionary', 'gorilla',
      // Fine-tuned models that use [TOOL_CALLS] format
      'nexus', 'tools-sft', 'tool-calling'
    ];
    const lowerModelId = modelId.toLowerCase();
    return toolSupportedKeywords.some(keyword => lowerModelId.includes(keyword));
  }

  /**
   * Check if a model uses custom tool call format (<tool_call> or [TOOL_CALLS])
   * These are fine-tuned models that have internalized tool schemas and don't need
   * tool schemas passed via the API - they output tool calls as content.
   *
   * Delegates to centralized check in ContextBuilderFactory for consistency.
   */
  static usesToolCallsContentFormat(modelId: string): boolean {
    return usesCustomToolFormat(modelId);
  }

  /**
   * Map OpenAI finish reasons to our standard types
   */
  private mapFinishReason(reason: string | undefined): 'stop' | 'length' | 'tool_calls' | 'content_filter' {
    if (!reason) return 'stop';

    switch (reason) {
      case 'stop':
        return 'stop';
      case 'length':
      case 'max_tokens':
        return 'length';
      case 'tool_calls':
      case 'function_call':
        return 'tool_calls';
      case 'content_filter':
        return 'content_filter';
      default:
        return 'stop';
    }
  }

  protected buildMessages(prompt: string, systemPrompt?: string): any[] {
    const messages = [];

    if (systemPrompt) {
      messages.push({ role: 'system', content: systemPrompt });
    }

    messages.push({ role: 'user', content: prompt });

    return messages;
  }

  protected handleError(error: any, operation: string): never {
    if (error instanceof LLMProviderError) {
      throw error;
    }

    let message = `LM Studio ${operation} failed`;
    let code = 'UNKNOWN_ERROR';

    if (error?.message) {
      message += `: ${error.message}`;
    }

    if (error?.code === 'ECONNREFUSED') {
      message = 'Cannot connect to LM Studio server. Make sure LM Studio is running and the server is started.';
      code = 'CONNECTION_REFUSED';
    } else if (error?.code === 'ENOTFOUND') {
      message = 'LM Studio server not found. Check the URL configuration.';
      code = 'SERVER_NOT_FOUND';
    }

    throw new LLMProviderError(message, this.name, code, error);
  }
}

```

## services/llm/adapters/lmstudio/LMStudioModels.ts

```typescript
/**
 * LM Studio Model Specifications
 * Models are discovered dynamically from the LM Studio server
 * This file provides helper functions and type definitions
 */

import { ModelSpec } from '../modelTypes';

/**
 * LM Studio uses dynamic model discovery via /v1/models endpoint
 * Models are loaded by the user and can vary
 * No static model list needed - adapter queries server for available models
 */

/**
 * Create a dynamic model spec from LM Studio model data
 * Used when models are discovered from the server
 */
export function createLMStudioModelSpec(
  modelId: string,
  contextWindow?: number,
  maxTokens?: number
): ModelSpec {
  return {
    provider: 'lmstudio',
    name: modelId,
    apiName: modelId,
    contextWindow: contextWindow || 4096,
    maxTokens: maxTokens || 2048,
    inputCostPerMillion: 0, // Local models are free
    outputCostPerMillion: 0,
    capabilities: {
      supportsJSON: true,
      supportsImages: detectVisionSupport(modelId),
      supportsFunctions: detectToolSupport(modelId),
      supportsStreaming: true,
      supportsThinking: false
    }
  };
}

/**
 * Detect if a model supports vision based on common name patterns
 */
function detectVisionSupport(modelId: string): boolean {
  const visionKeywords = ['vision', 'llava', 'bakllava', 'cogvlm', 'yi-vl', 'moondream'];
  const lowerModelId = modelId.toLowerCase();
  return visionKeywords.some(keyword => lowerModelId.includes(keyword));
}

/**
 * Detect if a model supports tool/function calling based on common name patterns
 * Many newer models support function calling
 *
 * Note: Models with "nexus" or "tools-sft" use [TOOL_CALLS] content format
 */
function detectToolSupport(modelId: string): boolean {
  const toolSupportedKeywords = [
    'gpt', 'mistral', 'mixtral', 'hermes', 'nous', 'qwen',
    'deepseek', 'dolphin', 'functionary', 'gorilla',
    // Fine-tuned models with [TOOL_CALLS] format
    'nexus', 'tools-sft', 'tool-calling'
  ];
  const lowerModelId = modelId.toLowerCase();
  return toolSupportedKeywords.some(keyword => lowerModelId.includes(keyword));
}

/**
 * Common LM Studio model families and their typical characteristics
 * Used for display purposes and capability hints
 */
export const LM_STUDIO_MODEL_FAMILIES = {
  llama: {
    name: 'Llama',
    description: 'Meta\'s Llama models - general purpose, high quality',
    typical: {
      contextWindow: 4096,
      supportsJSON: true,
      supportsFunctions: true
    }
  },
  mistral: {
    name: 'Mistral',
    description: 'Mistral AI models - efficient and capable',
    typical: {
      contextWindow: 8192,
      supportsJSON: true,
      supportsFunctions: true
    }
  },
  phi: {
    name: 'Phi',
    description: 'Microsoft Phi models - compact and efficient',
    typical: {
      contextWindow: 2048,
      supportsJSON: true,
      supportsFunctions: false
    }
  },
  qwen: {
    name: 'Qwen',
    description: 'Alibaba Qwen models - multilingual and capable',
    typical: {
      contextWindow: 8192,
      supportsJSON: true,
      supportsFunctions: true
    }
  },
  deepseek: {
    name: 'DeepSeek',
    description: 'DeepSeek models - coding and reasoning focused',
    typical: {
      contextWindow: 16384,
      supportsJSON: true,
      supportsFunctions: true
    }
  }
};

/**
 * Get model family information if available
 */
export function getModelFamily(modelId: string) {
  const lowerModelId = modelId.toLowerCase();

  for (const [familyKey, familyInfo] of Object.entries(LM_STUDIO_MODEL_FAMILIES)) {
    if (lowerModelId.includes(familyKey)) {
      return familyInfo;
    }
  }

  return null;
}

```

## services/llm/adapters/lmstudio/ToolCallContentParser.ts

```typescript
/**
 * ToolCallContentParser
 *
 * Re-export from shared/ for backwards compatibility.
 * The canonical implementation is now in adapters/shared/ToolCallContentParser.ts
 *
 * @deprecated Import from '../shared/ToolCallContentParser' instead
 */

export { ToolCallContentParser } from '../shared/ToolCallContentParser';
export type { ParsedToolCallResult, RawToolCall } from '../shared/ToolCallContentParser';

```

## services/llm/adapters/mistral/MistralAdapter.ts

```typescript
/**
 * Mistral AI Adapter with true streaming support
 * Implements Mistral's native streaming using client.chat.stream()
 * Based on official Mistral TypeScript SDK documentation
 */

import { Mistral } from '@mistralai/mistralai';
import { BaseAdapter } from '../BaseAdapter';
import { 
  GenerateOptions, 
  StreamChunk, 
  LLMResponse, 
  ModelInfo, 
  ProviderCapabilities,
  ModelPricing
} from '../types';
import { MISTRAL_MODELS, MISTRAL_DEFAULT_MODEL } from './MistralModels';
import { MCPToolExecution } from '../shared/ToolExecutionUtils';

export class MistralAdapter extends BaseAdapter {
  readonly name = 'mistral';
  readonly baseUrl = 'https://api.mistral.ai';

  private client: Mistral;

  constructor(apiKey: string, model?: string) {
    super(apiKey, model || MISTRAL_DEFAULT_MODEL);

    this.client = new Mistral({ apiKey: this.apiKey });
    this.initializeCache();
  }

  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    try {
      const model = options?.model || this.currentModel;
      
      // Tool execution requires streaming - use generateStreamAsync instead
      if (options?.tools && options.tools.length > 0) {
        throw new Error('Tool execution requires streaming. Use generateStreamAsync() instead.');
      }

      // Use basic chat completions
      return await this.generateWithChatCompletions(prompt, options);
    } catch (error) {
      throw this.handleError(error, 'generation');
    }
  }

  /**
   * Generate streaming response using async generator
   * Uses unified stream processing with automatic tool call accumulation
   */
  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      const result = await this.client.chat.stream({
        model: options?.model || this.currentModel,
        messages: this.buildMessages(prompt, options?.systemPrompt),
        temperature: options?.temperature,
        maxTokens: options?.maxTokens,
        topP: options?.topP,
        stop: options?.stopSequences,
        tools: options?.tools ? this.convertTools(options.tools) : undefined
      });

      // Use unified stream processing with automatic tool call accumulation
      // Note: Mistral SDK wraps chunks in .data property
      yield* this.processStream(result, {
        debugLabel: 'Mistral',
        extractContent: (chunk) => chunk.data?.choices[0]?.delta?.content || null,
        extractToolCalls: (chunk) => chunk.data?.choices[0]?.delta?.tool_calls || null,
        extractFinishReason: (chunk) => chunk.data?.choices[0]?.finish_reason || null,
        extractUsage: (chunk) => chunk.data?.usage || null
      });
    } catch (error) {
      console.error('[MistralAdapter] Streaming error:', error);
      throw error;
    }
  }

  async listModels(): Promise<ModelInfo[]> {
    try {
      return MISTRAL_MODELS.map(model => ({
        id: model.apiName,
        name: model.name,
        contextWindow: model.contextWindow,
        maxOutputTokens: model.maxTokens,
        supportsJSON: model.capabilities.supportsJSON,
        supportsImages: model.capabilities.supportsImages,
        supportsFunctions: model.capabilities.supportsFunctions,
        supportsStreaming: model.capabilities.supportsStreaming,
        supportsThinking: false,
        costPer1kTokens: {
          input: model.inputCostPerMillion / 1000,
          output: model.outputCostPerMillion / 1000
        },
        pricing: {
          inputPerMillion: model.inputCostPerMillion,
          outputPerMillion: model.outputCostPerMillion,
          currency: 'USD',
          lastUpdated: new Date().toISOString()
        }
      }));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }

  getCapabilities(): ProviderCapabilities {
    const baseCapabilities = {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsThinking: false,
      maxContextWindow: 128000,
      supportedFeatures: [
        'messages',
        'function_calling',
        'streaming',
        'json_mode'
      ]
    };

    return baseCapabilities;
  }

  /**
   * Generate using standard chat completions
   */
  private async generateWithChatCompletions(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    const model = options?.model || this.currentModel;
    
    const chatParams: any = {
      model,
      messages: this.buildMessages(prompt, options?.systemPrompt),
      temperature: options?.temperature,
      maxTokens: options?.maxTokens,
      topP: options?.topP,
      stop: options?.stopSequences
    };

    // Add tools if provided
    if (options?.tools) {
      chatParams.tools = this.convertTools(options.tools);
    }

    const response = await this.client.chat.complete(chatParams);
    const choice = response.choices[0];
    
    if (!choice) {
      throw new Error('No response from Mistral');
    }
    
    let text = this.extractMessageContent(choice.message?.content) || '';
    const usage = this.extractUsage(response);
    let finishReason = choice.finishReason || 'stop';

    // If tools were provided and we got tool calls, return placeholder text
    if (options?.tools && choice.message?.toolCalls && choice.message.toolCalls.length > 0) {
      text = text || '[AI requested tool calls but tool execution not available]';
    }

    return this.buildLLMResponse(
      text,
      model,
      usage,
      undefined,
      finishReason as 'stop' | 'length' | 'tool_calls' | 'content_filter'
    );
  }

  // Private methods
  private convertTools(tools: any[]): any[] {
    return tools.map(tool => {
      if (tool.type === 'function') {
        // Handle both nested (Chat Completions) and flat (Responses API) formats
        const toolDef = tool.function || tool;
        return {
          type: 'function',
          function: {
            name: toolDef.name,
            description: toolDef.description,
            parameters: toolDef.parameters || toolDef.input_schema
          }
        };
      }
      return tool;
    });
  }

  private extractToolCalls(message: any): any[] {
    return message?.toolCalls || [];
  }

  private extractMessageContent(content: any): string {
    if (typeof content === 'string') {
      return content;
    }
    if (Array.isArray(content)) {
      return content
        .filter(chunk => chunk.type === 'text')
        .map(chunk => chunk.text || '')
        .join('');
    }
    return '';
  }

  private mapFinishReason(reason: string | null): 'stop' | 'length' | 'tool_calls' | 'content_filter' {
    if (!reason) return 'stop';
    
    const reasonMap: Record<string, 'stop' | 'length' | 'tool_calls' | 'content_filter'> = {
      'stop': 'stop',
      'length': 'length',
      'tool_calls': 'tool_calls',
      'model_length': 'length',
      'content_filter': 'content_filter'
    };
    return reasonMap[reason] || 'stop';
  }

  protected extractUsage(response: any): any {
    const usage = response.usage;
    if (usage) {
      return {
        promptTokens: usage.prompt_tokens || 0,
        completionTokens: usage.completion_tokens || 0,
        totalTokens: usage.total_tokens || 0
      };
    }
    return undefined;
  }

  private getCostPer1kTokens(modelId: string): { input: number; output: number } | undefined {
    const model = MISTRAL_MODELS.find(m => m.apiName === modelId);
    if (!model) return undefined;
    
    return {
      input: model.inputCostPerMillion / 1000,
      output: model.outputCostPerMillion / 1000
    };
  }

  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    const costs = this.getCostPer1kTokens(modelId);
    if (!costs) return null;
    
    return {
      rateInputPerMillion: costs.input * 1000,
      rateOutputPerMillion: costs.output * 1000,
      currency: 'USD'
    };
  }
}
```

## services/llm/adapters/mistral/MistralModels.ts

```typescript
/**
 * Mistral Model Specifications
 * Updated June 17, 2025 with latest Mistral releases
 */

import { ModelSpec } from '../modelTypes';

export const MISTRAL_MODELS: ModelSpec[] = [
  {
    provider: 'mistral',
    name: 'Mistral Large Latest',
    apiName: 'mistral-large-latest',
    contextWindow: 128000,
    maxTokens: 8192,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 6.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'mistral',
    name: 'Mistral Medium Latest',
    apiName: 'mistral-medium-latest',
    contextWindow: 128000,
    maxTokens: 8192,
    inputCostPerMillion: 0.40,
    outputCostPerMillion: 2.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'mistral',
    name: 'Mistral Saba',
    apiName: 'mistral-saba-latest',
    contextWindow: 128000,
    maxTokens: 4096,
    inputCostPerMillion: 0.20,
    outputCostPerMillion: 0.60,
    capabilities: {
      supportsJSON: false,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'mistral',
    name: 'Magistral Medium',
    apiName: 'magistral-medium-latest',
    contextWindow: 40000,
    maxTokens: 40000,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 5.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: true
    }
  }
];

export const MISTRAL_DEFAULT_MODEL = 'mistral-large-latest';
```

## services/llm/adapters/ModelRegistry.ts

```typescript
/**
 * Centralized AI Model Registry
 * 
 * This file imports all provider-specific model definitions and provides
 * a unified interface for working with models across all providers.
 * 
 * Updated June 17, 2025 with modular provider structure
 */

import { ModelSpec } from './modelTypes';
import { OPENAI_MODELS, OPENAI_DEFAULT_MODEL } from './openai/OpenAIModels';
import { GOOGLE_MODELS, GOOGLE_DEFAULT_MODEL } from './google/GoogleModels';
import { ANTHROPIC_MODELS, ANTHROPIC_DEFAULT_MODEL } from './anthropic/AnthropicModels';
import { MISTRAL_MODELS, MISTRAL_DEFAULT_MODEL } from './mistral/MistralModels';
import { OPENROUTER_MODELS, OPENROUTER_DEFAULT_MODEL } from './openrouter/OpenRouterModels';
import { REQUESTY_MODELS, REQUESTY_DEFAULT_MODEL } from './requesty/RequestyModels';
import { GROQ_MODELS, GROQ_DEFAULT_MODEL } from './groq/GroqModels';
import type { LLMProviderSettings } from '../../../types';

// Re-export ModelSpec for convenience
export type { ModelSpec };

/**
 * Complete model registry organized by provider
 * Reconstructed from individual provider model definitions
 * Note: Ollama models are dynamically generated based on user configuration
 */
export const AI_MODELS: Record<string, ModelSpec[]> = {
  openai: OPENAI_MODELS,
  google: GOOGLE_MODELS,
  anthropic: ANTHROPIC_MODELS,
  mistral: MISTRAL_MODELS,
  openrouter: OPENROUTER_MODELS,
  requesty: REQUESTY_MODELS,
  groq: GROQ_MODELS
};

/**
 * Helper functions for working with the model registry
 */
export class ModelRegistry {
  /**
   * Get all models for a specific provider
   * For Ollama, returns user-configured model dynamically
   * For LM Studio, returns empty array (models discovered via adapter.listModels())
   */
  static getProviderModels(provider: string, settings?: LLMProviderSettings): ModelSpec[] {
    // Special handling for Ollama - user-configured models only
    if (provider === 'ollama') {
      const ollamaModel = settings?.providers?.ollama?.ollamaModel;

      if (!ollamaModel || !ollamaModel.trim()) {
        return []; // No models if not configured
      }

      // Create dynamic ModelSpec for user's configured model
      return [{
        provider: 'ollama',
        name: ollamaModel,
        apiName: ollamaModel,
        contextWindow: 128000, // Fixed reasonable default
        maxTokens: 4096,
        inputCostPerMillion: 0,
        outputCostPerMillion: 0,
        capabilities: {
          supportsJSON: false,
          supportsImages: ollamaModel.includes('vision') || ollamaModel.includes('llava'),
          supportsFunctions: false,
          supportsStreaming: true,
          supportsThinking: false
        }
      }];
    }

    // Special handling for LM Studio - models discovered dynamically
    // Return empty array here; models will be loaded via adapter.listModels()
    if (provider === 'lmstudio') {
      return [];
    }

    // Special handling for WebLLM - local models with $0 cost
    if (provider === 'webllm') {
      return [{
        provider: 'webllm',
        name: 'Nexus 7B',
        apiName: 'nexus-tools-q4f16',
        contextWindow: 32768,
        maxTokens: 4096,
        inputCostPerMillion: 0,
        outputCostPerMillion: 0,
        capabilities: {
          supportsJSON: true,
          supportsImages: false,
          supportsFunctions: true,
          supportsStreaming: true,
          supportsThinking: false
        }
      }];
    }

    // Standard behavior for other providers
    return AI_MODELS[provider] || [];
  }

  /**
   * Find a specific model by provider and API name
   * For OpenRouter, supports :online suffix (e.g., "gpt-4:online")
   * For Anthropic, supports :1m suffix for 1M context variants (e.g., "claude-sonnet-4-5-20250929:1m")
   */
  static findModel(provider: string, apiName: string): ModelSpec | undefined {
    const providerModels = this.getProviderModels(provider);

    // For OpenRouter models, check if apiName has :online suffix
    if (provider === 'openrouter' && apiName.endsWith(':online')) {
      const baseModelName = apiName.replace(':online', '');
      return providerModels.find(model => model.apiName === baseModelName);
    }

    // For Anthropic models, check if apiName has :1m suffix
    // The :1m suffix indicates 1M context variant, which shares the same apiName
    // but has different contextWindow and betaHeaders
    if (provider === 'anthropic' && apiName.endsWith(':1m')) {
      const baseModelName = apiName.replace(':1m', '');
      return providerModels.find(model =>
        model.apiName === baseModelName && model.contextWindow >= 1000000
      );
    }

    return providerModels.find(model => model.apiName === apiName);
  }

  /**
   * Get all available providers
   */
  static getProviders(): string[] {
    return Object.keys(AI_MODELS);
  }

  /**
   * Get models with specific capabilities
   */
  static getModelsByCapability(capability: keyof ModelSpec['capabilities'], value = true): ModelSpec[] {
    const allModels = Object.values(AI_MODELS).flat();
    return allModels.filter(model => model.capabilities[capability] === value);
  }

  /**
   * Get models within a cost range (input cost per million tokens)
   */
  static getModelsByCostRange(maxInputCost: number, maxOutputCost?: number): ModelSpec[] {
    const allModels = Object.values(AI_MODELS).flat();
    return allModels.filter(model => {
      const withinInputCost = model.inputCostPerMillion <= maxInputCost;
      const withinOutputCost = maxOutputCost ? model.outputCostPerMillion <= maxOutputCost : true;
      return withinInputCost && withinOutputCost;
    });
  }

  /**
   * Get the latest models (all current models)
   */
  static getLatestModels(): ModelSpec[] {
    return Object.values(AI_MODELS).flat();
  }

  /**
   * Check if a model name is valid for OpenRouter with :online suffix
   */
  static isValidOpenRouterModel(apiName: string): boolean {
    if (!apiName.endsWith(':online')) {
      return this.findModel('openrouter', apiName) !== undefined;
    }
    
    const baseModelName = apiName.replace(':online', '');
    return this.findModel('openrouter', baseModelName) !== undefined;
  }

  /**
   * Convert ModelSpec to the legacy ModelInfo format
   */
  static toModelInfo(modelSpec: ModelSpec): any {
    return {
      id: modelSpec.apiName,
      name: modelSpec.name,
      contextWindow: modelSpec.contextWindow,
      maxOutputTokens: modelSpec.maxTokens,
      supportsJSON: modelSpec.capabilities.supportsJSON,
      supportsImages: modelSpec.capabilities.supportsImages,
      supportsFunctions: modelSpec.capabilities.supportsFunctions,
      supportsStreaming: modelSpec.capabilities.supportsStreaming,
      supportsThinking: modelSpec.capabilities.supportsThinking,
      costPer1kTokens: {
        input: modelSpec.inputCostPerMillion / 1000,
        output: modelSpec.outputCostPerMillion / 1000
      },
      pricing: {
        inputPerMillion: modelSpec.inputCostPerMillion,
        outputPerMillion: modelSpec.outputCostPerMillion,
        currency: 'USD',
        lastUpdated: new Date().toISOString()
      }
    };
  }
}

/**
 * Export default models for each provider (recommended models)
 */
export const DEFAULT_MODELS: Record<string, string> = {
  openai: OPENAI_DEFAULT_MODEL,
  google: GOOGLE_DEFAULT_MODEL,
  anthropic: ANTHROPIC_DEFAULT_MODEL,
  mistral: MISTRAL_DEFAULT_MODEL,
  openrouter: OPENROUTER_DEFAULT_MODEL,
  requesty: REQUESTY_DEFAULT_MODEL,
  groq: GROQ_DEFAULT_MODEL
};
```

## services/llm/adapters/modelTypes.ts

```typescript
/**
 * Shared model type definitions
 * Updated June 17, 2025
 */

export interface ModelSpec {
  /** Provider name (openai, google, anthropic, etc.) */
  provider: string;
  /** Human-readable model name */
  name: string;
  /** API identifier used in requests */
  apiName: string;
  /** Context window size in tokens */
  contextWindow: number;
  /** Maximum output tokens */
  maxTokens: number;
  /** Input cost per million tokens in USD */
  inputCostPerMillion: number;
  /** Output cost per million tokens in USD */
  outputCostPerMillion: number;
  /** Model capabilities */
  capabilities: {
    supportsJSON: boolean;
    supportsImages: boolean;
    supportsFunctions: boolean;
    supportsStreaming: boolean;
    supportsThinking: boolean;
  };
  /** Optional beta headers required for this model (Anthropic only) */
  betaHeaders?: string[];
}
```

## services/llm/adapters/ollama/OllamaAdapter.ts

```typescript
/**
 * Ollama LLM Adapter
 * Provides local, privacy-focused LLM models via Ollama
 * Local LLM provider for text generation
 */

import { requestUrl } from 'obsidian';
import { BaseAdapter } from '../BaseAdapter';
import {
  GenerateOptions,
  StreamChunk,
  LLMResponse,
  ModelInfo,
  ProviderCapabilities,
  ModelPricing,
  TokenUsage,
  LLMProviderError
} from '../types';

export class OllamaAdapter extends BaseAdapter {
  readonly name = 'ollama';
  readonly baseUrl: string;
  
  private ollamaUrl: string;

  constructor(ollamaUrl: string, userModel: string) {
    // Ollama doesn't need an API key - set requiresApiKey to false
    // Use user-configured model instead of hardcoded default
    super('', userModel, ollamaUrl, false);

    this.ollamaUrl = ollamaUrl;
    this.baseUrl = ollamaUrl;

    this.initializeCache();
  }

  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      const model = options?.model || this.currentModel;

      // Check for pre-built conversation history (tool continuations)
      let messages: any[];
      if (options?.conversationHistory && options.conversationHistory.length > 0) {
        messages = options.conversationHistory;
      } else {
        messages = this.buildMessages(prompt, options?.systemPrompt);
      }

      // Build options object, removing undefined values
      const ollamaOptions: any = {
        temperature: options?.temperature,
        num_predict: options?.maxTokens,
        stop: options?.stopSequences,
        top_p: options?.topP,
        frequency_penalty: options?.frequencyPenalty,
        presence_penalty: options?.presencePenalty
      };
      Object.keys(ollamaOptions).forEach(key => {
        if (ollamaOptions[key] === undefined) {
          delete ollamaOptions[key];
        }
      });

      // Use /api/chat endpoint (supports messages array and tool calling)
      const response = await fetch(`${this.ollamaUrl}/api/chat`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          model: model,
          messages: messages,
          stream: true,
          options: ollamaOptions
        })
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new LLMProviderError(
          `Ollama API error: ${response.status} ${response.statusText} - ${errorText}`,
          'streaming',
          'API_ERROR'
        );
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new LLMProviderError(
          'No response body available for streaming',
          'streaming',
          'NO_RESPONSE_BODY'
        );
      }

      const decoder = new TextDecoder();
      let fullContent = '';

      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value);
          const lines = chunk.split('\n').filter(line => line.trim());

          for (const line of lines) {
            try {
              const data = JSON.parse(line);

              // /api/chat returns message.content instead of response
              if (data.message?.content) {
                fullContent += data.message.content;
                yield { content: data.message.content, complete: false };
              }

              if (data.done) {
                yield {
                  content: '',
                  complete: true,
                  usage: {
                    promptTokens: data.prompt_eval_count || 0,
                    completionTokens: data.eval_count || 0,
                    totalTokens: (data.prompt_eval_count || 0) + (data.eval_count || 0)
                  }
                };
              }
            } catch (parseError) {
              // Skip invalid JSON lines
              continue;
            }
          }
        }
      } finally {
        reader.releaseLock();
      }
    } catch (error) {
      if (error instanceof LLMProviderError) {
        throw error;
      }
      throw new LLMProviderError(
        `Ollama streaming failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'streaming',
        'NETWORK_ERROR'
      );
    }
  }

  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    try {
      const model = options?.model || this.currentModel;

      // Check for pre-built conversation history (tool continuations)
      let messages: any[];
      if (options?.conversationHistory && options.conversationHistory.length > 0) {
        messages = options.conversationHistory;
      } else {
        messages = this.buildMessages(prompt, options?.systemPrompt);
      }

      // Build options object
      const ollamaOptions: any = {
        temperature: options?.temperature,
        num_predict: options?.maxTokens,
        stop: options?.stopSequences,
        top_p: options?.topP,
        frequency_penalty: options?.frequencyPenalty,
        presence_penalty: options?.presencePenalty
      };

      // Remove undefined values
      Object.keys(ollamaOptions).forEach(key => {
        if (ollamaOptions[key] === undefined) {
          delete ollamaOptions[key];
        }
      });

      // Use /api/chat endpoint (supports messages array and tool calling)
      const response = await fetch(`${this.ollamaUrl}/api/chat`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: model,
          messages: messages,
          stream: false,
          options: ollamaOptions
        })
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new LLMProviderError(
          `Ollama API error: ${response.status} ${response.statusText} - ${errorText}`,
          'generation',
          'API_ERROR'
        );
      }

      const data = await response.json();

      // /api/chat returns message.content instead of response
      if (!data.message?.content) {
        throw new LLMProviderError(
          'Invalid response format from Ollama API: missing message.content field',
          'generation',
          'INVALID_RESPONSE'
        );
      }

      // Extract usage information
      const usage: TokenUsage = {
        promptTokens: data.prompt_eval_count || 0,
        completionTokens: data.eval_count || 0,
        totalTokens: (data.prompt_eval_count || 0) + (data.eval_count || 0)
      };

      const finishReason = data.done ? 'stop' : 'length';
      const metadata = {
        cached: false,
        modelDetails: data.model,
        totalDuration: data.total_duration,
        loadDuration: data.load_duration,
        promptEvalDuration: data.prompt_eval_duration,
        evalDuration: data.eval_duration
      };

      return await this.buildLLMResponse(
        data.message.content,
        model,
        usage,
        metadata,
        finishReason
      );
    } catch (error) {
      if (error instanceof LLMProviderError) {
        throw error;
      }
      throw new LLMProviderError(
        `Ollama generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'generation',
        'NETWORK_ERROR'
      );
    }
  }

  async generateStream(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    try {
      const model = options?.model || this.currentModel;

      // Check for pre-built conversation history (tool continuations)
      let messages: any[];
      if (options?.conversationHistory && options.conversationHistory.length > 0) {
        messages = options.conversationHistory;
      } else {
        messages = this.buildMessages(prompt, options?.systemPrompt);
      }

      // Build options object
      const ollamaOptions: any = {
        temperature: options?.temperature,
        num_predict: options?.maxTokens,
        stop: options?.stopSequences,
        top_p: options?.topP
      };

      // Remove undefined values
      Object.keys(ollamaOptions).forEach(key => {
        if (ollamaOptions[key] === undefined) {
          delete ollamaOptions[key];
        }
      });

      // Use /api/chat endpoint (supports messages array and tool calling)
      const response = await fetch(`${this.ollamaUrl}/api/chat`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: model,
          messages: messages,
          stream: true,
          options: ollamaOptions
        })
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new LLMProviderError(
          `Ollama API error: ${response.status} ${response.statusText} - ${errorText}`,
          'streaming',
          'API_ERROR'
        );
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new LLMProviderError(
          'No response body available for streaming',
          'streaming',
          'NO_RESPONSE_BODY'
        );
      }

      let fullText = '';
      let usage: TokenUsage = {
        promptTokens: 0,
        completionTokens: 0,
        totalTokens: 0
      };
      let finishReason: 'stop' | 'length' = 'stop';
      let metadata: Record<string, any> = {};

      try {
        const decoder = new TextDecoder();

        while (true) {
          const { done, value } = await reader.read();

          if (done) break;

          const chunk = decoder.decode(value);
          const lines = chunk.split('\n').filter(line => line.trim());

          for (const line of lines) {
            try {
              const data = JSON.parse(line);

              // /api/chat returns message.content instead of response
              if (data.message?.content) {
                fullText += data.message.content;
              }

              if (data.done) {
                usage = {
                  promptTokens: data.prompt_eval_count || 0,
                  completionTokens: data.eval_count || 0,
                  totalTokens: (data.prompt_eval_count || 0) + (data.eval_count || 0)
                };

                metadata = {
                  modelDetails: data.model,
                  totalDuration: data.total_duration,
                  loadDuration: data.load_duration,
                  promptEvalDuration: data.prompt_eval_duration,
                  evalDuration: data.eval_duration
                };

                finishReason = 'stop';
                break;
              }
            } catch (parseError) {
              // Skip invalid JSON lines
              continue;
            }
          }
        }
      } finally {
        reader.releaseLock();
      }

      const result: LLMResponse = {
        text: fullText,
        model: model,
        provider: this.name,
        usage: usage,
        cost: {
          inputCost: 0, // Local models are free
          outputCost: 0,
          totalCost: 0,
          currency: 'USD',
          rateInputPerMillion: 0,
          rateOutputPerMillion: 0
        },
        finishReason: finishReason,
        metadata: {
          ...metadata,
          cached: false,
          streamed: true
        }
      };

      return result;
    } catch (error) {
      const errorObj = error instanceof Error ? error : new Error('Unknown streaming error');

      if (error instanceof LLMProviderError) {
        throw error;
      }
      throw new LLMProviderError(
        `Ollama streaming failed: ${errorObj.message}`,
        'streaming',
        'NETWORK_ERROR'
      );
    }
  }

  async listModels(): Promise<ModelInfo[]> {
    // Only return the user-configured model
    // This ensures the UI only shows the model the user specifically configured
    return [{
      id: this.currentModel,
      name: this.currentModel,
      contextWindow: 128000, // Use a reasonable default, not model-specific
      supportsStreaming: true,
      supportsJSON: false, // Ollama doesn't have built-in JSON mode
      supportsImages: this.currentModel.includes('vision') || this.currentModel.includes('llava'),
      supportsFunctions: false,
      supportsThinking: false,
      pricing: {
        inputPerMillion: 0, // Local models are free
        outputPerMillion: 0,
        currency: 'USD',
        lastUpdated: new Date().toISOString()
      }
    }];
  }

  getCapabilities(): ProviderCapabilities {
    return {
      supportsStreaming: true,
      supportsJSON: false, // Ollama doesn't have built-in JSON mode
      supportsImages: false, // Depends on specific model
      supportsFunctions: false, // Standard Ollama doesn't support function calling
      supportsThinking: false,
      maxContextWindow: 128000, // Varies by model, this is a reasonable default
      supportedFeatures: ['streaming', 'local', 'privacy']
    };
  }

  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    // Local models are free - zero rates
    return {
      rateInputPerMillion: 0,
      rateOutputPerMillion: 0,
      currency: 'USD'
    };
  }

  async isAvailable(): Promise<boolean> {
    try {
      const response = await requestUrl({
        url: `${this.ollamaUrl}/api/tags`,
        method: 'GET'
      });
      return response.status === 200;
    } catch (error) {
      return false;
    }
  }

  // Utility methods
  private formatSize(bytes: number): string {
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    if (bytes === 0) return '0 B';
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
  }

  protected buildMessages(prompt: string, systemPrompt?: string): any[] {
    const messages = [];
    
    if (systemPrompt) {
      messages.push({ role: 'system', content: systemPrompt });
    }
    
    messages.push({ role: 'user', content: prompt });
    
    return messages;
  }

  protected handleError(error: any, operation: string): never {
    if (error instanceof LLMProviderError) {
      throw error;
    }

    let message = `Ollama ${operation} failed`;
    let code = 'UNKNOWN_ERROR';

    if (error?.message) {
      message += `: ${error.message}`;
    }

    if (error?.code === 'ECONNREFUSED') {
      message = 'Cannot connect to Ollama server. Make sure Ollama is running.';
      code = 'CONNECTION_REFUSED';
    } else if (error?.code === 'ENOTFOUND') {
      message = 'Ollama server not found. Check the URL configuration.';
      code = 'SERVER_NOT_FOUND';
    }

    throw new LLMProviderError(message, this.name, code, error);
  }
}
```

## services/llm/adapters/openai/DeepResearchHandler.ts

```typescript
/**
 * OpenAI Deep Research Handler
 * Handles deep research models that use the Responses API
 * Separate from streaming chat functionality
 */

import OpenAI from 'openai';
import { GenerateOptions, LLMResponse, TokenUsage } from '../types';
import { LLMProviderError } from '../types';
import type {
  Response,
  ResponseOutputItem,
  ResponseOutputMessage,
  ResponseOutputText
} from 'openai/resources/responses/responses';

/**
 * Type guard to check if an output item is a message
 */
function isResponseOutputMessage(item: ResponseOutputItem): item is ResponseOutputMessage {
  return item.type === 'message';
}

/**
 * Type guard to check if content is output text
 */
function isResponseOutputText(content: ResponseOutputMessage['content'][number]): content is ResponseOutputText {
  return content.type === 'output_text';
}

/**
 * Usage information structure
 */
interface UsageInfo {
  prompt_tokens?: number;
  input_tokens?: number;
  completion_tokens?: number;
  output_tokens?: number;
  total_tokens?: number;
}

/**
 * Type guard to check if an item has usage information
 */
function hasUsage(item: unknown): item is { usage: UsageInfo } {
  return typeof item === 'object' && item !== null && 'usage' in item && item.usage !== undefined;
}

export class DeepResearchHandler {
  constructor(private client: OpenAI) {}

  /**
   * Check if a model is a deep research model
   */
  isDeepResearchModel(model: string): boolean {
    return model.includes('deep-research') || model.includes('gpt-5.2-pro');
  }

  /**
   * Generate response using deep research model
   */
  async generate(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    const model = options?.model || 'sonar-deep-research';

    // Build input format for Deep Research API
    const input: any[] = [];

    // Add system message if provided
    if (options?.systemPrompt) {
      input.push({
        role: 'developer',
        content: [{ type: 'input_text', text: options.systemPrompt }]
      });
    }

    // Add user message
    input.push({
      role: 'user',
      content: [{ type: 'input_text', text: prompt }]
    });

    const requestParams: any = {
      model,
      input,
      reasoning: { summary: 'auto' },
      background: true // Enable async processing
    };

    // Add tools if specified, default to web_search_preview for deep research models
    if (model.includes('deep-research')) {
        requestParams.tools = [{ type: 'web_search_preview' }];
    }

    // Add optional tools if specified
    if (options?.tools && options.tools.length > 0) {
      // Convert tools to Deep Research API format
      const drTools = options.tools.map(tool => {
        if (tool.type === 'function') {
          return { type: 'code_interpreter', container: { type: 'auto', file_ids: [] } };
        }
        return { type: tool.type };
      });
      requestParams.tools = [...(requestParams.tools || []), ...drTools];
    }

    try {
      // Submit the deep research request
      const response = await this.client.responses.create(requestParams);

      // Poll for completion if response is not immediately ready
      let finalResponse = response;
      if (response.status === 'in_progress' || !this.isComplete(response)) {
        finalResponse = await this.pollForCompletion(response.id, model);
      }

      // Extract the final report from the output array
      return this.parseResponse(finalResponse, model);
    } catch (error) {
      console.error(`[DeepResearchHandler] Deep research failed for ${model}:`, error);
      throw new LLMProviderError(
        `Deep research generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'openai',
        'DEEP_RESEARCH_ERROR',
        error instanceof Error ? error : undefined
      );
    }
  }

  /**
   * Check if deep research response is complete
   */
  private isComplete(response: Response): boolean {
    return response.output &&
           response.output.length > 0 &&
           response.output.some((item) => {
             if (!isResponseOutputMessage(item)) return false;
             if (!item.content || item.content.length === 0) return false;
             const firstContent = item.content[0];
             return isResponseOutputText(firstContent) && Boolean(firstContent.text);
           });
  }

  /**
   * Poll for deep research completion
   */
  private async pollForCompletion(responseId: string, model: string, maxWaitTime = 300000): Promise<Response> {
    const startTime = Date.now();
    const pollInterval = (model.includes('o4-mini') || model.includes('gpt-5.2-pro')) ? 2000 : 5000; // Faster polling for mini model and pro model

    while (Date.now() - startTime < maxWaitTime) {
      try {
        const response = await this.client.responses.retrieve(responseId);

        if (response.status === 'completed' || this.isComplete(response)) {
          return response;
        }

        if (response.status === 'failed' || response.status === 'cancelled') {
          throw new Error(`Deep research ${response.status}: ${response.error || 'Unknown error'}`);
        }

        await new Promise(resolve => setTimeout(resolve, pollInterval));

      } catch (error) {
        if (error instanceof Error && error.message.includes('Deep research')) {
          throw error; // Re-throw deep research specific errors
        }
        await new Promise(resolve => setTimeout(resolve, pollInterval));
      }
    }

    throw new Error(`Deep research timed out after ${maxWaitTime}ms`);
  }

  /**
   * Parse deep research response structure
   */
  private parseResponse(response: Response, model: string): LLMResponse {
    if (!response.output || response.output.length === 0) {
      throw new Error('No output received from deep research');
    }

    // Find the final message in the output array
    const finalOutput = response.output[response.output.length - 1];

    if (!isResponseOutputMessage(finalOutput) || !finalOutput.content || finalOutput.content.length === 0) {
      throw new Error('Invalid deep research response structure');
    }

    const content = finalOutput.content[0];
    if (!isResponseOutputText(content)) {
      throw new Error('Expected text output from deep research');
    }

    const text = content.text || '';
    const annotations = content.annotations || [];

    // Extract usage information if available
    let usage: TokenUsage | undefined;
    const usageOutput = response.output.find((item): item is ResponseOutputItem & { usage: UsageInfo } => hasUsage(item));
    if (usageOutput?.usage) {
      usage = {
        promptTokens: usageOutput.usage.prompt_tokens || usageOutput.usage.input_tokens || 0,
        completionTokens: usageOutput.usage.completion_tokens || usageOutput.usage.output_tokens || 0,
        totalTokens: usageOutput.usage.total_tokens || 0
      };
    }

    // Build metadata with citations
    const metadata: Record<string, unknown> = {
      deepResearch: true,
      citations: annotations.map((annotation) => {
        // Only process URL citations
        if ('url' in annotation && annotation.type === 'url_citation') {
          return {
            title: annotation.title,
            url: annotation.url,
            startIndex: annotation.start_index,
            endIndex: annotation.end_index
          };
        }
        return null;
      }).filter((citation): citation is NonNullable<typeof citation> => citation !== null),
      intermediateSteps: response.output.length - 1, // Number of intermediate processing steps
      processingTime: response.metadata?.processing_time_ms
    };

    return {
      text,
      model,
      provider: 'openai',
      usage,
      metadata,
      finishReason: 'stop' // Deep research always completes normally
    };
  }
}

```

## services/llm/adapters/openai/OpenAIAdapter.ts

```typescript
/**
 * OpenAI Adapter - Clean implementation focused on streaming
 * Supports both regular chat completions and deep research models
 */

import OpenAI from 'openai';
import { Stream } from 'openai/streaming';
import { BaseAdapter } from '../BaseAdapter';

// OpenAI Responses API types - using namespace for proper type access
type OpenAIResponse = OpenAI.Responses.Response;
type OpenAIStreamEvent = OpenAI.Responses.ResponseStreamEvent;
import {
  GenerateOptions,
  StreamChunk,
  LLMResponse,
  ModelInfo,
  ProviderCapabilities,
  ModelPricing,
  SearchResult
} from '../types';
import { ModelRegistry } from '../ModelRegistry';
import { DeepResearchHandler } from './DeepResearchHandler';
import { WebSearchUtils } from '../../utils/WebSearchUtils';
import { OPENAI_MODELS } from './OpenAIModels';
import { MCPToolExecution } from '../shared/ToolExecutionUtils';

export class OpenAIAdapter extends BaseAdapter {
  readonly name = 'openai';
  readonly baseUrl = 'https://api.openai.com/v1';

  private client: OpenAI;
  private deepResearch: DeepResearchHandler;

  constructor(apiKey: string) {
    super(apiKey, 'gpt-5');

    this.client = new OpenAI({
      apiKey: this.apiKey,
      dangerouslyAllowBrowser: true, // Required for Obsidian plugin environment
    });

    this.deepResearch = new DeepResearchHandler(this.client);
    this.initializeCache();
  }

  /**
   * Generate response without caching
   */
  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    try {
      // Validate web search support
      if (options?.webSearch) {
        WebSearchUtils.validateWebSearchRequest('openai', options.webSearch);
      }

      const model = options?.model || this.currentModel;

      // Route deep research models to specialized handler
      if (this.deepResearch.isDeepResearchModel(model)) {
        return await this.deepResearch.generate(prompt, options);
      }

      // Tool execution requires streaming - use generateStreamAsync instead
      if (options?.tools && options.tools.length > 0) {
        throw new Error('Tool execution requires streaming. Use generateStreamAsync() instead.');
      }

      // Otherwise use basic Responses API without tools
      return await this.generateWithResponsesAPI(prompt, options);
    } catch (error) {
      throw this.handleError(error, 'generation');
    }
  }

  /**
   * Generate streaming response using async generator
   * Uses OpenAI Responses API for stateful conversations with tool support
   */
  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      const model = options?.model || this.currentModel;

      // Deep research models cannot be used in streaming chat
      if (this.deepResearch.isDeepResearchModel(model)) {
        throw new Error(`Deep research models (${model}) cannot be used in streaming chat. Please select a different model for real-time conversations.`);
      }

      // Build Responses API parameters with retry logic for race conditions
      const stream = await this.retryWithBackoff(async () => {
        const responseParams: any = {
          model,
          stream: true
        };

        // Handle input - either tool outputs (continuation) or text (initial)
        if (options?.conversationHistory && options.conversationHistory.length > 0) {
          // Tool continuation: conversationHistory contains ResponseInputItem[] (function_call_output)
          responseParams.input = options.conversationHistory;
        } else {
          // Initial request: use text input
          responseParams.input = prompt;
        }

        // Add instructions (replaces system message in Chat Completions)
        if (options?.systemPrompt) {
          responseParams.instructions = options.systemPrompt;
        }

        // Add previous_response_id for stateful continuation
        if (options?.previousResponseId) {
          responseParams.previous_response_id = options.previousResponseId;
        }

        // Add tools if provided (convert from Chat Completions format to Responses API format)
        if (options?.tools) {
          responseParams.tools = options.tools.map((tool: any) => {
            // Responses API uses flat structure: {type, name, description, parameters}
            // Chat Completions uses nested: {type, function: {name, description, parameters}}
            if (tool.function) {
              return {
                type: 'function',
                name: tool.function.name,
                description: tool.function.description || null,
                parameters: tool.function.parameters || null,
                strict: tool.function.strict || null
              };
            }
            // Already in Responses API format
            return tool;
          });
        }

        // Add optional parameters
        if (options?.temperature !== undefined) responseParams.temperature = options.temperature;
        if (options?.maxTokens !== undefined) responseParams.max_output_tokens = options.maxTokens;
        if (options?.topP !== undefined) responseParams.top_p = options.topP;
        if (options?.frequencyPenalty !== undefined) responseParams.frequency_penalty = options.frequencyPenalty;
        if (options?.presencePenalty !== undefined) responseParams.presence_penalty = options.presencePenalty;

        // Enable reasoning for GPT-5/o-series models if thinking is enabled
        // This enables chain-of-thought reasoning that streams to the UI
        if (options?.enableThinking && this.supportsReasoning(model)) {
          responseParams.reasoning = {
            effort: options.thinkingEffort || 'medium',  // Use user-selected effort level
            summary: 'auto'    // Can be 'auto', 'concise', or 'detailed'
          };
          // Include encrypted_content for multi-turn conversations
          responseParams.include = responseParams.include || [];
          responseParams.include.push('reasoning.encrypted_content');
        }

        // Create Responses API stream
        // TypeScript can't narrow the overloaded create() return type based on params,
        // so we cast to the expected streaming type
        return await this.client.responses.create(responseParams) as unknown as Stream<OpenAIStreamEvent>;
      });

      // Process Responses API stream events
      yield* this.processResponsesStream(stream);

    } catch (error) {
      console.error('[OpenAIAdapter] Streaming error:', error);
      throw this.handleError(error, 'streaming generation');
    }
  }

  /**
   * Process Responses API stream events
   * Handles ResponseStreamEvent format from OpenAI Responses API
   * Includes reasoning/thinking support for GPT-5 and o-series models
   * @private
   */
  private async* processResponsesStream(stream: any): AsyncGenerator<StreamChunk, void, unknown> {
    let fullContent = '';
    let currentResponseId: string | null = null;
    const toolCallsMap = new Map<number, any>();
    let usage: any = null;

    // Reasoning tracking for GPT-5/o-series models
    let currentReasoningId: string | null = null;
    let currentReasoningEncryptedContent: string | null = null;
    let isInReasoningPart = false;

    try {
      for await (const event of stream) {
        // Extract response ID from events
        if (event.response?.id && !currentResponseId) {
          currentResponseId = event.response.id;
        }

        // Handle different event types
        switch (event.type) {
          case 'response.output_text.delta':
            // Text content delta
            if (event.delta) {
              fullContent += event.delta;
              yield {
                content: event.delta,
                complete: false,
                usage: undefined
              };
            }
            break;

          case 'response.output_item.added':
            // New output item added (could be message, function call, or reasoning)
            if (event.item) {
              const item = event.item;

              // Handle reasoning item (GPT-5/o-series chain-of-thought)
              if (item.type === 'reasoning') {
                currentReasoningId = item.id;
                yield {
                  content: '',
                  complete: false,
                  reasoning: '',  // Initial empty to signal reasoning started
                  reasoningComplete: false,
                  reasoningId: item.id
                };
              }
              // Handle message with text content (only for messages, not function calls)
              else if (item.type === 'message' && item.content) {
                for (const content of item.content) {
                  if (content.type === 'text' && content.text) {
                    fullContent += content.text;
                    yield {
                      content: content.text,
                      complete: false,
                      usage: undefined
                    };
                  }
                }
              }
            }
            break;

          case 'response.content_part.added':
            // Content part added - check for reasoning_text
            if (event.part?.type === 'reasoning_text') {
              isInReasoningPart = true;
              if (event.part.text) {
                yield {
                  content: '',
                  complete: false,
                  reasoning: event.part.text,
                  reasoningComplete: false,
                  reasoningId: currentReasoningId || undefined
                };
              }
            }
            break;

          case 'response.content_part.delta':
            // Incremental content delta - check if we're in a reasoning part
            if (isInReasoningPart && event.delta) {
              yield {
                content: '',
                complete: false,
                reasoning: event.delta,
                reasoningComplete: false,
                reasoningId: currentReasoningId || undefined
              };
            }
            break;

          case 'response.content_part.done':
            // Content part finished
            if (event.part?.type === 'reasoning_text') {
              isInReasoningPart = false;
            }
            break;

          case 'response.output_item.done':
            // Output item complete - capture function calls or reasoning completion
            if (event.item) {
              const item = event.item;

              if (item.type === 'function_call') {
                const index = event.output_index || 0;

                toolCallsMap.set(index, {
                  id: item.call_id || item.id,
                  type: 'function',
                  function: {
                    name: item.name || '',
                    arguments: item.arguments || '{}'
                  }
                });
              } else if (item.type === 'reasoning') {
                // Reasoning item complete - capture encrypted_content for multi-turn
                currentReasoningEncryptedContent = item.encrypted_content || null;
                yield {
                  content: '',
                  complete: false,
                  reasoning: '',
                  reasoningComplete: true,
                  reasoningId: item.id,
                  reasoningEncryptedContent: currentReasoningEncryptedContent || undefined
                };
                currentReasoningId = null;
              }
            }
            break;

          case 'response.function_call_arguments.delta':
            // Arguments are streamed but we capture the complete call in output_item.done
            // No action needed here - just let the deltas flow
            break;

          // Handle reasoning summary events (GPT-5 sends these instead of reasoning_text)
          case 'response.reasoning_summary_text.delta':
            // Incremental reasoning summary text
            if (event.delta) {
              yield {
                content: '',
                complete: false,
                reasoning: event.delta,
                reasoningComplete: false,
                reasoningId: event.item_id || currentReasoningId || undefined
              };
            }
            break;

          case 'response.reasoning_summary_text.done':
            // Reasoning summary text complete - yield the full text
            if (event.text) {
              yield {
                content: '',
                complete: false,
                reasoning: '', // Already streamed via delta events
                reasoningComplete: true,
                reasoningId: event.item_id || currentReasoningId || undefined
              };
            }
            break;

          case 'response.reasoning_summary_part.done':
            // Reasoning summary part complete - mark reasoning as done
            yield {
              content: '',
              complete: false,
              reasoning: '',
              reasoningComplete: true,
              reasoningId: event.item_id || currentReasoningId || undefined
            };
            break;

          case 'response.done':
          case 'response.completed':
            // Final event - extract usage if available
            if (event.response?.usage) {
              usage = {
                promptTokens: event.response.usage.input_tokens || 0,
                completionTokens: event.response.usage.output_tokens || 0,
                totalTokens: event.response.usage.total_tokens || 0
              };
            }

            // Store response ID in metadata for continuation
            const metadata = currentResponseId ? { responseId: currentResponseId } : undefined;

            // Final yield with tool calls if any
            const toolCallsArray = Array.from(toolCallsMap.values());
            yield {
              content: '',
              complete: true,
              usage,
              toolCalls: toolCallsArray.length > 0 ? toolCallsArray : undefined,
              toolCallsReady: toolCallsArray.length > 0,
              metadata // Include response ID for tracking
            };

            break;

          default:
            // Ignore other event types
            break;
        }
      }
    } catch (error) {
      console.error('[OpenAIAdapter] Error processing Responses API stream:', error);
      throw error;
    }
  }

  /**
   * Generate using Responses API for non-streaming requests
   */
  private async generateWithResponsesAPI(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    const model = options?.model || this.currentModel;

    const responseParams: any = {
      model,
      input: prompt,
      stream: false
    };

    // Add instructions (replaces system message)
    if (options?.systemPrompt) {
      responseParams.instructions = options.systemPrompt;
    }

    // Add optional parameters
    if (options?.temperature !== undefined) responseParams.temperature = options.temperature;
    if (options?.maxTokens !== undefined) responseParams.max_output_tokens = options.maxTokens;
    if (options?.topP !== undefined) responseParams.top_p = options.topP;
    if (options?.frequencyPenalty !== undefined) responseParams.frequency_penalty = options.frequencyPenalty;
    if (options?.presencePenalty !== undefined) responseParams.presence_penalty = options.presencePenalty;

    // TypeScript can't narrow the overloaded create() return type based on params,
    // so we cast to the expected non-streaming Response type
    const response = await this.client.responses.create(responseParams) as unknown as OpenAIResponse;

    if (!response.output || response.output.length === 0) {
      throw new Error('No output from OpenAI Responses API');
    }

    // Extract text content from output array
    let text = '';
    for (const item of response.output) {
      if (item.type === 'message' && item.content) {
        for (const content of item.content) {
          if (content.type === 'output_text') {
            text += content.text || '';
          }
        }
      }
    }

    const usage = response.usage ? {
      promptTokens: response.usage.input_tokens || 0,
      completionTokens: response.usage.output_tokens || 0,
      totalTokens: response.usage.total_tokens || 0
    } : undefined;

    return this.buildLLMResponse(
      text,
      model,
      usage,
      { responseId: response.id }, // Store response ID
      'stop'
    );
  }

  /**
   * Extract search results from OpenAI response
   * OpenAI may include sources in annotations or tool results
   */
  private extractOpenAISources(response: any): SearchResult[] {
    try {
      const sources: SearchResult[] = [];

      // Check for annotations (if OpenAI includes web sources)
      const annotations = response.choices?.[0]?.message?.annotations || [];
      for (const annotation of annotations) {
        if (annotation.type === 'url_citation' || annotation.type === 'citation') {
          const result = WebSearchUtils.validateSearchResult({
            title: annotation.title || annotation.text || 'Unknown Source',
            url: annotation.url,
            date: annotation.date || annotation.timestamp
          });
          if (result) sources.push(result);
        }
      }

      // Check for tool calls with web search results
      const toolCalls = response.choices?.[0]?.message?.toolCalls || [];
      for (const toolCall of toolCalls) {
        if (toolCall.function?.name === 'web_search' && toolCall.result) {
          try {
            const searchResult = JSON.parse(toolCall.result);
            if (searchResult.sources && Array.isArray(searchResult.sources)) {
              const extractedSources = WebSearchUtils.extractSearchResults(searchResult.sources);
              sources.push(...extractedSources);
            }
          } catch (error) {
          }
        }
      }

      return sources;
    } catch (error) {
      return [];
    }
  }

  /**
   * List available models
   */
  async listModels(): Promise<ModelInfo[]> {
    try {
      // Use centralized model registry instead of API call
      const openaiModels = ModelRegistry.getProviderModels('openai');
      return openaiModels.map(model => ModelRegistry.toModelInfo(model));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }


  /**
   * Check if model supports reasoning/thinking (uses model registry)
   */
  private supportsReasoning(modelId: string): boolean {
    const model = OPENAI_MODELS.find(m => m.apiName === modelId);
    return model?.capabilities.supportsThinking || false;
  }

  /**
   * Get provider capabilities
   */
  getCapabilities(): ProviderCapabilities {
    const baseCapabilities = {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsThinking: true,
      supportsImageGeneration: true,
      maxContextWindow: 2000000, // GPT-5 context window
      supportedFeatures: [
        'streaming',
        'json_mode',
        'function_calling',
        'image_input',
        'image_generation',
        'thinking_models',
        'deep_research'
      ]
    };

    return baseCapabilities;
  }

  /**
   * Get model pricing
   */
  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    try {
      const models = ModelRegistry.getProviderModels('openai');
      const model = models.find(m => m.apiName === modelId);
      if (!model) {
        return null;
      }

      return {
        rateInputPerMillion: model.inputCostPerMillion,
        rateOutputPerMillion: model.outputCostPerMillion,
        currency: 'USD'
      };
    } catch (error) {
      return null;
    }
  }
}

```

## services/llm/adapters/openai/OpenAIImageAdapter.ts

```typescript
/**
 * OpenAI Image Generation Adapter
 * Supports OpenAI's gpt-image-1 model via Responses API for image generation
 * Based on 2025 API documentation
 */

import OpenAI from 'openai';
import { BaseImageAdapter } from '../BaseImageAdapter';
import { 
  ImageGenerationParams, 
  ImageGenerationResponse, 
  ImageValidationResult,
  ImageModel,
  ImageUsage
} from '../../types/ImageTypes';
import { 
  ProviderConfig,
  ProviderCapabilities,
  ModelInfo,
  CostDetails
} from '../types';

export class OpenAIImageAdapter extends BaseImageAdapter {
  
  // Image adapters don't support streaming in the same way as text
  async* generateStreamAsync(): AsyncGenerator<never, void, unknown> {
    // Image generation is not streamable - it's a single result
    // This method should not be called for image adapters
    throw new Error('Image generation does not support streaming');
  }
  
  readonly name = 'openai-image';
  readonly baseUrl = 'https://api.openai.com/v1';
  readonly supportedModels: ImageModel[] = ['gpt-image-1'];
  readonly supportedSizes: string[] = ['1024x1024', '1536x1024', '1024x1536', 'auto'];
  readonly supportedFormats: string[] = ['png'];
  
  private client: OpenAI;
  private readonly imageModel = 'gpt-image-1'; // Use gpt-image-1 via Responses API

  constructor(config?: ProviderConfig) {
    const apiKey = config?.apiKey || '';
    super(apiKey, 'gpt-image-1', config?.baseUrl);
    
    this.client = new OpenAI({
      apiKey: apiKey,
      organization: process.env.OPENAI_ORG_ID,
      project: process.env.OPENAI_PROJECT_ID,
      baseURL: config?.baseUrl || this.baseUrl,
      dangerouslyAllowBrowser: true // Required for Obsidian plugin environment
    });

    this.initializeCache();
  }

  /**
   * Generate images using OpenAI's gpt-image-1 model via Responses API
   */
  async generateImage(params: ImageGenerationParams): Promise<ImageGenerationResponse> {
    try {
      this.validateConfiguration();

      const response = await this.withRetry(async () => {
        // Use a supported model for Responses API (gpt-5.2 supports image_generation tool)
        const requestParams = {
          model: 'gpt-5.2', // Model that supports image_generation tool
          input: params.prompt,
          tools: [{
            type: 'image_generation' as const,
            size: params.size as 'auto' | '1024x1024' | '1536x1024' | '1024x1536' || '1024x1024'
            // quality and background removed - not in new interface
          }]
        };

        const result = await this.client.responses.create(requestParams);
        return result;
      }, 2); // Reduced retry count for faster failure detection

      return await this.buildImageResponse(response, params);
    } catch (error) {
      this.handleImageError(error, 'image generation', params);
    }
  }

  /**
   * Validate OpenAI-specific image generation parameters
   */
  validateImageParams(params: ImageGenerationParams): ImageValidationResult {
    // Start with common validation
    const baseValidation = this.validateCommonParams(params);
    if (!baseValidation.isValid) {
      return baseValidation;
    }

    const errors: string[] = [...baseValidation.errors];
    const warnings: string[] = [...(baseValidation.warnings || [])];
    const adjustedParams: Partial<ImageGenerationParams> = {};

    // Validate prompt length (gpt-image-1 has a 32,000 character limit)
    if (params.prompt.length > 32000) {
      errors.push('Prompt too long (max 32,000 characters for gpt-image-1)');
    }

    // Validate model - only gpt-image-1 supported
    if (params.model && params.model !== 'gpt-image-1') {
      errors.push('Only gpt-image-1 model is supported for OpenAI');
    }

    // Size validation for gpt-image-1
    if (params.size) {
      const validSizes = ['1024x1024', '1536x1024', '1024x1536', 'auto'];
      if (!validSizes.includes(params.size)) {
        errors.push(`Invalid size for gpt-image-1. Supported sizes: ${validSizes.join(', ')}`);
      }
    }

    // Quality and format validation removed - properties no longer in interface

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      adjustedParams
    };
  }

  /**
   * Get OpenAI image generation capabilities
   */
  getImageCapabilities(): ProviderCapabilities {
    return {
      supportsStreaming: false,
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsThinking: false,
      supportsImageGeneration: true,
      maxContextWindow: 32000, // Character limit for prompts
      supportedFeatures: [
        'text_to_image',
        'quality_control',
        'size_variants',
        'style_control',
        'high_resolution'
      ]
    };
  }

  /**
   * Get supported image sizes for gpt-image-1
   */
  getSupportedImageSizes(): string[] {
    return [...this.supportedSizes];
  }

  /**
   * Get pricing for gpt-image-1 image generation
   */
  async getImageModelPricing(model: string = 'gpt-image-1'): Promise<CostDetails> {
    // gpt-image-1 pricing is token-based, approximate base price
    const basePrice = 0.015; // Approximate cost per image

    return {
      inputCost: 0,
      outputCost: basePrice,
      totalCost: basePrice,
      currency: 'USD',
      rateInputPerMillion: 0,
      rateOutputPerMillion: basePrice * 1_000_000
    };
  }

  /**
   * List available OpenAI image models
   */
  async listModels(): Promise<ModelInfo[]> {
    return [{
      id: this.imageModel,
      name: 'GPT Image 1',
      contextWindow: 32000,
      maxOutputTokens: 0,
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: false,
      supportsThinking: false,
      supportsImageGeneration: true,
      pricing: {
        inputPerMillion: 0,
        outputPerMillion: 0,
        imageGeneration: 0.015,
        currency: 'USD',
        lastUpdated: '2025-01-01'
      }
    }];
  }

  // Private helper methods

  private async buildImageResponse(
    response: any, // Responses API response format
    params: ImageGenerationParams
  ): Promise<ImageGenerationResponse> {
    // Extract image data from Responses API format
    const imageData = response.output
      .filter((output: any) => output.type === "image_generation_call")
      .map((output: any) => output.result);

    if (!imageData || imageData.length === 0) {
      throw new Error('No image data received from OpenAI Responses API');
    }

    const imageBase64 = imageData[0];
    if (!imageBase64) {
      throw new Error('No base64 image data received from OpenAI');
    }

    // Convert base64 to buffer
    const buffer = Buffer.from(imageBase64, 'base64');

    // Extract dimensions from size parameter or use default
    const size = params.size || '1024x1024';
    const [width, height] = size === 'auto' ? [1024, 1024] : size.split('x').map(Number);

    const usage: ImageUsage = this.buildImageUsage(1, size, this.imageModel);

    // Extract revised prompt from image generation call
    const imageGenerationCall = response.output.find((output: any) => output.type === "image_generation_call");
    const revisedPrompt = imageGenerationCall?.revised_prompt;

    return {
      imageData: buffer,
      format: 'png', // Default format for Responses API
      dimensions: { width, height },
      metadata: {
        size: params.size || '1024x1024',
        responseFormat: 'responses_api',
        model: this.imageModel,
        provider: this.name,
        generatedAt: new Date().toISOString(),
        originalPrompt: params.prompt,
        responseId: response.id,
        apiResponse: {
          outputCount: response.output.length,
          imageOutputCount: imageData.length
        }
      },
      usage,
      revisedPrompt: revisedPrompt
    };
  }
}
```

## services/llm/adapters/openai/OpenAIModels.ts

```typescript
/**
 * OpenAI Model Specifications
 * Updated October 19, 2025 - Added GPT-5.2 family
 *
 * Pricing Notes:
 * - GPT-5 family supports 90% caching discount (cached tokens: $0.125/M vs $1.25/M fresh)
 * - Caching discounts are applied automatically when prompt_tokens_details.cached_tokens > 0
 * - Pricing shown here is for Standard tier; Batch API offers 50% off, Priority costs more
 *
 * Reference: https://openai.com/api/pricing/
 */

import { ModelSpec } from '../modelTypes';

export const OPENAI_MODELS: ModelSpec[] = [
  // GPT-5.2 family (latest flagship models)
  {
    provider: 'openai',
    name: 'GPT-5.2',
    apiName: 'gpt-5.2',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 1.75,
    outputCostPerMillion: 14.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openai',
    name: 'GPT-5.2 Pro',
    apiName: 'gpt-5.2-pro',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 21.00,
    outputCostPerMillion: 168.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },

  // GPT-5 model family
  {
    provider: 'openai',
    name: 'GPT-5.1',
    apiName: 'gpt-5.1-2025-11-13',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 1.25,
    outputCostPerMillion: 10.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openai',
    name: 'GPT-5',
    apiName: 'gpt-5',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 1.25,
    outputCostPerMillion: 10.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openai',
    name: 'GPT-5 Mini',
    apiName: 'gpt-5-mini',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 0.25,
    outputCostPerMillion: 2.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openai',
    name: 'GPT-5 Nano',
    apiName: 'gpt-5-nano',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 0.05,
    outputCostPerMillion: 0.40,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  }

  // Note: o3/o4 reasoning models removed due to incompatible API (requires max_completion_tokens)
  // These models use a different parameter structure and would need special handling
];

export const OPENAI_DEFAULT_MODEL = 'gpt-5.1-2025-11-13';
```

## services/llm/adapters/openrouter/OpenRouterAdapter.ts

```typescript
/**
 * OpenRouter Adapter - Clean implementation with centralized SSE streaming
 * Supports 400+ models through OpenRouter's unified API
 * Uses BaseAdapter's processSSEStream for reliable streaming
 */

import { BaseAdapter } from '../BaseAdapter';
import {
  GenerateOptions,
  StreamChunk,
  LLMResponse,
  ModelInfo,
  ProviderCapabilities,
  ModelPricing,
  SearchResult
} from '../types';
import { ModelRegistry } from '../ModelRegistry';
import { ReasoningPreserver } from '../shared/ReasoningPreserver';
import { WebSearchUtils } from '../../utils/WebSearchUtils';
import { BRAND_NAME } from '../../../../constants/branding';
import { MCPToolExecution } from '../shared/ToolExecutionUtils';

export class OpenRouterAdapter extends BaseAdapter {
  readonly name = 'openrouter';
  readonly baseUrl = 'https://openrouter.ai/api/v1';

  private httpReferer: string;
  private xTitle: string;

  constructor(
    apiKey: string,
    options?: { httpReferer?: string; xTitle?: string }
  ) {
    super(apiKey, 'anthropic/claude-3.5-sonnet');
    this.httpReferer = options?.httpReferer?.trim() || 'https://synapticlabs.ai';
    this.xTitle = options?.xTitle?.trim() || BRAND_NAME;
    this.initializeCache();
  }

  /**
   * Generate response without caching
   */
  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    try {
      // Validate web search support
      if (options?.webSearch) {
        WebSearchUtils.validateWebSearchRequest('openrouter', options.webSearch);
      }

      const baseModel = options?.model || this.currentModel;

      // Add :online suffix for web search
      const model = options?.webSearch ? `${baseModel}:online` : baseModel;

      // Handle post-stream tool execution: if detectedToolCalls are provided, execute only tools
      if (options?.detectedToolCalls && options.detectedToolCalls.length > 0) {
        return await this.executeDetectedToolCalls(options.detectedToolCalls, model, prompt, options);
      }

      // Tool execution requires streaming - use generateStreamAsync instead
      if (options?.tools && options.tools.length > 0) {
        throw new Error('Tool execution requires streaming. Use generateStreamAsync() instead.');
      }

      const requestBody = {
        model,
        messages: this.buildMessages(prompt, options?.systemPrompt),
        temperature: options?.temperature,
        max_tokens: options?.maxTokens,
        top_p: options?.topP,
        frequency_penalty: options?.frequencyPenalty,
        presence_penalty: options?.presencePenalty,
        response_format: options?.jsonMode ? { type: 'json_object' } : undefined,
        stop: options?.stopSequences,
        tools: options?.tools ? this.convertTools(options.tools) : undefined,
        usage: { include: true } // Enable token usage and cost tracking
      };

      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          ...this.buildHeaders(),
          'Authorization': `Bearer ${this.apiKey}`,
          'HTTP-Referer': this.httpReferer,
          'X-Title': this.xTitle
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();

      const text = data.choices[0]?.message?.content || '';
      const usage = this.extractUsage(data);
      const finishReason = data.choices[0]?.finish_reason || 'stop';

      // Extract web search results if web search was enabled
      const webSearchResults = options?.webSearch
        ? this.extractOpenRouterSources(data)
        : undefined;

      return this.buildLLMResponse(
        text,
        baseModel, // Use base model name, not :online version
        usage,
        { webSearchResults },
        finishReason as 'stop' | 'length' | 'tool_calls' | 'content_filter'
      );
    } catch (error) {
      throw this.handleError(error, 'generation');
    }
  }

  /**
   * Generate streaming response using unified stream processing
   * Uses processStream which automatically handles SSE parsing and tool call accumulation
   */
  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      // Validate web search support
      if (options?.webSearch) {
        WebSearchUtils.validateWebSearchRequest('openrouter', options.webSearch);
      }

      const baseModel = options?.model || this.currentModel;

      // Add :online suffix for web search
      const model = options?.webSearch ? `${baseModel}:online` : baseModel;

      const messages = options?.conversationHistory || this.buildMessages(prompt, options?.systemPrompt);

      // Check if this model requires reasoning preservation (Gemini via OpenRouter)
      const needsReasoning = ReasoningPreserver.requiresReasoningPreservation(baseModel, 'openrouter');
      const hasTools = options?.tools && options.tools.length > 0;

      const requestBody: any = {
        model,
        messages,
        temperature: options?.temperature,
        max_tokens: options?.maxTokens,
        top_p: options?.topP,
        frequency_penalty: options?.frequencyPenalty,
        presence_penalty: options?.presencePenalty,
        response_format: options?.jsonMode ? { type: 'json_object' } : undefined,
        stop: options?.stopSequences,
        tools: options?.tools ? this.convertTools(options.tools) : undefined,
        stream: true,
        // Enable reasoning for Gemini models to capture thought signatures
        ...ReasoningPreserver.getReasoningRequestParams(baseModel, 'openrouter', hasTools || false)
      };

      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          ...this.buildHeaders(),
          'Authorization': `Bearer ${this.apiKey}`,
          'HTTP-Referer': this.httpReferer,
          'X-Title': this.xTitle
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorBody}`);
      }

      // Track generation ID for async usage retrieval
      let generationId: string | null = null;
      let usageFetchTriggered = false;
      // Track reasoning data for models that need preservation (Gemini via OpenRouter)
      // Gemini requires TWO different fields for tool continuations:
      // - reasoning_details: array of reasoning objects from OpenRouter
      // - thought_signature: string signature required by Google for function call continuations
      let capturedReasoning: any[] | undefined = undefined;
      let capturedThoughtSignature: string | undefined = undefined;

      // Use unified stream processing (automatically uses SSE parsing for Response objects)
      yield* this.processStream(response, {
        debugLabel: 'OpenRouter',

        extractContent: (parsed: any) => {
          // Capture generation ID from first chunk
          if (!generationId && parsed.id) {
            generationId = parsed.id;
          }

          // Capture reasoning_details for Gemini models (required for tool continuations)
          if (needsReasoning && !capturedReasoning) {
            capturedReasoning =
              parsed.reasoning_details ||
              parsed.choices?.[0]?.message?.reasoning_details ||
              parsed.choices?.[0]?.delta?.reasoning_details ||
              parsed.choices?.[0]?.reasoning_details ||
              ReasoningPreserver.extractFromStreamChunk(parsed);

          }

          // Capture thought_signature for Gemini models (OpenAI compatibility format)
          // Per Google docs, this can be in: extra_content.google.thought_signature
          // or directly on the delta/message
          if (needsReasoning && !capturedThoughtSignature) {
            const delta = parsed.choices?.[0]?.delta;
            const message = parsed.choices?.[0]?.message;

            capturedThoughtSignature =
              // OpenAI compatibility format per Google docs
              delta?.extra_content?.google?.thought_signature ||
              message?.extra_content?.google?.thought_signature ||
              parsed.extra_content?.google?.thought_signature ||
              // Direct formats
              delta?.thought_signature ||
              delta?.thoughtSignature ||
              message?.thought_signature ||
              message?.thoughtSignature ||
              parsed.thought_signature ||
              parsed.thoughtSignature;

          }

          // Process all available choices - reasoning models may use multiple choices
          for (const choice of parsed.choices || []) {
            const delta = choice?.delta;
            const content = delta?.content || delta?.text || choice?.text;
            if (content) {
              return content;
            }
          }
          return null;
        },

        extractToolCalls: (parsed: any) => {
          // Extract tool calls from any choice that has them
          for (const choice of parsed.choices || []) {
            let toolCalls = choice?.delta?.tool_calls || choice?.delta?.toolCalls;
            if (toolCalls) {
              // Extract reasoning_details from this chunk (it may contain encrypted thought signatures)
              const chunkReasoningDetails = choice?.delta?.reasoning_details;
              if (chunkReasoningDetails && Array.isArray(chunkReasoningDetails)) {
                // Look for reasoning.encrypted entries - these contain the thought_signature
                for (const entry of chunkReasoningDetails) {
                  if (entry.type === 'reasoning.encrypted' && entry.data && entry.id) {
                    // Match encrypted entry to tool call by id
                    for (const tc of toolCalls) {
                      if (tc.id === entry.id || tc.id?.startsWith(entry.id?.split('_').slice(0, -1).join('_'))) {
                        tc.thought_signature = entry.data;
                      }
                    }
                    // Also store as fallback
                    if (!capturedThoughtSignature) {
                      capturedThoughtSignature = entry.data;
                    }
                  }
                }
                // Update capturedReasoning to include all entries (both text and encrypted)
                if (!capturedReasoning) {
                  capturedReasoning = chunkReasoningDetails;
                } else if (Array.isArray(capturedReasoning)) {
                  // Merge in new entries
                  capturedReasoning = [...capturedReasoning, ...chunkReasoningDetails];
                }
              }

              // Also check direct thought_signature fields (fallback)
              for (const tc of toolCalls) {
                const tcThoughtSig =
                  tc.thought_signature ||
                  tc.thoughtSignature ||
                  tc.extra_content?.google?.thought_signature;
                if (tcThoughtSig && !tc.thought_signature) {
                  tc.thought_signature = tcThoughtSig;
                }
              }

              // Attach reasoning data (both reasoning_details AND thought_signature)
              const hasReasoning = capturedReasoning || capturedThoughtSignature;
              if (hasReasoning) {
                toolCalls = ReasoningPreserver.attachToToolCalls(
                  toolCalls,
                  {
                    reasoning_details: capturedReasoning,
                    thought_signature: capturedThoughtSignature
                  }
                );
              }
              return toolCalls;
            }
          }
          return null;
        },

        extractFinishReason: (parsed: any) => {
          // Extract finish reason from any choice
          for (const choice of parsed.choices || []) {
            if (choice?.finish_reason) {
              // Last chance to capture thought_signature from final chunk
              if (needsReasoning && !capturedThoughtSignature) {
                const delta = choice?.delta;
                const message = choice?.message;
                capturedThoughtSignature =
                  delta?.extra_content?.google?.thought_signature ||
                  message?.extra_content?.google?.thought_signature ||
                  parsed.extra_content?.google?.thought_signature ||
                  delta?.thought_signature ||
                  message?.thought_signature ||
                  parsed.thought_signature ||
                  choice?.thought_signature;

              }

              // When we detect completion, trigger async usage fetch (only once)
              if (generationId && options?.onUsageAvailable && !usageFetchTriggered) {
                usageFetchTriggered = true;
                // Fire and forget - don't await
                this.fetchAndNotifyUsage(generationId, baseModel, options.onUsageAvailable).catch(() => undefined);
              }

              return choice.finish_reason;
            }
          }
          return null;
        },

        extractUsage: (parsed: any) => {
          // OpenRouter doesn't include usage in streaming responses
          // We'll fetch it asynchronously using the generation ID when completion is detected
          return null;
        },

        // Extract reasoning from reasoning_details array (OpenRouter unified format)
        extractReasoning: (parsed: any) => {
          // Check for reasoning_details in delta or message
          const reasoningDetails =
            parsed.choices?.[0]?.delta?.reasoning_details ||
            parsed.choices?.[0]?.message?.reasoning_details ||
            parsed.reasoning_details;

          if (reasoningDetails && Array.isArray(reasoningDetails)) {
            // Find reasoning.text entries (these contain the actual reasoning text)
            const textEntries = reasoningDetails.filter((r: any) => r.type === 'reasoning.text');
            if (textEntries.length > 0) {
              const reasoningText = textEntries.map((r: any) => r.text || '').join('');
              if (reasoningText) {
                return {
                  text: reasoningText,
                  complete: false  // We can't know if reasoning is complete from streaming
                };
              }
            }

            // Also check for reasoning.summary entries
            const summaryEntries = reasoningDetails.filter((r: any) => r.type === 'reasoning.summary');
            if (summaryEntries.length > 0) {
              const summaryText = summaryEntries.map((r: any) => r.text || r.summary || '').join('');
              if (summaryText) {
                return {
                  text: summaryText,
                  complete: false
                };
              }
            }
          }
          return null;
        }
      });

    } catch (error) {
      throw this.handleError(error, 'streaming generation');
    }
  }

  /**
   * Fetch usage data and notify via callback - runs asynchronously after streaming completes
   */
  private async fetchAndNotifyUsage(
    generationId: string,
    model: string,
    onUsageAvailable: (usage: any, cost?: any) => void
  ): Promise<void> {
    try {
      const stats = await this.fetchGenerationStats(generationId);

      if (!stats) {
        return;
      }

      const usage = {
        promptTokens: stats.promptTokens,
        completionTokens: stats.completionTokens,
        totalTokens: stats.totalTokens
      };

      // Calculate cost - prefer provider total_cost when present, otherwise fall back to pricing calculation
      let cost;
      if (stats.totalCost !== undefined) {
        cost = {
          totalCost: stats.totalCost,
          currency: stats.currency || 'USD'
        };
      } else {
        cost = await this.calculateCost(usage, model);
      }

      // Notify via callback
      onUsageAvailable(usage, cost || undefined);

    } catch (error) {
      throw error;
    }
  }

  /**
   * Fetch generation statistics from OpenRouter using generation ID with exponential backoff
   * This is the proper way to get token usage and cost for streaming requests
   */
  private async fetchGenerationStats(generationId: string): Promise<{
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    totalCost?: number;
    currency?: string;
  } | null> {
    // OpenRouter stats can lag ~3-6s; extend retries to reduce 404 noise
    const maxRetries = 12;
    const baseDelay = 900; // Start near 1s
    const incrementDelay = 500; // Grow more aggressively
    let lastStatus: number | null = null;

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        // Linear backoff: 800ms, 1000ms, 1200ms, 1400ms, 1600ms
        if (attempt > 0) {
          const delay = baseDelay + (incrementDelay * attempt);
          await new Promise(resolve => setTimeout(resolve, delay));
        }

        const response = await fetch(`${this.baseUrl}/generation?id=${generationId}`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'HTTP-Referer': this.httpReferer,
            'X-Title': this.xTitle
          }
        });

        lastStatus = response.status;

        if (response.status === 404) {
          // Stats not ready yet, retry
          continue;
        }

        if (!response.ok) {
          return null;
        }

        const data = await response.json();

        // Extract token counts from response
        // OpenRouter returns: tokens_prompt, tokens_completion, native_tokens_prompt, native_tokens_completion
        const promptTokens = data.data?.native_tokens_prompt || data.data?.tokens_prompt || 0;
        const completionTokens = data.data?.native_tokens_completion || data.data?.tokens_completion || 0;
        const totalCost = data.data?.total_cost ?? undefined;
        const currency = 'USD';

        if (promptTokens > 0 || completionTokens > 0) {
          return {
            promptTokens,
            completionTokens,
            totalTokens: promptTokens + completionTokens,
            totalCost,
            currency
          };
        }

        // Data returned but no tokens - might not be ready yet
      } catch (error) {
        if (attempt === maxRetries - 1) {
          return null;
        }
      }
    }

    return null;
  }

  /**
   * List available models
   */
  async listModels(): Promise<ModelInfo[]> {
    try {
      // Use centralized model registry
      const openrouterModels = ModelRegistry.getProviderModels('openrouter');
      return openrouterModels.map(model => ModelRegistry.toModelInfo(model));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }

  /**
   * Get provider capabilities
   */
  getCapabilities(): ProviderCapabilities {
    const baseCapabilities = {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsThinking: false,
      maxContextWindow: 2000000, // Varies by model
      supportedFeatures: [
        'streaming',
        'json_mode',
        'function_calling',
        'image_input',
        '400+ models'
      ]
    };

    return baseCapabilities;
  }

  /**
   * Execute detected tool calls from streaming and get AI response
   * Used for post-stream tool execution - implements pingpong pattern
   */
  private async executeDetectedToolCalls(detectedToolCalls: any[], model: string, prompt: string, options?: GenerateOptions): Promise<LLMResponse> {

    try {
      // Convert to MCP format
      const mcpToolCalls: any[] = detectedToolCalls.map((tc: any) => ({
        id: tc.id,
        function: {
          name: tc.function?.name || tc.name,
          arguments: tc.function?.arguments || JSON.stringify(tc.parameters || {})
        }
      }));

      // Execute tool calls directly using MCPToolExecution
      // Note: This path is deprecated - tool execution now happens in StreamingOrchestrator
      // Passing null will return error results for all tools
      const toolResults = await MCPToolExecution.executeToolCalls(
        null, // No toolExecutor available in adapter context
        mcpToolCalls,
        'openrouter',
        options?.onToolEvent
      );


      // Now do the "pingpong" - send the conversation with tool results back to the LLM
      const messages = this.buildMessages(prompt, options?.systemPrompt);

      // Build assistant message with reasoning preserved using centralized utility
      const assistantMessage = ReasoningPreserver.buildAssistantMessageWithReasoning(
        detectedToolCalls,
        '' // Empty content since this was a tool call
      );

      messages.push(assistantMessage);

      // Add tool result messages
      const toolMessages = MCPToolExecution.buildToolMessages(toolResults, 'openrouter');
      messages.push(...toolMessages);


      // Make API call to get AI's response to the tool results
      const requestBody = {
        model,
        messages,
        temperature: options?.temperature,
        max_tokens: options?.maxTokens,
        top_p: options?.topP,
        frequency_penalty: options?.frequencyPenalty,
        presence_penalty: options?.presencePenalty,
        response_format: options?.jsonMode ? { type: 'json_object' } : undefined,
        stop: options?.stopSequences,
        usage: { include: true } // Enable token usage and cost tracking
      };
      
      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          ...this.buildHeaders(),
          'Authorization': `Bearer ${this.apiKey}`,
          'HTTP-Referer': this.httpReferer,
          'X-Title': this.xTitle
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      const choice = data.choices[0];
      const finalContent = choice?.message?.content || 'No response from AI after tool execution';
      const usage = this.extractUsage(data);


      // Combine original tool calls with their execution results
      const completeToolCalls = detectedToolCalls.map(originalCall => {
        const result = toolResults.find(r => r.id === originalCall.id);
        return {
          id: originalCall.id,
          name: originalCall.function?.name || originalCall.name,
          parameters: JSON.parse(originalCall.function?.arguments || '{}'),
          result: result?.result,
          success: result?.success || false,
          error: result?.error,
          executionTime: result?.executionTime
        };
      });

      // Return LLMResponse with AI's natural language response to tool results
      return this.buildLLMResponse(
        finalContent,
        model,
        usage,
        MCPToolExecution.buildToolMetadata(toolResults),
        choice?.finish_reason || 'stop',
        completeToolCalls
      );

    } catch (error) {
      console.error('OpenRouter adapter post-stream tool execution failed:', error);
      throw this.handleError(error, 'post-stream tool execution');
    }
  }

  /**
   * Extract search results from OpenRouter response annotations
   */
  private extractOpenRouterSources(response: any): SearchResult[] {
    try {
      const annotations = response.choices?.[0]?.message?.annotations || [];
      const sources = annotations
        .filter((ann: any) => ann.type === 'url_citation')
        .map((ann: any) => {
          const citation = ann.url_citation;
          return WebSearchUtils.validateSearchResult({
            title: citation?.title || citation?.text || 'Unknown Source',
            url: citation?.url,
            date: citation?.date || citation?.timestamp
          });
        })
        .filter((result: SearchResult | null): result is SearchResult => result !== null);

      return sources;
    } catch (error) {
      return [];
    }
  }

  /**
   * Get model pricing
   */
  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    try {
      const models = ModelRegistry.getProviderModels('openrouter');
      const model = models.find(m => m.apiName === modelId);
      if (!model) {
        return null;
      }

      return {
        rateInputPerMillion: model.inputCostPerMillion,
        rateOutputPerMillion: model.outputCostPerMillion,
        currency: 'USD'
      };
    } catch (error) {
      return null;
    }
  }

  private convertTools(tools: any[]): any[] {
    return tools.map(tool => {
      if (tool.type === 'function') {
        // Handle both nested (Chat Completions) and flat (Responses API) formats
        const toolDef = tool.function || tool;
        return {
          type: 'function',
          function: {
            name: toolDef.name,
            description: toolDef.description,
            parameters: toolDef.parameters || toolDef.input_schema
          }
        };
      }
      return tool;
    });
  }
}

```

## services/llm/adapters/openrouter/OpenRouterImageAdapter.ts

```typescript
/**
 * OpenRouter Image Generation Adapter
 * Supports image generation through OpenRouter's unified API
 * Uses models with "image" in their output_modalities
 *
 * API: POST /api/v1/chat/completions with modalities: ['image', 'text']
 */

import { Vault } from 'obsidian';
import { BaseImageAdapter } from '../BaseImageAdapter';
import {
  ImageGenerationParams,
  ImageGenerationResponse,
  ImageValidationResult,
  ImageModel,
  ImageUsage,
  AspectRatio,
  NanoBananaImageSize
} from '../../types/ImageTypes';
import {
  ProviderConfig,
  ProviderCapabilities,
  ModelInfo,
  CostDetails
} from '../types';
import { BRAND_NAME } from '../../../../constants/branding';

export class OpenRouterImageAdapter extends BaseImageAdapter {

  async* generateStreamAsync(): AsyncGenerator<never, void, unknown> {
    throw new Error('Image generation does not support streaming');
  }

  readonly name = 'openrouter-image';
  readonly baseUrl = 'https://openrouter.ai/api/v1';
  readonly supportedModels: ImageModel[] = [
    'gemini-2.5-flash-image' as ImageModel,
    'gemini-3-pro-image-preview' as ImageModel
  ];
  readonly supportedSizes: string[] = ['1024x1024', '1536x1024', '1024x1536', '1792x1024', '1024x1792'];
  readonly supportedFormats: string[] = ['png', 'jpeg', 'webp'];

  private vault: Vault | null = null;
  private httpReferer: string;
  private xTitle: string;

  // OpenRouter model IDs for image generation
  private readonly modelMap: Record<string, string> = {
    'gemini-2.5-flash-image': 'google/gemini-2.5-flash-image-preview',
    'gemini-3-pro-image-preview': 'google/gemini-3-pro-image-preview',
    // Add other image-capable models as they become available
    'flux-2-pro': 'black-forest-labs/flux.2-pro',
    'flux-2-flex': 'black-forest-labs/flux.2-flex'
  };

  private readonly defaultModel = 'gemini-2.5-flash-image';

  // Supported aspect ratios per OpenRouter docs
  private readonly openRouterAspectRatios = [
    '1:1', '2:3', '3:2', '3:4', '4:3', '4:5', '5:4', '9:16', '16:9', '21:9'
  ];

  constructor(config?: ProviderConfig & { vault?: Vault; httpReferer?: string; xTitle?: string }) {
    const apiKey = config?.apiKey || '';
    super(apiKey, 'gemini-2.5-flash-image', config?.baseUrl);

    if (config?.vault) {
      this.vault = config.vault;
    }

    this.httpReferer = config?.httpReferer?.trim() || 'https://synapticlabs.ai';
    this.xTitle = config?.xTitle?.trim() || BRAND_NAME;

    this.initializeCache();
  }

  /**
   * Set vault for reading reference images
   */
  setVault(vault: Vault): void {
    this.vault = vault;
  }

  /**
   * Generate images using OpenRouter's unified API
   * Uses modalities: ['image', 'text'] for image generation
   */
  async generateImage(params: ImageGenerationParams): Promise<ImageGenerationResponse> {
    try {
      this.validateConfiguration();

      const model = params.model || this.defaultModel;
      const openRouterModel = this.modelMap[model] || `google/${model}`;

      const response = await this.withRetry(async () => {
        // Build message content with prompt and reference images
        const content: any[] = [{ type: 'text', text: params.prompt }];

        // Add reference images if provided
        if (params.referenceImages && params.referenceImages.length > 0) {
          const referenceImageParts = await this.loadReferenceImages(params.referenceImages);
          content.push(...referenceImageParts);
        }

        // Build request body per OpenRouter docs
        const requestBody: any = {
          model: openRouterModel,
          messages: [
            {
              role: 'user',
              content: content.length === 1 ? params.prompt : content
            }
          ],
          modalities: ['image', 'text']
        };

        // Add image_config for aspect ratio
        if (params.aspectRatio) {
          requestBody.image_config = {
            aspect_ratio: params.aspectRatio
          };
        }

        const result = await fetch(`${this.baseUrl}/chat/completions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this.apiKey}`,
            'HTTP-Referer': this.httpReferer,
            'X-Title': this.xTitle
          },
          body: JSON.stringify(requestBody)
        });

        if (!result.ok) {
          const errorBody = await result.text();
          throw new Error(`HTTP ${result.status}: ${result.statusText} - ${errorBody}`);
        }

        return await result.json();
      }, 2);

      return this.buildImageResponse(response, params);
    } catch (error) {
      this.handleImageError(error, 'image generation', params);
    }
  }

  /**
   * Load reference images from vault and convert to OpenRouter format
   */
  private async loadReferenceImages(paths: string[]): Promise<any[]> {
    if (!this.vault) {
      throw new Error('Vault not configured - cannot load reference images');
    }

    const parts: any[] = [];

    for (const path of paths) {
      try {
        const file = this.vault.getAbstractFileByPath(path);
        if (!file) {
          throw new Error(`Reference image not found: ${path}`);
        }

        // Read file as binary
        const arrayBuffer = await this.vault.readBinary(file as import('obsidian').TFile);
        const buffer = Buffer.from(arrayBuffer);
        const base64 = buffer.toString('base64');

        // Determine MIME type from extension
        const mimeType = this.getMimeType(path);

        // OpenRouter uses OpenAI-style image format
        parts.push({
          type: 'image_url',
          image_url: {
            url: `data:${mimeType};base64,${base64}`
          }
        });
      } catch (error) {
        throw new Error(`Failed to load reference image ${path}: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }

    return parts;
  }

  /**
   * Get MIME type from file extension
   */
  private getMimeType(path: string): string {
    const ext = path.toLowerCase().split('.').pop() || '';
    const mimeTypes: Record<string, string> = {
      'png': 'image/png',
      'jpg': 'image/jpeg',
      'jpeg': 'image/jpeg',
      'gif': 'image/gif',
      'webp': 'image/webp',
      'bmp': 'image/bmp'
    };
    return mimeTypes[ext] || 'image/png';
  }

  /**
   * Validate OpenRouter-specific image generation parameters
   */
  validateImageParams(params: ImageGenerationParams): ImageValidationResult {
    const baseValidation = this.validateCommonParams(params);
    if (!baseValidation.isValid) {
      return baseValidation;
    }

    const errors: string[] = [...baseValidation.errors];
    const warnings: string[] = [...(baseValidation.warnings || [])];
    const adjustedParams: Partial<ImageGenerationParams> = {};

    // Validate model
    const model = params.model || this.defaultModel;
    if (model && !this.modelMap[model]) {
      warnings.push(`Unknown model ${model}, will attempt to use as-is`);
    }

    // Validate aspect ratio
    if (params.aspectRatio && !this.openRouterAspectRatios.includes(params.aspectRatio)) {
      errors.push(`Invalid aspect ratio. Supported ratios: ${this.openRouterAspectRatios.join(', ')}`);
    }

    // Validate reference images
    if (params.referenceImages && params.referenceImages.length > 0) {
      // OpenRouter/Gemini supports up to 14 reference images
      if (params.referenceImages.length > 14) {
        errors.push('Too many reference images. Maximum is 14 reference images');
      }

      // Validate image extensions
      const validExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.bmp'];
      for (const path of params.referenceImages) {
        const ext = '.' + (path.toLowerCase().split('.').pop() || '');
        if (!validExtensions.includes(ext)) {
          errors.push(`Invalid reference image format: ${path}. Supported formats: ${validExtensions.join(', ')}`);
        }
      }
    }

    // Set default model if not specified
    if (!params.model) {
      adjustedParams.model = this.defaultModel;
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      adjustedParams
    };
  }

  /**
   * Get OpenRouter image capabilities
   */
  getImageCapabilities(): ProviderCapabilities {
    return {
      supportsStreaming: false,
      supportsJSON: false,
      supportsImages: true,
      supportsFunctions: false,
      supportsThinking: false,
      supportsImageGeneration: true,
      maxContextWindow: 32000,
      supportedFeatures: [
        'text_to_image',
        'image_to_image',
        'multi_reference_images',
        'aspect_ratio_control',
        'multiple_model_choice'
      ]
    };
  }

  /**
   * Get supported aspect ratios
   */
  getSupportedAspectRatios(): AspectRatio[] {
    return [
      AspectRatio.SQUARE,
      AspectRatio.PORTRAIT_2_3,
      AspectRatio.LANDSCAPE_3_2,
      AspectRatio.PORTRAIT_3_4,
      AspectRatio.LANDSCAPE_4_3,
      AspectRatio.PORTRAIT_4_5,
      AspectRatio.LANDSCAPE_5_4,
      AspectRatio.PORTRAIT_9_16,
      AspectRatio.LANDSCAPE_16_9,
      AspectRatio.ULTRAWIDE_21_9
    ];
  }

  /**
   * Get supported image sizes
   */
  getSupportedImageSizes(): string[] {
    return [...this.supportedSizes];
  }

  /**
   * Get pricing for OpenRouter image models
   * Note: OpenRouter pricing varies by underlying model
   */
  async getImageModelPricing(model: string = 'gemini-2.5-flash-image'): Promise<CostDetails> {
    // OpenRouter pricing is model-dependent
    // These are approximate prices - actual cost from OpenRouter API response
    const pricing: Record<string, number> = {
      'gemini-2.5-flash-image': 0.039,
      'gemini-3-pro-image-preview': 0.08,
      'flux-2-pro': 0.05,
      'flux-2-flex': 0.03
    };

    const basePrice = pricing[model] || 0.05;

    return {
      inputCost: 0,
      outputCost: basePrice,
      totalCost: basePrice,
      currency: 'USD',
      rateInputPerMillion: 0,
      rateOutputPerMillion: basePrice * 1_000_000
    };
  }

  /**
   * List available OpenRouter image models
   */
  async listModels(): Promise<ModelInfo[]> {
    return [
      {
        id: 'gemini-2.5-flash-image',
        name: 'Nano Banana (via OpenRouter)',
        contextWindow: 32000,
        maxOutputTokens: 0,
        supportsJSON: false,
        supportsImages: true,
        supportsFunctions: false,
        supportsStreaming: false,
        supportsThinking: false,
        supportsImageGeneration: true,
        pricing: {
          inputPerMillion: 0,
          outputPerMillion: 0,
          imageGeneration: 0.039,
          currency: 'USD',
          lastUpdated: '2025-12-07'
        }
      },
      {
        id: 'gemini-3-pro-image-preview',
        name: 'Nano Banana Pro (via OpenRouter)',
        contextWindow: 32000,
        maxOutputTokens: 0,
        supportsJSON: false,
        supportsImages: true,
        supportsFunctions: false,
        supportsStreaming: false,
        supportsThinking: false,
        supportsImageGeneration: true,
        pricing: {
          inputPerMillion: 0,
          outputPerMillion: 0,
          imageGeneration: 0.08,
          currency: 'USD',
          lastUpdated: '2025-12-07'
        }
      },
      {
        id: 'flux-2-pro',
        name: 'FLUX.2 Pro (via OpenRouter)',
        contextWindow: 4096,
        maxOutputTokens: 0,
        supportsJSON: false,
        supportsImages: false,
        supportsFunctions: false,
        supportsStreaming: false,
        supportsThinking: false,
        supportsImageGeneration: true,
        pricing: {
          inputPerMillion: 0,
          outputPerMillion: 0,
          imageGeneration: 0.05,
          currency: 'USD',
          lastUpdated: '2025-12-07'
        }
      },
      {
        id: 'flux-2-flex',
        name: 'FLUX.2 Flex (via OpenRouter)',
        contextWindow: 4096,
        maxOutputTokens: 0,
        supportsJSON: false,
        supportsImages: false,
        supportsFunctions: false,
        supportsStreaming: false,
        supportsThinking: false,
        supportsImageGeneration: true,
        pricing: {
          inputPerMillion: 0,
          outputPerMillion: 0,
          imageGeneration: 0.03,
          currency: 'USD',
          lastUpdated: '2025-12-07'
        }
      }
    ];
  }

  // Private helper methods

  private buildImageResponse(
    response: any,
    params: ImageGenerationParams
  ): ImageGenerationResponse {
    // OpenRouter response format:
    // { choices: [{ message: { content: "...", images: [{ type: "image_url", image_url: { url: "data:image/png;base64,..." } }] } }] }

    if (!response.choices || response.choices.length === 0) {
      throw new Error('No response choices received from OpenRouter');
    }

    const message = response.choices[0].message;
    if (!message?.images || message.images.length === 0) {
      throw new Error('No images found in OpenRouter response');
    }

    const imageData = message.images[0];
    const imageUrl = imageData.image_url?.url || imageData.imageUrl?.url;

    if (!imageUrl) {
      throw new Error('No image URL found in OpenRouter response');
    }

    // Parse base64 data URL
    const matches = imageUrl.match(/^data:image\/(\w+);base64,(.+)$/);
    if (!matches) {
      throw new Error('Invalid image data URL format from OpenRouter');
    }

    const format = matches[1] as 'png' | 'jpeg' | 'webp';
    const base64Data = matches[2];
    const buffer = Buffer.from(base64Data, 'base64');

    // Extract dimensions from aspectRatio
    let width = 1024, height = 1024;
    let aspectRatio: AspectRatio = params.aspectRatio || AspectRatio.SQUARE;

    // Map aspect ratios to dimensions per OpenRouter docs
    const aspectRatioToDimensions: Record<string, [number, number]> = {
      '1:1': [1024, 1024],
      '2:3': [832, 1248],
      '3:2': [1248, 832],
      '3:4': [864, 1184],
      '4:3': [1184, 864],
      '4:5': [896, 1152],
      '5:4': [1152, 896],
      '9:16': [768, 1344],
      '16:9': [1344, 768],
      '21:9': [1536, 672]
    };

    if (params.aspectRatio && aspectRatioToDimensions[params.aspectRatio]) {
      [width, height] = aspectRatioToDimensions[params.aspectRatio];
    }

    const usage: ImageUsage = this.buildImageUsage(1, `${width}x${height}`, params.model || this.defaultModel);

    return {
      imageData: buffer,
      format: format,
      dimensions: { width, height },
      metadata: {
        aspectRatio,
        model: params.model || this.defaultModel,
        provider: this.name,
        generatedAt: new Date().toISOString(),
        originalPrompt: params.prompt,
        referenceImagesCount: params.referenceImages?.length || 0,
        openRouterModel: this.modelMap[params.model || this.defaultModel]
      },
      usage
    };
  }
}

```

## services/llm/adapters/openrouter/OpenRouterModels.ts

```typescript
/**
 * OpenRouter Model Specifications
 * OpenRouter provides access to multiple providers through a unified API
 * Updated August 10, 2025 with GPT-5 models
 */

import { ModelSpec } from '../modelTypes';

// OpenRouter provides access to models from other providers
// Each model has its own specific API name in OpenRouter
export const OPENROUTER_MODELS: ModelSpec[] = [
  // OpenAI GPT-5.2 models via OpenRouter
  {
    provider: 'openrouter',
    name: 'GPT-5.2',
    apiName: 'openai/gpt-5.2',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 1.75,
    outputCostPerMillion: 14.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openrouter',
    name: 'GPT-5.2 Pro',
    apiName: 'openai/gpt-5.2-pro',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 21.00,
    outputCostPerMillion: 168.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },

  // OpenAI GPT-5 models via OpenRouter
  {
    provider: 'openrouter',
    name: 'GPT-5.1',
    apiName: 'openai/gpt-5.1',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 1.25,
    outputCostPerMillion: 10.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openrouter',
    name: 'GPT-5',
    apiName: 'openai/gpt-5',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 1.25,
    outputCostPerMillion: 10.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openrouter',
    name: 'GPT-5 Mini',
    apiName: 'openai/gpt-5-mini',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 0.25,
    outputCostPerMillion: 2.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openrouter',
    name: 'GPT-5 Nano',
    apiName: 'openai/gpt-5-nano',
    contextWindow: 400000,
    maxTokens: 128000,
    inputCostPerMillion: 0.05,
    outputCostPerMillion: 0.40,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },

  // Google models via OpenRouter
  {
    provider: 'openrouter',
    name: 'Gemini 3.0 Pro Preview',
    apiName: 'google/gemini-3-pro-preview',
    contextWindow: 1048576,
    maxTokens: 8192,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 12.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openrouter',
    name: 'Gemini 3.0 Flash Preview',
    apiName: 'google/gemini-3-flash-preview',
    contextWindow: 1048576,
    maxTokens: 65536,
    inputCostPerMillion: 0.50,
    outputCostPerMillion: 3.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openrouter',
    name: 'Gemini 2.5 Pro',
    apiName: 'google/gemini-2.5-pro',
    contextWindow: 1048576,
    maxTokens: 66000,
    inputCostPerMillion: 1.25,
    outputCostPerMillion: 10.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openrouter',
    name: 'Gemini 2.5 Flash',
    apiName: 'google/gemini-2.5-flash',
    contextWindow: 1048576,
    maxTokens: 65536,
    inputCostPerMillion: 0.15,
    outputCostPerMillion: 0.60,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Anthropic models via OpenRouter
  {
    provider: 'openrouter',
    name: 'Claude 4.5 Opus',
    apiName: 'anthropic/claude-opus-4.5',
    contextWindow: 200000,
    maxTokens: 32000,
    inputCostPerMillion: 5.00,
    outputCostPerMillion: 25.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openrouter',
    name: 'Claude 4.5 Haiku',
    apiName: 'anthropic/claude-haiku-4-5',
    contextWindow: 200000,
    maxTokens: 64000,
    inputCostPerMillion: 1.00,
    outputCostPerMillion: 5.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'openrouter',
    name: 'Claude 4 Sonnet',
    apiName: 'anthropic/claude-sonnet-4',
    contextWindow: 200000,
    maxTokens: 64000,
    inputCostPerMillion: 3.00,
    outputCostPerMillion: 15.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'openrouter',
    name: 'Claude 4.5 Sonnet',
    apiName: 'anthropic/claude-sonnet-4.5',
    contextWindow: 1000000,
    maxTokens: 64000,
    inputCostPerMillion: 3.00,
    outputCostPerMillion: 15.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
];

export const OPENROUTER_DEFAULT_MODEL = 'openai/gpt-5.1';
```

## services/llm/adapters/perplexity/PerplexityAdapter.ts

```typescript
/**
 * Perplexity AI Adapter with true streaming support
 * Supports Perplexity's Sonar models with web search and reasoning capabilities
 * Based on official Perplexity streaming documentation with SSE parsing
 */

import { BaseAdapter } from '../BaseAdapter';
import {
  GenerateOptions,
  StreamChunk,
  LLMResponse,
  ModelInfo,
  ProviderCapabilities,
  ModelPricing,
  TokenUsage,
  SearchResult
} from '../types';
import { PERPLEXITY_MODELS, PERPLEXITY_DEFAULT_MODEL } from './PerplexityModels';
import { WebSearchUtils } from '../../utils/WebSearchUtils';
import { MCPToolExecution } from '../shared/ToolExecutionUtils';

export interface PerplexityOptions extends GenerateOptions {
  webSearch?: boolean;
  searchMode?: 'web' | 'academic';
  reasoningEffort?: 'low' | 'medium' | 'high';
  searchContextSize?: 'low' | 'medium' | 'high';
}

interface PerplexityChatMessage {
  content?: string;
  toolCalls?: any[];
}

interface PerplexityChatChoice {
  message?: PerplexityChatMessage;
  finish_reason?: string;
}

interface PerplexityChatResponse {
  choices: PerplexityChatChoice[];
  usage?: {
    prompt_tokens?: number;
    completion_tokens?: number;
    total_tokens?: number;
  };
  search_results?: any[];
}

export class PerplexityAdapter extends BaseAdapter {
  readonly name = 'perplexity';
  readonly baseUrl = 'https://api.perplexity.ai';

  constructor(apiKey: string, model?: string) {
    super(apiKey, model || PERPLEXITY_DEFAULT_MODEL);
    this.initializeCache();
  }

  async generateUncached(prompt: string, options?: PerplexityOptions): Promise<LLMResponse> {
    try {
      // Validate web search support (Perplexity always supports web search)
      if (options?.webSearch) {
        WebSearchUtils.validateWebSearchRequest('perplexity', options.webSearch);
      }

      const model = options?.model || this.currentModel;

      // Perplexity does not support native function calling
      // If tools are requested, proceed without tools

      // Use standard chat completions (Perplexity's strength is web search, not tool calling)
      return await this.generateWithChatCompletions(prompt, options);
    } catch (error) {
      throw this.handleError(error, 'generation');
    }
  }

  /**
   * Generate streaming response using async generator
   * Uses unified stream processing with automatic tool call accumulation
   */
  async* generateStreamAsync(prompt: string, options?: PerplexityOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      const requestBody = {
        model: options?.model || this.currentModel,
        messages: this.buildMessages(prompt, options?.systemPrompt),
        temperature: options?.temperature,
        max_tokens: options?.maxTokens,
        top_p: options?.topP,
        presence_penalty: options?.presencePenalty,
        frequency_penalty: options?.frequencyPenalty,
        tools: options?.tools ? this.convertTools(options.tools) : undefined,
        stream: true,
        extra: {
          search_mode: options?.searchMode || 'web',
          reasoning_effort: options?.reasoningEffort || 'medium',
          web_search_options: {
            search_context_size: options?.searchContextSize || 'low'
          }
        }
      };

      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      }

      // Use unified stream processing with automatic SSE parsing and tool call accumulation
      yield* this.processStream(response, {
        debugLabel: 'Perplexity',
        extractContent: (parsed) => parsed.choices?.[0]?.delta?.content || null,
        extractToolCalls: (parsed) => parsed.choices?.[0]?.delta?.tool_calls || null,
        extractFinishReason: (parsed) => parsed.choices?.[0]?.finish_reason || null,
        extractUsage: (parsed) => parsed.usage || null
      });
    } catch (error) {
      console.error('[PerplexityAdapter] Streaming error:', error);
      throw error;
    }
  }

  async listModels(): Promise<ModelInfo[]> {
    try {
      return PERPLEXITY_MODELS.map(model => ({
        id: model.apiName,
        name: model.name,
        contextWindow: model.contextWindow,
        maxOutputTokens: model.maxTokens,
        supportsJSON: model.capabilities.supportsJSON,
        supportsImages: model.capabilities.supportsImages,
        supportsFunctions: model.capabilities.supportsFunctions,
        supportsStreaming: model.capabilities.supportsStreaming,
        supportsThinking: false,
        costPer1kTokens: {
          input: model.inputCostPerMillion / 1000,
          output: model.outputCostPerMillion / 1000
        },
        pricing: {
          inputPerMillion: model.inputCostPerMillion,
          outputPerMillion: model.outputCostPerMillion,
          currency: 'USD',
          lastUpdated: new Date().toISOString()
        }
      }));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }

  getCapabilities(): ProviderCapabilities {
    return {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false, // Perplexity does not support function calling
      supportsThinking: false,
      maxContextWindow: 127072,
      supportedFeatures: [
        'messages',
        'streaming',
        'web_search', // This is Perplexity's main strength
        'reasoning',
        'sonar_models',
        'academic_search',
        'real_time_information',
        'citations'
      ]
    };
  }

  /**
   * Generate using standard chat completions
   */
  private async generateWithChatCompletions(prompt: string, options?: PerplexityOptions): Promise<LLMResponse> {
    const model = options?.model || this.currentModel;
    
    const requestBody: any = {
      model,
      messages: this.buildMessages(prompt, options?.systemPrompt),
      temperature: options?.temperature,
      max_tokens: options?.maxTokens,
      top_p: options?.topP,
      presence_penalty: options?.presencePenalty,
      frequency_penalty: options?.frequencyPenalty,
      extra: {
        search_mode: options?.searchMode || 'web',
        reasoning_effort: options?.reasoningEffort || 'medium',
        web_search_options: {
          search_context_size: options?.searchContextSize || 'low'
        }
      }
    };

    // Add tools if provided
    if (options?.tools) {
      requestBody.tools = this.convertTools(options.tools);
    }

    const response = await fetch(`${this.baseUrl}/chat/completions`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP ${response.status}: ${errorText}`);
    }

    const data = await response.json() as PerplexityChatResponse;
    const choice = data.choices[0];
    
    if (!choice) {
      throw new Error('No response from Perplexity');
    }
    
    let text = choice.message?.content || '';
    const usage = this.extractUsage(data);
    const rawFinishReason = choice.finish_reason || 'stop';

    // If tools were provided and we got tool calls, return placeholder text
    if (options?.tools && choice.message?.toolCalls && choice.message.toolCalls.length > 0) {
      text = text || '[AI requested tool calls but tool execution not available]';
    }

    // Extract and format web search results
    const webSearchResults = options?.webSearch || data.search_results
      ? this.extractPerplexitySources(data.search_results || [])
      : undefined;

    // Map finish reason to expected type
    const finishReason = this.mapFinishReason(rawFinishReason);

    return this.buildLLMResponse(
      text,
      model,
      usage,
      {
        provider: 'perplexity',
        searchResults: data.search_results, // Keep raw data for debugging
        searchMode: options?.searchMode,
        webSearchResults
      },
      finishReason
    );
  }

  // Private methods

  /**
   * Extract search results from Perplexity response
   */
  private extractPerplexitySources(searchResults: any[]): SearchResult[] {
    try {
      if (!Array.isArray(searchResults)) {
        return [];
      }

      return searchResults
        .map(result => WebSearchUtils.validateSearchResult({
          title: result.title || result.name || 'Unknown Source',
          url: result.url,
          date: result.date || result.timestamp
        }))
        .filter((result: SearchResult | null): result is SearchResult => result !== null);
    } catch (error) {
      return [];
    }
  }

  private extractToolCalls(message: any): any[] {
    return message?.toolCalls || [];
  }

  private mapFinishReason(reason: string | null): 'stop' | 'length' | 'tool_calls' | 'content_filter' {
    if (!reason) return 'stop';
    
    const reasonMap: Record<string, 'stop' | 'length' | 'tool_calls' | 'content_filter'> = {
      'stop': 'stop',
      'length': 'length',
      'tool_calls': 'tool_calls',
      'content_filter': 'content_filter'
    };
    return reasonMap[reason] || 'stop';
  }

  protected extractUsage(response: any): TokenUsage | undefined {
    const usage = response?.usage;
    if (usage) {
      return {
        promptTokens: usage.prompt_tokens || 0,
        completionTokens: usage.completion_tokens || 0,
        totalTokens: usage.total_tokens || 0
      };
    }
    return undefined;
  }

  private getCostPer1kTokens(modelId: string): { input: number; output: number } | undefined {
    const model = PERPLEXITY_MODELS.find(m => m.apiName === modelId);
    if (!model) return undefined;
    
    return {
      input: model.inputCostPerMillion / 1000,
      output: model.outputCostPerMillion / 1000
    };
  }

  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    const costs = this.getCostPer1kTokens(modelId);
    if (!costs) return null;

    return {
      rateInputPerMillion: costs.input * 1000,
      rateOutputPerMillion: costs.output * 1000,
      currency: 'USD'
    };
  }

  private convertTools(tools: any[]): any[] {
    return tools.map(tool => {
      if (tool.type === 'function') {
        // Handle both nested (Chat Completions) and flat (Responses API) formats
        const toolDef = tool.function || tool;
        return {
          type: 'function',
          function: {
            name: toolDef.name,
            description: toolDef.description,
            parameters: toolDef.parameters || toolDef.input_schema
          }
        };
      }
      return tool;
    });
  }
}
```

## services/llm/adapters/perplexity/PerplexityModels.ts

```typescript
/**
 * Perplexity AI Model Definitions
 * Based on 2025 Perplexity API specifications
 */

import { ModelSpec } from '../modelTypes';

export const PERPLEXITY_MODELS: ModelSpec[] = [
  // Search Models (Online)
  {
    provider: 'perplexity',
    name: 'Sonar',
    apiName: 'sonar',
    contextWindow: 128000,
    maxTokens: 8000,
    inputCostPerMillion: 1.00,
    outputCostPerMillion: 1.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'perplexity',
    name: 'Sonar Pro',
    apiName: 'sonar-pro',
    contextWindow: 200000,
    maxTokens: 8000,
    inputCostPerMillion: 3.00,
    outputCostPerMillion: 15.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Reasoning Models
  {
    provider: 'perplexity',
    name: 'Sonar Reasoning',
    apiName: 'sonar-reasoning',
    contextWindow: 128000,
    maxTokens: 8000,
    inputCostPerMillion: 1.00,
    outputCostPerMillion: 5.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'perplexity',
    name: 'Sonar Reasoning Pro',
    apiName: 'sonar-reasoning-pro',
    contextWindow: 200000,
    maxTokens: 8000,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 8.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: true
    }
  },

  // Research Models
  {
    provider: 'perplexity',
    name: 'Sonar Deep Research',
    apiName: 'sonar-deep-research',
    contextWindow: 200000,
    maxTokens: 8000,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 8.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Offline Model
  {
    provider: 'perplexity',
    name: 'r1-1776',
    apiName: 'r1-1776',
    contextWindow: 128000,
    maxTokens: 8000,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 8.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: true,
      supportsThinking: false
    }
  }
];

export const PERPLEXITY_DEFAULT_MODEL = 'sonar-pro';

export const PERPLEXITY_SEARCH_MODELS = PERPLEXITY_MODELS.filter(m => 
  m.apiName !== 'r1-1776' // All models except r1-1776 have web search
);
export const PERPLEXITY_REASONING_MODELS = PERPLEXITY_MODELS.filter(m => 
  m.capabilities.supportsThinking
);
export const PERPLEXITY_OFFLINE_MODELS = PERPLEXITY_MODELS.filter(m => 
  m.apiName === 'r1-1776' // Only r1-1776 is offline
);
```

## services/llm/adapters/requesty/RequestyAdapter.ts

```typescript
/**
 * Requesty AI Adapter with true streaming support
 * OpenAI-compatible streaming interface for 150+ models via router
 * Based on Requesty streaming documentation
 */

import { BaseAdapter } from '../BaseAdapter';
import {
  GenerateOptions,
  StreamChunk,
  LLMResponse,
  ModelInfo,
  ProviderCapabilities,
  ModelPricing
} from '../types';
import { REQUESTY_MODELS, REQUESTY_DEFAULT_MODEL } from './RequestyModels';
import { MCPToolExecution } from '../shared/ToolExecutionUtils';

/**
 * Requesty API response structure (OpenAI-compatible)
 */
interface RequestyChatCompletionResponse {
  choices: Array<{
    message?: {
      content?: string;
      toolCalls?: any[];
    };
    finish_reason?: string;
  }>;
  usage?: {
    prompt_tokens?: number;
    completion_tokens?: number;
    total_tokens?: number;
  };
}

export class RequestyAdapter extends BaseAdapter {
  readonly name = 'requesty';
  readonly baseUrl = 'https://router.requesty.ai/v1';

  constructor(apiKey: string, model?: string) {
    super(apiKey, model || REQUESTY_DEFAULT_MODEL);
    this.initializeCache();
  }

  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    try {
      const model = options?.model || this.currentModel;
      
      // Tool execution requires streaming - use generateStreamAsync instead
      if (options?.tools && options.tools.length > 0) {
        throw new Error('Tool execution requires streaming. Use generateStreamAsync() instead.');
      }

      // Use basic chat completions
      return await this.generateWithChatCompletions(prompt, options);
    } catch (error) {
      throw this.handleError(error, 'generation');
    }
  }

  /**
   * Generate streaming response using async generator
   * Uses unified stream processing with automatic tool call accumulation
   */
  async* generateStreamAsync(prompt: string, options?: GenerateOptions): AsyncGenerator<StreamChunk, void, unknown> {
    try {
      const response = await fetch(`${this.baseUrl}/chat/completions`, {
        method: 'POST',
        headers: {
          ...this.buildHeaders(),
          'Authorization': `Bearer ${this.apiKey}`,
          'HTTP-Referer': 'https://synaptic-lab-kit.com',
          'X-Title': 'Synaptic Lab Kit',
          'User-Agent': 'Synaptic-Lab-Kit/1.0.0'
        },
        body: JSON.stringify({
          model: options?.model || this.currentModel,
          messages: this.buildMessages(prompt, options?.systemPrompt),
          temperature: options?.temperature,
          max_tokens: options?.maxTokens,
          response_format: options?.jsonMode ? { type: 'json_object' } : undefined,
          stop: options?.stopSequences,
          tools: options?.tools,
          stream: true
        })
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      }

      // Use unified stream processing with automatic SSE parsing and tool call accumulation
      yield* this.processStream(response, {
        debugLabel: 'Requesty',
        extractContent: (parsed) => parsed.choices[0]?.delta?.content || null,
        extractToolCalls: (parsed) => parsed.choices[0]?.delta?.tool_calls || null,
        extractFinishReason: (parsed) => parsed.choices[0]?.finish_reason || null,
        extractUsage: (parsed) => parsed.usage || null
      });
    } catch (error) {
      console.error('[RequestyAdapter] Streaming error:', error);
      throw error;
    }
  }

  async listModels(): Promise<ModelInfo[]> {
    try {
      return REQUESTY_MODELS.map(model => ({
        id: model.apiName,
        name: model.name,
        contextWindow: model.contextWindow,
        maxOutputTokens: model.maxTokens,
        supportsJSON: model.capabilities.supportsJSON,
        supportsImages: model.capabilities.supportsImages,
        supportsFunctions: model.capabilities.supportsFunctions,
        supportsStreaming: model.capabilities.supportsStreaming,
        supportsThinking: false,
        costPer1kTokens: {
          input: model.inputCostPerMillion / 1000,
          output: model.outputCostPerMillion / 1000
        },
        pricing: {
          inputPerMillion: model.inputCostPerMillion,
          outputPerMillion: model.outputCostPerMillion,
          currency: 'USD',
          lastUpdated: new Date().toISOString()
        }
      }));
    } catch (error) {
      this.handleError(error, 'listing models');
      return [];
    }
  }

  getCapabilities(): ProviderCapabilities {
    const baseCapabilities = {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsThinking: false,
      maxContextWindow: 200000,
      supportedFeatures: [
        'messages',
        'function_calling',
        'vision',
        'streaming',
        'json_mode',
        'router_fallback'
      ]
    };

    return baseCapabilities;
  }

  /**
   * Generate using standard chat completions
   */
  private async generateWithChatCompletions(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    const model = options?.model || this.currentModel;
    
    const requestBody: any = {
      model,
      messages: this.buildMessages(prompt, options?.systemPrompt),
      temperature: options?.temperature,
      max_tokens: options?.maxTokens,
      response_format: options?.jsonMode ? { type: 'json_object' } : undefined,
      stop: options?.stopSequences
    };

    // Add tools if provided
    if (options?.tools) {
      requestBody.tools = options.tools;
    }

    const response = await fetch(`${this.baseUrl}/chat/completions`, {
      method: 'POST',
      headers: {
        ...this.buildHeaders(),
        'Authorization': `Bearer ${this.apiKey}`,
        'HTTP-Referer': 'https://synaptic-lab-kit.com',
        'X-Title': 'Synaptic Lab Kit',
        'User-Agent': 'Synaptic-Lab-Kit/1.0.0'
      },
      body: JSON.stringify(requestBody)
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`HTTP ${response.status}: ${errorText}`);
    }

    const data = await response.json() as RequestyChatCompletionResponse;
    const choice = data.choices[0];
    
    if (!choice) {
      throw new Error('No response from Requesty');
    }
    
    let text = choice.message?.content || '';
    const usage = this.extractUsage(data);
    const finishReason = this.mapFinishReason(choice.finish_reason || null);

    // If tools were provided and we got tool calls, return placeholder text
    if (options?.tools && choice.message?.toolCalls && choice.message.toolCalls.length > 0) {
      text = text || '[AI requested tool calls but tool execution not available]';
    }

    return this.buildLLMResponse(
      text,
      model,
      usage,
      { provider: 'requesty' },
      finishReason
    );
  }

  // Private methods
  private extractToolCalls(message: any): any[] {
    return message?.toolCalls || [];
  }

  private mapFinishReason(reason: string | null): 'stop' | 'length' | 'tool_calls' | 'content_filter' {
    if (!reason) return 'stop';
    
    const reasonMap: Record<string, 'stop' | 'length' | 'tool_calls' | 'content_filter'> = {
      'stop': 'stop',
      'length': 'length',
      'tool_calls': 'tool_calls',
      'content_filter': 'content_filter'
    };
    return reasonMap[reason] || 'stop';
  }

  protected extractUsage(response: any): any {
    const usage = response.usage;
    if (usage) {
      return {
        promptTokens: usage.prompt_tokens || 0,
        completionTokens: usage.completion_tokens || 0,
        totalTokens: usage.total_tokens || 0
      };
    }
    return undefined;
  }

  private getCostPer1kTokens(modelId: string): { input: number; output: number } | undefined {
    const model = REQUESTY_MODELS.find(m => m.apiName === modelId);
    if (!model) return undefined;
    
    return {
      input: model.inputCostPerMillion / 1000,
      output: model.outputCostPerMillion / 1000
    };
  }

  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    const costs = this.getCostPer1kTokens(modelId);
    if (!costs) return null;
    
    return {
      rateInputPerMillion: costs.input * 1000,
      rateOutputPerMillion: costs.output * 1000,
      currency: 'USD'
    };
  }
}
```

## services/llm/adapters/requesty/RequestyModels.ts

```typescript
/**
 * Requesty Model Specifications
 * Requesty provides access to multiple providers through a unified API
 * Updated June 17, 2025
 */

import { ModelSpec } from '../modelTypes';

// Requesty provides access to models from other providers
// Each model has its own specific API name in Requesty
export const REQUESTY_MODELS: ModelSpec[] = [
  // OpenAI models via Requesty
  {
    provider: 'requesty',
    name: 'GPT-5.2',
    apiName: 'openai/gpt-5.2',
    contextWindow: 200000,
    maxTokens: 65536,
    inputCostPerMillion: 5.00,
    outputCostPerMillion: 15.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'requesty',
    name: 'GPT-5.2 Pro',
    apiName: 'openai/gpt-5.2-pro',
    contextWindow: 200000,
    maxTokens: 65536,
    inputCostPerMillion: 15.00,
    outputCostPerMillion: 60.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: false, // Pro model does not support streaming
      supportsThinking: true
    }
  },
  {
    provider: 'requesty',
    name: 'GPT-5.2 Mini',
    apiName: 'openai/gpt-5.2-mini',
    contextWindow: 200000,
    maxTokens: 65536,
    inputCostPerMillion: 0.25,
    outputCostPerMillion: 1.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'requesty',
    name: 'GPT-5 Nano',
    apiName: 'openai/gpt-5-nano',
    contextWindow: 200000,
    maxTokens: 65536,
    inputCostPerMillion: 0.05,
    outputCostPerMillion: 0.20,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },
  {
    provider: 'requesty',
    name: 'o3',
    apiName: 'openai/o3',
    contextWindow: 200000,
    maxTokens: 100000,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 8.00,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: false,
      supportsThinking: true
    }
  },
  {
    provider: 'requesty',
    name: 'o3 Pro',
    apiName: 'openai/o3-pro',
    contextWindow: 200000,
    maxTokens: 100000,
    inputCostPerMillion: 20.00,
    outputCostPerMillion: 80.00,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: false,
      supportsThinking: true
    }
  },
  {
    provider: 'requesty',
    name: 'o4 Mini',
    apiName: 'openai/o4-mini',
    contextWindow: 200000,
    maxTokens: 100000,
    inputCostPerMillion: 1.10,
    outputCostPerMillion: 4.40,
    capabilities: {
      supportsJSON: false,
      supportsImages: false,
      supportsFunctions: false,
      supportsStreaming: false,
      supportsThinking: true
    }
  },

  // Google models via Requesty
  {
    provider: 'requesty',
    name: 'Gemini 3.0 Flash Preview',
    apiName: 'google/gemini-3-flash-preview',
    contextWindow: 1048576,
    maxTokens: 65536,
    inputCostPerMillion: 0.50,
    outputCostPerMillion: 3.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'requesty',
    name: 'Gemini 2.5 Pro Experimental',
    apiName: 'google/gemini-2.5-pro',
    contextWindow: 1048576,
    maxTokens: 65535,
    inputCostPerMillion: 1.25,
    outputCostPerMillion: 10.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'requesty',
    name: 'Gemini 2.5 Flash',
    apiName: 'google/gemini-2.5-flash',
    contextWindow: 1048576,
    maxTokens: 65536,
    inputCostPerMillion: 0.15,
    outputCostPerMillion: 0.60,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Anthropic models via Requesty
  {
    provider: 'requesty',
    name: 'Claude 4.5 Haiku',
    apiName: 'anthropic/claude-haiku-4-5',
    contextWindow: 200000,
    maxTokens: 64000,
    inputCostPerMillion: 1.00,
    outputCostPerMillion: 5.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: true
    }
  },
  {
    provider: 'requesty',
    name: 'Claude 4 Sonnet',
    apiName: 'anthropic/claude-sonnet-4-20250514',
    contextWindow: 200000,
    maxTokens: 64000,
    inputCostPerMillion: 3.00,
    outputCostPerMillion: 15.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  },

  // Mistral models via Requesty
  {
    provider: 'requesty',
    name: 'Mistral Large',
    apiName: 'mistral/mistral-large-latest',
    contextWindow: 131000,
    maxTokens: 130000,
    inputCostPerMillion: 2.00,
    outputCostPerMillion: 6.00,
    capabilities: {
      supportsJSON: true,
      supportsImages: true,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false
    }
  }
];

export const REQUESTY_DEFAULT_MODEL = 'anthropic/claude-sonnet-4-20250514';
```

## services/llm/adapters/shared/ReasoningPreserver.ts

```typescript
/**
 * ReasoningPreserver - Handles preservation of reasoning/thinking data for LLM tool continuations
 *
 * OpenRouter Gemini models and Google Gemini models require reasoning data (thought_signature,
 * reasoning_details) to be preserved and sent back when continuing conversations after tool calls.
 *
 * This utility centralizes the logic for:
 * - Detecting if a model requires reasoning preservation
 * - Extracting reasoning data from responses
 * - Attaching reasoning data to tool calls
 * - Building messages with preserved reasoning
 *
 * Follows Single Responsibility Principle - only handles reasoning preservation.
 */

export interface ReasoningDetails {
  /** OpenRouter format: array of reasoning detail objects */
  reasoning_details?: any[];
  /** Google Gemini format: thought signature string */
  thought_signature?: string;
}

export class ReasoningPreserver {
  /**
   * Check if a model requires reasoning preservation for tool continuations
   * Currently: Gemini models via OpenRouter, and direct Gemini models
   */
  static requiresReasoningPreservation(model: string, provider: string): boolean {
    const modelLower = model.toLowerCase();

    // OpenRouter Gemini models
    if (provider === 'openrouter') {
      return modelLower.includes('gemini') || modelLower.includes('google/');
    }

    // Direct Google provider
    if (provider === 'google') {
      return true; // All Google models may use thinking
    }

    return false;
  }

  /**
   * Extract reasoning data from a streaming chunk (OpenRouter format)
   * Returns the reasoning_details array if present
   *
   * In streaming, reasoning_details appears in choice.delta.reasoning_details
   * See: https://openrouter.ai/docs/guides/best-practices/reasoning-tokens
   */
  static extractFromStreamChunk(parsed: any): any[] | undefined {
    // Check top-level first
    if (parsed.reasoning_details) {
      return parsed.reasoning_details;
    }

    // Check each choice
    for (const choice of parsed.choices || []) {
      // Streaming: check delta
      if (choice?.delta?.reasoning_details) {
        return choice.delta.reasoning_details;
      }
      // Non-streaming: check message
      if (choice?.message?.reasoning_details) {
        return choice.message.reasoning_details;
      }
      // Also check at choice level
      if (choice?.reasoning_details) {
        return choice.reasoning_details;
      }
    }
    return undefined;
  }

  /**
   * Extract reasoning data from a non-streaming response (OpenRouter format)
   */
  static extractFromResponse(choice: any): ReasoningDetails | undefined {
    const message = choice?.message;
    if (!message) return undefined;

    const result: ReasoningDetails = {};

    if (message.reasoning_details) {
      result.reasoning_details = message.reasoning_details;
    }

    if (message.thought_signature) {
      result.thought_signature = message.thought_signature;
    }

    return Object.keys(result).length > 0 ? result : undefined;
  }

  /**
   * Extract thought_signature from Google Gemini streaming part
   */
  static extractThoughtSignatureFromPart(part: any): string | undefined {
    return part.thoughtSignature || part.thought_signature;
  }

  /**
   * Attach reasoning details to tool calls for preservation through the execution flow
   * Returns new tool call objects with reasoning attached
   */
  static attachToToolCalls(
    toolCalls: any[],
    reasoning: ReasoningDetails | undefined
  ): any[] {
    if (!reasoning || !toolCalls?.length) {
      return toolCalls;
    }

    return toolCalls.map(tc => ({
      ...tc,
      ...(reasoning.reasoning_details && { reasoning_details: reasoning.reasoning_details }),
      ...(reasoning.thought_signature && { thought_signature: reasoning.thought_signature })
    }));
  }

  /**
   * Extract reasoning from tool calls (for building continuation messages)
   */
  static extractFromToolCalls(toolCalls: any[]): ReasoningDetails | undefined {
    if (!toolCalls?.length) return undefined;

    // Find the first tool call with reasoning data
    for (const tc of toolCalls) {
      if (tc.reasoning_details) {
        return { reasoning_details: tc.reasoning_details };
      }
      if (tc.thought_signature) {
        return { thought_signature: tc.thought_signature };
      }
    }

    return undefined;
  }

  /**
   * Build an assistant message with reasoning preserved (OpenRouter/OpenAI format)
   * Used for tool continuation requests
   *
   * CRITICAL: Must preserve reasoning_details and thought_signature at BOTH levels:
   * 1. On each individual tool_call (required by Gemini for function calls)
   * 2. On the message itself (for some providers)
   */
  static buildAssistantMessageWithReasoning(
    toolCalls: any[],
    content: string | null = null
  ): any {
    const reasoning = this.extractFromToolCalls(toolCalls);

    const message: any = {
      role: 'assistant',
      content,
      tool_calls: toolCalls.map(tc => {
        const toolCall: any = {
          id: tc.id,
          type: 'function',
          function: {
            name: tc.function?.name || tc.name,
            arguments: tc.function?.arguments || JSON.stringify(tc.parameters || {})
          }
        };

        // CRITICAL: Preserve reasoning data on each tool call (Gemini requires this)
        if (tc.reasoning_details) {
          toolCall.reasoning_details = tc.reasoning_details;
        }
        if (tc.thought_signature) {
          toolCall.thought_signature = tc.thought_signature;
        }

        return toolCall;
      })
    };

    // Also preserve reasoning_details at message level for OpenRouter Gemini continuations
    if (reasoning?.reasoning_details) {
      message.reasoning_details = reasoning.reasoning_details;
    }

    return message;
  }

  /**
   * Build a Google Gemini model message with thought signature preserved
   * Used for tool continuation requests
   */
  static buildGoogleModelMessageWithThinking(toolCalls: any[]): any {
    const parts = toolCalls.map(tc => {
      const part: any = {
        functionCall: {
          name: tc.function?.name || tc.name,
          args: JSON.parse(tc.function?.arguments || '{}')
        }
      };

      // Preserve thought_signature if present
      if (tc.thought_signature) {
        part.thoughtSignature = tc.thought_signature;
      }

      return part;
    });

    return {
      role: 'model',
      parts
    };
  }

  /**
   * Get reasoning request parameters for a model
   * Returns the parameters to enable reasoning capture (if applicable)
   */
  static getReasoningRequestParams(model: string, provider: string, hasTools: boolean): any {
    if (!hasTools) return {};

    if (this.requiresReasoningPreservation(model, provider)) {
      if (provider === 'openrouter') {
        // OpenRouter unified reasoning parameter format
        // See: https://openrouter.ai/docs/guides/best-practices/reasoning-tokens
        // Note: effort is for OpenAI models, max_tokens is for Anthropic/Google
        // Since we're targeting Gemini, use max_tokens
        return {
          reasoning: {
            max_tokens: 8192,
            exclude: false  // Include reasoning in response
          }
        };
      }
      if (provider === 'google') {
        // Google uses thinkingBudget in generationConfig
        return { thinkingBudget: 8192 };
      }
    }

    return {};
  }
}

```

## services/llm/adapters/shared/ToolCallContentParser.ts

```typescript
/**
 * ToolCallContentParser
 *
 * Parses tool calls from content that uses various tool call formats
 * commonly used by fine-tuned models (e.g., Nexus tools SFT, WebLLM models).
 *
 * Supported formats:
 *
 * 1. [TOOL_CALLS] format:
 *    "[TOOL_CALLS] [{\"name\": \"tool_name\", \"arguments\": \"{...}\", \"id\": \"abc123\"}]"
 *
 * 2. <tool_call> XML format:
 *    "<tool_call>
 *    {\"name\": \"tool_name\", \"arguments\": {...}}
 *    </tool_call>"
 *
 * This parser extracts these embedded tool calls and converts them to the
 * standard ToolCall format used by the streaming orchestrator.
 *
 * Used by:
 * - LMStudioAdapter (local models via LM Studio)
 * - WebLLMAdapter (native WebGPU models)
 * - OllamaAdapter (Ollama local models)
 */

import { ToolCall, ToolCallFormat } from '../types';

export interface ParsedToolCallResult {
  /** Whether tool calls were found in the content */
  hasToolCalls: boolean;
  /** Extracted tool calls in standard format */
  toolCalls: ToolCall[];
  /** Content with [TOOL_CALLS] prefix and JSON removed (any remaining text) */
  cleanContent: string;
  /** Any text that appeared before [TOOL_CALLS] */
  prefixContent: string;
  /** Format detected: 'bracket' = [TOOL_CALLS], 'xml' = <tool_call>, 'native' = OpenAI */
  detectedFormat?: ToolCallFormat;
}

export interface RawToolCall {
  name: string;
  arguments: string;
  id?: string;
}

export class ToolCallContentParser {
  /** Pattern to detect [TOOL_CALLS] prefix */
  private static readonly TOOL_CALLS_PATTERN = /\[TOOL_CALLS\]/;

  /** Pattern to extract JSON array after [TOOL_CALLS] */
  private static readonly TOOL_CALLS_JSON_PATTERN = /\[TOOL_CALLS\]\s*(\[[\s\S]*\])/;

  /** Pattern to strip [/TOOL_CALLS] end tag if present */
  private static readonly END_TAG_PATTERN = /\[\/TOOL_CALLS\]\s*$/;

  /** Pattern to detect <tool_call> XML format */
  private static readonly XML_TOOL_CALL_PATTERN = /<tool_call>/i;

  /** Pattern to extract JSON from <tool_call>...</tool_call> (single or multiple) */
  private static readonly XML_TOOL_CALL_JSON_PATTERN = /<tool_call>\s*([\s\S]*?)\s*<\/tool_call>/gi;

  /**
   * Check if content contains [TOOL_CALLS] format
   */
  static hasBracketToolCallsFormat(content: string): boolean {
    return this.TOOL_CALLS_PATTERN.test(content);
  }

  /**
   * Check if content contains <tool_call> XML format
   */
  static hasXmlToolCallFormat(content: string): boolean {
    return this.XML_TOOL_CALL_PATTERN.test(content);
  }

  /**
   * Check if content contains any supported tool call format
   */
  static hasToolCallsFormat(content: string): boolean {
    return this.hasBracketToolCallsFormat(content) || this.hasXmlToolCallFormat(content);
  }

  /**
   * Parse content for embedded tool calls
   *
   * @param content - The raw content string that may contain tool calls
   * @returns ParsedToolCallResult with extracted tool calls and cleaned content
   */
  static parse(content: string): ParsedToolCallResult {
    const result: ParsedToolCallResult = {
      hasToolCalls: false,
      toolCalls: [],
      cleanContent: content,
      prefixContent: ''
    };

    if (!content || !this.hasToolCallsFormat(content)) {
      return result;
    }

    // Determine which format is used and delegate to appropriate parser
    if (this.hasXmlToolCallFormat(content)) {
      return this.parseXmlFormat(content);
    }

    if (this.hasBracketToolCallsFormat(content)) {
      return this.parseBracketFormat(content);
    }

    return result;
  }

  /**
   * Parse the [TOOL_CALLS] bracket format
   */
  private static parseBracketFormat(content: string): ParsedToolCallResult {
    const result: ParsedToolCallResult = {
      hasToolCalls: false,
      toolCalls: [],
      cleanContent: content,
      prefixContent: '',
      detectedFormat: 'bracket'
    };

    try {
      // Strip [/TOOL_CALLS] end tag if present before parsing
      const normalizedContent = content.replace(this.END_TAG_PATTERN, '');

      // Find the position of [TOOL_CALLS]
      const toolCallsMatch = normalizedContent.match(this.TOOL_CALLS_PATTERN);
      if (!toolCallsMatch || toolCallsMatch.index === undefined) {
        return result;
      }

      // Extract any content before [TOOL_CALLS]
      result.prefixContent = normalizedContent.slice(0, toolCallsMatch.index).trim();

      // Extract the JSON array after [TOOL_CALLS]
      const jsonMatch = normalizedContent.match(this.TOOL_CALLS_JSON_PATTERN);
      if (!jsonMatch || !jsonMatch[1]) {
        return result;
      }

      const jsonString = jsonMatch[1];

      // Parse the JSON array
      const rawToolCalls: RawToolCall[] = JSON.parse(jsonString);

      if (!Array.isArray(rawToolCalls)) {
        return result;
      }

      // Convert to standard ToolCall format with format tracking
      result.toolCalls = rawToolCalls.map((rawCall, index) =>
        this.convertToToolCall(rawCall, index, 'bracket')
      );

      result.hasToolCalls = result.toolCalls.length > 0;

      // Clean content: remove [TOOL_CALLS], JSON, and end tag - keep any remaining text
      const afterJson = normalizedContent.slice(
        (jsonMatch.index || 0) + jsonMatch[0].length
      ).trim();

      result.cleanContent = [result.prefixContent, afterJson]
        .filter(Boolean)
        .join('\n')
        .trim();

    } catch (error) {
      console.error('[ToolCallContentParser] Failed to parse bracket format tool calls:', error);
      result.cleanContent = content;
    }

    return result;
  }

  /**
   * Parse the <tool_call> XML format
   * Supports multiple <tool_call>...</tool_call> blocks in content
   */
  private static parseXmlFormat(content: string): ParsedToolCallResult {
    const result: ParsedToolCallResult = {
      hasToolCalls: false,
      toolCalls: [],
      cleanContent: content,
      prefixContent: '',
      detectedFormat: 'xml'
    };

    try {
      // Find content before first <tool_call>
      const firstMatch = content.match(/<tool_call>/i);
      if (firstMatch && firstMatch.index !== undefined) {
        result.prefixContent = content.slice(0, firstMatch.index).trim();
      }

      // Extract all <tool_call>...</tool_call> blocks
      // Reset regex lastIndex for multiple uses
      const regex = new RegExp(this.XML_TOOL_CALL_JSON_PATTERN.source, 'gi');
      let match;
      let lastMatchEnd = 0;
      const toolCallMatches: { json: string; start: number; end: number }[] = [];

      while ((match = regex.exec(content)) !== null) {
        toolCallMatches.push({
          json: match[1],
          start: match.index,
          end: match.index + match[0].length
        });
        lastMatchEnd = match.index + match[0].length;
      }

      if (toolCallMatches.length === 0) {
        return result;
      }

      // Parse each tool call JSON
      for (let i = 0; i < toolCallMatches.length; i++) {
        const jsonString = toolCallMatches[i].json.trim();

        try {
          const parsed = JSON.parse(jsonString);

          // Handle both single object and array formats
          const toolCallsArray = Array.isArray(parsed) ? parsed : [parsed];

          for (const rawCall of toolCallsArray) {
            result.toolCalls.push(this.convertToToolCall(rawCall, result.toolCalls.length, 'xml'));
          }
        } catch (parseError) {
        }
      }

      result.hasToolCalls = result.toolCalls.length > 0;

      // Clean content: remove all <tool_call>...</tool_call> blocks
      let cleanContent = content;
      // Process in reverse order to preserve indices
      for (let i = toolCallMatches.length - 1; i >= 0; i--) {
        const m = toolCallMatches[i];
        cleanContent = cleanContent.slice(0, m.start) + cleanContent.slice(m.end);
      }

      result.cleanContent = cleanContent.trim();

    } catch (error) {
      console.error('[ToolCallContentParser] Failed to parse XML format tool calls:', error);
      result.cleanContent = content;
    }

    return result;
  }

  /**
   * Convert a raw tool call to the standard ToolCall format
   */
  private static convertToToolCall(raw: RawToolCall, index: number, format?: ToolCallFormat): ToolCall {
    // Generate ID if not provided
    const id = raw.id || `toolcall_${Date.now()}_${index}`;

    // Ensure arguments is a string (may already be JSON string or could be object)
    let argsString: string;
    if (typeof raw.arguments === 'string') {
      argsString = raw.arguments;
    } else {
      argsString = JSON.stringify(raw.arguments);
    }

    return {
      id,
      type: 'function',
      function: {
        name: raw.name,
        arguments: argsString
      },
      sourceFormat: format
    };
  }

  /**
   * Parse streaming content incrementally
   * Returns partial result for streaming UI updates
   *
   * @param accumulatedContent - Content accumulated so far in the stream
   * @returns ParsedToolCallResult (may be incomplete if stream is ongoing)
   */
  static parseStreaming(accumulatedContent: string): ParsedToolCallResult & { isComplete: boolean } {
    const result = this.parse(accumulatedContent);

    // Check if tool call content appears complete
    const isComplete = result.hasToolCalls && this.isToolCallComplete(accumulatedContent);

    return {
      ...result,
      isComplete
    };
  }

  /**
   * Check if tool call content appears complete (handles both formats)
   */
  private static isToolCallComplete(content: string): boolean {
    // Check XML format first
    if (this.hasXmlToolCallFormat(content)) {
      return this.isXmlToolCallComplete(content);
    }

    // Check bracket format
    if (this.hasBracketToolCallsFormat(content)) {
      return this.isBracketToolCallComplete(content);
    }

    return false;
  }

  /**
   * Check if a [TOOL_CALLS] bracket format appears complete
   */
  private static isBracketToolCallComplete(content: string): boolean {
    const jsonMatch = content.match(this.TOOL_CALLS_JSON_PATTERN);
    if (!jsonMatch) return false;

    const jsonString = jsonMatch[1];
    try {
      JSON.parse(jsonString);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Check if <tool_call> XML format appears complete
   */
  private static isXmlToolCallComplete(content: string): boolean {
    // Check if there's a closing </tool_call> tag
    const openTags = (content.match(/<tool_call>/gi) || []).length;
    const closeTags = (content.match(/<\/tool_call>/gi) || []).length;

    if (openTags === 0 || closeTags === 0 || openTags !== closeTags) {
      return false;
    }

    // Verify JSON inside is parseable
    const regex = new RegExp(this.XML_TOOL_CALL_JSON_PATTERN.source, 'gi');
    let match;
    while ((match = regex.exec(content)) !== null) {
      try {
        JSON.parse(match[1].trim());
      } catch {
        return false;
      }
    }

    return true;
  }

  /**
   * Extract tool name from partial streaming content
   * Useful for showing tool call UI before full JSON is received
   */
  static extractPartialToolInfo(content: string): { name?: string; inProgress: boolean } {
    if (!this.hasToolCallsFormat(content)) {
      return { inProgress: false };
    }

    // Try to extract the first tool name even if JSON is incomplete
    // This pattern works for both formats since they both use "name": "..." JSON syntax
    const nameMatch = content.match(/"name"\s*:\s*"([^"]+)"/);

    return {
      name: nameMatch?.[1],
      inProgress: true
    };
  }
}

```

## services/llm/adapters/shared/ToolExecutionUtils.ts

```typescript
/**
 * Tool Execution Utilities
 *
 * Clean architecture: Tool execution is decoupled from LLM adapters.
 * Adapters handle LLM communication, this utility handles tool execution.
 *
 * The toolExecutor is passed explicitly - no reaching into adapter internals.
 * This enables tools to work on ALL platforms (desktop + mobile).
 */

import { SupportedProvider } from '../types';

export interface ToolCall {
  id: string;
  function: {
    name: string;
    arguments: string;
  };
}

export interface ToolResult {
  id: string;
  name?: string;
  success: boolean;
  result?: any;
  error?: string;
  executionTime?: number;
}

/**
 * Interface for tool executors
 * DirectToolExecutor implements this interface
 */
export interface IToolExecutor {
  executeToolCalls(
    toolCalls: ToolCall[],
    context?: { sessionId?: string; workspaceId?: string },
    onToolEvent?: (event: 'started' | 'completed', data: any) => void
  ): Promise<ToolResult[]>;
}

/**
 * Static utility class for tool execution
 * Decoupled from adapters - receives toolExecutor explicitly
 */
export class ToolExecutionUtils {

  /**
   * Execute tool calls using the provided executor
   * Clean interface - no adapter dependency
   */
  static async executeToolCalls(
    toolExecutor: IToolExecutor | null | undefined,
    toolCalls: ToolCall[],
    provider: SupportedProvider,
    onToolEvent?: (event: 'started' | 'completed', data: any) => void,
    context?: { sessionId?: string; workspaceId?: string }
  ): Promise<ToolResult[]> {
    if (!toolExecutor) {
      return toolCalls.map(tc => ({
        id: tc.id,
        name: tc.function.name,
        success: false,
        error: 'Tool execution not available - no executor configured'
      }));
    }

    try {
      return await toolExecutor.executeToolCalls(toolCalls, context, onToolEvent);
    } catch (error) {
      console.error(`[ToolExecutionUtils] Tool execution failed:`, error);
      throw error;
    }
  }

  /**
   * Build tool messages for continuation
   * Formats differently for Anthropic, Google, vs other providers
   */
  static buildToolMessages(
    toolResults: ToolResult[],
    provider: SupportedProvider
  ): Array<any> {
    if (provider === 'anthropic') {
      // Anthropic format: role='user', content array with tool_result objects
      return toolResults.map(result => ({
        role: 'user' as const,
        content: [
          {
            type: 'tool_result',
            tool_use_id: result.id,
            content: result.success
              ? JSON.stringify(result.result)
              : `Error: ${result.error}`
          }
        ]
      }));
    } else if (provider === 'google') {
      // Google Gemini format: role='function', parts array with functionResponse objects
      return toolResults.map(result => ({
        role: 'function' as const,
        parts: [
          {
            functionResponse: {
              name: result.name,
              response: result.success
                ? result.result
                : { error: result.error }
            }
          }
        ]
      }));
    } else {
      // OpenAI format (used by OpenAI, OpenRouter, Groq, Mistral, etc.)
      return toolResults.map(result => ({
        role: 'tool' as const,
        tool_call_id: result.id,
        content: result.success
          ? JSON.stringify(result.result)
          : `Error: ${result.error}`
      }));
    }
  }

  /**
   * Build tool metadata for response
   */
  static buildToolMetadata(toolResults: ToolResult[]) {
    return {
      toolCallCount: toolResults.length,
      toolCalls: toolResults.length > 0 ? toolResults.map(result => ({
        id: result.id,
        name: result.name,
        result: result.result,
        success: result.success,
        error: result.error,
        executionTime: result.executionTime
      })) : undefined
    };
  }
}

// Re-export with old names for backward compatibility during migration
export type { ToolCall as MCPToolCall, ToolResult as MCPToolResult };
export { ToolExecutionUtils as MCPToolExecution };

```

## services/llm/adapters/types.ts

```typescript
/**
 * Core types for LLM adapters
 * Based on patterns from services/llm/
 */

/**
 * Supported LLM providers
 */
export type SupportedProvider = 'openai' | 'openrouter' | 'anthropic' | 'google' | 'groq' | 'mistral' | 'perplexity' | 'requesty';

export interface GenerateOptions {
  model?: string;
  temperature?: number;
  maxTokens?: number;
  systemPrompt?: string;
  jsonMode?: boolean;
  stream?: boolean;
  stopSequences?: string[];
  enableThinking?: boolean;
  enableInteractiveThinking?: boolean;
  thinkingEffort?: 'low' | 'medium' | 'high';
  tools?: Tool[];
  enableTools?: boolean;
  webSearch?: boolean;
  fileSearch?: boolean;
  // Tool event callback for live UI updates
  onToolEvent?: (event: 'started' | 'completed', data: any) => void;
  // Usage callback for async cost calculation (e.g., OpenRouter streaming)
  onUsageAvailable?: (usage: TokenUsage, cost?: CostDetails) => void;
  // Cache options
  disableCache?: boolean;
  cacheTTL?: number;
  topP?: number;
  frequencyPenalty?: number;
  presencePenalty?: number;
  // Pre-detected tool calls for post-stream execution
  detectedToolCalls?: any[];
  // Conversation history for pingpong pattern (overrides prompt-based message building)
  conversationHistory?: any[];
  // OpenAI Responses API: Previous response ID for stateful continuations
  previousResponseId?: string;
}

export interface StreamChunk {
  content: string;
  complete: boolean;
  usage?: TokenUsage;
  toolCalls?: ToolCall[];
  toolCallsReady?: boolean; // True when tool calls are complete and safe to execute
  metadata?: Record<string, any>; // For provider-specific metadata (e.g., OpenAI response ID)
  // Reasoning/thinking support (Claude, GPT-5, Gemini, etc.)
  reasoning?: string;           // Incremental reasoning text
  reasoningComplete?: boolean;  // True when reasoning finished
  reasoningId?: string;         // Unique ID for the reasoning block (OpenAI)
  reasoningEncryptedContent?: string; // OpenAI: encrypted_content for multi-turn preservation
}

export interface SearchResult {
  title: string;
  url: string;
  date?: string;
}

export interface LLMResponse {
  text: string;
  model: string;
  provider?: string;
  usage?: TokenUsage;
  cost?: CostDetails;
  metadata?: Record<string, any>;
  finishReason?: 'stop' | 'length' | 'tool_calls' | 'content_filter';
  toolCalls?: ToolCall[];
  webSearchResults?: SearchResult[];
}

export interface TokenUsage {
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
  // Detailed breakdowns from OpenAI API
  cachedTokens?: number; // Cached input tokens (75-90% discount)
  reasoningTokens?: number; // Hidden reasoning tokens (o1/o3 models)
  audioTokens?: number; // Audio input/output tokens
}

export interface CostDetails {
  inputCost: number;
  outputCost: number;
  totalCost: number;
  currency: string;
  rateInputPerMillion: number;
  rateOutputPerMillion: number;
  cached?: {
    tokens: number;
    cost: number;
  };
}

export interface ModelPricing {
  rateInputPerMillion: number;
  rateOutputPerMillion: number;
  currency: string;
}

export interface ModelInfo {
  id: string;
  name: string;
  contextWindow: number;
  maxOutputTokens?: number;
  supportsJSON: boolean;
  supportsImages: boolean;
  supportsFunctions: boolean;
  supportsStreaming: boolean;
  supportsThinking?: boolean;
  supportsImageGeneration?: boolean;
  pricing: {
    inputPerMillion: number;
    outputPerMillion: number;
    imageGeneration?: number;
    currency: string;
    lastUpdated: string; // ISO date string
  };
}

export interface Tool {
  type: 'function' | 'web_search' | 'file_search' | 'code_execution';
  function?: {
    name: string;
    description: string;
    parameters: Record<string, any>;
  };
}

/** Format the model used to output tool calls */
export type ToolCallFormat = 'bracket' | 'xml' | 'native';

export interface ToolCall {
  id: string;
  type: string;
  function?: {
    name: string;
    arguments: string;
  };
  // OpenRouter: reasoning_details for Gemini models (must be preserved in continuations)
  reasoning_details?: any[];
  // Google Gemini: thought_signature for thinking models
  thought_signature?: string;
  /** Format the model used: 'bracket' = [TOOL_CALLS], 'xml' = <tool_call>, 'native' = OpenAI */
  sourceFormat?: ToolCallFormat;
}

export interface ProviderConfig {
  apiKey: string;
  baseUrl?: string;
  organizationId?: string;
  projectId?: string;
  customHeaders?: Record<string, string>;
}

export interface ProviderCapabilities {
  supportsStreaming: boolean;
  supportsJSON: boolean;
  supportsImages: boolean;
  supportsFunctions: boolean;
  supportsThinking: boolean;
  supportsImageGeneration?: boolean;
  maxContextWindow: number;
  supportedFeatures: string[];
}

export class LLMProviderError extends Error {
  constructor(
    message: string,
    public provider: string,
    public code?: string,
    public originalError?: Error
  ) {
    super(message);
    this.name = 'LLMProviderError';
  }
}
```

## services/llm/adapters/webllm/index.ts

```typescript
/**
 * WebLLM Adapter Exports
 *
 * Native local LLM support via WebGPU
 */

// Main adapter
export { WebLLMAdapter } from './WebLLMAdapter';

// Services
export { WebLLMEngine } from './WebLLMEngine';
export { WebLLMModelManager } from './WebLLMModelManager';
export { WebLLMVRAMDetector } from './WebLLMVRAMDetector';

// Model definitions
export {
  WEBLLM_MODELS,
  HF_BASE_URL,
  MODEL_LIBS,
  getWebLLMModel,
  getModelsForVRAM,
  getBestModelForVRAM,
  getModelFileUrl,
  getModelManifestUrl,
  formatVRAMRequirement,
  getModelDisplayInfo,
} from './WebLLMModels';

// Types
export type {
  // Worker messages
  WorkerMessage,
  InitMessage,
  GenerateMessage,
  StreamMessage,
  AbortMessage,
  UnloadMessage,
  FileRequestMessage,

  // Worker responses
  WorkerResponse,
  InitProgressResponse,
  ReadyResponse,
  ChunkResponse,
  CompleteResponse,
  ErrorResponse,
  FileDataResponse,

  // Chat
  ChatMessage,

  // Model
  WebLLMModelSpec,
  InstalledModel,

  // VRAM
  VRAMInfo,

  // Settings
  WebLLMSettings,

  // State
  WebLLMStatus,
  WebLLMState,

  // Errors
  WebLLMErrorCode,

  // Download
  DownloadProgress,
  ModelManifest,
  ModelFile,
} from './types';

export { WebLLMError } from './types';

```

## services/llm/adapters/webllm/NexusToolCallConverter.ts

```typescript
/**
 * NexusToolCallConverter
 *
 * Converts old-style tool calls (e.g., "contentManager_readContent") to the
 * new two-tool architecture format using useTool wrapper.
 *
 * Nexus models are fine-tuned on the full toolset and output tool calls
 * in the old format. This converter wraps them in useTool format so they
 * can be executed by the two-tool architecture.
 *
 * Old format:
 *   { name: "contentManager_readContent", arguments: "{\"path\": \"test.md\"}" }
 *
 * New format (useTool wrapper):
 *   {
 *     name: "toolManager_useTool",
 *     arguments: "{\"context\": {...}, \"calls\": [{\"agent\": \"contentManager\", \"tool\": \"readContent\", \"params\": {\"path\": \"test.md\"}}]}"
 *   }
 */

import { ToolCall } from '../types';

/**
 * Default context for Nexus tool calls
 * Nexus models don't provide context, so we use sensible defaults
 */
interface NexusDefaultContext {
  workspaceId: string;
  sessionId: string;
  memory: string;
  goal: string;
}

/**
 * Tool call in useTool format
 */
interface UseToolCall {
  agent: string;
  tool: string;
  params: Record<string, unknown>;
}

/**
 * Full useTool params structure
 */
interface UseToolParams {
  context: NexusDefaultContext;
  calls: UseToolCall[];
  strategy?: 'serial' | 'parallel';
}

/**
 * Known agents in the system - used to parse tool names
 * Format: agentName_toolName
 */
const KNOWN_AGENTS = [
  'toolManager',
  'promptManager',
  'contentManager',
  'commandManager',
  'storageManager',
  'searchManager',
  'memoryManager',
];

export class NexusToolCallConverter {
  private defaultContext: NexusDefaultContext;
  private sessionId: string;

  constructor(sessionId?: string, workspaceId?: string) {
    this.sessionId = sessionId || `nexus_${Date.now()}`;
    this.defaultContext = {
      workspaceId: workspaceId || 'default',
      sessionId: this.sessionId,
      memory: 'Nexus local model session - tool calls converted from fine-tuned format',
      goal: 'Execute tool calls as requested by Nexus model',
    };
  }

  /**
   * Update the session/workspace context
   */
  updateContext(sessionId?: string, workspaceId?: string): void {
    if (sessionId) {
      this.sessionId = sessionId;
      this.defaultContext.sessionId = sessionId;
    }
    if (workspaceId) {
      this.defaultContext.workspaceId = workspaceId;
    }
  }

  /**
   * Check if a tool call is already in useTool format
   */
  isUseToolFormat(toolCall: ToolCall): boolean {
    const name = toolCall.function?.name || '';
    return name === 'toolManager_useTool' || name === 'toolManager.useTool';
  }

  /**
   * Check if a tool call is in old format (needs conversion)
   */
  needsConversion(toolCall: ToolCall): boolean {
    if (this.isUseToolFormat(toolCall)) {
      return false;
    }

    const name = toolCall.function?.name || '';

    // Skip getTools - Nexus doesn't need it
    if (name === 'toolManager_getTools' || name === 'toolManager.getTools') {
      return false;
    }

    // Check if it matches known agent pattern
    return this.parseToolName(name) !== null;
  }

  /**
   * Parse an old-style tool name into agent and tool components
   * Returns null if not a valid tool name
   *
   * Handles two formats:
   * 1. agentName_toolName (underscore)
   * 2. agentName.toolName (dot)
   *
   * Bare tool names (e.g., "createContent") are NOT auto-converted.
   * They will fail with a helpful "did you mean?" error from DirectToolExecutor.
   */
  private parseToolName(name: string): { agent: string; tool: string } | null {
    // Try underscore format first: agentName_toolName
    for (const agent of KNOWN_AGENTS) {
      if (name.startsWith(agent + '_')) {
        const tool = name.slice(agent.length + 1);
        if (tool) {
          return { agent, tool };
        }
      }
    }

    // Try dot format: agentName.toolName
    for (const agent of KNOWN_AGENTS) {
      if (name.startsWith(agent + '.')) {
        const tool = name.slice(agent.length + 1);
        if (tool) {
          return { agent, tool };
        }
      }
    }

    // Bare tool names not supported - let DirectToolExecutor handle with helpful error
    return null;
  }

  /**
   * Convert a single tool call to useTool format
   */
  convertToUseTool(toolCall: ToolCall): ToolCall {
    // Already in useTool format
    if (this.isUseToolFormat(toolCall)) {
      return toolCall;
    }

    const name = toolCall.function?.name || '';
    const parsed = this.parseToolName(name);

    if (!parsed) {
      // Can't parse - return as-is
      return toolCall;
    }

    // Parse the original arguments
    let originalParams: Record<string, unknown> = {};
    try {
      const argsStr = toolCall.function?.arguments || '{}';
      originalParams = JSON.parse(argsStr);
    } catch {
      // Invalid JSON - use empty params
    }

    // Build useTool params
    const useToolParams: UseToolParams = {
      context: { ...this.defaultContext },
      calls: [
        {
          agent: parsed.agent,
          tool: parsed.tool,
          params: originalParams,
        },
      ],
    };

    // Return converted tool call
    return {
      id: toolCall.id,
      type: 'function',
      function: {
        name: 'toolManager_useTool',
        arguments: JSON.stringify(useToolParams),
      },
    };
  }

  /**
   * Convert multiple tool calls to useTool format
   * Optionally batch them into a single useTool call
   */
  convertToolCalls(toolCalls: ToolCall[], batch: boolean = false): ToolCall[] {
    if (!toolCalls || toolCalls.length === 0) {
      return [];
    }

    // Filter out getTools calls - Nexus doesn't need them
    const filteredCalls = toolCalls.filter(tc => {
      const name = tc.function?.name || '';
      return name !== 'toolManager_getTools' && name !== 'toolManager.getTools';
    });

    if (filteredCalls.length === 0) {
      return [];
    }

    // If not batching, convert each call individually
    if (!batch) {
      return filteredCalls.map(tc => this.convertToUseTool(tc));
    }

    // Batch mode: combine all calls into a single useTool call
    const allCalls: UseToolCall[] = [];

    for (const toolCall of filteredCalls) {
      // If already useTool format, extract its calls
      if (this.isUseToolFormat(toolCall)) {
        try {
          const params = JSON.parse(toolCall.function?.arguments || '{}');
          if (params.calls && Array.isArray(params.calls)) {
            allCalls.push(...params.calls);
          }
        } catch {
          // Invalid JSON - skip
        }
        continue;
      }

      // Convert old-style call
      const name = toolCall.function?.name || '';
      const parsed = this.parseToolName(name);

      if (parsed) {
        let originalParams: Record<string, unknown> = {};
        try {
          originalParams = JSON.parse(toolCall.function?.arguments || '{}');
        } catch {
          // Invalid JSON
        }

        allCalls.push({
          agent: parsed.agent,
          tool: parsed.tool,
          params: originalParams,
        });
      }
    }

    if (allCalls.length === 0) {
      return [];
    }

    // Return single batched useTool call
    const batchedParams: UseToolParams = {
      context: { ...this.defaultContext },
      calls: allCalls,
      strategy: allCalls.length > 1 ? 'serial' : undefined,
    };

    return [
      {
        id: `batch_${Date.now()}`,
        type: 'function',
        function: {
          name: 'toolManager_useTool',
          arguments: JSON.stringify(batchedParams),
        },
      },
    ];
  }

  /**
   * Static helper to check if a model uses the Nexus tool format
   * (for integration with WebLLMAdapter.usesToolCallsContentFormat)
   */
  static isNexusModel(modelId: string): boolean {
    const nexusKeywords = ['nexus', 'tools-sft', 'claudesidian'];
    const lowerModelId = modelId.toLowerCase();
    return nexusKeywords.some(keyword => lowerModelId.includes(keyword));
  }
}

```

## services/llm/adapters/webllm/types.ts

```typescript
/**
 * WebLLM Adapter Types
 *
 * Type definitions for the WebLLM native integration.
 * Enables running LLMs locally via WebGPU with no external dependencies.
 */

// ============================================================================
// Worker Message Types (Interface Segregation - focused message types)
// ============================================================================

/** Base interface for all worker messages */
interface BaseWorkerMessage {
  id: string;
}

/** Initialize the WebLLM engine with a model */
export interface InitMessage extends BaseWorkerMessage {
  type: 'init';
  payload: {
    modelId: string;
    modelUrl?: string;
    quantization?: 'q4f16' | 'q5f16' | 'q8f16';
  };
}

/** Generate a response (non-streaming) */
export interface GenerateMessage extends BaseWorkerMessage {
  type: 'generate';
  payload: {
    messages: ChatMessage[];
    temperature?: number;
    maxTokens?: number;
    topP?: number;
    stopSequences?: string[];
  };
}

/** Generate a streaming response */
export interface StreamMessage extends BaseWorkerMessage {
  type: 'stream';
  payload: {
    messages: ChatMessage[];
    temperature?: number;
    maxTokens?: number;
    topP?: number;
    stopSequences?: string[];
  };
}

/** Abort an in-progress generation */
export interface AbortMessage extends BaseWorkerMessage {
  type: 'abort';
}

/** Unload the model from GPU memory */
export interface UnloadMessage extends BaseWorkerMessage {
  type: 'unload';
}

/** Request a file from the main thread (for local model loading) */
export interface FileRequestMessage extends BaseWorkerMessage {
  type: 'file_request';
  payload: {
    path: string;
  };
}

/** Union type for all worker messages */
export type WorkerMessage =
  | InitMessage
  | GenerateMessage
  | StreamMessage
  | AbortMessage
  | UnloadMessage
  | FileRequestMessage;

// ============================================================================
// Worker Response Types
// ============================================================================

/** Base interface for all worker responses */
interface BaseWorkerResponse {
  id: string;
}

/** Model initialization progress */
export interface InitProgressResponse extends BaseWorkerResponse {
  type: 'init_progress';
  payload: {
    progress: number; // 0-1
    stage: 'downloading' | 'loading' | 'compiling';
    message?: string;
  };
}

/** Model is ready for generation */
export interface ReadyResponse extends BaseWorkerResponse {
  type: 'ready';
  payload: {
    modelId: string;
    contextWindow: number;
    maxTokens: number;
  };
}

/** Streaming chunk */
export interface ChunkResponse extends BaseWorkerResponse {
  type: 'chunk';
  payload: {
    content: string;
    tokenCount?: number;
  };
}

/** Generation complete */
export interface CompleteResponse extends BaseWorkerResponse {
  type: 'complete';
  payload: {
    content: string;
    usage: {
      promptTokens: number;
      completionTokens: number;
      totalTokens: number;
    };
    finishReason: 'stop' | 'length' | 'abort';
  };
}

/** Error occurred */
export interface ErrorResponse extends BaseWorkerResponse {
  type: 'error';
  payload: {
    code: WebLLMErrorCode;
    message: string;
    details?: any;
  };
}

/** File data response (from main thread to worker) */
export interface FileDataResponse extends BaseWorkerResponse {
  type: 'file_data';
  payload: {
    path: string;
    data: ArrayBuffer;
  };
}

/** Union type for all worker responses */
export type WorkerResponse =
  | InitProgressResponse
  | ReadyResponse
  | ChunkResponse
  | CompleteResponse
  | ErrorResponse
  | FileDataResponse;

// ============================================================================
// Chat Message Types
// ============================================================================

export interface ChatMessage {
  role: 'system' | 'user' | 'assistant' | 'tool';
  content: string;
  name?: string;
  tool_call_id?: string;
}

// ============================================================================
// Model Types
// ============================================================================

export interface WebLLMModelSpec {
  id: string;
  name: string;
  provider: 'webllm';
  apiName: string;
  contextWindow: number;
  maxTokens: number;
  vramRequired: number; // GB
  quantization: 'q4f16' | 'q5f16' | 'q8f16';
  huggingFaceRepo: string;
  /**
   * URL to pre-built WASM model library.
   * Models sharing the same architecture can reuse the same library.
   * For Mistral-based models, use the pre-built Mistral library from WebLLM.
   */
  modelLibUrl?: string;
  /**
   * If true, model files are at root of repo (not in quantization subdirectory).
   * Default behavior expects files in {repo}/resolve/main/{quantization}/
   * With flatStructure: true, files are at {repo}/resolve/main/
   */
  flatStructure?: boolean;
  capabilities: {
    supportsJSON: boolean;
    supportsImages: boolean;
    supportsFunctions: boolean;
    supportsStreaming: boolean;
    supportsThinking: boolean;
  };
}

export interface InstalledModel {
  id: string;
  name: string;
  quantization: string;
  sizeBytes: number;
  installedAt: string;
  path: string;
}

// ============================================================================
// VRAM Detection Types
// ============================================================================

export interface VRAMInfo {
  available: boolean;
  estimatedVRAM: number; // GB
  gpuName?: string;
  recommendedQuantizations: ('q4f16' | 'q5f16' | 'q8f16')[];
  webGPUSupported: boolean;
}

// ============================================================================
// Settings Types
// ============================================================================

export interface WebLLMSettings {
  enabled: boolean;
  installedModel: string | null;
  quantization: 'q4f16' | 'q5f16' | 'q8f16';
  autoLoadOnStartup: boolean;
  customModelUrl?: string;
}

// ============================================================================
// Status Types
// ============================================================================

export type WebLLMStatus =
  | 'unavailable'      // WebGPU not supported
  | 'available'        // WebGPU available, no model loaded
  | 'needs_download'   // Model not installed
  | 'downloading'      // Model download in progress
  | 'loading'          // Model loading into GPU
  | 'ready'            // Model loaded and ready
  | 'generating'       // Currently generating
  | 'error';           // Error state

export interface WebLLMState {
  status: WebLLMStatus;
  loadedModel: string | null;
  downloadProgress?: number;
  loadProgress?: number;
  error?: string;
  vramInfo?: VRAMInfo;
}

// ============================================================================
// Error Types
// ============================================================================

export type WebLLMErrorCode =
  | 'WEBGPU_NOT_SUPPORTED'
  | 'INSUFFICIENT_VRAM'
  | 'MODEL_NOT_FOUND'
  | 'DOWNLOAD_FAILED'
  | 'LOAD_FAILED'
  | 'GENERATION_FAILED'
  | 'WORKER_ERROR'
  | 'MODULE_LOAD_FAILED'
  | 'ABORTED'
  | 'CONFIG_INVALID'
  | 'GPU_OOM'
  | 'WEBGPU_ERROR'
  | 'NETWORK_ERROR'
  | 'UNKNOWN';

export class WebLLMError extends Error {
  constructor(
    message: string,
    public code: WebLLMErrorCode,
    public details?: any
  ) {
    super(message);
    this.name = 'WebLLMError';
  }
}

// ============================================================================
// Download Types
// ============================================================================

export interface DownloadProgress {
  totalBytes: number;
  downloadedBytes: number;
  percentage: number;
  currentFile: string;
  filesComplete: number;
  filesTotal: number;
  speed?: number; // bytes per second
  eta?: number; // seconds remaining
}

export interface ModelManifest {
  modelId: string;
  quantization: string;
  files: ModelFile[];
  configUrl: string;
  totalSize: number;
}

export interface ModelFile {
  name: string;
  url: string;
  size: number;
  sha256?: string;
}

```

## services/llm/adapters/webllm/WebLLMAdapter.ts

```typescript
/**
 * WebLLMAdapter
 *
 * Adapter for running LLMs locally via WebGPU using MLC.ai's WebLLM.
 * Provides fully offline inference after initial model download.
 *
 * Features:
 * - WebGPU-accelerated inference
 * - Streaming responses
 * - Tool calling via [TOOL_CALLS] format
 * - No external API required
 *
 * Note: Uses main-thread execution instead of Web Workers because
 * Obsidian's sandboxed Electron environment blocks CDN imports in workers.
 * WebGPU handles GPU compute, so main thread execution doesn't block UI.
 *
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘  âš ï¸ KNOWN LIMITATION: TOOL CONTINUATIONS DISABLED (Dec 2025)              â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘  Tool calling works for the FIRST generation only. Multi-turn tool        â•‘
 * â•‘  continuations (ping-pong pattern) cause a hard Electron/WebGPU crash.    â•‘
 * â•‘                                                                            â•‘
 * â•‘  SYMPTOMS:                                                                 â•‘
 * â•‘  - First generation completes successfully with tool call                 â•‘
 * â•‘  - Tool execution works fine                                              â•‘
 * â•‘  - Second generation (continuation) crashes Obsidian renderer process    â•‘
 * â•‘  - Crash happens during prefill phase of stream iteration                â•‘
 * â•‘  - No JavaScript error is caught - it's a hard renderer crash            â•‘
 * â•‘                                                                            â•‘
 * â•‘  INVESTIGATION DONE (Dec 6, 2025):                                         â•‘
 * â•‘  1. Generation lock mechanism - prevents concurrent GPU ops               â•‘
 * â•‘  2. KV cache reset timing - before/after/skip - all crash                 â•‘
 * â•‘  3. Non-streaming API for continuations - also crashes                    â•‘
 * â•‘  4. Longer delays (1s+) between generations - still crashes              â•‘
 * â•‘  5. Skipping ALL resets - crashes during prefill                          â•‘
 * â•‘                                                                            â•‘
 * â•‘  LIKELY CAUSE:                                                             â•‘
 * â•‘  WebGPU resource management issue in WebLLM on Apple Silicon.             â•‘
 * â•‘  The second prefill operation corrupts GPU memory or hits an             â•‘
 * â•‘  unhandled edge case in the WebGPU -> Metal translation layer.           â•‘
 * â•‘  See: https://github.com/mlc-ai/web-llm/issues/647                        â•‘
 * â•‘                                                                            â•‘
 * â•‘  WORKAROUND:                                                               â•‘
 * â•‘  Tool continuations are blocked with a user-friendly error message.       â•‘
 * â•‘  Users should use Ollama or LM Studio for tool-calling workflows.         â•‘
 * â•‘                                                                            â•‘
 * â•‘  TO RE-ENABLE:                                                             â•‘
 * â•‘  1. Update to newer WebLLM version when available                         â•‘
 * â•‘  2. Remove the isToolContinuation check in generateStreamAsync()          â•‘
 * â•‘  3. Test thoroughly on multiple macOS/GPU configurations                  â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

import { Vault } from 'obsidian';
import { BaseAdapter } from '../BaseAdapter';
import {
  GenerateOptions,
  StreamChunk,
  LLMResponse,
  ModelInfo,
  ProviderCapabilities,
  ModelPricing,
  TokenUsage,
  LLMProviderError,
} from '../types';
import { ToolCallContentParser } from '../shared/ToolCallContentParser';
import { WebLLMEngine, GenerationResult } from './WebLLMEngine';
import { WebLLMModelManager } from './WebLLMModelManager';
import { WebLLMVRAMDetector } from './WebLLMVRAMDetector';
import { NexusToolCallConverter } from './NexusToolCallConverter';
import {
  WebLLMModelSpec,
  WebLLMState,
  WebLLMStatus,
  WebLLMError,
  ChatMessage,
} from './types';
import { WEBLLM_MODELS, getWebLLMModel, getModelsForVRAM } from './WebLLMModels';

// Unique instance counter for debugging adapter recreation issues
let webllmAdapterInstanceCount = 0;

export class WebLLMAdapter extends BaseAdapter {
  readonly name = 'webllm';
  readonly baseUrl = ''; // Local model - no external URL

  private engine: WebLLMEngine;
  private modelManager: WebLLMModelManager;
  private state: WebLLMState;
  private vault: Vault;
  private instanceId: number;
  private toolCallConverter: NexusToolCallConverter;

  mcpConnector?: any; // For tool execution support

  constructor(vault: Vault, mcpConnector?: any, sessionId?: string, workspaceId?: string) {
    console.log('[WebLLMAdapter] CONSTRUCTOR CALLED');
    // WebLLM doesn't need an API key
    super('', '', '', false);

    this.instanceId = ++webllmAdapterInstanceCount;

    this.vault = vault;
    this.mcpConnector = mcpConnector;
    // Use shared singleton engine - critical for multiple adapter instances
    // This ensures the GPU-loaded model is shared across all adapters
    this.engine = WebLLMEngine.getSharedInstance();
    this.modelManager = new WebLLMModelManager(vault);

    // Initialize tool call converter for two-tool architecture
    // Nexus models are trained on the full toolset - convert to useTool format
    this.toolCallConverter = new NexusToolCallConverter(sessionId, workspaceId);

    this.state = {
      status: 'unavailable',
      loadedModel: null,
    };

    this.initializeCache();
  }

  /**
   * Update session/workspace context for tool call conversion
   */
  updateToolContext(sessionId?: string, workspaceId?: string): void {
    this.toolCallConverter.updateContext(sessionId, workspaceId);
  }

  // ============================================================================
  // Initialization
  // ============================================================================

  /**
   * Initialize the WebLLM adapter
   * Checks WebGPU availability
   */
  async initialize(): Promise<void> {
    // Check WebGPU availability
    const vramInfo = await WebLLMVRAMDetector.detect();
    this.state.vramInfo = vramInfo;

    if (!vramInfo.webGPUSupported) {
      this.state.status = 'unavailable';
      return;
    }

    this.state.status = 'available';
  }

  /**
   * Load a model into GPU memory
   */
  async loadModel(
    modelSpec: WebLLMModelSpec,
    onProgress?: (progress: number, stage: string) => void
  ): Promise<void> {
    if (this.state.status === 'unavailable') {
      throw new WebLLMError('WebGPU not available', 'WEBGPU_NOT_SUPPORTED');
    }

    this.state.status = 'loading';

    try {
      // Initialize model via main-thread engine
      const result = await this.engine.initModel(modelSpec, {
        onProgress: (progress) => {
          this.state.loadProgress = progress.progress;
          if (onProgress) {
            onProgress(progress.progress, progress.stage);
          }
        },
      });

      this.state.status = 'ready';
      this.state.loadedModel = modelSpec.id;
      this.currentModel = modelSpec.apiName;
    } catch (error) {
      this.state.status = 'error';
      this.state.error = error instanceof Error ? error.message : 'Unknown error';
      throw error;
    }
  }

  /**
   * Unload the current model from GPU memory
   */
  async unloadModel(): Promise<void> {
    if (this.state.loadedModel) {
      await this.engine.unloadModel();
      this.state.status = 'available';
      this.state.loadedModel = null;
      this.currentModel = '';
    }
  }

  // ============================================================================
  // Generation (BaseAdapter implementation)
  // ============================================================================

  /**
   * Generate response without caching
   */
  async generateUncached(prompt: string, options?: GenerateOptions): Promise<LLMResponse> {
    await this.ensureModelLoadedAsync();

    const messages = this.buildMessages(prompt, options?.systemPrompt);

    try {
      this.state.status = 'generating';

      const result = await this.engine.generate(messages, {
        temperature: options?.temperature,
        maxTokens: options?.maxTokens,
        topP: options?.topP,
        stopSequences: options?.stopSequences,
      });

      this.state.status = 'ready';

      let content = result.content;
      let toolCalls: any[] = [];

      // Check for [TOOL_CALLS] or <tool_call> format
      if (ToolCallContentParser.hasToolCallsFormat(content)) {
        const parsed = ToolCallContentParser.parse(content);
        if (parsed.hasToolCalls) {
          content = parsed.cleanContent;
          // Convert old-style tool calls to useTool format
          // Nexus models are trained on the full toolset - wrap in useTool
          toolCalls = this.toolCallConverter.convertToolCalls(parsed.toolCalls);
        }
      }

      const usage: TokenUsage = {
        promptTokens: result.usage.promptTokens,
        completionTokens: result.usage.completionTokens,
        totalTokens: result.usage.totalTokens,
      };

      return await this.buildLLMResponse(
        content,
        this.currentModel,
        usage,
        { cached: false },
        toolCalls.length > 0 ? 'tool_calls' : this.mapFinishReason(result.finishReason),
        toolCalls
      );
    } catch (error) {
      this.state.status = 'ready';
      throw this.handleError(error, 'generation');
    }
  }

  /**
   * Generate streaming response
   */
  async* generateStreamAsync(
    prompt: string,
    options?: GenerateOptions
  ): AsyncGenerator<StreamChunk, void, unknown> {
    await this.ensureModelLoadedAsync();

    // Check for pre-built conversation history (tool continuations)
    let messages: ChatMessage[];
    if (options?.conversationHistory && options.conversationHistory.length > 0) {
      messages = options.conversationHistory;
    } else {
      messages = this.buildMessages(prompt, options?.systemPrompt);
    }

    // Debug logging - full request (check console with filter: LLM_DEBUG)
    console.log('[LLM_DEBUG] ====== WebLLM/Nexus Request ======');
    console.log('[LLM_DEBUG] Messages:');
    for (const msg of messages) {
      console.log(`[LLM_DEBUG] [${msg.role}]:`);
      console.log(msg.content);
      console.log('[LLM_DEBUG] ---');
    }
    console.log('[LLM_DEBUG] ================================');

    // CRITICAL: Reset adapter state to 'ready' before starting new generation
    // This ensures clean state regardless of previous generation's outcome
    // The engine handles the actual locking via generationLock
    if (this.state.status === 'generating') {
      this.state.status = 'ready';
    }

    const isToolContinuation = !!(options?.conversationHistory?.length);

    this.state.status = 'generating';

    try {

      let accumulatedContent = '';
      let hasToolCallsFormat = false;
      let finalUsage: TokenUsage | undefined;
      let chunkCount = 0;

      for await (const response of this.engine.generateStream(messages, {
        temperature: options?.temperature,
        maxTokens: options?.maxTokens,
        topP: options?.topP,
        stopSequences: options?.stopSequences,
        isToolContinuation, // Pass flag to skip resetChat on continuations
      })) {
        // Check if this is a chunk or final result
        if ('tokenCount' in response && !('usage' in response)) {
          // This is a StreamChunk from the engine
          const chunk = response;
          chunkCount++;
          accumulatedContent += chunk.content;

          // Check for [TOOL_CALLS] format early in stream
          if (!hasToolCallsFormat && ToolCallContentParser.hasToolCallsFormat(accumulatedContent)) {
            hasToolCallsFormat = true;
          }

          // If [TOOL_CALLS] detected, buffer chunks (don't show raw JSON to user)
          if (!hasToolCallsFormat) {
            yield {
              content: chunk.content,
              complete: false,
            };
          }
        } else if ('usage' in response) {
          // This is a GenerationResult (final)
          const complete = response as GenerationResult;

          finalUsage = {
            promptTokens: complete.usage.promptTokens,
            completionTokens: complete.usage.completionTokens,
            totalTokens: complete.usage.totalTokens,
          };

          // Handle [TOOL_CALLS] or <tool_call> format at completion
          if (hasToolCallsFormat) {
            const parsed = ToolCallContentParser.parse(accumulatedContent);

            // Debug logging - response
            console.log('[LLM_DEBUG] ====== WebLLM/Nexus Response ======');
            console.log('[LLM_DEBUG] Raw accumulated content:');
            console.log(accumulatedContent);
            console.log('[LLM_DEBUG] Parsed tool calls:', parsed.hasToolCalls ? parsed.toolCalls.length : 0);
            if (parsed.hasToolCalls) {
              console.log('[LLM_DEBUG] Tool calls:', JSON.stringify(parsed.toolCalls, null, 2));
            }
            console.log('[LLM_DEBUG] ================================');

            if (parsed.hasToolCalls) {
              // DEBUG: Log tool calls before conversion
              console.log('[NEXUS_TOOL_DEBUG] Tool calls before conversion:', JSON.stringify(parsed.toolCalls, null, 2));

              // Convert old-style tool calls to useTool format
              // Nexus models are trained on the full toolset - wrap in useTool
              const convertedToolCalls = this.toolCallConverter.convertToolCalls(parsed.toolCalls);

              // DEBUG: Log converted tool calls
              console.log('[NEXUS_TOOL_DEBUG] Converted tool calls:', JSON.stringify(convertedToolCalls, null, 2));

              yield {
                content: parsed.cleanContent,
                complete: true,
                toolCalls: convertedToolCalls,
                toolCallsReady: true,
                usage: finalUsage,
              };
            } else {
              // Parsing failed - yield raw content
              console.log('[NEXUS_TOOL_DEBUG] Parsing failed - no tool calls found');
              yield {
                content: accumulatedContent,
                complete: true,
                usage: finalUsage,
              };
            }
          } else {
            yield {
              content: '',
              complete: true,
              usage: finalUsage,
            };
          }
        }
      }
    } catch (error) {

      if (error instanceof WebLLMError) {
        throw error;
      }

      throw new LLMProviderError(
        `WebLLM streaming failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'webllm',
        'GENERATION_FAILED'
      );
    } finally {
      // CRITICAL: Always reset adapter status in finally block
      // This ensures clean state even if the generator is abandoned (not fully consumed)
      this.state.status = 'ready';
    }
  }

  // ============================================================================
  // Model Information
  // ============================================================================

  /**
   * List available models (based on VRAM)
   */
  async listModels(): Promise<ModelInfo[]> {
    const vramInfo = this.state.vramInfo || await WebLLMVRAMDetector.detect();
    const availableModels = getModelsForVRAM(vramInfo.estimatedVRAM);

    return availableModels.map(model => ({
      id: model.id,
      name: model.name,
      contextWindow: model.contextWindow,
      maxOutputTokens: model.maxTokens,
      supportsJSON: model.capabilities.supportsJSON,
      supportsImages: model.capabilities.supportsImages,
      supportsFunctions: model.capabilities.supportsFunctions,
      supportsStreaming: model.capabilities.supportsStreaming,
      supportsThinking: model.capabilities.supportsThinking,
      pricing: {
        inputPerMillion: 0, // Free - local
        outputPerMillion: 0,
        currency: 'USD',
        lastUpdated: new Date().toISOString(),
      },
    }));
  }

  /**
   * Get adapter capabilities
   */
  getCapabilities(): ProviderCapabilities {
    return {
      supportsStreaming: true,
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true, // Via [TOOL_CALLS] format
      supportsThinking: false,
      maxContextWindow: 4096, // Must match WASM library (ctx4k)
      supportedFeatures: ['streaming', 'function_calling', 'local', 'privacy', 'offline'],
    };
  }

  /**
   * Get model pricing (always free for local models)
   */
  async getModelPricing(modelId: string): Promise<ModelPricing | null> {
    return {
      rateInputPerMillion: 0,
      rateOutputPerMillion: 0,
      currency: 'USD',
    };
  }

  /**
   * Check if adapter is available
   * Performs lazy initialization if not yet initialized
   */
  async isAvailable(): Promise<boolean> {
    // Lazy initialization: if adapter wasn't initialized during startup,
    // initialize now to check WebGPU availability
    if (this.state.status === 'unavailable' && !this.state.vramInfo) {
      await this.initialize();
    }
    return this.state.status !== 'unavailable';
  }

  // ============================================================================
  // State & Status
  // ============================================================================

  /**
   * Get current adapter state
   */
  getState(): WebLLMState {
    return { ...this.state };
  }

  /**
   * Get current status
   */
  getStatus(): WebLLMStatus {
    return this.state.status;
  }

  /**
   * Check if model is loaded
   */
  isModelLoaded(): boolean {
    return this.state.loadedModel !== null;
  }

  /**
   * Check if a model uses [TOOL_CALLS] content format
   * All Nexus fine-tuned models use this format (legacy identifiers included for compatibility)
   */
  static usesToolCallsContentFormat(modelId: string): boolean {
    const contentFormatKeywords = ['nexus', 'tools-sft', 'claudesidian'];
    const lowerModelId = modelId.toLowerCase();
    return contentFormatKeywords.some(keyword => lowerModelId.includes(keyword));
  }

  // ============================================================================
  // Model Management Delegation
  // ============================================================================

  /**
   * Get model manager for download/install operations
   */
  getModelManager(): WebLLMModelManager {
    return this.modelManager;
  }

  /**
   * Get VRAM info
   */
  getVRAMInfo() {
    return this.state.vramInfo;
  }

  // ============================================================================
  // Helper Methods
  // ============================================================================

  /**
   * Ensure a model is loaded before generation
   * Will auto-load the default model if not already loaded
   */
  private async ensureModelLoadedAsync(): Promise<void> {
    const engineLoaded = this.engine?.isModelLoaded();

    // Lazy initialization: if adapter wasn't initialized during startup,
    // initialize now on first use. This prevents blocking vault startup.
    if (this.state.status === 'unavailable' && !this.state.vramInfo) {
      console.log('[WebLLMAdapter] Lazy initialization on first use...');
      await this.initialize();
    }

    if (this.state.status === 'unavailable') {
      throw new LLMProviderError(
        'WebGPU not available',
        'webllm',
        'WEBGPU_NOT_SUPPORTED'
      );
    }

    // If engine has model loaded, we're good - trust the shared engine state
    // This handles: tool continuation, multiple adapter instances, etc.
    if (engineLoaded) {
      // Sync adapter state with engine state
      const engineModelId = this.engine.getCurrentModelId();
      if (engineModelId && !this.state.loadedModel) {
        this.state.loadedModel = engineModelId;
        this.state.status = 'ready';
      }
      return;
    }

    // Also check if status is ready (normal case)
    if (this.state.loadedModel && this.state.status === 'ready') {
      return;
    }

    // If currently loading, wait
    if (this.state.status === 'loading') {
      // Wait for loading to complete (poll every 500ms, max 60s)
      for (let i = 0; i < 120; i++) {
        await new Promise(resolve => setTimeout(resolve, 500));
        // Use type assertion to break TypeScript's type narrowing (status can change async)
        const currentStatus = this.state.status as WebLLMStatus;
        if (currentStatus === 'ready') return;
        if (currentStatus === 'error') throw new LLMProviderError(
          this.state.error || 'Model loading failed',
          'webllm',
          'MODEL_LOAD_FAILED'
        );
      }
      throw new LLMProviderError('Model loading timeout', 'webllm', 'MODEL_LOAD_TIMEOUT');
    }

    // No model loaded - try to auto-load the default model
    // Get the default/first available model
    const modelSpec = WEBLLM_MODELS[0];
    if (!modelSpec) {
      throw new LLMProviderError(
        'No WebLLM models available',
        'webllm',
        'NO_MODELS_AVAILABLE'
      );
    }

    // WebLLM handles its own model caching via browser Cache API / IndexedDB
    // No need to check if model is "installed" locally - just load it
    // First load will download from HuggingFace, subsequent loads use cache
    await this.loadModel(modelSpec);
  }

  /**
   * Sync version for compatibility (throws if not loaded)
   */
  private ensureModelLoaded(): void {
    if (!this.state.loadedModel) {
      throw new LLMProviderError(
        'No model loaded. Model will be auto-loaded on first generation.',
        'webllm',
        'MODEL_NOT_LOADED'
      );
    }

    if (this.state.status === 'unavailable') {
      throw new LLMProviderError(
        'WebGPU not available',
        'webllm',
        'WEBGPU_NOT_SUPPORTED'
      );
    }
  }

  /**
   * Build chat messages from prompt and system prompt
   */
  protected buildMessages(prompt: string, systemPrompt?: string): ChatMessage[] {
    const messages: ChatMessage[] = [];

    if (systemPrompt) {
      messages.push({ role: 'system', content: systemPrompt });
    }

    messages.push({ role: 'user', content: prompt });

    return messages;
  }

  /**
   * Map WebLLM finish reason to standard type
   */
  private mapFinishReason(reason: string): 'stop' | 'length' | 'tool_calls' | 'content_filter' {
    switch (reason) {
      case 'stop':
        return 'stop';
      case 'length':
        return 'length';
      case 'abort':
        return 'stop';
      default:
        return 'stop';
    }
  }

  /**
   * Handle and normalize errors
   */
  protected handleError(error: any, operation: string): never {
    if (error instanceof LLMProviderError) {
      throw error;
    }

    if (error instanceof WebLLMError) {
      throw new LLMProviderError(
        error.message,
        'webllm',
        error.code,
        error
      );
    }

    throw new LLMProviderError(
      `WebLLM ${operation} failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
      'webllm',
      'UNKNOWN_ERROR',
      error
    );
  }

  // ============================================================================
  // Cleanup
  // ============================================================================

  /**
   * Clean up resources
   */
  async dispose(): Promise<void> {
    await this.engine.dispose();
    this.state.status = 'unavailable';
    this.state.loadedModel = null;
  }
}

```

## services/llm/adapters/webllm/WebLLMCachePrefetcher.ts

```typescript
/**
 * WebLLMCachePrefetcher
 *
 * Pre-fetches model files and stores them in the browser Cache API.
 *
 * Why this is needed:
 * - HuggingFace stores large files in XetHub (Git LFS replacement)
 * - XetHub URLs redirect to cas-bridge.xethub.hf.co
 * - WebLLM uses Cache.add(url) which fails on redirects
 * - Solution: Pre-fetch files with requestUrl (follows redirects, handles CORS)
 *   and store with cache.put(originalUrl, response)
 *
 * When WebLLM later tries to fetch the same URLs, they'll be in cache.
 */

import { requestUrl } from 'obsidian';
import { WebLLMModelSpec } from './types';
import { HF_BASE_URL } from './WebLLMModels';

export interface PrefetchProgress {
  totalFiles: number;
  completedFiles: number;
  currentFile: string;
  totalBytes: number;
  downloadedBytes: number;
  percentage: number;
}

const CACHE_NAME = 'webllm-prefetch-cache';

/**
 * Get list of files to prefetch for a model
 */
async function getModelFileList(modelSpec: WebLLMModelSpec): Promise<Array<{ name: string; url: string; size: number }>> {
  console.log('[WebLLMCachePrefetcher] getModelFileList START');
  console.log('[WebLLMCachePrefetcher] Getting file list for:', modelSpec.huggingFaceRepo);
  const basePath = modelSpec.flatStructure
    ? `${HF_BASE_URL}/${modelSpec.huggingFaceRepo}/resolve/main`
    : `${HF_BASE_URL}/${modelSpec.huggingFaceRepo}/resolve/main/${modelSpec.quantization}`;
  console.log('[WebLLMCachePrefetcher] Base path:', basePath);

  const files: Array<{ name: string; url: string; size: number }> = [];

  // Always include config
  files.push({
    name: 'mlc-chat-config.json',
    url: `${basePath}/mlc-chat-config.json`,
    size: 0
  });

  // Fetch tensor-cache.json to get shard list
  console.log('[WebLLMCachePrefetcher] Fetching tensor-cache.json...');
  try {
    const tensorCacheUrl = `${basePath}/tensor-cache.json`;
    const resp = await requestUrl({ url: tensorCacheUrl, method: 'GET' });
    console.log('[WebLLMCachePrefetcher] tensor-cache.json status:', resp.status);
    if (resp.status === 200) {
      const tensorConfig = resp.json;
      files.push({ name: 'tensor-cache.json', url: tensorCacheUrl, size: 0 });

      // Add all shards from tensor-cache
      if (tensorConfig.records && Array.isArray(tensorConfig.records)) {
        console.log('[WebLLMCachePrefetcher] Found', tensorConfig.records.length, 'records in tensor-cache');
        for (const record of tensorConfig.records) {
          if (record.dataPath) {
            files.push({
              name: record.dataPath,
              url: `${basePath}/${record.dataPath}`,
              size: record.nbytes || 0,
            });
          }
        }
      }
    }
  } catch (err) {
    console.log('[WebLLMCachePrefetcher] tensor-cache.json fetch failed, probing for shards...', err);
    // Fall back to probing for shards
    for (let i = 0; i < 200; i++) {
      const shardName = `params_shard_${i}.bin`;
      const url = `${basePath}/${shardName}`;
      try {
        const resp = await requestUrl({ url, method: 'HEAD' });
        if (resp.status === 200) {
          const size = parseInt(resp.headers['content-length'] || '0', 10);
          files.push({ name: shardName, url, size });
        } else {
          break;
        }
      } catch {
        break;
      }
    }
  }

  // Add tokenizer files
  console.log('[WebLLMCachePrefetcher] Checking tokenizer files...');
  const tokenizerFiles = ['tokenizer.json', 'tokenizer_config.json', 'vocab.json', 'merges.txt', 'added_tokens.json'];
  for (const tokenFile of tokenizerFiles) {
    const url = `${basePath}/${tokenFile}`;
    try {
      const resp = await requestUrl({ url, method: 'HEAD' });
      if (resp.status === 200) {
        const size = parseInt(resp.headers['content-length'] || '0', 10);
        files.push({ name: tokenFile, url, size });
      }
    } catch {
      // Skip missing files
    }
  }
  console.log('[WebLLMCachePrefetcher] Tokenizer files checked');

  // Add WASM library
  if (modelSpec.modelLibUrl) {
    files.push({
      name: 'model.wasm',
      url: modelSpec.modelLibUrl,
      size: 0,
    });
  }

  console.log('[WebLLMCachePrefetcher] getModelFileList END - found', files.length, 'files');
  return files;
}

/**
 * Check if a file is already cached
 */
async function isFileCached(url: string): Promise<boolean> {
  try {
    const cache = await caches.open(CACHE_NAME);
    const response = await cache.match(url);
    return response !== undefined;
  } catch (err) {
    console.error('[WebLLMCachePrefetcher] isFileCached error:', err);
    return false;
  }
}

/**
 * Prefetch a single file and store in cache
 * Uses Obsidian's requestUrl which handles CORS and follows redirects
 */
async function prefetchFile(url: string, cache: Cache): Promise<number> {
  const fileName = url.split('/').pop() || url;

  // Check if already cached
  const cached = await cache.match(url);
  if (cached) {
    // Already cached, skip
    const blob = await cached.blob();
    console.log('[WebLLMCachePrefetcher] Already cached:', fileName, '(' + blob.size + ' bytes)');
    return blob.size;
  }

  console.log('[WebLLMCachePrefetcher] Downloading:', fileName);
  // Fetch the file using Obsidian's requestUrl (handles CORS, follows redirects)
  const response = await requestUrl({ url, method: 'GET' });
  if (response.status !== 200) {
    throw new Error(`Failed to fetch ${url}: ${response.status}`);
  }

  // Get the data as ArrayBuffer
  const arrayBuffer = response.arrayBuffer;
  const size = arrayBuffer.byteLength;

  // Determine content type
  const contentType = response.headers['content-type'] || 'application/octet-stream';

  // Create a Response object for Cache API
  const cacheResponse = new Response(arrayBuffer, {
    status: 200,
    statusText: 'OK',
    headers: {
      'Content-Type': contentType,
      'Content-Length': size.toString(),
    },
  });

  // Store in cache with ORIGINAL URL (not redirect URL)
  // This is the key - WebLLM will look for the original HuggingFace URL
  await cache.put(url, cacheResponse);
  console.log('[WebLLMCachePrefetcher] Cached:', fileName, '(' + size + ' bytes)');

  return size;
}

/**
 * Prefetch all model files
 */
export async function prefetchModel(
  modelSpec: WebLLMModelSpec,
  onProgress?: (progress: PrefetchProgress) => void
): Promise<void> {
  console.log('[WebLLMCachePrefetcher] Starting prefetch for model:', modelSpec.id);
  const files = await getModelFileList(modelSpec);
  console.log('[WebLLMCachePrefetcher] Found', files.length, 'files to prefetch');
  const cache = await caches.open(CACHE_NAME);

  let completedFiles = 0;
  let downloadedBytes = 0;
  // File sizes from tensor-cache.json are often inaccurate or 0
  // Use file count for progress instead of bytes
  const totalFiles = files.length;

  for (const file of files) {
    if (onProgress) {
      // Use file-based percentage (more reliable than byte-based)
      const percentage = totalFiles > 0 ? (completedFiles / totalFiles) * 100 : 0;
      onProgress({
        totalFiles,
        completedFiles,
        currentFile: file.name,
        totalBytes: 0, // Not reliably known
        downloadedBytes,
        percentage,
      });
    }

    try {
      const fileSize = await prefetchFile(file.url, cache);
      downloadedBytes += fileSize;
    } catch (error) {
      console.error(`[WebLLMCachePrefetcher] Failed to prefetch ${file.name}:`, error);
      // Continue with other files
    }

    completedFiles++;
  }

  if (onProgress) {
    onProgress({
      totalFiles,
      completedFiles: totalFiles,
      currentFile: 'Complete',
      totalBytes: downloadedBytes, // Final actual total
      downloadedBytes,
      percentage: 100,
    });
  }
}

/**
 * Check if a model is fully prefetched
 */
export async function isModelPrefetched(modelSpec: WebLLMModelSpec): Promise<boolean> {
  console.log('[WebLLMCachePrefetcher] isModelPrefetched CALLED for:', modelSpec?.id || 'undefined');
  if (!modelSpec) {
    console.error('[WebLLMCachePrefetcher] modelSpec is undefined!');
    return false;
  }
  try {
    console.log('[WebLLMCachePrefetcher] About to get file list...');
    const files = await getModelFileList(modelSpec);
    console.log('[WebLLMCachePrefetcher] Got file list, checking cache...');
    console.log('[WebLLMCachePrefetcher] Checking', files.length, 'files in cache');

    for (const file of files) {
      if (!(await isFileCached(file.url))) {
        console.log('[WebLLMCachePrefetcher] File not cached:', file.name);
        return false;
      }
    }

    console.log('[WebLLMCachePrefetcher] All files cached');
    return true;
  } catch (error) {
    console.error('[WebLLMCachePrefetcher] Error checking cache:', error);
    return false;
  }
}

/**
 * Clear prefetched model from cache
 */
export async function clearPrefetchedModel(modelSpec: WebLLMModelSpec): Promise<void> {
  const files = await getModelFileList(modelSpec);
  const cache = await caches.open(CACHE_NAME);

  for (const file of files) {
    await cache.delete(file.url);
  }
}

/**
 * Clear all prefetched data
 */
export async function clearAllPrefetchedData(): Promise<void> {
  await caches.delete(CACHE_NAME);
}

```

## services/llm/adapters/webllm/WebLLMEngine.ts

```typescript
/**
 * WebLLMEngine - Main thread WebLLM engine wrapper
 *
 * Runs WebLLM in the main thread instead of a worker to avoid
 * Obsidian's sandboxed Electron restrictions that block local module bundling.
 *
 * WebGPU handles the actual GPU compute, so main thread execution
 * doesn't block the UI during inference.
 *
 * Loads WebLLM from CDN (esm.run) - this is the cleanest solution because
 * WebLLM is designed for browsers and esm.run serves browser-compatible ESM.
 *
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘  MULTI-GENERATION CRASH INVESTIGATION NOTES (Dec 6, 2025)                 â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘  PROBLEM: Second generation (tool continuation) crashes Electron renderer â•‘
 * â•‘                                                                            â•‘
 * â•‘  CRASH LOCATION:                                                           â•‘
 * â•‘  - engine.chat.completions.create() succeeds                              â•‘
 * â•‘  - Stream object is created                                               â•‘
 * â•‘  - Crash happens during `for await (const chunk of stream)` iteration     â•‘
 * â•‘  - Specifically during WebLLM's prefill phase (processing input tokens)  â•‘
 * â•‘  - No JavaScript error is caught - hard renderer process crash            â•‘
 * â•‘                                                                            â•‘
 * â•‘  TESTED MITIGATIONS (all failed):                                          â•‘
 * â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â•‘
 * â•‘  â”‚ 1. Generation lock mechanism                                        â”‚  â•‘
 * â•‘  â”‚    - Added acquireGenerationLock() / releaseGenerationLock()       â”‚  â•‘
 * â•‘  â”‚    - Ensures sequential access to GPU                               â”‚  â•‘
 * â•‘  â”‚    - Result: Lock acquired, crash still happens during iteration   â”‚  â•‘
 * â•‘  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â•‘
 * â•‘  â”‚ 2. KV cache reset BEFORE generation                                 â”‚  â•‘
 * â•‘  â”‚    - await this.resetChat() before each generation                  â”‚  â•‘
 * â•‘  â”‚    - 100-300ms delay after reset                                    â”‚  â•‘
 * â•‘  â”‚    - Result: Reset completes, crash still happens during prefill   â”‚  â•‘
 * â•‘  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â•‘
 * â•‘  â”‚ 3. KV cache reset AFTER generation                                  â”‚  â•‘
 * â•‘  â”‚    - Reset in finally block after each generation                   â”‚  â•‘
 * â•‘  â”‚    - Result: First gen resets successfully, second gen crashes     â”‚  â•‘
 * â•‘  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â•‘
 * â•‘  â”‚ 4. NO KV cache resets at all                                        â”‚  â•‘
 * â•‘  â”‚    - Skipped all resetChat() calls                                  â”‚  â•‘
 * â•‘  â”‚    - Result: Still crashes - not reset-related                      â”‚  â•‘
 * â•‘  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â•‘
 * â•‘  â”‚ 5. Non-streaming API for continuations                              â”‚  â•‘
 * â•‘  â”‚    - Used stream: false for second generation                       â”‚  â•‘
 * â•‘  â”‚    - Result: Also crashes - not streaming-specific                  â”‚  â•‘
 * â•‘  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â•‘
 * â•‘  â”‚ 6. Longer delays between generations                                â”‚  â•‘
 * â•‘  â”‚    - 1000ms wait before second generation                           â”‚  â•‘
 * â•‘  â”‚    - 300ms after KV reset                                           â”‚  â•‘
 * â•‘  â”‚    - Result: Still crashes - not timing-related                     â”‚  â•‘
 * â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â•‘
 * â•‘                                                                            â•‘
 * â•‘  ENVIRONMENT:                                                              â•‘
 * â•‘  - macOS with Apple Silicon (M4)                                          â•‘
 * â•‘  - 24GB unified memory                                                    â•‘
 * â•‘  - WebGPU -> Metal translation layer                                      â•‘
 * â•‘  - WebLLM v0.2.80 via CDN (esm.run)                                       â•‘
 * â•‘  - Model: Nexus-Electron-Q3.0.2 (Qwen3-8B, 16K context, q4f16)           â•‘
 * â•‘                                                                            â•‘
 * â•‘  HYPOTHESIS:                                                               â•‘
 * â•‘  WebGPU resource management bug in WebLLM or browser WebGPU->Metal layer â•‘
 * â•‘  The second prefill allocates GPU buffers that conflict with state from  â•‘
 * â•‘  the first generation, causing memory corruption or invalid GPU state.   â•‘
 * â•‘  Similar issues reported: https://github.com/mlc-ai/web-llm/issues/647   â•‘
 * â•‘                                                                            â•‘
 * â•‘  CURRENT WORKAROUND:                                                       â•‘
 * â•‘  Tool continuations are blocked in WebLLMAdapter.generateStreamAsync()   â•‘
 * â•‘  Users see friendly error message suggesting Ollama/LM Studio             â•‘
 * â•‘                                                                            â•‘
 * â•‘  FUTURE FIX OPTIONS:                                                       â•‘
 * â•‘  1. Wait for WebLLM upstream fix                                          â•‘
 * â•‘  2. Try engine.unload() + reload between generations (slow)              â•‘
 * â•‘  3. Compile custom WASM with different memory management                  â•‘
 * â•‘  4. Test on different browser/Electron versions                           â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

import { WebLLMModelSpec, WebLLMError } from './types';
import { WEBLLM_MODELS, HF_BASE_URL } from './WebLLMModels';
import { prefetchModel, isModelPrefetched } from './WebLLMCachePrefetcher';

// Type imports for TypeScript (these are erased at runtime)
import type * as WebLLMTypes from '@mlc-ai/web-llm';

export interface EngineProgress {
  progress: number;
  stage: 'downloading' | 'loading' | 'compiling';
  message: string;
}

export interface GenerationResult {
  content: string;
  usage: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  finishReason: string;
}

export interface StreamChunk {
  content: string;
  tokenCount: number;
}

// Lazy-loaded WebLLM module
let webllm: typeof WebLLMTypes | null = null;

// Singleton engine instance - shared across all WebLLMAdapter instances
// This ensures the model stays loaded in GPU memory even when multiple adapters exist
let sharedEngineInstance: WebLLMEngine | null = null;

// Extend Window interface to include our patch tracking flag
interface NexusWindow extends Window {
  __nexus_wasm_patched?: boolean;
}

/**
 * Patch WebAssembly.instantiate to inject FFI stub functions
 *
 * Custom-compiled WASMs may import TVM FFI functions that the CDN version
 * of web-llm doesn't provide. We intercept WebAssembly.instantiate and
 * inject no-op stubs into the imports object.
 *
 * This is necessary because:
 * 1. Web-llm is loaded from CDN (esm.run), so we can't patch node_modules
 * 2. The stubs must be in the WASM import object, not just on window
 * 3. These are GPU stream management functions not used by WebGPU
 */
function patchWebAssemblyInstantiate(): void {
  const win = window as NexusWindow;

  // Check if we've already patched
  if (win.__nexus_wasm_patched) {
    return;
  }

  // Store original functions
  const originalInstantiate = WebAssembly.instantiate.bind(WebAssembly);
  const originalInstantiateStreaming = WebAssembly.instantiateStreaming?.bind(WebAssembly);

  // FFI stub functions - these are for CUDA/ROCm features not used by WebGPU
  // Add more stubs here as needed when new LinkErrors appear
  const ffiStubs: Record<string, () => number> = {
    TVMFFIEnvSetStream: () => 0,      // GPU stream management
    TVMFFIEnvGetStream: () => 0,      // GPU stream management
    TVMFFIEnvCheckSignals: () => 0,   // Interrupt/signal handling
  };

  // Type for WebAssembly module environment with FFI stubs
  type FFIEnv = Record<string, unknown> & Record<string, () => number>;

  // Helper to inject stubs into imports
  function injectStubs(imports: WebAssembly.Imports | undefined): WebAssembly.Imports {
    if (!imports) {
      return { env: { ...ffiStubs } };
    }

    // Clone imports to avoid mutating the original
    const patchedImports: WebAssembly.Imports = {};

    for (const namespace of Object.keys(imports)) {
      patchedImports[namespace] = { ...imports[namespace] };
    }

    // Inject stubs into 'env' namespace (where TVM FFI functions live)
    if (!patchedImports.env) {
      patchedImports.env = {};
    }

    const env = patchedImports.env as FFIEnv;

    // Add stubs only if not already present
    for (const [name, stub] of Object.entries(ffiStubs)) {
      if (!(name in env)) {
        env[name] = stub;
      }
    }

    return patchedImports;
  }

  // Patch WebAssembly.instantiate
  WebAssembly.instantiate = function(
    source: BufferSource | WebAssembly.Module,
    imports?: WebAssembly.Imports
  ): Promise<WebAssembly.WebAssemblyInstantiatedSource | WebAssembly.Instance> {
    const patchedImports = injectStubs(imports);
    return originalInstantiate(source, patchedImports);
  } as typeof WebAssembly.instantiate;

  // Patch WebAssembly.instantiateStreaming if available
  if (originalInstantiateStreaming) {
    WebAssembly.instantiateStreaming = function(
      source: Response | PromiseLike<Response>,
      imports?: WebAssembly.Imports
    ): Promise<WebAssembly.WebAssemblyInstantiatedSource> {
      const patchedImports = injectStubs(imports);
      return originalInstantiateStreaming(source, patchedImports);
    };
  }

  // Mark as patched
  win.__nexus_wasm_patched = true;
}

/**
 * Load WebLLM dynamically from CDN at runtime
 *
 * Uses jsDelivr's esm.run service which serves browser-compatible ESM modules.
 * This works in Electron's renderer because it has full browser capabilities.
 */
async function loadWebLLM(): Promise<typeof WebLLMTypes> {
  if (webllm) {
    return webllm;
  }

  // Patch WebAssembly.instantiate BEFORE loading WebLLM
  // This ensures the stubs are injected when WASM is instantiated
  patchWebAssemblyInstantiate();

  try {
    // Dynamic import from jsDelivr's esm.run service
    // This serves ESM modules that work in browser contexts
    // @ts-ignore - TypeScript doesn't understand CDN URLs, but Electron's renderer can import them
    const module = await import('https://esm.run/@mlc-ai/web-llm');

    webllm = module as typeof WebLLMTypes;

    if (!webllm.CreateMLCEngine) {
      throw new Error('CreateMLCEngine not found in module');
    }

    return webllm;
  } catch (error) {
    console.error('[WebLLMEngine] Failed to load WebLLM from CDN:', error);
    throw new WebLLMError(
      `Failed to load WebLLM: ${error instanceof Error ? error.message : String(error)}`,
      'MODULE_LOAD_FAILED',
      error
    );
  }
}

/**
 * Check if we should use stock WebLLM model for testing
 * Set to true to test with stock Mistral model instead of custom Nexus model
 */
const USE_STOCK_MODEL_FOR_TESTING = false; // Updated config with missing gen params

/**
 * Stock WebLLM model ID for testing
 * Uses official WebLLM model that's known to work
 */
const STOCK_TEST_MODEL_ID = 'Mistral-7B-Instruct-v0.3-q4f16_1-MLC';

/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘  CREATE WEBLLM CONFIG FOR NEXUS MODELS                                     â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘  This function creates the WebLLM AppConfig for a given model.            â•‘
 * â•‘                                                                            â•‘
 * â•‘  When adding new models to WebLLMModels.ts, this function will            â•‘
 * â•‘  automatically pick them up - no changes needed here!                      â•‘
 * â•‘                                                                            â•‘
 * â•‘  The config registers all models from WEBLLM_MODELS with WebLLM,          â•‘
 * â•‘  allowing runtime selection between them.                                  â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
function createNexusAppConfig(selectedModel?: WebLLMModelSpec): WebLLMTypes.AppConfig | undefined {
  if (USE_STOCK_MODEL_FOR_TESTING) {
    // Return undefined to use WebLLM's built-in model list
    return undefined;
  }

  // Build model list from all available Nexus models
  const modelList = WEBLLM_MODELS
    .filter(m => m.modelLibUrl) // Only include models with WASM libraries
    .map(model => ({
      model: `${HF_BASE_URL}/${model.huggingFaceRepo}/resolve/main/`,
      model_id: model.apiName,
      model_lib: model.modelLibUrl!,
      overrides: {
        context_window_size: model.contextWindow,
      },
    }));

  if (modelList.length === 0) {
    console.error('[WebLLMEngine] No valid models found in WEBLLM_MODELS');
    return undefined;
  }

  const targetModel = selectedModel || WEBLLM_MODELS[0];

  return { model_list: modelList };
}

export class WebLLMEngine {
  private engine: WebLLMTypes.MLCEngine | null = null;
  private isGenerating = false;
  private currentModelId: string | null = null;
  private abortController: AbortController | null = null;
  private generationLock: Promise<void> = Promise.resolve();
  private generationLockRelease: (() => void) | null = null;
  private hasGeneratedOnce = false; // Track if we've done at least one generation

  /**
   * Get the shared singleton engine instance
   * This ensures all WebLLMAdapter instances share the same GPU-loaded model
   */
  static getSharedInstance(): WebLLMEngine {
    if (!sharedEngineInstance) {
      sharedEngineInstance = new WebLLMEngine();
    }
    return sharedEngineInstance;
  }

  /**
   * Acquire the generation lock - ensures only one generation at a time
   * This prevents race conditions when tool continuations start before previous generation cleanup
   */
  private async acquireGenerationLock(): Promise<void> {
    // Wait for any existing generation to complete
    await this.generationLock;

    // Create a new lock
    this.generationLock = new Promise<void>((resolve) => {
      this.generationLockRelease = resolve;
    });
  }

  /**
   * Release the generation lock
   */
  private releaseGenerationLock(): void {
    if (this.generationLockRelease) {
      this.generationLockRelease();
      this.generationLockRelease = null;
    }
  }

  /**
   * Initialize the engine with a model
   */
  async initModel(
    modelSpec: WebLLMModelSpec,
    options?: {
      onProgress?: (progress: EngineProgress) => void;
    }
  ): Promise<{ modelId: string; contextWindow: number; maxTokens: number }> {
    console.log('[WebLLMEngine] initModel CALLED for:', modelSpec?.apiName || 'undefined');
    // If same model already loaded, skip
    if (this.engine && this.currentModelId === modelSpec.apiName) {
      return {
        modelId: modelSpec.apiName,
        contextWindow: modelSpec.contextWindow, // Use model's actual context window
        maxTokens: modelSpec.maxTokens,
      };
    }

    // Unload existing model if different
    if (this.engine && this.currentModelId !== modelSpec.apiName) {
      try {
        await this.unloadModel();
      } catch (unloadError) {
        // Ignore unload errors
      }
    }

    // Use stock model for testing, or custom model for production
    const modelIdToLoad = USE_STOCK_MODEL_FOR_TESTING ? STOCK_TEST_MODEL_ID : modelSpec.apiName;

    try {
      // Pre-fetch model files to cache (handles HuggingFace XetHub redirects)
      // This is critical because WebLLM's Cache.add() fails on redirects
      if (!USE_STOCK_MODEL_FOR_TESTING) {
        console.log('[WebLLMEngine] Checking if model is prefetched...');
        const alreadyPrefetched = await isModelPrefetched(modelSpec);
        console.log('[WebLLMEngine] Prefetch check result:', alreadyPrefetched);
        if (!alreadyPrefetched) {
          if (options?.onProgress) {
            options.onProgress({
              progress: 0,
              stage: 'downloading',
              message: 'Pre-fetching model files...',
            });
          }
          await prefetchModel(modelSpec, (prefetchProgress) => {
            if (options?.onProgress) {
              options.onProgress({
                // Normalize to 0-1 range (prefetcher returns 0-100)
                progress: prefetchProgress.percentage / 100,
                stage: 'downloading',
                message: `Downloading ${prefetchProgress.currentFile} (${prefetchProgress.completedFiles}/${prefetchProgress.totalFiles})`,
              });
            }
          });
        }
      }

      // Load WebLLM at runtime (not bundled)
      const webllmLib = await loadWebLLM();

      // Progress callback adapter with error protection
      const progressCallback = (report: WebLLMTypes.InitProgressReport) => {
        try {
          if (options?.onProgress) {
            const stage = report.text?.includes('Loading') ? 'loading' :
                          report.text?.includes('Download') ? 'downloading' : 'compiling';
            options.onProgress({
              progress: report.progress || 0,
              stage: stage as EngineProgress['stage'],
              message: report.text || '',
            });
          }
        } catch (progressError) {
          // Ignore progress callback errors
        }
      };

      // Create custom app config for Nexus model (or undefined to use built-in list)
      const appConfig = createNexusAppConfig();

      // Validate config before proceeding
      if (!appConfig?.model_list?.length) {
        throw new WebLLMError(
          'No models configured. Please check WebLLMModels.ts configuration.',
          'CONFIG_INVALID'
        );
      }

      // Create the MLC engine with timeout protection
      const enginePromise = webllmLib.CreateMLCEngine(modelIdToLoad, {
        appConfig,
        initProgressCallback: progressCallback,
      });

      // Add a timeout to prevent infinite hangs (5 minute timeout for large models)
      const timeoutPromise = new Promise<never>((_, reject) => {
        setTimeout(() => reject(new Error('Model loading timed out after 5 minutes')), 5 * 60 * 1000);
      });

      this.engine = await Promise.race([enginePromise, timeoutPromise]);

      this.currentModelId = modelIdToLoad;

      return {
        modelId: modelSpec.apiName,
        contextWindow: modelSpec.contextWindow, // Must match WASM (ctx4k = 4096)
        maxTokens: modelSpec.maxTokens,
      };
    } catch (error) {
      // Clean up any partial state
      this.engine = null;
      this.currentModelId = null;

      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error('[WebLLMEngine] Failed to load model:', errorMessage);
      console.error('[WebLLMEngine] Full error:', error);

      // Check for common error types
      if (errorMessage.includes('out of memory') || errorMessage.includes('OOM')) {
        throw new WebLLMError(
          'GPU out of memory. Try closing other GPU-intensive apps or use a smaller model.',
          'GPU_OOM',
          error
        );
      }

      if (errorMessage.includes('WebGPU') || errorMessage.includes('GPU')) {
        throw new WebLLMError(
          'WebGPU error. Your GPU may not be supported or drivers need updating.',
          'WEBGPU_ERROR',
          error
        );
      }

      if (errorMessage.includes('network') || errorMessage.includes('fetch') || errorMessage.includes('404')) {
        throw new WebLLMError(
          'Failed to download model files. Check your internet connection.',
          'NETWORK_ERROR',
          error
        );
      }

      throw new WebLLMError(
        `Failed to initialize model: ${errorMessage}`,
        'LOAD_FAILED',
        error
      );
    }
  }

  /**
   * Generate a response (non-streaming)
   */
  async generate(
    messages: { role: string; content: string }[],
    options?: {
      temperature?: number;
      maxTokens?: number;
      topP?: number;
      stopSequences?: string[];
    }
  ): Promise<GenerationResult> {
    if (!this.engine) {
      throw new WebLLMError('Engine not initialized', 'GENERATION_FAILED');
    }

    if (this.isGenerating) {
      throw new WebLLMError('Generation already in progress', 'GENERATION_FAILED');
    }

    this.isGenerating = true;

    try {
      // Clear KV cache before generation to prevent OOM
      await this.resetChat();

      const response = await this.engine.chat.completions.create({
        messages: messages as WebLLMTypes.ChatCompletionMessageParam[],
        temperature: options?.temperature ?? 0.5,
        max_tokens: options?.maxTokens ?? 2048,
        top_p: options?.topP ?? 0.95,
        stop: options?.stopSequences,
        stream: false,
      });

      const choice = response.choices[0];
      const usage = response.usage || { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 };

      return {
        content: choice.message?.content || '',
        usage: {
          promptTokens: usage.prompt_tokens || 0,
          completionTokens: usage.completion_tokens || 0,
          totalTokens: usage.total_tokens || 0,
        },
        finishReason: choice.finish_reason || 'stop',
      };
    } finally {
      this.isGenerating = false;
    }
  }

  /**
   * Reset the chat state (clears KV cache from GPU memory)
   * CRITICAL for tool continuations - without this, OOM occurs!
   * NOTE: Only call resetChat ONCE - calling twice can corrupt WebGPU state
   */
  async resetChat(): Promise<void> {
    if (this.engine) {
      try {
        // Single reset call - double reset can corrupt WebGPU state on Apple Silicon
        await this.engine.resetChat();
      } catch (error) {
        // Non-fatal - continue anyway
      }
    }
  }

  /**
   * Generate a streaming response
   * @param isToolContinuation - If true, skip resetChat to preserve conversation context
   */
  async *generateStream(
    messages: { role: string; content: string }[],
    options?: {
      temperature?: number;
      maxTokens?: number;
      topP?: number;
      stopSequences?: string[];
      isToolContinuation?: boolean;
    }
  ): AsyncGenerator<StreamChunk | GenerationResult, void, unknown> {
    if (!this.engine) {
      throw new WebLLMError('Engine not initialized', 'GENERATION_FAILED');
    }

    const isToolContinuation = options?.isToolContinuation || false;

    // CRITICAL: Acquire lock to ensure sequential generation
    // This prevents race conditions during tool continuations
    await this.acquireGenerationLock();

    // If there's a lingering generation flag, force cleanup
    if (this.isGenerating) {
      try {
        this.engine.interruptGenerate();
        // Longer wait for interrupt to take effect
        await new Promise(resolve => setTimeout(resolve, 500));
      } catch (e) {
        // Ignore interrupt errors
      }
      this.isGenerating = false;
    }

    this.isGenerating = true;
    this.abortController = new AbortController();

    try {
      // Ensure any previous generation is fully stopped
      try {
        this.engine.interruptGenerate();
      } catch (e) {
        // Ignore - might not have anything to interrupt
      }

      // For tool continuations, add a longer delay to let WebGPU fully release resources
      if (isToolContinuation) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }

      // Always reset KV cache BEFORE each generation to ensure clean state
      try {
        await this.resetChat();
        // Longer delay after reset for GPU to fully process
        await new Promise(resolve => setTimeout(resolve, 300));
      } catch (e) {
        // Ignore reset errors
      }

      // Wrap stream creation in try-catch to capture WebGPU errors
      let stream: any;
      try {
        stream = await this.engine.chat.completions.create({
          messages: messages as WebLLMTypes.ChatCompletionMessageParam[],
          temperature: options?.temperature ?? 0.5,
          max_tokens: options?.maxTokens ?? 2048,
          top_p: options?.topP ?? 0.95,
          stop: options?.stopSequences,
          stream: true,
          stream_options: { include_usage: true },
        });
      } catch (streamError) {
        console.error('[NEXUS_DEBUG] Stream creation FAILED:', streamError);
        throw streamError;
      }

      let fullContent = '';
      let usage = { promptTokens: 0, completionTokens: 0, totalTokens: 0 };
      let finishReason = 'stop';
      let chunkCount = 0;

      try {
        for await (const chunk of stream) {
        chunkCount++;

        // Check for abort
        if (this.abortController?.signal.aborted) {
          finishReason = 'abort';
          break;
        }

        const delta = chunk.choices[0]?.delta;
        const content = delta?.content || '';

        if (content) {
          fullContent += content;
          yield {
            content,
            tokenCount: fullContent.length, // Approximate
          } as StreamChunk;
        }

        // Capture finish reason
        if (chunk.choices[0]?.finish_reason) {
          finishReason = chunk.choices[0].finish_reason;
        }

        // Capture usage from final chunk
        if (chunk.usage) {
          usage = {
            promptTokens: chunk.usage.prompt_tokens || 0,
            completionTokens: chunk.usage.completion_tokens || 0,
            totalTokens: chunk.usage.total_tokens || 0,
          };
        }
        }
      } catch (streamIterError) {
        // CRITICAL: Capture the actual WebGPU/WebLLM error
        console.error('[NEXUS_DEBUG] âš ï¸ STREAM ITERATION CRASHED:', streamIterError);
        console.error('[NEXUS_DEBUG] Error type:', streamIterError?.constructor?.name);
        console.error('[NEXUS_DEBUG] Error message:', streamIterError instanceof Error ? streamIterError.message : String(streamIterError));
        console.error('[NEXUS_DEBUG] Error stack:', streamIterError instanceof Error ? streamIterError.stack : 'N/A');

        // Check if it's a GPU device lost error
        if (streamIterError instanceof Error && streamIterError.message?.includes('Device')) {
          console.error('[NEXUS_DEBUG] GPU Device Lost - this is a WebGPU issue');
        }

        // Re-throw to propagate error
        throw streamIterError;
      }

      // Yield final result
      yield {
        content: fullContent,
        usage,
        finishReason,
      } as GenerationResult;
    } finally {
      this.isGenerating = false;
      this.abortController = null;

      // NOTE: We do NOT reset KV cache after generation anymore
      // The resetChat() was causing empty responses on tool continuations
      // because WebLLM seems to need the KV cache state to persist
      // We only reset at the START of first generation (hasGeneratedOnce check)

      // Release the generation lock so next generation can proceed
      this.releaseGenerationLock();
    }
  }

  /**
   * Abort current generation
   */
  abort(): void {
    if (this.abortController) {
      this.abortController.abort();
    }
    if (this.engine && this.isGenerating) {
      this.engine.interruptGenerate();
      this.isGenerating = false;
    }
  }

  /**
   * Unload the model from GPU memory
   */
  async unloadModel(): Promise<void> {
    if (this.engine) {
      await this.engine.unload();
      this.engine = null;
      this.currentModelId = null;
    }
  }

  /**
   * Check if a model is loaded
   */
  isModelLoaded(): boolean {
    return this.engine !== null && this.currentModelId !== null;
  }

  /**
   * Get the currently loaded model ID
   */
  getCurrentModelId(): string | null {
    return this.currentModelId;
  }

  /**
   * Check if generation is in progress
   */
  isGenerationInProgress(): boolean {
    return this.isGenerating;
  }

  /**
   * Dispose the engine completely
   */
  async dispose(): Promise<void> {
    await this.unloadModel();
  }
}

```

## services/llm/adapters/webllm/WebLLMLifecycleManager.ts

```typescript
/**
 * WebLLMLifecycleManager
 *
 * Manages the lifecycle of WebLLM/Nexus model loading and unloading.
 * Implements smart loading/unloading based on:
 * - Provider selection (load when switching to webllm, unload when switching away)
 * - Idle timeout (unload after 10 minutes of inactivity)
 * - ChatView state (pre-load if Nexus is default when ChatView opens)
 *
 * This service reduces GPU memory usage by automatically unloading the model
 * when not in use, while ensuring responsive loading when needed.
 */

import { WebLLMAdapter } from './WebLLMAdapter';
import { WEBLLM_MODELS } from './WebLLMModels';
import { Notice } from 'obsidian';
import { getAllPluginIds } from '../../../../constants/branding';

export interface WebLLMLifecycleCallbacks {
  onLoadingStart?: () => void;
  onLoadingProgress?: (progress: number, stage: string) => void;
  onLoadingComplete?: () => void;
  onUnload?: () => void;
  onError?: (error: Error) => void;
}

/**
 * Helper function to safely get instanceId from adapter
 * Uses 'in' operator type guard and Record<string, unknown> for type safety
 * instead of 'as any' cast
 */
function getAdapterInstanceId(adapter: WebLLMAdapter | null): number | undefined {
  if (adapter && 'instanceId' in adapter) {
    const value = (adapter as unknown as Record<string, unknown>).instanceId;
    return typeof value === 'number' ? value : undefined;
  }
  return undefined;
}

/**
 * Helper function to safely get plugin registry from window
 * Uses Record<string, unknown> for type-safe nested property access
 * instead of 'as any' cast
 */
function getPluginRegistry(): Record<string, unknown> | undefined {
  const globalWindow = window as unknown as Record<string, unknown>;
  if (!globalWindow.app || typeof globalWindow.app !== 'object') {
    return undefined;
  }

  const app = globalWindow.app as Record<string, unknown>;
  if (!app.plugins || typeof app.plugins !== 'object') {
    return undefined;
  }

  const plugins = app.plugins as Record<string, unknown>;
  if (!plugins.plugins || typeof plugins.plugins !== 'object') {
    return undefined;
  }

  return plugins.plugins as Record<string, unknown>;
}

export class WebLLMLifecycleManager {
  private static readonly IDLE_TIMEOUT_MS = 10 * 60 * 1000; // 10 minutes

  private adapter: WebLLMAdapter | null = null;
  private idleTimer: ReturnType<typeof setTimeout> | null = null;
  private lastActivityTime: number = 0;
  private callbacks: WebLLMLifecycleCallbacks = {};
  private isLoading: boolean = false;
  private isChatViewOpen: boolean = false;

  /**
   * Set the WebLLM adapter reference
   * Called when AdapterRegistry initializes
   */
  setAdapter(adapter: WebLLMAdapter | null): void {
    this.adapter = adapter;
  }

  /**
   * Set callbacks for lifecycle events
   */
  setCallbacks(callbacks: WebLLMLifecycleCallbacks): void {
    this.callbacks = callbacks;
  }

  /**
   * Check if Nexus is the default provider
   */
  private isNexusDefaultProvider(): boolean {
    try {
      const registry = getPluginRegistry();
      if (!registry) {
        return false;
      }

      for (const id of getAllPluginIds()) {
        const plugin = registry[id];
        if (!plugin || typeof plugin !== 'object') {
          continue;
        }

        // Navigate through nested structure safely
        const pluginObj = plugin as Record<string, unknown>;
        const settings = pluginObj.settings;
        if (!settings || typeof settings !== 'object') {
          continue;
        }

        const settingsObj = settings as Record<string, unknown>;
        const settingsData = settingsObj.settings;
        if (!settingsData || typeof settingsData !== 'object') {
          continue;
        }

        const settingsDataObj = settingsData as Record<string, unknown>;
        const llmProviders = settingsDataObj.llmProviders;
        if (!llmProviders || typeof llmProviders !== 'object') {
          continue;
        }

        const llmProvidersObj = llmProviders as Record<string, unknown>;
        const defaultModel = llmProvidersObj.defaultModel;
        if (!defaultModel || typeof defaultModel !== 'object') {
          continue;
        }

        const defaultModelObj = defaultModel as Record<string, unknown>;
        const provider = defaultModelObj.provider;

        if (provider === 'webllm') {
          return true;
        }
      }

      return false;
    } catch (error) {
      return false;
    }
  }

  /**
   * Check if the model is installed
   */
  private async isModelInstalled(): Promise<boolean> {
    if (!this.adapter) return false;

    try {
      const modelSpec = WEBLLM_MODELS[0];
      if (!modelSpec) return false;

      const modelManager = this.adapter.getModelManager();
      return await modelManager.isModelInstalled(modelSpec.id);
    } catch {
      return false;
    }
  }

  /**
   * Handle ChatView opened event
   * Pre-loads the model if Nexus is the current provider to avoid delay on first message.
   *
   * @param currentProvider The currently selected provider (e.g., 'webllm', 'openai')
   */
  async handleChatViewOpened(currentProvider?: string): Promise<void> {
    this.isChatViewOpen = true;

    console.log('[WebLLMLifecycleManager] handleChatViewOpened called with provider:', currentProvider);
    console.log('[WebLLMLifecycleManager] adapter exists:', !!this.adapter);

    // Pre-load model if Nexus is the current provider
    // This gives a better UX - model is ready when user sends first message
    if (currentProvider === 'webllm' && this.adapter) {
      const isInstalled = await this.isModelInstalled();
      const isLoaded = this.adapter.isModelLoaded();

      console.log('[WebLLMLifecycleManager] isInstalled:', isInstalled, 'isLoaded:', isLoaded, 'isLoading:', this.isLoading);

      if (isInstalled && !isLoaded && !this.isLoading) {
        console.log('[WebLLMLifecycleManager] Starting pre-load...');
        // Pre-load in background - callbacks will show loading overlay
        this.loadModel().catch((error) => {
          console.error('[WebLLMLifecycleManager] Pre-load failed:', error);
        });
      } else {
        console.log('[WebLLMLifecycleManager] Skipping pre-load - conditions not met');
      }
    } else {
      console.log('[WebLLMLifecycleManager] Not loading - provider is not webllm or no adapter');
    }
  }

  /**
   * Handle ChatView closed event
   * Start idle timer (don't immediately unload)
   */
  handleChatViewClosed(): void {
    this.isChatViewOpen = false;
    // Don't immediately unload - let idle timer handle it
    this.startIdleTimer();
  }

  /**
   * Handle provider change event
   * Load model when switching TO webllm, unload when switching AWAY
   */
  async handleProviderChanged(fromProvider: string, toProvider: string): Promise<void> {
    if (!this.adapter) return;

    if (toProvider === 'webllm') {
      // Switching TO Nexus
      const isInstalled = await this.isModelInstalled();
      const isLoaded = this.adapter.isModelLoaded();

      if (isInstalled && !isLoaded && !this.isLoading) {
        await this.loadModel();
      }

      // Clear idle timer when actively using Nexus
      this.clearIdleTimer();

    } else if (fromProvider === 'webllm') {
      // Switching AWAY from Nexus
      if (this.adapter.isModelLoaded()) {
        await this.unloadModel();
      }
    }
  }

  /**
   * Record activity (generation start/complete)
   * Resets the idle timer
   */
  recordActivity(): void {
    this.lastActivityTime = Date.now();
    this.clearIdleTimer();
    this.startIdleTimer();
  }

  /**
   * Load the model into GPU memory
   * Note: WebLLM uses browser Cache API for model storage, NOT vault storage.
   * We don't check isModelInstalled() because that checks the wrong storage system.
   * WebLLM will automatically use cached model if available, or download if not.
   */
  async loadModel(): Promise<void> {
    if (!this.adapter || this.isLoading) return;

    const modelSpec = WEBLLM_MODELS[0];
    if (!modelSpec) {
      return;
    }

    this.isLoading = true;
    this.callbacks.onLoadingStart?.();

    try {
      await this.adapter.loadModel(modelSpec, (progress, stage) => {
        this.callbacks.onLoadingProgress?.(progress, stage);
      });

      this.isLoading = false;
      this.lastActivityTime = Date.now();
      this.callbacks.onLoadingComplete?.();

      new Notice('Nexus model loaded', 3000);
    } catch (error) {
      this.isLoading = false;
      const err = error instanceof Error ? error : new Error(String(error));
      this.callbacks.onError?.(err);
      console.error('[NexusLifecycle] Failed to load model:', error);
    }
  }

  /**
   * Unload the model from GPU memory
   */
  async unloadModel(): Promise<void> {
    if (!this.adapter) return;

    if (!this.adapter.isModelLoaded()) {
      return; // Already unloaded
    }

    try {
      await this.adapter.unloadModel();
      this.clearIdleTimer();
      this.callbacks.onUnload?.();

      new Notice('Nexus model unloaded to free GPU memory', 3000);
    } catch (error) {
      console.error('[NexusLifecycle] Failed to unload model:', error);
    }
  }

  /**
   * Start the idle timer
   * Unloads model after IDLE_TIMEOUT_MS of inactivity
   */
  private startIdleTimer(): void {
    if (this.idleTimer) return;

    this.idleTimer = setTimeout(async () => {
      this.idleTimer = null;

      if (!this.adapter?.isModelLoaded()) return;

      const idleTime = Date.now() - this.lastActivityTime;
      if (idleTime >= WebLLMLifecycleManager.IDLE_TIMEOUT_MS) {
        await this.unloadModel();
      }
    }, WebLLMLifecycleManager.IDLE_TIMEOUT_MS);
  }

  /**
   * Clear the idle timer
   */
  private clearIdleTimer(): void {
    if (this.idleTimer) {
      clearTimeout(this.idleTimer);
      this.idleTimer = null;
    }
  }

  /**
   * Check if the model is currently loaded
   */
  isModelLoaded(): boolean {
    return this.adapter?.isModelLoaded() ?? false;
  }

  /**
   * Check if the model is currently loading
   */
  isModelLoading(): boolean {
    return this.isLoading;
  }

  /**
   * Get the current adapter state
   */
  getState() {
    return this.adapter?.getState();
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    this.clearIdleTimer();
    this.adapter = null;
    this.callbacks = {};
  }
}

// Singleton instance for global access
let lifecycleManagerInstance: WebLLMLifecycleManager | null = null;

/**
 * Get the global WebLLMLifecycleManager instance
 */
export function getWebLLMLifecycleManager(): WebLLMLifecycleManager {
  if (!lifecycleManagerInstance) {
    lifecycleManagerInstance = new WebLLMLifecycleManager();
  }
  return lifecycleManagerInstance;
}

/**
 * Dispose the global instance
 */
export function disposeWebLLMLifecycleManager(): void {
  if (lifecycleManagerInstance) {
    lifecycleManagerInstance.dispose();
    lifecycleManagerInstance = null;
  }
}

```

## services/llm/adapters/webllm/WebLLMModelManager.ts

```typescript
/**
 * WebLLMModelManager
 *
 * Single Responsibility: Handle model download, storage, and deletion.
 * Manages model files in the vault's .obsidian/models/ directory.
 */

import { Vault, requestUrl, FileSystemAdapter } from 'obsidian';
import {
  InstalledModel,
  DownloadProgress,
  ModelManifest,
  ModelFile,
  WebLLMError,
  WebLLMModelSpec,
} from './types';
import { HF_BASE_URL, getWebLLMModel } from './WebLLMModels';

/** Default model storage path within vault */
const MODEL_STORAGE_PATH = '.obsidian/models';

/** Manifest file name for tracking installed models */
const INSTALLED_MANIFEST = 'installed-models.json';

export class WebLLMModelManager {
  private vault: Vault;
  private storagePath: string;

  constructor(vault: Vault, customStoragePath?: string) {
    this.vault = vault;
    this.storagePath = customStoragePath || MODEL_STORAGE_PATH;
  }

  // ============================================================================
  // Model Installation Status
  // ============================================================================

  /**
   * Check if a model is installed
   */
  async isModelInstalled(modelId: string): Promise<boolean> {
    const installed = await this.getInstalledModels();
    return installed.some(m => m.id === modelId);
  }

  /**
   * Get list of installed models
   */
  async getInstalledModels(): Promise<InstalledModel[]> {
    try {
      const manifestPath = `${this.storagePath}/${INSTALLED_MANIFEST}`;
      const exists = await this.vault.adapter.exists(manifestPath);

      if (!exists) {
        return [];
      }

      const content = await this.vault.adapter.read(manifestPath);
      return JSON.parse(content);
    } catch (error) {
      return [];
    }
  }

  /**
   * Get the storage path for a specific model
   */
  getModelPath(modelId: string): string {
    return `${this.storagePath}/${modelId}`;
  }

  // ============================================================================
  // Model Download
  // ============================================================================

  /**
   * Download a model from HuggingFace Hub
   */
  async downloadModel(
    modelSpec: WebLLMModelSpec,
    onProgress?: (progress: DownloadProgress) => void
  ): Promise<void> {
    const modelPath = this.getModelPath(modelSpec.id);

    // Ensure storage directories exist
    await this.ensureDirectoryExists(this.storagePath);
    await this.ensureDirectoryExists(modelPath);

    try {
      // Fetch model manifest from HuggingFace
      const manifest = await this.fetchModelManifest(modelSpec);

      // Download each file
      let downloadedBytes = 0;
      const totalBytes = manifest.totalSize;

      for (let i = 0; i < manifest.files.length; i++) {
        const file = manifest.files[i];

        // Report progress
        if (onProgress) {
          onProgress({
            totalBytes,
            downloadedBytes,
            percentage: totalBytes > 0 ? (downloadedBytes / totalBytes) * 100 : 0,
            currentFile: file.name,
            filesComplete: i,
            filesTotal: manifest.files.length,
          });
        }

        // Download file
        const filePath = `${modelPath}/${file.name}`;
        await this.downloadFile(file.url, filePath, (bytes) => {
          if (onProgress) {
            onProgress({
              totalBytes,
              downloadedBytes: downloadedBytes + bytes,
              percentage: totalBytes > 0 ? ((downloadedBytes + bytes) / totalBytes) * 100 : 0,
              currentFile: file.name,
              filesComplete: i,
              filesTotal: manifest.files.length,
            });
          }
        });

        downloadedBytes += file.size;
      }

      // Save model config
      await this.saveModelConfig(modelPath, manifest);

      // Update installed models manifest
      await this.addInstalledModel({
        id: modelSpec.id,
        name: modelSpec.name,
        quantization: modelSpec.quantization,
        sizeBytes: totalBytes,
        installedAt: new Date().toISOString(),
        path: modelPath,
      });
    } catch (error) {
      // Clean up partial download on failure
      await this.deleteModelFiles(modelPath);

      throw new WebLLMError(
        `Failed to download model: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'DOWNLOAD_FAILED',
        error
      );
    }
  }

  /**
   * Get the base URL path for model files
   * Handles both flat structure (files at root) and nested structure (files in quantization subdirectory)
   */
  private getModelBasePath(modelSpec: WebLLMModelSpec): string {
    if (modelSpec.flatStructure) {
      return `${HF_BASE_URL}/${modelSpec.huggingFaceRepo}/resolve/main`;
    }
    return `${HF_BASE_URL}/${modelSpec.huggingFaceRepo}/resolve/main/${modelSpec.quantization}`;
  }

  /**
   * Fetch model manifest from HuggingFace
   * The manifest contains the list of files to download
   */
  private async fetchModelManifest(modelSpec: WebLLMModelSpec): Promise<ModelManifest> {
    const basePath = this.getModelBasePath(modelSpec);
    const configUrl = `${basePath}/mlc-chat-config.json`;

    try {
      const response = await requestUrl({
        url: configUrl,
        method: 'GET',
      });

      if (response.status !== 200) {
        throw new Error(`Failed to fetch manifest: ${response.status}`);
      }

      const config = response.json;

      // Parse file list from config
      // MLC models typically have: mlc-chat-config.json, tokenizer files, and weight shards
      const files: ModelFile[] = [];
      let totalSize = 0;

      // Add config file
      files.push({
        name: 'mlc-chat-config.json',
        url: configUrl,
        size: JSON.stringify(config).length,
      });

      // Add tokenizer files
      const tokenizerFiles = ['tokenizer.json', 'tokenizer_config.json', 'tokenizer.model'];
      for (const tokenFile of tokenizerFiles) {
        const url = `${basePath}/${tokenFile}`;
        try {
          // Check if file exists (HEAD request)
          const headResp = await requestUrl({ url, method: 'HEAD' });
          if (headResp.status === 200) {
            const size = parseInt(headResp.headers['content-length'] || '0', 10);
            files.push({ name: tokenFile, url, size });
            totalSize += size;
          }
        } catch {
          // File doesn't exist, skip
        }
      }

      // Check for tensor-cache.json (MLC LLM standard format)
      // This file lists all weight shards with their sizes
      const tensorCacheUrl = `${basePath}/tensor-cache.json`;
      try {
        const tensorResp = await requestUrl({ url: tensorCacheUrl, method: 'GET' });
        if (tensorResp.status === 200) {
          const tensorConfig = tensorResp.json;
          files.push({
            name: 'tensor-cache.json',
            url: tensorCacheUrl,
            size: JSON.stringify(tensorConfig).length,
          });

          // Add all weight shards listed in tensor-cache.json
          if (tensorConfig.records && Array.isArray(tensorConfig.records)) {
            for (const record of tensorConfig.records) {
              if (record.dataPath) {
                const dataUrl = `${basePath}/${record.dataPath}`;
                // Use size from metadata if available
                const size = record.nbytes || 0;
                files.push({ name: record.dataPath, url: dataUrl, size });
                totalSize += size;
              }
            }
          }
        }
      } catch {
        // No tensor cache, fall back to probing for shards
        // Probe for weight shards until we get a 404
        for (let i = 0; i < 200; i++) { // Max 200 shards
          const shardName = `params_shard_${i}.bin`;
          const url = `${basePath}/${shardName}`;

          try {
            const headResp = await requestUrl({ url, method: 'HEAD' });
            if (headResp.status === 200) {
              const size = parseInt(headResp.headers['content-length'] || '0', 10);
              files.push({ name: shardName, url, size });
              totalSize += size;
            } else {
              break;
            }
          } catch {
            // Shard doesn't exist, stop looking
            break;
          }
        }
      }

      return {
        modelId: modelSpec.id,
        quantization: modelSpec.quantization,
        files,
        configUrl,
        totalSize,
      };
    } catch (error) {
      throw new WebLLMError(
        `Failed to fetch model manifest: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'DOWNLOAD_FAILED',
        error
      );
    }
  }

  /**
   * Download a single file
   */
  private async downloadFile(
    url: string,
    localPath: string,
    onProgress?: (downloadedBytes: number) => void
  ): Promise<void> {
    try {
      // Check if file already exists (for resume support)
      const exists = await this.vault.adapter.exists(localPath);
      if (exists) {
        return;
      }

      // Download using Obsidian's requestUrl (handles CORS)
      const response = await requestUrl({
        url,
        method: 'GET',
      });

      if (response.status !== 200) {
        throw new Error(`Download failed: ${response.status}`);
      }

      // Write to vault
      await this.vault.adapter.writeBinary(localPath, response.arrayBuffer);

      if (onProgress) {
        onProgress(response.arrayBuffer.byteLength);
      }
    } catch (error) {
      throw new WebLLMError(
        `Failed to download file ${url}: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'DOWNLOAD_FAILED',
        error
      );
    }
  }

  /**
   * Save model configuration
   */
  private async saveModelConfig(modelPath: string, manifest: ModelManifest): Promise<void> {
    const configPath = `${modelPath}/manifest.json`;
    await this.vault.adapter.write(configPath, JSON.stringify(manifest, null, 2));
  }

  // ============================================================================
  // Model Deletion
  // ============================================================================

  /**
   * Delete a model from storage
   */
  async deleteModel(modelId: string): Promise<void> {
    const modelPath = this.getModelPath(modelId);

    // Delete model files
    await this.deleteModelFiles(modelPath);

    // Update installed models manifest
    await this.removeInstalledModel(modelId);
  }

  /**
   * Delete model files recursively
   */
  private async deleteModelFiles(path: string): Promise<void> {
    try {
      const exists = await this.vault.adapter.exists(path);
      if (!exists) return;

      const stat = await this.vault.adapter.stat(path);

      if (stat?.type === 'folder') {
        const files = await this.vault.adapter.list(path);

        // Delete all files
        for (const file of files.files) {
          await this.vault.adapter.remove(file);
        }

        // Delete subfolders recursively
        for (const folder of files.folders) {
          await this.deleteModelFiles(folder);
        }

        // Delete the folder itself
        await this.vault.adapter.rmdir(path, true);
      } else {
        await this.vault.adapter.remove(path);
      }
    } catch (error) {
      // Ignore deletion errors
    }
  }

  // ============================================================================
  // Installed Models Manifest
  // ============================================================================

  /**
   * Add a model to the installed manifest
   */
  private async addInstalledModel(model: InstalledModel): Promise<void> {
    const installed = await this.getInstalledModels();

    // Remove existing entry if present
    const filtered = installed.filter(m => m.id !== model.id);
    filtered.push(model);

    await this.saveInstalledManifest(filtered);
  }

  /**
   * Remove a model from the installed manifest
   */
  private async removeInstalledModel(modelId: string): Promise<void> {
    const installed = await this.getInstalledModels();
    const filtered = installed.filter(m => m.id !== modelId);
    await this.saveInstalledManifest(filtered);
  }

  /**
   * Save the installed models manifest
   */
  private async saveInstalledManifest(models: InstalledModel[]): Promise<void> {
    await this.ensureDirectoryExists(this.storagePath);
    const manifestPath = `${this.storagePath}/${INSTALLED_MANIFEST}`;
    await this.vault.adapter.write(manifestPath, JSON.stringify(models, null, 2));
  }

  // ============================================================================
  // File Reading (for serving to worker)
  // ============================================================================

  /**
   * Read a model file as ArrayBuffer
   * Used to serve model weights to the worker
   */
  async readModelFile(modelId: string, fileName: string): Promise<ArrayBuffer> {
    const filePath = `${this.getModelPath(modelId)}/${fileName}`;

    const exists = await this.vault.adapter.exists(filePath);
    if (!exists) {
      throw new WebLLMError(
        `Model file not found: ${fileName}`,
        'MODEL_NOT_FOUND'
      );
    }

    return await this.vault.adapter.readBinary(filePath);
  }

  /**
   * Get model file URL for local serving
   * Returns a file:// URL or blob URL for local access
   */
  async getLocalModelUrl(modelId: string): Promise<string> {
    const modelPath = this.getModelPath(modelId);

    const adapter: any = this.vault.adapter;
    if (typeof adapter.getResourcePath === 'function') {
      return adapter.getResourcePath(modelPath);
    }

    if (adapter instanceof FileSystemAdapter) {
      return `file://${adapter.getBasePath()}/${modelPath}`;
    }

    // Fallback: relative path
    return modelPath;
  }

  // ============================================================================
  // Utility Methods
  // ============================================================================

  /**
   * Ensure a directory exists, creating it if necessary
   */
  private async ensureDirectoryExists(path: string): Promise<void> {
    try {
      const exists = await this.vault.adapter.exists(path);
      if (!exists) {
        await this.vault.adapter.mkdir(path);
      }
    } catch (error) {
      // Directory might already exist, ignore error
    }
  }

  /**
   * Get total size of installed models
   */
  async getTotalInstalledSize(): Promise<number> {
    const installed = await this.getInstalledModels();
    return installed.reduce((total, model) => total + model.sizeBytes, 0);
  }

  /**
   * Format bytes for display
   */
  static formatBytes(bytes: number): string {
    if (bytes === 0) return '0 B';

    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    const k = 1024;
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return `${(bytes / Math.pow(k, i)).toFixed(2)} ${units[i]}`;
  }
}

```

## services/llm/adapters/webllm/WebLLMModels.ts

```typescript
/**
 * WebLLM Model Specifications
 * ============================================================================
 *
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘  HOW TO ADD A NEW MODEL                                                    â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘  1. Convert model to WebLLM format (see local-models/ and                 â•‘
 * â•‘     extract_text_model.py for the pipeline)                               â•‘
 * â•‘  2. Upload to HuggingFace: professorsynapse/[model-name]-webllm           â•‘
 * â•‘  3. Add MODEL_LIBS entry if using a new base model architecture           â•‘
 * â•‘  4. Add entry to WEBLLM_MODELS array below                                â•‘
 * â•‘  5. Run `npm run build` to verify                                         â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * Naming Convention (see Nexus Versioning Spec.md):
 * - Nexus-[SizeClass]-[ProviderCode][BaseVer].[BuildID]
 * - Size Classes: Quark (1-4B), Electron (7-9B), Proton (12-19B), Atom (20-32B+)
 * - Provider Codes: L=Llama, Q=Qwen, M=Mistral, G=Gemma, P=Phi
 *
 * Example model IDs:
 * - nexus-quark-p2.0.1    â†’ Phi-2 based 3B model, build 0.1
 * - nexus-electron-q3.0.1 â†’ Qwen3 based 8B model, build 0.1
 * - nexus-proton-l3.0.1   â†’ Llama3 based 14B model, build 0.1
 */

import { WebLLMModelSpec } from './types';

/**
 * Base URL for HuggingFace model downloads
 */
export const HF_BASE_URL = 'https://huggingface.co';

/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘  MODEL LIBRARIES (WASM files)                                              â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘  WASM libraries are pre-built by MLC-AI and hosted on GitHub.             â•‘
 * â•‘  Add new entries here when using a different base model architecture.     â•‘
 * â•‘                                                                            â•‘
 * â•‘  Find available libraries at:                                             â•‘
 * â•‘  https://github.com/mlc-ai/binary-mlc-llm-libs/tree/main/web-llm-models   â•‘
 * â•‘                                                                            â•‘
 * â•‘  IMPORTANT: Version must match the WebLLM CDN version (currently v0_2_80) â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
export const MODEL_LIBS = {
  // Qwen3-1.7B library with 4K context window - from MLC-AI prebuilt libs
  // Optimized for lower VRAM usage (~2GB)
  QWEN3_1_7B_4K: 'https://raw.githubusercontent.com/mlc-ai/binary-mlc-llm-libs/main/web-llm-models/v0_2_80/Qwen3-1.7B-q4f16_1-ctx4k_cs1k-webgpu.wasm',
};

/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘  AVAILABLE WEBLLM MODELS                                                   â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘  ADD NEW MODELS TO THIS ARRAY                                              â•‘
 * â•‘                                                                            â•‘
 * â•‘  Each model needs:                                                         â•‘
 * â•‘  - id: Unique lowercase identifier (e.g., 'nexus-electron-q3.0.1')        â•‘
 * â•‘  - name: Display name for UI (e.g., 'Nexus Electron')                     â•‘
 * â•‘  - apiName: Model ID used by WebLLM (usually same as id)                  â•‘
 * â•‘  - contextWindow: Max context length in tokens                            â•‘
 * â•‘  - maxTokens: Max output tokens                                           â•‘
 * â•‘  - vramRequired: Approximate VRAM in GB                                   â•‘
 * â•‘  - quantization: Quantization type (e.g., 'q4f16', 'q4f32')              â•‘
 * â•‘  - huggingFaceRepo: Full repo path (professorsynapse/[name]-webllm)       â•‘
 * â•‘  - modelLibUrl: WASM library from MODEL_LIBS above                        â•‘
 * â•‘  - capabilities: What the model supports                                   â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
export const WEBLLM_MODELS: WebLLMModelSpec[] = [
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NEXUS QUARK - 1.7B Qwen3-based model fine-tuned for tool calling
  // Uses <tool_call> XML format for function calling (native Qwen3 format)
  // 4K context - optimized for lower VRAM usage (~2GB)
  // Fine-tuned on full toolset - skips getTools, uses useTool directly
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  {
    id: 'nexus-quark-q3.0.5',
    name: 'Nexus Quark',
    provider: 'webllm',
    apiName: 'nexus-quark-q3.0.5',
    contextWindow: 4096,
    maxTokens: 2048,
    vramRequired: 2.0,
    quantization: 'q4f16',
    huggingFaceRepo: 'professorsynapse/nexus-quark-q3.0.5',
    modelLibUrl: MODEL_LIBS.QWEN3_1_7B_4K,
    flatStructure: true,
    capabilities: {
      supportsJSON: true,
      supportsImages: false,
      supportsFunctions: true,
      supportsStreaming: true,
      supportsThinking: false,
    },
  },
];

/**
 * Get model by ID
 */
export function getWebLLMModel(modelId: string): WebLLMModelSpec | undefined {
  return WEBLLM_MODELS.find(m => m.id === modelId || m.apiName === modelId);
}

/**
 * Get models that fit within VRAM limit
 */
export function getModelsForVRAM(availableVRAM: number): WebLLMModelSpec[] {
  // Reserve 1.5GB for OS and other applications
  const effectiveVRAM = availableVRAM - 1.5;

  return WEBLLM_MODELS
    .filter(m => m.vramRequired <= effectiveVRAM)
    .sort((a, b) => b.vramRequired - a.vramRequired); // Prefer higher quality
}

/**
 * Get the best model for available VRAM
 */
export function getBestModelForVRAM(availableVRAM: number): WebLLMModelSpec | undefined {
  const models = getModelsForVRAM(availableVRAM);
  return models[0]; // Returns highest quality that fits
}

/**
 * Get download URL for a model file
 */
export function getModelFileUrl(modelSpec: WebLLMModelSpec, fileName: string): string {
  // URL pattern: https://huggingface.co/{repo}/resolve/main/{quantization}/{file}
  return `${HF_BASE_URL}/${modelSpec.huggingFaceRepo}/resolve/main/${modelSpec.quantization}/${fileName}`;
}

/**
 * Get model manifest URL (contains list of files to download)
 */
export function getModelManifestUrl(modelSpec: WebLLMModelSpec): string {
  return getModelFileUrl(modelSpec, 'mlc-chat-config.json');
}

/**
 * Format VRAM requirement for display
 */
export function formatVRAMRequirement(vramGB: number): string {
  return `~${vramGB.toFixed(1)}GB VRAM`;
}

/**
 * Get model display info for UI
 */
export function getModelDisplayInfo(modelSpec: WebLLMModelSpec): {
  name: string;
  description: string;
  vramRequirement: string;
  recommended: boolean;
} {
  const quantName = modelSpec.quantization.toUpperCase();

  // Q4F16 is currently the only available quantization
  // It provides a good balance of speed and quality for tool-calling tasks
  const qualityNote = 'Optimized for tool-calling, uses pre-built Mistral library';

  return {
    name: modelSpec.name,
    description: `${quantName} quantization. ${qualityNote}`,
    vramRequirement: formatVRAMRequirement(modelSpec.vramRequired),
    recommended: true, // Only model available
  };
}

```

## services/llm/adapters/webllm/WebLLMVRAMDetector.ts

```typescript
/**
 * WebLLMVRAMDetector
 *
 * Single Responsibility: Detect WebGPU availability and estimate VRAM capacity.
 * Used to determine if WebLLM can run and which quantization levels are supported.
 *
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘  PLATFORM SUPPORT                                                          â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘  - macOS (Apple Silicon): Works natively via Metal                        â•‘
 * â•‘  - Windows (NVIDIA/AMD): Requires updated GPU drivers + Vulkan support    â•‘
 * â•‘  - Linux: Requires Vulkan support                                         â•‘
 * â•‘                                                                            â•‘
 * â•‘  TROUBLESHOOTING WINDOWS + NVIDIA:                                         â•‘
 * â•‘  1. Update NVIDIA drivers to latest version (needs Vulkan support)        â•‘
 * â•‘  2. Ensure Obsidian is up-to-date (needs recent Electron with WebGPU)     â•‘
 * â•‘  3. Check chrome://gpu in Obsidian DevTools for WebGPU status             â•‘
 * â•‘  4. Try enabling chrome://flags/#enable-unsafe-webgpu if available        â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

import { VRAMInfo } from './types';

// ============================================================================
// WebGPU Type Definitions
// ============================================================================

/**
 * WebGPU adapter info interface
 * Provides GPU hardware information
 */
interface GPUAdapterInfo {
  vendor?: string;
  architecture?: string;
  device?: string;
  description?: string;
}

/**
 * WebGPU adapter interface
 * Represents a physical GPU available to the system
 */
interface GPUAdapter {
  readonly info?: GPUAdapterInfo;
  readonly limits: GPUSupportedLimits;
  requestAdapterInfo?(): Promise<GPUAdapterInfo>;
  requestDevice(): Promise<GPUDevice>;
}

/**
 * WebGPU supported limits interface
 */
interface GPUSupportedLimits {
  readonly maxBufferSize: number;
  // Additional limits exist but maxBufferSize is what we need for VRAM estimation
}

/**
 * WebGPU device interface
 */
interface GPUDevice {
  readonly limits: GPUSupportedLimits;
  destroy(): void;
}

/**
 * WebGPU API interface
 */
interface GPU {
  requestAdapter(options?: { powerPreference?: 'low-power' | 'high-performance' }): Promise<GPUAdapter | null>;
}

/**
 * Extended Navigator interface with WebGPU support
 */
interface NavigatorGPU extends Navigator {
  readonly gpu: GPU;
}

/**
 * Type guard to check if navigator has WebGPU support
 */
function hasGPU(navigator: Navigator): navigator is NavigatorGPU {
  return 'gpu' in navigator;
}

export class WebLLMVRAMDetector {
  private static cachedInfo: VRAMInfo | null = null;

  /**
   * Check if WebGPU is available in the current environment
   */
  static async isWebGPUAvailable(): Promise<boolean> {
    if (typeof navigator === 'undefined') {
      return false;
    }

    if (!hasGPU(navigator)) {
      return false;
    }

    try {
      const gpu = navigator.gpu;

      // Try different adapter options for better compatibility
      // Windows/NVIDIA may need explicit high-performance preference
      let adapter = await gpu.requestAdapter({ powerPreference: 'high-performance' });

      if (!adapter) {
        // Fallback: try without power preference
        adapter = await gpu.requestAdapter();
      }

      return !!adapter;
    } catch (error) {
      return false;
    }
  }

  /**
   * Detect VRAM and GPU capabilities
   * Results are cached after first detection
   */
  static async detect(): Promise<VRAMInfo> {
    // Return cached result if available
    if (this.cachedInfo) {
      return this.cachedInfo;
    }

    const info: VRAMInfo = {
      available: false,
      estimatedVRAM: 0,
      recommendedQuantizations: [],
      webGPUSupported: false,
    };

    // Check WebGPU support
    if (typeof navigator === 'undefined' || !hasGPU(navigator)) {
      this.cachedInfo = info;
      return info;
    }

    try {
      const gpu = navigator.gpu;

      // Request high-performance adapter first (important for Windows/NVIDIA)
      let adapter = await gpu.requestAdapter({ powerPreference: 'high-performance' });

      if (!adapter) {
        // Fallback to default adapter
        adapter = await gpu.requestAdapter();
      }

      if (!adapter) {
        this.cachedInfo = info;
        return info;
      }

      info.webGPUSupported = true;
      info.available = true;

      // Get adapter info for GPU name
      // Note: requestAdapterInfo() was deprecated, use adapter.info property instead
      let gpuDescription = 'Unknown GPU';
      try {
        // New API: adapter.info is a synchronous property
        if (adapter.info) {
          gpuDescription = adapter.info.description || adapter.info.device || adapter.info.vendor || 'Unknown GPU';
        } else if (typeof adapter.requestAdapterInfo === 'function') {
          // Fallback to old API for older implementations
          const adapterInfo = await adapter.requestAdapterInfo();
          gpuDescription = adapterInfo.description || adapterInfo.device || 'Unknown GPU';
        }
      } catch (infoError) {
        // Ignore error getting adapter info
      }
      info.gpuName = gpuDescription;

      // Request device to get limits
      const device = await adapter.requestDevice();

      // Estimate VRAM from maxBufferSize
      // This is not exact but gives a reasonable approximation
      const maxBufferSize = device.limits.maxBufferSize;
      const estimatedVRAM = maxBufferSize / (1024 * 1024 * 1024); // Convert to GB

      // Apply heuristics based on known GPU patterns
      info.estimatedVRAM = this.refineVRAMEstimate(estimatedVRAM, info.gpuName || 'Unknown GPU');

      // Determine recommended quantizations based on VRAM
      info.recommendedQuantizations = this.getRecommendedQuantizations(info.estimatedVRAM);

      // Clean up
      device.destroy();

      this.cachedInfo = info;
      return info;
    } catch (error) {
      this.cachedInfo = info;
      return info;
    }
  }

  /**
   * Refine VRAM estimate using GPU name heuristics
   */
  private static refineVRAMEstimate(rawEstimate: number, gpuName: string): number {
    const lowerName = gpuName.toLowerCase();

    // Known VRAM amounts for common GPUs
    const knownGPUs: Record<string, number> = {
      // NVIDIA RTX 40 series
      '4090': 24,
      '4080': 16,
      '4070 ti super': 16,
      '4070 ti': 12,
      '4070 super': 12,
      '4070': 12,
      '4060 ti': 8,
      '4060': 8,
      // NVIDIA RTX 30 series
      '3090': 24,
      '3080 ti': 12,
      '3080': 10,
      '3070 ti': 8,
      '3070': 8,
      '3060 ti': 8,
      '3060': 12,
      // Apple Silicon (unified memory - these are typical configurations)
      // Order matters: more specific patterns must come before base patterns
      'm1 ultra': 64,
      'm1 max': 32,
      'm1 pro': 16,
      'm1': 8,
      'm2 ultra': 64,
      'm2 max': 32,
      'm2 pro': 16,
      'm2': 8,
      'm3 max': 36,
      'm3 pro': 18,
      'm3': 8,
      'm4 max': 48,
      'm4 pro': 24,
      'm4': 16, // Base M4 typically 16GB or 24GB (user has 24GB)
      // AMD
      '7900 xtx': 24,
      '7900 xt': 20,
      '7800 xt': 16,
      '7700 xt': 12,
      '6900 xt': 16,
      '6800 xt': 16,
    };

    // Check if GPU name matches any known pattern
    for (const [pattern, vram] of Object.entries(knownGPUs)) {
      if (lowerName.includes(pattern)) {
        return vram;
      }
    }

    // Default Apple Silicon detection (unified memory)
    if (lowerName.includes('apple') || lowerName.includes('m1') || lowerName.includes('m2') || lowerName.includes('m3') || lowerName.includes('m4')) {
      // Apple Silicon can use more of unified memory
      // Conservative estimate: 75% of system memory for ML
      return Math.max(rawEstimate, 8); // Assume at least 8GB unified
    }

    // Integrated Intel/AMD graphics
    if (lowerName.includes('intel') || lowerName.includes('integrated')) {
      return Math.min(rawEstimate, 4); // Cap at 4GB for integrated
    }

    // Use raw estimate with a conservative multiplier
    // maxBufferSize often underestimates true VRAM
    return Math.max(rawEstimate * 1.5, 4);
  }

  /**
   * Get recommended quantization levels based on available VRAM
   *
   * Mistral 7B VRAM requirements:
   * - Q4F16: ~5GB
   * - Q5F16: ~5.5GB
   * - Q8F16: ~7GB
   */
  private static getRecommendedQuantizations(vramGB: number): ('q4f16' | 'q5f16' | 'q8f16')[] {
    const recommendations: ('q4f16' | 'q5f16' | 'q8f16')[] = [];

    // Add buffer for OS and other applications (1-2GB)
    const effectiveVRAM = vramGB - 1.5;

    if (effectiveVRAM >= 7) {
      recommendations.push('q8f16');
    }

    if (effectiveVRAM >= 5.5) {
      recommendations.push('q5f16');
    }

    if (effectiveVRAM >= 5) {
      recommendations.push('q4f16');
    }

    return recommendations;
  }

  /**
   * Get human-readable VRAM status message
   */
  static getStatusMessage(info: VRAMInfo): string {
    if (!info.webGPUSupported) {
      return 'WebGPU is not supported in your browser. WebLLM requires WebGPU for GPU-accelerated inference.';
    }

    if (info.recommendedQuantizations.length === 0) {
      return `Insufficient VRAM detected (~${info.estimatedVRAM.toFixed(1)}GB). Minimum 5GB required for Q4 quantization.`;
    }

    const quantList = info.recommendedQuantizations.join(', ').toUpperCase();
    return `${info.gpuName || 'GPU'} detected with ~${info.estimatedVRAM.toFixed(1)}GB VRAM. Supported: ${quantList}`;
  }

  /**
   * Clear cached detection results
   * Useful if GPU configuration might have changed
   */
  static clearCache(): void {
    this.cachedInfo = null;
  }
}

```

## services/llm/adapters/webllm/WebLLMWorkerService.ts

```typescript
/**
 * WebLLMWorkerService
 *
 * Single Responsibility: Manage Web Worker lifecycle and postMessage communication.
 * Handles worker creation (via Blob URL for Obsidian compatibility), message routing,
 * and response streaming.
 */

import {
  WorkerMessage,
  WorkerResponse,
  ChunkResponse,
  CompleteResponse,
  ErrorResponse,
  InitProgressResponse,
  ReadyResponse,
  WebLLMError,
  WebLLMModelSpec,
} from './types';

/** Promise resolver for pending requests */
interface PendingRequest<T = any> {
  resolve: (value: T) => void;
  reject: (error: Error) => void;
  onProgress?: (progress: number, stage: string) => void;
  onChunk?: (content: string) => void;
}

/** Event emitter for streaming responses */
type StreamCallback = (response: WorkerResponse) => void;

export class WebLLMWorkerService {
  private worker: Worker | null = null;
  private pendingRequests: Map<string, PendingRequest> = new Map();
  private streamCallbacks: Map<string, StreamCallback> = new Map();
  private isInitialized = false;
  private currentModelId: string | null = null;

  // Callback for file requests from worker (for local model loading)
  private fileRequestHandler?: (path: string) => Promise<ArrayBuffer>;

  /**
   * Initialize the Web Worker
   * Uses Blob URL pattern to work within Obsidian's restrictions
   */
  async initialize(fileHandler?: (path: string) => Promise<ArrayBuffer>): Promise<void> {
    if (this.worker) {
      return;
    }

    this.fileRequestHandler = fileHandler;

    try {
      const workerCode = this.buildWorkerCode();
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      const workerUrl = URL.createObjectURL(blob);

      this.worker = new Worker(workerUrl);
      this.setupMessageHandlers();

      // Clean up blob URL after worker starts
      URL.revokeObjectURL(workerUrl);

      this.isInitialized = true;
    } catch (error) {
      console.error('[WebLLMWorkerService] Failed to initialize worker:', error);
      throw new WebLLMError(
        'Failed to initialize WebLLM worker',
        'WORKER_ERROR',
        error
      );
    }
  }

  /**
   * Build the worker code as a string
   * This bypasses Obsidian's worker import restrictions
   */
  private buildWorkerCode(): string {
    // The worker code is inlined as a string
    // WebLLM is loaded via CDN inside the worker
    return `
// WebLLM Worker
// Handles model loading and inference in a separate thread

// Import WebLLM from CDN
importScripts('https://cdn.jsdelivr.net/npm/@mlc-ai/web-llm@0.2.78/lib/index.min.js');

let engine = null;
let isGenerating = false;

// Handle messages from main thread
self.onmessage = async function(event) {
  const message = event.data;

  try {
    switch (message.type) {
      case 'init':
        await handleInit(message);
        break;

      case 'generate':
        await handleGenerate(message);
        break;

      case 'stream':
        await handleStream(message);
        break;

      case 'abort':
        handleAbort(message);
        break;

      case 'unload':
        await handleUnload(message);
        break;

      case 'file_data':
        // Response from main thread for file request
        // Handled by pending promise in custom fetch
        break;
    }
  } catch (error) {
    self.postMessage({
      type: 'error',
      id: message.id,
      payload: {
        code: 'WORKER_ERROR',
        message: error.message || 'Unknown error',
        details: error.stack
      }
    });
  }
};

// Initialize the WebLLM engine with a model
async function handleInit(message) {
  const { modelId, modelUrl } = message.payload;

  // Progress callback
  const progressCallback = (report) => {
    self.postMessage({
      type: 'init_progress',
      id: message.id,
      payload: {
        progress: report.progress || 0,
        stage: report.text?.includes('Loading') ? 'loading' :
               report.text?.includes('Download') ? 'downloading' : 'compiling',
        message: report.text
      }
    });
  };

  try {
    // Create engine with progress tracking
    engine = await webllm.CreateMLCEngine(
      modelId,
      {
        initProgressCallback: progressCallback,
        // Custom model URL if provided
        ...(modelUrl && { modelUrl })
      }
    );

    // Get model info
    const config = engine.config || {};

    self.postMessage({
      type: 'ready',
      id: message.id,
      payload: {
        modelId: modelId,
        contextWindow: config.context_window_size || 32768,
        maxTokens: config.max_gen_len || 4096
      }
    });
  } catch (error) {
    throw new Error('Failed to initialize model: ' + error.message);
  }
}

// Generate response (non-streaming)
async function handleGenerate(message) {
  if (!engine) {
    throw new Error('Engine not initialized');
  }

  if (isGenerating) {
    throw new Error('Generation already in progress');
  }

  isGenerating = true;

  try {
    const { messages, temperature, maxTokens, topP, stopSequences } = message.payload;

    const response = await engine.chat.completions.create({
      messages: messages,
      temperature: temperature ?? 0.5,
      max_tokens: maxTokens ?? 2048,
      top_p: topP ?? 0.95,
      stop: stopSequences,
      stream: false
    });

    const choice = response.choices[0];
    const usage = response.usage || {};

    self.postMessage({
      type: 'complete',
      id: message.id,
      payload: {
        content: choice.message?.content || '',
        usage: {
          promptTokens: usage.prompt_tokens || 0,
          completionTokens: usage.completion_tokens || 0,
          totalTokens: usage.total_tokens || 0
        },
        finishReason: choice.finish_reason || 'stop'
      }
    });
  } finally {
    isGenerating = false;
  }
}

// Generate streaming response
async function handleStream(message) {
  if (!engine) {
    throw new Error('Engine not initialized');
  }

  if (isGenerating) {
    throw new Error('Generation already in progress');
  }

  isGenerating = true;

  try {
    const { messages, temperature, maxTokens, topP, stopSequences } = message.payload;

    const stream = await engine.chat.completions.create({
      messages: messages,
      temperature: temperature ?? 0.5,
      max_tokens: maxTokens ?? 2048,
      top_p: topP ?? 0.95,
      stop: stopSequences,
      stream: true,
      stream_options: { include_usage: true }
    });

    let fullContent = '';
    let usage = { promptTokens: 0, completionTokens: 0, totalTokens: 0 };
    let finishReason = 'stop';

    for await (const chunk of stream) {
      const delta = chunk.choices[0]?.delta;
      const content = delta?.content || '';

      if (content) {
        fullContent += content;

        self.postMessage({
          type: 'chunk',
          id: message.id,
          payload: {
            content: content,
            tokenCount: fullContent.length // Approximate
          }
        });
      }

      // Capture finish reason
      if (chunk.choices[0]?.finish_reason) {
        finishReason = chunk.choices[0].finish_reason;
      }

      // Capture usage from final chunk
      if (chunk.usage) {
        usage = {
          promptTokens: chunk.usage.prompt_tokens || 0,
          completionTokens: chunk.usage.completion_tokens || 0,
          totalTokens: chunk.usage.total_tokens || 0
        };
      }
    }

    self.postMessage({
      type: 'complete',
      id: message.id,
      payload: {
        content: fullContent,
        usage: usage,
        finishReason: finishReason
      }
    });
  } finally {
    isGenerating = false;
  }
}

// Abort current generation
function handleAbort(message) {
  if (engine && isGenerating) {
    engine.interruptGenerate();
    isGenerating = false;

    self.postMessage({
      type: 'complete',
      id: message.id,
      payload: {
        content: '',
        usage: { promptTokens: 0, completionTokens: 0, totalTokens: 0 },
        finishReason: 'abort'
      }
    });
  }
}

// Unload model from GPU memory
async function handleUnload(message) {
  if (engine) {
    await engine.unload();
    engine = null;
  }

  self.postMessage({
    type: 'ready',
    id: message.id,
    payload: {
      modelId: null,
      contextWindow: 0,
      maxTokens: 0
    }
  });
}
`;
  }

  /**
   * Set up message handlers for worker responses
   */
  private setupMessageHandlers(): void {
    if (!this.worker) return;

    this.worker.onmessage = (event: MessageEvent<WorkerResponse>) => {
      const response = event.data;
      const requestId = response.id;

      // Handle streaming callbacks
      const streamCallback = this.streamCallbacks.get(requestId);
      if (streamCallback) {
        streamCallback(response);

        // Clean up on completion or error
        if (response.type === 'complete' || response.type === 'error') {
          this.streamCallbacks.delete(requestId);
        }
        return;
      }

      // Handle pending request promises
      const pending = this.pendingRequests.get(requestId);
      if (!pending) {
        return;
      }

      switch (response.type) {
        case 'init_progress':
          if (pending.onProgress) {
            const progress = response as InitProgressResponse;
            pending.onProgress(progress.payload.progress, progress.payload.stage);
          }
          break;

        case 'ready':
          this.pendingRequests.delete(requestId);
          this.currentModelId = (response as ReadyResponse).payload.modelId;
          pending.resolve(response.payload);
          break;

        case 'complete':
          this.pendingRequests.delete(requestId);
          pending.resolve((response as CompleteResponse).payload);
          break;

        case 'error':
          this.pendingRequests.delete(requestId);
          const error = response as ErrorResponse;
          pending.reject(new WebLLMError(
            error.payload.message,
            error.payload.code,
            error.payload.details
          ));
          break;
      }
    };

    this.worker.onerror = (event: ErrorEvent) => {
      console.error('[WebLLMWorkerService] Worker error:', event);

      // Reject all pending requests
      for (const [id, pending] of this.pendingRequests) {
        pending.reject(new WebLLMError(
          'Worker error: ' + event.message,
          'WORKER_ERROR',
          event
        ));
      }
      this.pendingRequests.clear();
      this.streamCallbacks.clear();
    };
  }

  /**
   * Send a message to the worker and wait for response
   */
  private async sendMessage<T>(message: { type: string; payload?: any }, options?: {
    onProgress?: (progress: number, stage: string) => void;
  }): Promise<T> {
    if (!this.worker) {
      throw new WebLLMError('Worker not initialized', 'WORKER_ERROR');
    }

    const id = crypto.randomUUID();
    const fullMessage = { ...message, id };

    return new Promise<T>((resolve, reject) => {
      this.pendingRequests.set(id, {
        resolve,
        reject,
        onProgress: options?.onProgress,
      });

      this.worker!.postMessage(fullMessage);
    });
  }

  /**
   * Initialize a model
   */
  async initModel(
    modelSpec: WebLLMModelSpec,
    options?: {
      customUrl?: string;
      onProgress?: (progress: number, stage: string) => void;
    }
  ): Promise<{ modelId: string; contextWindow: number; maxTokens: number }> {
    return this.sendMessage({
      type: 'init',
      payload: {
        modelId: modelSpec.apiName,
        modelUrl: options?.customUrl,
        quantization: modelSpec.quantization,
      },
    }, {
      onProgress: options?.onProgress,
    });
  }

  /**
   * Generate a response (non-streaming)
   */
  async generate(
    messages: { role: string; content: string }[],
    options?: {
      temperature?: number;
      maxTokens?: number;
      topP?: number;
      stopSequences?: string[];
    }
  ): Promise<{
    content: string;
    usage: { promptTokens: number; completionTokens: number; totalTokens: number };
    finishReason: string;
  }> {
    return this.sendMessage({
      type: 'generate',
      payload: {
        messages,
        ...options,
      },
    });
  }

  /**
   * Generate a streaming response
   * Returns an async generator that yields chunks
   */
  async *generateStream(
    messages: { role: string; content: string }[],
    options?: {
      temperature?: number;
      maxTokens?: number;
      topP?: number;
      stopSequences?: string[];
    }
  ): AsyncGenerator<WorkerResponse, void, unknown> {
    if (!this.worker) {
      throw new WebLLMError('Worker not initialized', 'WORKER_ERROR');
    }

    const id = crypto.randomUUID();

    // Create a queue for responses
    const responseQueue: WorkerResponse[] = [];
    let resolveNext: ((value: WorkerResponse | null) => void) | null = null;
    let isDone = false;

    // Set up callback to receive responses
    this.streamCallbacks.set(id, (response) => {
      if (response.type === 'complete' || response.type === 'error') {
        isDone = true;
      }

      if (resolveNext) {
        resolveNext(response);
        resolveNext = null;
      } else {
        responseQueue.push(response);
      }
    });

    // Send the stream request
    this.worker.postMessage({
      type: 'stream',
      id,
      payload: {
        messages,
        ...options,
      },
    });

    // Yield responses as they arrive
    try {
      while (!isDone) {
        let response: WorkerResponse | null;

        if (responseQueue.length > 0) {
          response = responseQueue.shift()!;
        } else {
          // Wait for next response
          response = await new Promise<WorkerResponse | null>((resolve) => {
            resolveNext = resolve;
          });
        }

        if (response) {
          yield response;

          if (response.type === 'complete' || response.type === 'error') {
            break;
          }
        }
      }
    } finally {
      this.streamCallbacks.delete(id);
    }
  }

  /**
   * Abort current generation
   */
  async abort(): Promise<void> {
    if (!this.worker) return;

    const id = crypto.randomUUID();
    this.worker.postMessage({ type: 'abort', id });
  }

  /**
   * Unload the model from GPU memory
   */
  async unloadModel(): Promise<void> {
    if (!this.worker) return;

    await this.sendMessage({ type: 'unload', payload: {} });
    this.currentModelId = null;
  }

  /**
   * Check if a model is currently loaded
   */
  isModelLoaded(): boolean {
    return this.currentModelId !== null;
  }

  /**
   * Get the currently loaded model ID
   */
  getCurrentModelId(): string | null {
    return this.currentModelId;
  }

  /**
   * Terminate the worker
   */
  terminate(): void {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
      this.isInitialized = false;
      this.currentModelId = null;
      this.pendingRequests.clear();
      this.streamCallbacks.clear();
    }
  }

  /**
   * Check if worker is initialized
   */
  isReady(): boolean {
    return this.isInitialized && this.worker !== null;
  }
}

```

## services/llm/core/AdapterRegistry.ts

```typescript
/**
 * AdapterRegistry - Manages adapter lifecycle and provider availability
 *
 * Extracted from LLMService.ts to follow Single Responsibility Principle.
 * This service is responsible ONLY for:
 * - Initializing adapters for configured providers
 * - Managing adapter instances
 * - Providing adapter availability checks
 * - Handling adapter cleanup
 *
 * MOBILE COMPATIBILITY (Dec 2025):
 * - SDK-based providers (OpenAI, Anthropic, Google, Mistral, Groq) are SKIPPED on mobile
 * - Only fetch-based providers (OpenRouter, Requesty, Perplexity) work on mobile
 * - These make direct HTTP requests without Node.js SDK dependencies
 * - Use platform.ts `isProviderCompatible()` to check before initializing
 */

import { Vault } from 'obsidian';
import { BaseAdapter } from '../adapters/BaseAdapter';
import { LLMProviderSettings, LLMProviderConfig } from '../../../types';
import { isMobile } from '../../../utils/platform';

// Type imports for TypeScript (don't affect bundling)
import type { WebLLMAdapter as WebLLMAdapterType } from '../adapters/webllm/WebLLMAdapter';

/**
 * Interface for adapter registry operations
 */
export interface IAdapterRegistry {
  /**
   * Initialize all adapters based on provider settings
   */
  initialize(settings: LLMProviderSettings, vault?: Vault): void;

  /**
   * Update settings and reinitialize adapters
   */
  updateSettings(settings: LLMProviderSettings): void;

  /**
   * Get adapter instance for a provider
   */
  getAdapter(providerId: string): BaseAdapter | undefined;

  /**
   * Get all available provider IDs
   */
  getAvailableProviders(): string[];

  /**
   * Check if a provider is initialized and available
   */
  isProviderAvailable(providerId: string): boolean;

  /**
   * Clear all adapters (for cleanup)
   */
  clear(): void;
}

/**
 * AdapterRegistry implementation
 * Manages the lifecycle of LLM provider adapters
 *
 * Note: Tool execution is now handled separately by IToolExecutor.
 * Adapters only handle LLM communication - they don't need mcpConnector.
 */
export class AdapterRegistry implements IAdapterRegistry {
  private adapters: Map<string, BaseAdapter> = new Map();
  private settings: LLMProviderSettings;
  private vault?: Vault;
  private webllmAdapter?: WebLLMAdapterType;
  private initPromise?: Promise<void>;

  constructor(settings: LLMProviderSettings, vault?: Vault) {
    this.settings = settings;
    this.vault = vault;
  }

  /**
   * Initialize all adapters based on provider settings
   * Now async to support dynamic imports for mobile compatibility
   */
  initialize(settings: LLMProviderSettings, vault?: Vault): void {
    this.settings = settings;
    if (vault) this.vault = vault;
    this.adapters.clear();
    // Start async initialization
    this.initPromise = this.initializeAdaptersAsync();
  }

  /**
   * Wait for initialization to complete (call after initialize if you need adapters immediately)
   */
  async waitForInit(): Promise<void> {
    if (this.initPromise) {
      await this.initPromise;
    }
  }

  /**
   * Update settings and reinitialize all adapters
   */
  updateSettings(settings: LLMProviderSettings): void {
    this.initialize(settings, this.vault);
  }

  /**
   * Get adapter instance for a specific provider
   */
  getAdapter(providerId: string): BaseAdapter | undefined {
    return this.adapters.get(providerId);
  }

  /**
   * Get all available (initialized) provider IDs
   */
  getAvailableProviders(): string[] {
    return Array.from(this.adapters.keys());
  }

  /**
   * Check if a provider is available
   */
  isProviderAvailable(providerId: string): boolean {
    return this.adapters.has(providerId);
  }

  /**
   * Clear all adapters
   */
  clear(): void {
    // Dispose Nexus adapter properly (cleanup GPU resources)
    if (this.webllmAdapter) {
      // Clear lifecycle manager reference first (dynamic import)
      import('../adapters/webllm/WebLLMLifecycleManager').then(({ getWebLLMLifecycleManager }) => {
        const lifecycleManager = getWebLLMLifecycleManager();
        lifecycleManager.setAdapter(null);
      }).catch(() => {});

      this.webllmAdapter.dispose().catch((error) => {
      });
      this.webllmAdapter = undefined;
    }
    this.adapters.clear();
  }

  /**
   * Get the WebLLM adapter instance (for model management)
   */
  getWebLLMAdapter(): WebLLMAdapterType | undefined {
    return this.webllmAdapter;
  }

  /**
   * Initialize adapters for all configured providers using dynamic imports
   * MOBILE: Only initializes fetch-based providers (OpenRouter, Requesty, Perplexity)
   * DESKTOP: Initializes all providers including SDK-based ones
   */
  private async initializeAdaptersAsync(): Promise<void> {
    const providers = this.settings?.providers;

    if (!providers) {
      return;
    }

    const onMobile = isMobile();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MOBILE-COMPATIBLE PROVIDERS (use fetch, no SDK dependencies)
    // These work on all platforms
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    await this.initializeProviderAsync('openrouter', providers.openrouter, async (config) => {
      const { OpenRouterAdapter } = await import('../adapters/openrouter/OpenRouterAdapter');
      return new OpenRouterAdapter(config.apiKey, {
        httpReferer: config.httpReferer,
        xTitle: config.xTitle
      });
    });

    await this.initializeProviderAsync('requesty', providers.requesty, async (config) => {
      const { RequestyAdapter } = await import('../adapters/requesty/RequestyAdapter');
      return new RequestyAdapter(config.apiKey);
    });

    await this.initializeProviderAsync('perplexity', providers.perplexity, async (config) => {
      const { PerplexityAdapter } = await import('../adapters/perplexity/PerplexityAdapter');
      return new PerplexityAdapter(config.apiKey);
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DESKTOP-ONLY PROVIDERS (use Node.js SDKs)
    // Skip on mobile to avoid crashes from SDK Node.js dependencies
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (!onMobile) {
      await this.initializeProviderAsync('openai', providers.openai, async (config) => {
        const { OpenAIAdapter } = await import('../adapters/openai/OpenAIAdapter');
        return new OpenAIAdapter(config.apiKey);
      });

      await this.initializeProviderAsync('anthropic', providers.anthropic, async (config) => {
        const { AnthropicAdapter } = await import('../adapters/anthropic/AnthropicAdapter');
        return new AnthropicAdapter(config.apiKey);
      });

      await this.initializeProviderAsync('google', providers.google, async (config) => {
        const { GoogleAdapter } = await import('../adapters/google/GoogleAdapter');
        return new GoogleAdapter(config.apiKey);
      });

      await this.initializeProviderAsync('mistral', providers.mistral, async (config) => {
        const { MistralAdapter } = await import('../adapters/mistral/MistralAdapter');
        return new MistralAdapter(config.apiKey);
      });

      await this.initializeProviderAsync('groq', providers.groq, async (config) => {
        const { GroqAdapter } = await import('../adapters/groq/GroqAdapter');
        return new GroqAdapter(config.apiKey);
      });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LOCAL PROVIDERS (require localhost servers - desktop only)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (!onMobile) {
      // Ollama - apiKey is actually the server URL
      if (providers.ollama?.enabled && providers.ollama.apiKey) {
        try {
          const ollamaModel = providers.ollama.ollamaModel;
          if (ollamaModel && ollamaModel.trim()) {
            const { OllamaAdapter } = await import('../adapters/ollama/OllamaAdapter');
            this.adapters.set('ollama', new OllamaAdapter(providers.ollama.apiKey, ollamaModel));
          }
        } catch (error) {
          console.error('AdapterRegistry: Failed to initialize Ollama adapter:', error);
          this.logError('ollama', error);
        }
      }

      // LM Studio - apiKey is actually the server URL
      if (providers.lmstudio?.enabled && providers.lmstudio.apiKey) {
        try {
          const { LMStudioAdapter } = await import('../adapters/lmstudio/LMStudioAdapter');
          this.adapters.set('lmstudio', new LMStudioAdapter(providers.lmstudio.apiKey));
        } catch (error) {
          console.error('AdapterRegistry: Failed to initialize LM Studio adapter:', error);
          this.logError('lmstudio', error);
        }
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // NEXUS/WEBLLM (Re-enabled Dec 2025)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // WebLLM adapter for local LLM inference via WebGPU
    // Note: Nexus models are fine-tuned on the toolset - they skip getTools and
    // output tool calls that are converted to useTool format automatically.
    //
    // TEMPORARILY DISABLED: WebLLM initialization was causing vault startup hangs.
    // The prefetcher HTTP requests to HuggingFace may be blocking.
    // TODO: Fix prefetcher and re-enable
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (!onMobile && providers.webllm?.enabled) {
      // Defer WebLLM initialization - don't block startup
      // Model will be loaded on-demand when user sends first message
      console.log('[AdapterRegistry] WebLLM enabled - deferring initialization to on-demand loading');
      // We still need to register a placeholder so the provider shows in UI
      // but we won't actually load the model until it's used
      try {
        const { WebLLMAdapter } = await import('../adapters/webllm/WebLLMAdapter');
        const adapter = new WebLLMAdapter(this.vault!);
        // DON'T call adapter.initialize() here - it blocks on WebGPU detection
        // The adapter will auto-initialize on first generate() call
        this.webllmAdapter = adapter;
        this.adapters.set('webllm', adapter);
        console.log('[AdapterRegistry] WebLLM adapter registered (not initialized)');
      } catch (error) {
        console.error('AdapterRegistry: Failed to create WebLLM adapter:', error);
        this.logError('webllm', error);
      }
    }
  }

  /**
   * Initialize a single provider adapter using async factory pattern
   * Handles common validation and error logging with dynamic import support
   */
  private async initializeProviderAsync(
    providerId: string,
    config: LLMProviderConfig | undefined,
    factory: (config: LLMProviderConfig) => Promise<BaseAdapter>
  ): Promise<void> {
    if (config?.apiKey && config.enabled) {
      try {
        const adapter = await factory(config);
        this.adapters.set(providerId, adapter);
      } catch (error) {
        console.error(`AdapterRegistry: Failed to initialize ${providerId} adapter:`, error);
        this.logError(providerId, error);
      }
    }
  }

  /**
   * Log detailed error information for debugging
   */
  private logError(providerId: string, error: unknown): void {
    console.error(`AdapterRegistry: Error details for ${providerId}:`, {
      message: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      name: error instanceof Error ? error.name : undefined
    });
  }
}

```

## services/llm/core/FileContentService.ts

```typescript
/**
 * FileContentService - LLM-specific file content gathering
 *
 * Thin wrapper around VaultOperations for LLM-specific file content formatting.
 * This service handles:
 * - Parallel file reading via VaultOperations
 * - Formatting file content with path headers for LLM context
 * - Error handling and graceful degradation
 */

import { VaultOperations } from '../../../core/VaultOperations';

/**
 * Interface for file content gathering operations
 */
export interface IFileContentService {
  /**
   * Gather and format file content for LLM context
   * @param filepaths - Array of file paths to read
   * @returns Formatted string with file headers and content
   */
  gatherFileContent(filepaths: string[]): Promise<string>;
}

/**
 * FileContentService implementation
 * Uses VaultOperations for cached, parallel file reading
 */
export class FileContentService implements IFileContentService {
  constructor(private vaultOperations: VaultOperations) {}

  /**
   * Gather and format file content from multiple paths
   *
   * Uses VaultOperations.batchRead() for parallel, cached reads
   * Formats content with file path headers for LLM context
   *
   * Format:
   * ```
   * --- path/to/file1.md ---
   * [file content]
   *
   * --- path/to/file2.md ---
   * [file content or error message]
   * ```
   */
  async gatherFileContent(filepaths: string[]): Promise<string> {
    if (filepaths.length === 0) {
      return '';
    }

    // Use VaultOperations.batchRead() for parallel, cached reads
    const contentMap = await this.vaultOperations.batchRead(filepaths);

    // Format content with file headers
    const contentParts: string[] = [];

    for (const filepath of filepaths) {
      const content = contentMap.get(filepath);

      if (content !== null && content !== undefined) {
        // File read successfully
        contentParts.push(`--- ${filepath} ---\n${content}\n`);
      } else {
        // File read failed (null from VaultOperations)
        contentParts.push(`--- ${filepath} ---\n[Error: File not found or could not be read]\n`);
      }
    }

    return contentParts.join('\n');
  }

  /**
   * Format files as XML blocks (for advanced system prompts)
   * Used by ModelAgentManager for structured context
   *
   * Format:
   * ```xml
   * <file_path_to_file1_md>
   * path/to/file1.md
   *
   * [content]
   * </file_path_to_file1_md>
   * ```
   */
  async formatAsXml(filepaths: string[]): Promise<string> {
    if (filepaths.length === 0) {
      return '';
    }

    const contentMap = await this.vaultOperations.batchRead(filepaths);
    const xmlParts: string[] = [];

    for (const filepath of filepaths) {
      const content = contentMap.get(filepath);
      const xmlTag = this.normalizePathToXmlTag(filepath);

      if (content !== null && content !== undefined) {
        xmlParts.push(`<${xmlTag}>\n${filepath}\n\n${content}\n</${xmlTag}>\n`);
      } else {
        xmlParts.push(`<${xmlTag}>\n${filepath}\n\n[Error: File not found]\n</${xmlTag}>\n`);
      }
    }

    return xmlParts.join('\n');
  }

  /**
   * Convert file path to valid XML tag name
   * Example: "path/to/file.md" -> "file_path_to_file_md"
   */
  private normalizePathToXmlTag(path: string): string {
    return path
      .replace(/[^a-zA-Z0-9_]/g, '_')  // Replace non-alphanumeric with underscore
      .replace(/^_+|_+$/g, '')          // Remove leading/trailing underscores
      .replace(/__+/g, '_')             // Replace multiple underscores with single
      .toLowerCase();
  }
}

```

## services/llm/core/index.ts

```typescript
/**
 * LLM Core Services Index
 * Exports for core LLM functionality
 */

export { LLMService } from './LLMService';
export type { LLMExecutionOptions, LLMExecutionResult } from './LLMService';
export { AdapterRegistry } from './AdapterRegistry';
export type { IAdapterRegistry } from './AdapterRegistry';
export { ModelDiscoveryService } from './ModelDiscoveryService';
export type { IModelDiscoveryService, ModelWithProvider } from './ModelDiscoveryService';
export { FileContentService } from './FileContentService';
export type { IFileContentService } from './FileContentService';
export { StreamingOrchestrator } from './StreamingOrchestrator';
export type { StreamingOptions, StreamYield } from './StreamingOrchestrator';
```

## services/llm/core/LLMService.ts

```typescript
/**
 * LLM Service - Main wrapper around the adapter kit
 * Provides unified interface to all LLM providers with Obsidian integration
 */

import { Vault, EventRef, DataAdapter } from 'obsidian';
import { BaseAdapter } from '../adapters/BaseAdapter';
import { GenerateOptions, LLMResponse, ModelInfo } from '../adapters/types';
import { LLMProviderSettings, LLMProviderConfig } from '../../../types';
import { IToolExecutor } from '../adapters/shared/ToolExecutionUtils';
import { ConversationContextBuilder } from '../../chat/ConversationContextBuilder';
import { ConversationData } from '../../../types/chat/ChatTypes';
import { AdapterRegistry } from './AdapterRegistry';
import { ModelDiscoveryService } from './ModelDiscoveryService';
import { FileContentService } from './FileContentService';
import { StreamingOrchestrator, StreamingOptions, StreamYield, ConversationMessage } from './StreamingOrchestrator';
import { VaultOperations } from '../../../core/VaultOperations';
import { CacheManager, VaultAdapter } from '../utils/CacheManager';
import { Logger } from '../utils/Logger';
import { LLMSettingsNotifier } from '../LLMSettingsNotifier';

export interface LLMExecutionOptions extends GenerateOptions {
  provider?: string;
  model?: string;
  filepaths?: string[];
  systemPrompt?: string;
  userPrompt: string;
  webSearch?: boolean;
}

export interface LLMExecutionResult {
  success: boolean;
  response?: string;
  model?: string;
  provider?: string;
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  cost?: {
    inputCost: number;
    outputCost: number;
    totalCost: number;
    currency: string;
  };
  filesIncluded?: string[];
  webSearchResults?: any[]; // SearchResult[] from adapters/types, avoiding circular import
  error?: string;
}

export class LLMService {
  private adapterRegistry: AdapterRegistry;
  private modelDiscovery: ModelDiscoveryService;
  private fileContentService?: FileContentService;
  private settings: LLMProviderSettings;
  private vault?: Vault;
  private settingsEventRef: EventRef | null = null;
  private toolExecutor?: IToolExecutor;

  constructor(settings: LLMProviderSettings, vault?: Vault) {
    this.settings = settings;
    this.vault = vault;
    if (vault) {
      const adapter = vault.adapter as DataAdapter & VaultAdapter;
      CacheManager.configureVaultAdapter(adapter);
      Logger.setVaultAdapter(adapter);
    }
    this.adapterRegistry = new AdapterRegistry(settings, vault);
    this.adapterRegistry.initialize(settings, vault);
    this.modelDiscovery = new ModelDiscoveryService(this.adapterRegistry, settings);

    // Subscribe to settings changes for automatic adapter refresh (Obsidian Events API)
    this.settingsEventRef = LLMSettingsNotifier.onSettingsChanged((newSettings) => {
      this.updateSettings(newSettings);
    });
  }

  /**
   * Set the tool executor for tool call handling
   * This enables tools on ALL platforms (desktop + mobile)
   */
  setToolExecutor(executor: IToolExecutor): void {
    this.toolExecutor = executor;
  }


  /** Update settings and reinitialize adapters */
  updateSettings(settings: LLMProviderSettings): void {
    this.settings = settings;
    this.adapterRegistry.updateSettings(settings);
    this.modelDiscovery = new ModelDiscoveryService(this.adapterRegistry, settings);
  }

  /** Get all available models from enabled providers */
  async getAvailableModels(): Promise<(ModelInfo & { provider: string; userDescription?: string })[]> {
    return this.modelDiscovery.getAvailableModels();
  }

  /** Get available providers (those with API keys and enabled) */
  getAvailableProviders(): string[] {
    return this.adapterRegistry.getAvailableProviders();
  }

  /** Check if a provider is available */
  isProviderAvailable(provider: string): boolean {
    return this.adapterRegistry.isProviderAvailable(provider);
  }

  /** Get the default provider and model */
  getDefaultModel(): { provider: string; model: string } {
    return this.settings.defaultModel;
  }

  /**
   * Get the model to use for agent operations (executePrompt).
   * If the default model is a local provider (webllm, ollama, lmstudio),
   * returns the configured agentModel or falls back to first available API provider.
   */
  getAgentModel(): { provider: string; model: string } {
    const LOCAL_PROVIDERS = ['webllm', 'ollama', 'lmstudio'];
    const defaultModel = this.settings.defaultModel;

    // If default is not a local provider, use it
    if (!LOCAL_PROVIDERS.includes(defaultModel.provider)) {
      return defaultModel;
    }

    // If agentModel is configured, use it
    if (this.settings.agentModel?.provider && this.settings.agentModel?.model) {
      return this.settings.agentModel;
    }

    // Fall back to first available API provider
    const availableProviders = this.getAvailableProviders();
    const apiProviders = availableProviders.filter(p => !LOCAL_PROVIDERS.includes(p));

    if (apiProviders.length > 0) {
      // Return first API provider with its default model
      // This is a best-effort fallback - the caller should handle model selection
      return { provider: apiProviders[0], model: '' };
    }

    // No API providers available - return default anyway (will likely fail)
    return defaultModel;
  }

  /** Execute a prompt with the specified or default provider/model */
  async executePrompt(options: LLMExecutionOptions): Promise<LLMExecutionResult> {
    try {
      // Validate that we have settings
      if (!this.settings || !this.settings.defaultModel) {
        return {
          success: false,
          error: 'LLM service not properly configured - missing settings'
        };
      }

      // Determine provider and model
      const provider = options.provider || this.settings.defaultModel.provider;
      const model = options.model || this.settings.defaultModel.model;

      // Validate provider and model are specified
      if (!provider) {
        return {
          success: false,
          error: 'No provider specified and no default provider configured. Please set up LLM providers in settings.'
        };
      }

      if (!model) {
        return {
          success: false,
          error: 'No model specified and no default model configured. Please set up default model in settings.'
        };
      }

      // Get adapter for the provider
      const adapter = this.adapterRegistry.getAdapter(provider);

      if (!adapter) {
        const availableProviders = this.adapterRegistry.getAvailableProviders();
        return {
          success: false,
          error: `Provider '${provider}' is not available. Available providers: ${availableProviders.length > 0 ? availableProviders.join(', ') : 'none (no API keys configured)'}. Please check API key configuration in settings.`
        };
      }

      // Build the complete prompt
      let fullPrompt = options.userPrompt;
      
      // Add file content if filepaths provided
      let filesIncluded: string[] = [];
      if (options.filepaths && options.filepaths.length > 0) {
        if (this.fileContentService) {
          const fileContent = await this.fileContentService.gatherFileContent(options.filepaths);
          if (fileContent.length > 0) {
            fullPrompt = `Context from files:\n\n${fileContent}\n\n---\n\nUser request: ${options.userPrompt}`;
            filesIncluded = options.filepaths;
          }
        }
      }

      // Execute the prompt
      const generateOptions: GenerateOptions = {
        model,
        systemPrompt: options.systemPrompt,
        temperature: options.temperature,
        maxTokens: options.maxTokens,
        jsonMode: options.jsonMode,
        topP: options.topP,
        frequencyPenalty: options.frequencyPenalty,
        presencePenalty: options.presencePenalty,
        stopSequences: options.stopSequences,
        webSearch: options.webSearch
      };

      const result: LLMResponse = await adapter.generate(fullPrompt, generateOptions);

      return {
        success: true,
        response: result.text,
        model: result.model,
        provider: result.provider,
        usage: result.usage,
        cost: result.cost,
        filesIncluded,
        webSearchResults: result.webSearchResults
      };

    } catch (error) {
      console.error('LLMService.executePrompt failed:', error);
      console.error('Error details:', {
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
        name: error instanceof Error ? error.name : undefined,
        toString: String(error)
      });
      
      return {
        success: false,
        error: `LLM execution failed: ${error instanceof Error ? error.message : 'Unknown error occurred'}. Check console for details.`
      };
    }
  }

  /** Set VaultOperations for file reading */
  setVaultOperations(vaultOperations: VaultOperations): void {
    this.fileContentService = new FileContentService(vaultOperations);
  }

  /** Test connection to a specific provider */
  async testProvider(provider: string): Promise<{ success: boolean; error?: string }> {
    try {
      const adapter = this.adapterRegistry.getAdapter(provider);
      if (!adapter) {
        return { success: false, error: `Provider '${provider}' is not configured` };
      }

      // Test with a simple prompt
      await adapter.generate('Hello', { maxTokens: 10 });
      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /** Get provider configuration */
  getProviderConfig(provider: string): LLMProviderConfig | undefined {
    return this.settings.providers[provider];
  }

  /** Get all provider configurations */
  getAllProviderConfigs(): { [providerId: string]: LLMProviderConfig } {
    return this.settings.providers;
  }

  /** Generate streaming LLM response with tool execution support */
  async* generateResponseStream(
    messages: Array<{ role: string; content: string }>,
    options?: StreamingOptions
  ): AsyncGenerator<StreamYield, void, unknown> {
    const orchestrator = new StreamingOrchestrator(
      this.adapterRegistry,
      this.settings,
      this.toolExecutor
    );
    // Convert messages to ConversationMessage format
    const conversationMessages: ConversationMessage[] = messages.map(msg => {
      // Type guard to check for tool_calls property
      if ('tool_calls' in msg && Array.isArray((msg as { tool_calls?: unknown }).tool_calls)) {
        return {
          role: msg.role as 'user' | 'assistant' | 'system' | 'tool',
          content: msg.content,
          tool_calls: (msg as { tool_calls: ConversationMessage['tool_calls'] }).tool_calls
        };
      }
      return {
        role: msg.role as 'user' | 'assistant' | 'system' | 'tool',
        content: msg.content
      };
    });
    yield* orchestrator.generateResponseStream(conversationMessages, options);
  }

  /** Get a specific adapter instance for direct access */
  getAdapter(providerId: string): BaseAdapter | undefined {
    return this.adapterRegistry.getAdapter(providerId);
  }

  /** Wait for adapter initialization to complete (async providers like LM Studio) */
  async waitForInit(): Promise<void> {
    return this.adapterRegistry.waitForInit();
  }

  /** Clean up resources and unsubscribe from settings changes */
  dispose(): void {
    if (this.settingsEventRef) {
      LLMSettingsNotifier.unsubscribe(this.settingsEventRef);
      this.settingsEventRef = null;
    }
    this.adapterRegistry.clear();
  }

}

```

## services/llm/core/ModelDiscoveryService.ts

```typescript
/**
 * ModelDiscoveryService - Query and aggregate models from all providers
 *
 * Extracted from LLMService.ts to follow Single Responsibility Principle.
 * This service is responsible ONLY for:
 * - Querying available models from each provider
 * - Aggregating models across all providers
 * - Adding provider metadata to model information
 * - Finding specific models across providers
 */

import { ModelInfo } from '../adapters/types';
import { LLMProviderSettings } from '../../../types';
import { IAdapterRegistry } from './AdapterRegistry';

/**
 * Model information with provider context
 */
export interface ModelWithProvider extends ModelInfo {
  provider: string;
  userDescription?: string;
}

/**
 * Interface for model discovery operations
 */
export interface IModelDiscoveryService {
  /**
   * Get all available models from enabled providers
   */
  getAvailableModels(): Promise<ModelWithProvider[]>;

  /**
   * Get models for a specific provider
   */
  getModelsForProvider(providerId: string): Promise<ModelInfo[]>;

  /**
   * Find a model by ID across all providers
   */
  findModel(modelId: string): Promise<ModelWithProvider | null>;
}

/**
 * ModelDiscoveryService implementation
 * Queries and aggregates models from all configured LLM providers
 */
export class ModelDiscoveryService implements IModelDiscoveryService {
  constructor(
    private adapterRegistry: IAdapterRegistry,
    private settings: LLMProviderSettings
  ) {}

  /**
   * Get all available models from enabled providers
   * Queries each provider in parallel for better performance
   */
  async getAvailableModels(): Promise<ModelWithProvider[]> {
    const allModels: ModelWithProvider[] = [];
    const availableProviders = this.adapterRegistry.getAvailableProviders();

    // Query all providers in parallel using Promise.allSettled
    // This ensures one provider failure doesn't block others
    await Promise.allSettled(
      availableProviders.map(async (providerId) => {
        const adapter = this.adapterRegistry.getAdapter(providerId);
        if (!adapter) return;

        try {
          const models = await adapter.listModels();

          // Add provider information and user description to each model
          const modelsWithProvider = models.map(model => ({
            ...model,
            provider: providerId,
            userDescription: this.settings.providers[providerId]?.userDescription
          }));

          allModels.push(...modelsWithProvider);
        } catch (error) {
        }
      })
    );

    return allModels;
  }

  /**
   * Get models for a specific provider
   * @throws Error if provider is not available
   */
  async getModelsForProvider(providerId: string): Promise<ModelInfo[]> {
    const adapter = this.adapterRegistry.getAdapter(providerId);

    if (!adapter) {
      throw new Error(`Provider ${providerId} not available`);
    }

    try {
      return await adapter.listModels();
    } catch (error) {
      console.error(`ModelDiscoveryService: Failed to get models from ${providerId}:`, error);
      throw error;
    }
  }

  /**
   * Find a model by ID across all providers
   * Returns null if model is not found
   */
  async findModel(modelId: string): Promise<ModelWithProvider | null> {
    const allModels = await this.getAvailableModels();
    return allModels.find(m => m.id === modelId) || null;
  }

  /**
   * Update settings (for when settings change)
   * Creates a new instance with updated settings
   */
  static create(adapterRegistry: IAdapterRegistry, settings: LLMProviderSettings): ModelDiscoveryService {
    return new ModelDiscoveryService(adapterRegistry, settings);
  }
}

```

## services/llm/core/ProviderMessageBuilder.ts

```typescript
/**
 * ProviderMessageBuilder - Provider-specific message formatting
 *
 * Handles building conversation history and continuation options for different
 * LLM providers (Anthropic, Google, OpenAI, generic OpenAI-compatible).
 *
 * Each provider has specific message format requirements:
 * - Anthropic: tool_use/tool_result blocks in messages
 * - Google: functionCall/functionResponse in parts
 * - OpenAI: Responses API with function_call_output items
 * - Generic: Chat Completions API message arrays
 */

import { ConversationContextBuilder } from '../../chat/ConversationContextBuilder';
import { ToolResult } from '../adapters/shared/ToolExecutionUtils';
import { Tool, ToolCall as AdapterToolCall } from '../adapters/types';
import { ToolCall as ChatToolCall } from '../../../types/chat/ChatTypes';

// Union type for tool calls from different sources
type ToolCallUnion = AdapterToolCall | ChatToolCall;

// Standardized message format for conversation history
export interface ConversationMessage {
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
  tool_calls?: ToolCallUnion[];
}

// Google-specific message format
export interface GoogleMessage {
  role: 'user' | 'model' | 'function';
  parts: Array<{ text?: string; functionCall?: any; functionResponse?: any }>;
}

// Internal options type used during streaming orchestration
export interface GenerateOptionsInternal {
  model: string;
  systemPrompt?: string;
  conversationHistory?: GoogleMessage[] | ConversationMessage[] | any[]; // any[] for OpenAI Responses API
  tools?: Tool[];
  onToolEvent?: (event: 'started' | 'completed', data: any) => void;
  onUsageAvailable?: (usage: any, cost?: any) => void;
  enableThinking?: boolean;
  thinkingEffort?: 'low' | 'medium' | 'high';
  previousResponseId?: string; // OpenAI Responses API
}

export interface StreamingOptions {
  provider?: string;
  model?: string;
  systemPrompt?: string;
  tools?: Tool[];
  onToolEvent?: (event: 'started' | 'completed', data: any) => void;
  onUsageAvailable?: (usage: any, cost?: any) => void;
  sessionId?: string;
  workspaceId?: string;
  conversationId?: string;
  temperature?: number;
  maxTokens?: number;
  topP?: number;
  frequencyPenalty?: number;
  presencePenalty?: number;
  enableThinking?: boolean;
  thinkingEffort?: 'low' | 'medium' | 'high';
  // Responses API (OpenAI/LM Studio): ID from first response, reused for all continuations
  responsesApiId?: string;
  // Callback when responsesApiId is first captured - caller should persist to conversation metadata
  onResponsesApiId?: (id: string) => void;
}

export class ProviderMessageBuilder {
  private conversationResponseIds: Map<string, string>;

  constructor(conversationResponseIds: Map<string, string>) {
    this.conversationResponseIds = conversationResponseIds;
  }

  /**
   * Extract system prompt from messages array
   * Most LLM providers expect system prompt as a separate option, not in messages array.
   * This method finds system messages and combines them into a single prompt.
   * @param messages - Array of messages that may contain system messages
   * @param existingSystemPrompt - Optional existing system prompt to prepend
   * @returns Combined system prompt or undefined if none found
   */
  static extractSystemPrompt(messages: ConversationMessage[], existingSystemPrompt?: string): string | undefined {
    const systemMessages = messages.filter(m => m.role === 'system');
    const systemContent = systemMessages.map(m => m.content).filter(Boolean).join('\n\n');

    if (existingSystemPrompt && systemContent) {
      return `${existingSystemPrompt}\n\n${systemContent}`;
    }
    return existingSystemPrompt || systemContent || undefined;
  }

  /**
   * Filter out system messages from array
   * Use this to get only user/assistant/tool messages for the messages array.
   * @param messages - Array of messages
   * @returns Messages without system role
   */
  static filterNonSystemMessages(messages: ConversationMessage[]): ConversationMessage[] {
    return messages.filter(m => m.role !== 'system');
  }

  /**
   * Build conversation history string from messages (for text-based providers)
   */
  buildConversationHistory(messages: ConversationMessage[]): string {
    if (messages.length <= 1) {
      return '';
    }

    return messages.slice(0, -1).map((msg: ConversationMessage) => {
      if (msg.role === 'user') return `User: ${msg.content}`;
      if (msg.role === 'assistant') {
        if (msg.tool_calls && msg.tool_calls.length > 0) {
          return `Assistant: [Calling tools: ${msg.tool_calls.map((tc) => {
            // Handle both AdapterToolCall and ChatToolCall
            if ('name' in tc) {
              const chatTc = tc as ChatToolCall;
              if (chatTc.name) return chatTc.name;
            }
            return tc.function?.name || 'unknown';
          }).join(', ')}]`;
        }
        return `Assistant: ${msg.content}`;
      }
      if (msg.role === 'tool') return `Tool Result: ${msg.content}`;
      if (msg.role === 'system') return `System: ${msg.content}`;
      return '';
    }).filter(Boolean).join('\n');
  }

  /**
   * Build continuation options with provider-specific formatting
   */
  buildContinuationOptions(
    provider: string,
    userPrompt: string,
    toolCalls: ToolCallUnion[],
    toolResults: ToolResult[],
    previousMessages: ConversationMessage[],
    generateOptions: GenerateOptionsInternal,
    options?: StreamingOptions
  ): GenerateOptionsInternal {
    // Check if this is an Anthropic model (direct only)
    // Note: OpenRouter always uses OpenAI format, even for Anthropic models
    const isAnthropicModel = provider === 'anthropic';

    // Check if this is a Google model (direct only)
    // Note: OpenRouter always uses OpenAI format, even for Google models
    const isGoogleModel = provider === 'google';

    if (isAnthropicModel) {
      // Build proper Anthropic messages with tool_use and tool_result blocks
      const conversationHistory = ConversationContextBuilder.buildToolContinuation(
        'anthropic',
        userPrompt,
        toolCalls,
        toolResults,
        previousMessages,
        generateOptions.systemPrompt
      ) as ConversationMessage[];

      // IMPORTANT: Disable thinking for tool continuations
      // Anthropic requires assistant messages to start with a thinking block when thinking is enabled,
      // but we don't have access to the original thinking content here.
      return {
        ...generateOptions,
        conversationHistory,
        systemPrompt: generateOptions.systemPrompt,
        enableThinking: false // Disable thinking for tool continuations
      };
    } else if (isGoogleModel) {
      // Build proper Google/Gemini conversation history with functionCall and functionResponse
      const conversationHistory = ConversationContextBuilder.buildToolContinuation(
        'google',
        userPrompt,
        toolCalls,
        toolResults,
        previousMessages,
        generateOptions.systemPrompt
      ) as GoogleMessage[];

      return {
        ...generateOptions,
        conversationHistory,
        systemPrompt: generateOptions.systemPrompt
      };
    } else if (provider === 'openai') {
      // OpenAI uses Responses API with function_call_output items + previous_response_id
      // State is reliably tracked on OpenAI's servers
      const toolInput = ConversationContextBuilder.buildResponsesAPIToolInput(
        toolCalls,
        toolResults
      );

      // Use responsesApiId from options (loaded from conversation metadata)
      // Falls back to in-memory map for backward compatibility
      let previousResponseId = options?.responsesApiId;
      if (!previousResponseId) {
        const convId = options?.conversationId;
        previousResponseId = convId ? this.conversationResponseIds.get(convId) : undefined;
      }

      return {
        ...generateOptions,
        conversationHistory: toolInput,
        previousResponseId,
        systemPrompt: generateOptions.systemPrompt,
        tools: generateOptions.tools
      };
    } else if (provider === 'lmstudio') {
      // LM Studio: Send FULL conversation history to ensure AI sees complete context
      // Format depends on model: Nexus uses custom <tool_call> format, others use OpenAI format
      const conversationHistory = ConversationContextBuilder.buildToolContinuation(
        'lmstudio',
        userPrompt,
        toolCalls,
        toolResults,
        previousMessages,
        generateOptions.systemPrompt,
        generateOptions.model // Pass model to determine correct format
      ) as ConversationMessage[];

      console.log('[LLM_DEBUG] LM Studio tool continuation - sending full history:');
      console.log('[LLM_DEBUG]   Model:', generateOptions.model);
      console.log('[LLM_DEBUG]   Previous messages:', previousMessages.length);
      console.log('[LLM_DEBUG]   Tool calls:', toolCalls.length);
      console.log('[LLM_DEBUG]   Built conversation:', conversationHistory.length, 'messages');

      return {
        ...generateOptions,
        conversationHistory,
        systemPrompt: generateOptions.systemPrompt,
        tools: generateOptions.tools
      };
    } else {
      // Other OpenAI-compatible providers (groq, mistral, perplexity, requesty, openrouter)
      // These still use Chat Completions API message arrays
      const conversationHistory = ConversationContextBuilder.buildToolContinuation(
        provider,
        userPrompt,
        toolCalls,
        toolResults,
        previousMessages,
        generateOptions.systemPrompt
      ) as ConversationMessage[];

      return {
        ...generateOptions,
        conversationHistory,
        systemPrompt: generateOptions.systemPrompt
      };
    }
  }

  /**
   * Build initial generate options for a provider
   * Automatically extracts system messages from the messages array and combines with options.systemPrompt
   */
  buildInitialOptions(
    provider: string,
    model: string,
    messages: ConversationMessage[],
    options?: StreamingOptions
  ): { generateOptions: GenerateOptionsInternal; userPrompt: string } {
    // Extract system messages and filter them out of the messages array
    // This handles cases where system prompt is passed as a message (e.g., subagent branches)
    const extractedSystemPrompt = ProviderMessageBuilder.extractSystemPrompt(messages, options?.systemPrompt);
    const nonSystemMessages = ProviderMessageBuilder.filterNonSystemMessages(messages);

    // Get only the latest user message as the actual prompt
    const latestUserMessage = nonSystemMessages[nonSystemMessages.length - 1];
    const userPrompt = latestUserMessage?.role === 'user' ? latestUserMessage.content : '';

    // Check if this is a Google model
    const isGoogleModel = provider === 'google';

    let generateOptions: GenerateOptionsInternal;

    if (isGoogleModel) {
      // For Google, build proper conversation history in Google format
      const googleConversationHistory: GoogleMessage[] = [];

      for (const msg of nonSystemMessages) {
        if (!msg.content || !msg.content.trim()) {
          continue;
        }

        if (msg.role === 'user') {
          googleConversationHistory.push({
            role: 'user',
            parts: [{ text: msg.content }]
          });
        } else if (msg.role === 'assistant') {
          googleConversationHistory.push({
            role: 'model',
            parts: [{ text: msg.content }]
          });
        }
      }

      generateOptions = {
        model,
        systemPrompt: extractedSystemPrompt,
        conversationHistory: googleConversationHistory,
        tools: options?.tools,
        onToolEvent: options?.onToolEvent,
        onUsageAvailable: options?.onUsageAvailable,
        enableThinking: options?.enableThinking,
        thinkingEffort: options?.thinkingEffort
      };
    } else {
      // For other providers (OpenAI, Anthropic), use text-based system prompt
      const conversationHistory = this.buildConversationHistory(nonSystemMessages);

      const systemPrompt = [
        extractedSystemPrompt || '',
        conversationHistory ? '\n=== Conversation History ===\n' + conversationHistory : ''
      ].filter(Boolean).join('\n');

      generateOptions = {
        model,
        systemPrompt: systemPrompt || extractedSystemPrompt,
        tools: options?.tools,
        onToolEvent: options?.onToolEvent,
        onUsageAvailable: options?.onUsageAvailable,
        enableThinking: options?.enableThinking,
        thinkingEffort: options?.thinkingEffort
      };
    }

    return { generateOptions, userPrompt };
  }

  /**
   * Update response ID for OpenAI provider
   */
  updateResponseId(conversationId: string | undefined, responseId: string): void {
    if (conversationId) {
      this.conversationResponseIds.set(conversationId, responseId);
    }
  }
}

```

## services/llm/core/StreamingOrchestrator.ts

```typescript
/**
 * StreamingOrchestrator - Manages streaming LLM responses with tool execution
 *
 * Orchestrates the complete streaming lifecycle by coordinating:
 * - ProviderMessageBuilder: Provider-specific message formatting
 * - ToolContinuationService: Tool execution and pingpong loop
 * - TerminalToolHandler: Detection of tools that stop the loop
 *
 * Follows Single Responsibility Principle - only handles stream coordination.
 */

import { IToolExecutor } from '../adapters/shared/ToolExecutionUtils';
import { LLMProviderSettings } from '../../../types';
import { IAdapterRegistry } from './AdapterRegistry';
import { TokenUsage } from '../adapters/types';
import { ToolCall as ChatToolCall } from '../../../types/chat/ChatTypes';
import {
  ProviderMessageBuilder,
  ConversationMessage,
  StreamingOptions,
  GoogleMessage
} from './ProviderMessageBuilder';
import { ToolContinuationService, StreamYield } from './ToolContinuationService';

// Re-export types for backward compatibility
export type { ConversationMessage, GoogleMessage, StreamingOptions, StreamYield };

export class StreamingOrchestrator {
  // Track OpenAI response IDs for stateful continuations
  private conversationResponseIds: Map<string, string> = new Map();

  // Delegate services
  private messageBuilder: ProviderMessageBuilder;
  private toolContinuation: ToolContinuationService;

  constructor(
    private adapterRegistry: IAdapterRegistry,
    private settings: LLMProviderSettings,
    toolExecutor?: IToolExecutor
  ) {
    this.messageBuilder = new ProviderMessageBuilder(this.conversationResponseIds);
    this.toolContinuation = new ToolContinuationService(toolExecutor, this.messageBuilder);
  }

  /**
   * Primary method: orchestrate streaming response with tool execution
   * @param messages - Conversation message history
   * @param options - Streaming configuration
   * @returns AsyncGenerator yielding chunks and tool calls
   */
  async* generateResponseStream(
    messages: ConversationMessage[],
    options?: StreamingOptions
  ): AsyncGenerator<StreamYield, void, unknown> {
    try {
      // Validate settings
      if (!this.settings || !this.settings.defaultModel) {
        throw new Error('LLM service not properly configured - missing settings');
      }

      // Determine provider and model
      const provider = options?.provider || this.settings.defaultModel.provider;
      const model = options?.model || this.settings.defaultModel.model;

      // Get adapter
      const adapter = this.adapterRegistry.getAdapter(provider);
      if (!adapter) {
        const availableProviders = this.adapterRegistry.getAvailableProviders();
        console.error(`[StreamingOrchestrator] Provider '${provider}' not available. Available providers:`, availableProviders);
        throw new Error(`Provider not available: ${provider}. Available: [${availableProviders.join(', ')}]`);
      }

      // Build initial options via message builder
      const { generateOptions, userPrompt } = this.messageBuilder.buildInitialOptions(
        provider,
        model,
        messages,
        options
      );

      // Store original messages for pingpong context (exclude the last user message)
      const previousMessages = messages.slice(0, -1);

      // Execute initial stream and detect tool calls
      let fullContent = '';
      let detectedToolCalls: ChatToolCall[] = [];
      let finalUsage: TokenUsage | undefined = undefined;

      // For Google, pass empty string as prompt since conversation is in conversationHistory
      const isGoogleModel = provider === 'google';
      const promptToPass = isGoogleModel ? '' : userPrompt;

      for await (const chunk of adapter.generateStreamAsync(promptToPass, generateOptions)) {
        // Track usage from chunks
        if (chunk.usage) {
          finalUsage = chunk.usage;
        }

        // Handle text content streaming
        if (chunk.content) {
          fullContent += chunk.content;

          yield {
            chunk: chunk.content,
            complete: false,
            content: fullContent,
            toolCalls: undefined
          };
        }

        // Handle reasoning/thinking content (Claude, GPT-5, Gemini)
        if (chunk.reasoning) {
          yield {
            chunk: '',
            complete: false,
            content: fullContent,
            toolCalls: undefined,
            reasoning: chunk.reasoning,
            reasoningComplete: chunk.reasoningComplete
          };
        }

        // Handle dynamic tool call detection
        if (chunk.toolCalls) {
          const chatToolCalls: ChatToolCall[] = chunk.toolCalls.map(tc => ({
            ...tc,
            type: tc.type || 'function',
            function: tc.function || { name: '', arguments: '{}' }
          }));

          // ALWAYS yield tool calls for progressive UI display
          yield {
            chunk: '',
            complete: false,
            content: fullContent,
            toolCalls: chatToolCalls,
            toolCallsReady: chunk.complete || false
          };

          // Only STORE tool calls for execution when streaming is COMPLETE
          if (chunk.complete) {
            detectedToolCalls = chatToolCalls;
          }
        }

        if (chunk.complete) {
          // Store response ID for future continuations (OpenAI uses Responses API)
          if (provider === 'openai' && chunk.metadata?.responseId) {
            const responseId = chunk.metadata.responseId;

            // Only capture if we don't already have one (from options or memory)
            const existingId = options?.responsesApiId ||
              (options?.conversationId ? this.conversationResponseIds.get(options.conversationId) : undefined);

            if (!existingId) {
              // Store in memory for this session
              if (options?.conversationId) {
                this.conversationResponseIds.set(options.conversationId, responseId);
              }
              // Notify caller to persist to conversation metadata
              if (options?.onResponsesApiId) {
                options.onResponsesApiId(responseId);
              }
              console.log('[LLM_DEBUG] Captured responsesApiId:', responseId);
            } else {
              console.log('[LLM_DEBUG] Using existing responsesApiId:', existingId);
            }
          }
          break;
        }
      }

      // If no tool calls detected, we're done
      if (detectedToolCalls.length === 0 || !generateOptions.tools || generateOptions.tools.length === 0) {
        yield {
          chunk: '',
          complete: true,
          content: fullContent,
          toolCalls: undefined,
          usage: finalUsage
        };
        return;
      }

      // Tool calls detected - delegate to ToolContinuationService
      yield* this.toolContinuation.executeToolsAndContinue(
        adapter,
        provider,
        detectedToolCalls,
        previousMessages,
        userPrompt,
        generateOptions,
        options,
        finalUsage
      );

    } catch (error) {
      throw error;
    }
  }
}

```

## services/llm/core/TerminalToolHandler.ts

```typescript
/**
 * TerminalToolHandler - Detects tools that should stop the pingpong loop
 *
 * Terminal tools (like subagent) start background processes where the parent
 * conversation should NOT continue with more tool calls or LLM responses.
 * Instead, we return a synthetic message informing the user about the spawned process.
 */

import { ToolCall as ChatToolCall } from '../../../types/chat/ChatTypes';

export interface TerminalToolResult {
  message: string;
  branchId?: string;
}

/**
 * List of tools that should terminate the pingpong loop
 * These tools spawn background processes and the parent should not continue
 */
const TERMINAL_TOOLS = ['subagent', 'promptManager_subagent', 'promptManager.subagent'];

/**
 * Check if any executed tool is a "terminal" tool that should stop the pingpong loop
 * @param toolCalls - The tool calls with their execution results
 * @returns Synthetic message to display, or null if no terminal tool found
 */
export function checkForTerminalTool(toolCalls: ChatToolCall[]): TerminalToolResult | null {
  for (const toolCall of toolCalls) {
    const toolName = toolCall.name || toolCall.function?.name || '';

    // Check for direct subagent calls
    const isDirectSubagent = TERMINAL_TOOLS.some(t => toolName.includes(t) || toolName.endsWith('subagent'));

    // Check for subagent wrapped in toolManager_useTool
    let isWrappedSubagent = false;
    let wrappedResult: any = null;
    let wrappedParams: any = null;

    if (toolName === 'toolManager_useTool' || toolName.endsWith('useTool')) {
      // Try to get params from multiple sources
      let params = toolCall.parameters as { calls?: Array<{ agent?: string; tool?: string; params?: any }> } | undefined;

      // If parameters is empty, try parsing from function.arguments
      if (!params?.calls && toolCall.function?.arguments) {
        try {
          const parsed = JSON.parse(toolCall.function.arguments);
          params = parsed;
        } catch {
          // Ignore parse errors
        }
      }

      const calls = params?.calls || [];

      for (const call of calls) {
        if (call.tool === 'subagent' || (call.agent === 'promptManager' && call.tool === 'subagent')) {
          isWrappedSubagent = true;
          wrappedParams = call.params;

          // Extract result from useTool's results array
          // Structure is: { success, data: { results: [...] } }
          const useToolResult = toolCall.result as {
            success?: boolean;
            data?: { results?: Array<{ success?: boolean; data?: any; agent?: string; tool?: string }> };
          } | undefined;
          const resultsArray = useToolResult?.data?.results;

          // Find the subagent result by index (matching position in calls array)
          const callIndex = calls.indexOf(call);
          if (resultsArray?.[callIndex]) {
            wrappedResult = resultsArray[callIndex];
          } else if (resultsArray?.[0]) {
            // Fallback to first result
            wrappedResult = resultsArray[0];
          }
          break;
        }
      }
    }

    if (isDirectSubagent || isWrappedSubagent) {
      // Get the appropriate result and params
      const result = isWrappedSubagent ? wrappedResult : toolCall.result as {
        success?: boolean;
        data?: {
          subagentId?: string;
          branchId?: string;
          status?: string;
          message?: string;
        };
      } | undefined;

      const params = isWrappedSubagent ? wrappedParams : toolCall.parameters as { task?: string; tools?: Record<string, string[]> } | undefined;

      if (result?.success && result?.data) {
        const { branchId } = result.data;

        // Build a clean message with the subagent info
        let terminalMessage = `\n\nâœ… **Subagent Started**\n\n`;
        terminalMessage += `**Task:** ${params?.task || 'Task assigned'}\n\n`;

        const toolsParam = params?.tools as Record<string, string[]> | undefined;
        if (toolsParam && Object.keys(toolsParam).length > 0) {
          const toolsList = Object.entries(toolsParam)
            .map(([agent, tools]) => `- ${agent}: ${(tools as string[]).join(', ')}`)
            .join('\n');
          terminalMessage += `**Tools Handed Off:**\n${toolsList}\n\n`;
        }

        terminalMessage += `The subagent is now working autonomously. You can:\n`;
        terminalMessage += `- Continue chatting here while it works\n`;
        terminalMessage += `- Click "View Branch â†’" on the tool result above to see progress\n`;
        terminalMessage += `- Results will appear here when complete`;

        return { message: terminalMessage, branchId };
      }
    }
  }

  return null;
}

/**
 * Check if a tool name is a terminal tool
 * @param toolName - The name of the tool to check
 * @returns true if the tool is a terminal tool
 */
export function isTerminalTool(toolName: string): boolean {
  return TERMINAL_TOOLS.some(t => toolName.includes(t) || toolName.endsWith('subagent'));
}

```

## services/llm/core/ToolContinuationService.ts

```typescript
/**
 * ToolContinuationService - Tool execution and pingpong loop management
 *
 * Handles the complete tool execution lifecycle:
 * - Initial tool call execution via MCP
 * - Building tool results for continuation
 * - Recursive tool call handling (pingpong pattern)
 * - Tool iteration limits and safety guards
 * - Dynamic tool schema merging from get_tools
 */

import { BaseAdapter } from '../adapters/BaseAdapter';
import { ConversationContextBuilder } from '../../chat/ConversationContextBuilder';
import { MCPToolExecution, IToolExecutor, ToolResult } from '../adapters/shared/ToolExecutionUtils';
import { Tool, TokenUsage, SupportedProvider, ToolCall as AdapterToolCall } from '../adapters/types';
import { ToolCall as ChatToolCall } from '../../../types/chat/ChatTypes';
import { checkForTerminalTool } from './TerminalToolHandler';
import {
  ProviderMessageBuilder,
  ConversationMessage,
  GenerateOptionsInternal,
  StreamingOptions
} from './ProviderMessageBuilder';

// Union type for tool calls from different sources
type ToolCallUnion = AdapterToolCall | ChatToolCall;

export interface StreamYield {
  chunk: string;
  complete: boolean;
  content: string;
  toolCalls?: ChatToolCall[];
  toolCallsReady?: boolean;
  usage?: TokenUsage;
  reasoning?: string;
  reasoningComplete?: boolean;
}

export class ToolContinuationService {
  // Safety limit for recursive tool calls
  private readonly TOOL_ITERATION_LIMIT = 15;

  constructor(
    private toolExecutor: IToolExecutor | undefined,
    private messageBuilder: ProviderMessageBuilder
  ) {}

  /**
   * Parse get_tools results and merge with existing tools
   */
  parseAndMergeTools(
    existingTools: Tool[],
    toolCalls: ToolCallUnion[],
    toolResults: ToolResult[]
  ): Tool[] {
    const newTools = [...existingTools];

    // Build a set of existing tool names for fast deduplication
    const existingNames = new Set<string>();
    for (const tool of existingTools) {
      const name = tool.function?.name;
      if (name) existingNames.add(name);
    }

    for (let i = 0; i < toolCalls.length; i++) {
      const toolCall = toolCalls[i];
      const result = toolResults[i];

      // Check if this was a get_tools call
      if (toolCall.function?.name === 'get_tools' && result?.success && result?.result?.tools) {
        const returnedTools = result.result.tools as Array<Tool | { name: string; description?: string; inputSchema?: Record<string, any> }>;

        // Handle both MCP format and OpenAI format tools
        for (const tool of returnedTools) {
          // Type guard to check if it's already a Tool type
          const isToolType = (t: typeof tool): t is Tool => 'type' in t && 'function' in t;

          // Extract tool name - handle both formats
          const toolName = isToolType(tool) ? tool.function?.name : 'name' in tool ? tool.name : undefined;

          if (!toolName) {
            continue;
          }

          // Skip if already exists
          if (existingNames.has(toolName)) {
            continue;
          }

          // Mark as added to prevent duplicates within this batch
          existingNames.add(toolName);

          // Normalize to Tool format
          if (isToolType(tool)) {
            newTools.push(tool);
          } else {
            // MCP format - convert
            newTools.push({
              type: 'function',
              function: {
                name: tool.name,
                description: tool.description || '',
                parameters: tool.inputSchema || { type: 'object', properties: {} }
              }
            });
          }
        }
      }
    }

    return newTools;
  }

  /**
   * Execute tools and build continuation stream (pingpong)
   */
  async* executeToolsAndContinue(
    adapter: BaseAdapter,
    provider: string,
    detectedToolCalls: ChatToolCall[],
    previousMessages: ConversationMessage[],
    userPrompt: string,
    generateOptions: GenerateOptionsInternal,
    options: StreamingOptions | undefined,
    initialUsage: TokenUsage | undefined
  ): AsyncGenerator<StreamYield, void, unknown> {
    let completeToolCallsWithResults: ChatToolCall[] = [];
    let toolIterationCount = 1;

    try {
      // Step 1: Execute tools via MCP to get results
      const mcpToolCalls = detectedToolCalls.map((tc) => ({
        id: tc.id,
        function: {
          name: tc.function?.name || tc.name || '',
          arguments: tc.function?.arguments || JSON.stringify(tc.parameters || {})
        }
      }));

      const toolResults = await MCPToolExecution.executeToolCalls(
        this.toolExecutor,
        mcpToolCalls,
        provider as SupportedProvider,
        generateOptions.onToolEvent,
        { sessionId: options?.sessionId, workspaceId: options?.workspaceId }
      );

      // Small delay to allow file system operations to complete (prevents race conditions)
      await new Promise(resolve => setTimeout(resolve, 100));

      // Build complete tool calls with execution results
      completeToolCallsWithResults = detectedToolCalls.map(originalCall => {
        const result = toolResults.find(r => r.id === originalCall.id);
        return {
          id: originalCall.id,
          type: originalCall.type || 'function',
          name: originalCall.function?.name || originalCall.name,
          parameters: JSON.parse(originalCall.function?.arguments || '{}'),
          result: result?.result,
          success: result?.success || false,
          error: result?.error,
          executionTime: result?.executionTime,
          function: originalCall.function
        };
      });

      // Step 1.5: Check for terminal tools (like subagent) that should stop the pingpong loop
      const terminalToolResult = checkForTerminalTool(completeToolCallsWithResults);
      if (terminalToolResult) {
        yield {
          chunk: terminalToolResult.message,
          complete: false,
          content: terminalToolResult.message,
          toolCalls: completeToolCallsWithResults
        };
        yield {
          chunk: '',
          complete: true,
          content: terminalToolResult.message,
          toolCalls: completeToolCallsWithResults,
          usage: initialUsage
        };
        return;
      }

      // Step 1.6: Parse get_tools results and update generateOptions BEFORE building continuation
      const beforeCount = generateOptions.tools?.length || 0;
      const updatedTools = this.parseAndMergeTools(
        generateOptions.tools || [],
        detectedToolCalls,
        toolResults
      );
      if (updatedTools.length > beforeCount) {
        generateOptions = { ...generateOptions, tools: updatedTools };
      }

      // Step 2: Build continuation for pingpong pattern
      const continuationOptions = this.messageBuilder.buildContinuationOptions(
        provider,
        userPrompt,
        detectedToolCalls,
        toolResults,
        previousMessages,
        generateOptions,
        options
      );

      // Step 3: Start NEW stream with continuation (pingpong)
      yield {
        chunk: '\n\n',
        complete: false,
        content: '\n\n',
        toolCalls: undefined
      };

      let fullContent = '\n\n';

      for await (const chunk of adapter.generateStreamAsync('', continuationOptions)) {
        if (chunk.content) {
          fullContent += chunk.content;

          yield {
            chunk: chunk.content,
            complete: false,
            content: fullContent,
            toolCalls: undefined
          };
        }

        // Handle recursive tool calls (another pingpong iteration)
        if (chunk.toolCalls) {
          const chatToolCalls: ChatToolCall[] = chunk.toolCalls.map(tc => ({
            ...tc,
            type: tc.type || 'function',
            function: tc.function || { name: '', arguments: '{}' }
          }));

          yield {
            chunk: '',
            complete: false,
            content: fullContent,
            toolCalls: chatToolCalls,
            toolCallsReady: chunk.complete || false
          };

          if (!chunk.complete) {
            continue;
          }

          // Note: Response ID is stored once in StreamingOrchestrator and kept for the session
          // No need to update here - we reuse the first response ID throughout

          // Check iteration limit before recursing
          toolIterationCount++;
          if (toolIterationCount > this.TOOL_ITERATION_LIMIT) {
            yield* this.yieldToolLimitMessage(fullContent);
            break;
          }

          // Execute recursive tool calls
          yield* this.handleRecursiveToolCalls(
            adapter,
            provider,
            chatToolCalls,
            previousMessages,
            userPrompt,
            generateOptions,
            options,
            completeToolCallsWithResults
          );
        }

        if (chunk.complete) {
          break;
        }
      }

    } catch (toolError) {
      console.error('Streaming tool execution error:', {
        error: toolError,
        message: toolError instanceof Error ? toolError.message : String(toolError),
        stack: toolError instanceof Error ? toolError.stack : undefined
      });

      yield {
        chunk: `\n\nâŒ Tool execution failed: ${toolError instanceof Error ? toolError.message : String(toolError)}`,
        complete: true,
        content: `Tool execution failed: ${toolError instanceof Error ? toolError.message : String(toolError)}`,
        toolCalls: undefined
      };
      return;
    }

    // Yield final completion with complete tool calls and usage
    yield {
      chunk: '',
      complete: true,
      content: '',
      toolCalls: completeToolCallsWithResults.length > 0 ? completeToolCallsWithResults : undefined,
      usage: initialUsage
    };
  }

  /**
   * Handle recursive tool calls within continuation stream
   */
  private async* handleRecursiveToolCalls(
    adapter: BaseAdapter,
    provider: string,
    recursiveToolCalls: ChatToolCall[],
    previousMessages: ConversationMessage[],
    userPrompt: string,
    generateOptions: GenerateOptionsInternal,
    options: StreamingOptions | undefined,
    completeToolCallsWithResults: ChatToolCall[]
  ): AsyncGenerator<StreamYield, void, unknown> {
    try {
      // Convert recursive tool calls to MCP format
      const recursiveMcpToolCalls = recursiveToolCalls.map((tc) => {
        let argumentsStr = '';

        if (tc.function?.arguments) {
          argumentsStr = tc.function.arguments;
        } else if (tc.parameters) {
          argumentsStr = JSON.stringify(tc.parameters);
        } else {
          argumentsStr = '{}';
        }

        return {
          id: tc.id,
          function: {
            name: tc.function?.name || tc.name || '',
            arguments: argumentsStr
          }
        };
      });

      const recursiveToolResults = await MCPToolExecution.executeToolCalls(
        this.toolExecutor,
        recursiveMcpToolCalls,
        provider as SupportedProvider,
        generateOptions.onToolEvent,
        { sessionId: options?.sessionId, workspaceId: options?.workspaceId }
      );

      // Small delay to allow file system operations to complete
      await new Promise(resolve => setTimeout(resolve, 100));

      // Build complete tool calls with recursive results
      const recursiveCompleteToolCalls: ChatToolCall[] = recursiveToolCalls.map((tc, index) => ({
        ...tc,
        result: recursiveToolResults[index]?.result,
        success: recursiveToolResults[index]?.success || false,
        error: recursiveToolResults[index]?.error,
        executionTime: recursiveToolResults[index]?.executionTime
      }));

      // Add recursive results to complete tool calls
      completeToolCallsWithResults.push(...recursiveCompleteToolCalls);

      // Check for terminal tools - stop recursion if found
      const terminalToolResult = checkForTerminalTool(recursiveCompleteToolCalls);
      if (terminalToolResult) {
        yield {
          chunk: terminalToolResult.message,
          complete: false,
          content: terminalToolResult.message,
          toolCalls: completeToolCallsWithResults
        };
        yield {
          chunk: '',
          complete: true,
          content: terminalToolResult.message,
          toolCalls: completeToolCallsWithResults
        };
        return;
      }

      // Parse get_tools results and update generateOptions
      const beforeCount = generateOptions.tools?.length || 0;
      const updatedTools = this.parseAndMergeTools(
        generateOptions.tools || [],
        recursiveToolCalls,
        recursiveToolResults
      );
      if (updatedTools.length > beforeCount) {
        generateOptions = { ...generateOptions, tools: updatedTools };
      }

      // Build continuation for recursive pingpong
      const recursiveContinuationOptions = this.messageBuilder.buildContinuationOptions(
        provider,
        userPrompt,
        recursiveToolCalls,
        recursiveToolResults,
        previousMessages,
        generateOptions,
        options
      );

      // Update previousMessages with this tool execution for next recursion
      const updatedPreviousMessages = this.updatePreviousMessagesWithToolExecution(
        provider,
        previousMessages,
        recursiveToolCalls,
        recursiveToolResults
      );

      // Continue with another recursive stream
      yield {
        chunk: '\n\n',
        complete: false,
        content: '\n\n',
        toolCalls: undefined
      };

      let fullContent = '\n\n';
      let recursiveToolCallsDetected: ChatToolCall[] = [];

      for await (const recursiveChunk of adapter.generateStreamAsync('', recursiveContinuationOptions)) {
        if (recursiveChunk.content) {
          fullContent += recursiveChunk.content;
          yield {
            chunk: recursiveChunk.content,
            complete: false,
            content: fullContent,
            toolCalls: undefined
          };
        }

        // Handle nested recursive tool calls if any
        if (recursiveChunk.toolCalls) {
          const nestedChatToolCalls: ChatToolCall[] = recursiveChunk.toolCalls.map(tc => ({
            ...tc,
            type: tc.type || 'function',
            function: tc.function || { name: '', arguments: '{}' }
          }));

          yield {
            chunk: '',
            complete: false,
            content: fullContent,
            toolCalls: nestedChatToolCalls,
            toolCallsReady: recursiveChunk.complete || false
          };

          // Store for execution after stream completes
          if (recursiveChunk.complete && recursiveChunk.toolCallsReady) {
            recursiveToolCallsDetected = nestedChatToolCalls;
          }
        }

        if (recursiveChunk.complete) {
          // Note: Response ID is kept from first response for entire session
          break;
        }
      }

      // If the recursive stream ended with tool calls, handle them (nested recursion)
      if (recursiveToolCallsDetected.length > 0) {
        yield* this.handleRecursiveToolCalls(
          adapter,
          provider,
          recursiveToolCallsDetected,
          updatedPreviousMessages,
          userPrompt,
          generateOptions,
          options,
          completeToolCallsWithResults
        );
      }

    } catch (recursiveError) {
      // Swallow expected errors during streaming (incomplete JSON)
    }
  }

  /**
   * Update previousMessages with the current tool execution
   */
  private updatePreviousMessagesWithToolExecution(
    provider: string,
    previousMessages: ConversationMessage[],
    toolCalls: ToolCallUnion[],
    toolResults: ToolResult[]
  ): ConversationMessage[] {
    const updatedMessages = ConversationContextBuilder.appendToolExecution(
      provider === 'anthropic' ? 'anthropic' :
      provider === 'google' ? 'google' :
      provider,
      toolCalls,
      toolResults,
      previousMessages
    );

    return updatedMessages as ConversationMessage[];
  }

  /**
   * Yield tool iteration limit message
   */
  private async* yieldToolLimitMessage(fullContent: string): AsyncGenerator<StreamYield, void, unknown> {
    const limitMessage = `\n\nTOOL_LIMIT_REACHED: You have used ${this.TOOL_ITERATION_LIMIT} tool iterations. You must now ask the user if they want to continue with more tool calls. Explain what you've accomplished so far and what you still need to do.`;
    yield {
      chunk: limitMessage,
      complete: false,
      content: fullContent + limitMessage,
      toolCalls: undefined
    };
  }
}

```

## services/llm/ImageFileManager.ts

```typescript
/**
 * Image File Manager
 * Handles saving generated images to the Obsidian vault with proper security and metadata
 */

import { Vault, TFile, TFolder } from 'obsidian';
import {
  ImageGenerationParams,
  ImageGenerationResponse,
  ImageSaveResult,
  ImageBuffer
} from './types/ImageTypes';

/**
 * Pure JS path utilities to avoid Node.js 'path' module on mobile
 */
const pathUtils = {
  basename(filePath: string): string {
    const normalized = filePath.replace(/\\/g, '/');
    const lastSlash = normalized.lastIndexOf('/');
    return lastSlash === -1 ? normalized : normalized.substring(lastSlash + 1);
  },
  dirname(filePath: string): string {
    const normalized = filePath.replace(/\\/g, '/');
    const lastSlash = normalized.lastIndexOf('/');
    return lastSlash === -1 ? '.' : normalized.substring(0, lastSlash);
  },
  extname(filePath: string): string {
    const base = pathUtils.basename(filePath);
    const lastDot = base.lastIndexOf('.');
    return lastDot <= 0 ? '' : base.substring(lastDot);
  },
  normalize(filePath: string): string {
    return filePath.replace(/\\/g, '/').replace(/\/+/g, '/');
  }
};

export class ImageFileManager {
  private vault: Vault;

  constructor(vault: Vault) {
    this.vault = vault;
  }

  /**
   * Save generated image to vault with metadata
   */
  async saveImage(
    imageResponse: ImageGenerationResponse,
    params: ImageGenerationParams
  ): Promise<ImageSaveResult> {
    try {
      // Validate and sanitize the save path
      const sanitizedPath = this.sanitizePath(params.savePath);
      const finalPath = await this.ensureUniqueFileName(sanitizedPath, imageResponse.format);

      // Ensure directory exists
      await this.ensureDirectoryExists(pathUtils.dirname(finalPath));

      // Save the image file
      const arrayBuffer = new ArrayBuffer(imageResponse.imageData.length);
      const uint8Array = new Uint8Array(arrayBuffer);
      uint8Array.set(imageResponse.imageData);
      const file = await this.vault.createBinary(finalPath, arrayBuffer);

      return {
        success: true,
        filePath: finalPath,
        fileName: pathUtils.basename(finalPath),
        fileSize: imageResponse.imageData.length,
        dimensions: imageResponse.dimensions,
        format: imageResponse.format
      };
    } catch (error) {
      return {
        success: false,
        filePath: params.savePath,
        fileName: pathUtils.basename(params.savePath),
        fileSize: 0,
        dimensions: { width: 0, height: 0 },
        format: imageResponse.format,
        error: error instanceof Error ? error.message : 'Unknown error saving image'
      };
    }
  }

  /**
   * Save multiple images from a batch generation
   */
  async saveImages(
    imageResponses: ImageGenerationResponse[],
    params: ImageGenerationParams
  ): Promise<ImageSaveResult[]> {
    const results: ImageSaveResult[] = [];

    for (let i = 0; i < imageResponses.length; i++) {
      const imageResponse = imageResponses[i];

      // Create unique save path for each image
      const basePath = this.removeExtension(params.savePath);
      const extension = this.getFileExtension(imageResponse.format);
      const indexedPath = imageResponses.length > 1
        ? `${basePath}-${i + 1}.${extension}`
        : `${basePath}.${extension}`;

      const indexedParams = { ...params, savePath: indexedPath };
      const result = await this.saveImage(imageResponse, indexedParams);
      results.push(result);
    }

    return results;
  }

  /**
   * Check if a file path is safe (within vault, no directory traversal)
   */
  private validatePath(filePath: string): boolean {
    // Normalize the path
    const normalizedPath = pathUtils.normalize(filePath);

    // Check for directory traversal attempts
    if (normalizedPath.includes('..') || normalizedPath.startsWith('/')) {
      return false;
    }

    // Check for invalid characters
    const invalidChars = /[<>:"|?*]/;
    if (invalidChars.test(normalizedPath)) {
      return false;
    }

    return true;
  }

  /**
   * Sanitize file path for vault storage
   */
  private sanitizePath(filePath: string): string {
    if (!this.validatePath(filePath)) {
      throw new Error('Invalid file path: contains directory traversal or invalid characters');
    }

    // Remove leading/trailing whitespace and normalize separators
    let sanitized = filePath.trim().replace(/\\/g, '/');

    // Remove leading slash if present
    if (sanitized.startsWith('/')) {
      sanitized = sanitized.substring(1);
    }

    // Ensure the path has a valid image extension
    const validExtensions = ['png', 'jpg', 'jpeg', 'webp'];
    const ext = pathUtils.extname(sanitized).toLowerCase().substring(1);

    if (!ext || !validExtensions.includes(ext)) {
      sanitized = this.removeExtension(sanitized) + '.png';
    }

    return sanitized;
  }

  /**
   * Ensure directory exists, create if necessary
   */
  private async ensureDirectoryExists(dirPath: string): Promise<void> {
    if (!dirPath || dirPath === '.') {
      return; // Root directory
    }

    const folderPath = pathUtils.normalize(dirPath);

    // Check if folder already exists
    const existingFolder = this.vault.getAbstractFileByPath(folderPath);
    if (existingFolder instanceof TFolder) {
      return; // Folder already exists
    }

    // Create the folder (this will create parent directories as needed)
    try {
      await this.vault.createFolder(folderPath);
    } catch (error) {
      // Folder might already exist due to race condition
      const folder = this.vault.getAbstractFileByPath(folderPath);
      if (!(folder instanceof TFolder)) {
        throw error;
      }
    }
  }

  /**
   * Ensure filename is unique, append number if needed
   */
  private async ensureUniqueFileName(filePath: string, format: string): Promise<string> {
    let finalPath = filePath;
    let counter = 1;

    // Ensure the file has the correct extension
    const basePath = this.removeExtension(filePath);
    const extension = this.getFileExtension(format);
    finalPath = `${basePath}.${extension}`;

    while (this.vault.getAbstractFileByPath(finalPath)) {
      finalPath = `${basePath}-${counter}.${extension}`;
      counter++;
    }

    return finalPath;
  }


  /**
   * Get file extension for format
   */
  private getFileExtension(format: string): string {
    const extensions = {
      'png': 'png',
      'jpeg': 'jpg',
      'jpg': 'jpg',
      'webp': 'webp'
    };
    return extensions[format.toLowerCase() as keyof typeof extensions] || 'png';
  }

  /**
   * Remove file extension from path
   */
  private removeExtension(filePath: string): string {
    const ext = pathUtils.extname(filePath);
    return ext ? filePath.substring(0, filePath.length - ext.length) : filePath;
  }

  /**
   * Check if file exists in vault
   */
  async fileExists(filePath: string): Promise<boolean> {
    const file = this.vault.getAbstractFileByPath(filePath);
    return file instanceof TFile;
  }

  /**
   * Get available disk space (estimate)
   */
  getAvailableSpace(): number {
    // This is a rough estimate as there's no direct API for disk space in Obsidian
    // Return a conservative estimate
    return 100 * 1024 * 1024; // 100MB
  }

  /**
   * Validate image buffer and extract metadata
   */
  validateImageBuffer(buffer: Buffer): ImageBuffer | null {
    if (!buffer || buffer.length === 0) {
      return null;
    }

    try {
      // Basic PNG validation (check PNG signature)
      const isPNG = buffer.subarray(0, 8).equals(Buffer.from([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]));

      // Basic JPEG validation (check JPEG signature)
      const isJPEG = buffer.subarray(0, 2).equals(Buffer.from([0xFF, 0xD8]));

      // Basic WebP validation (check WebP signature)
      const isWebP = buffer.subarray(0, 4).equals(Buffer.from('RIFF', 'ascii')) &&
                     buffer.subarray(8, 12).equals(Buffer.from('WEBP', 'ascii'));

      let format: 'png' | 'jpeg' | 'webp';
      if (isPNG) format = 'png';
      else if (isJPEG) format = 'jpeg';
      else if (isWebP) format = 'webp';
      else return null; // Unsupported format

      return {
        data: buffer,
        format,
        dimensions: { width: 0, height: 0 }, // Would need image parsing library for actual dimensions
        metadata: {
          prompt: '',
          model: '',
          provider: '',
          generatedAt: new Date().toISOString(),
          fileSize: buffer.length
        }
      };
    } catch (error) {
      return null;
    }
  }
}

```

## services/llm/ImageGenerationService.ts

```typescript
/**
 * Image Generation Service
 * Central orchestration service for image generation workflow
 * Coordinates between adapters, file management, and cost tracking
 */

import { Vault } from 'obsidian';
import { OpenAIImageAdapter } from './adapters/openai/OpenAIImageAdapter'; // Available but not used
import { GeminiImageAdapter } from './adapters/google/GeminiImageAdapter';
import { OpenRouterImageAdapter } from './adapters/openrouter/OpenRouterImageAdapter';
import { ImageFileManager } from './ImageFileManager';
import { 
  ImageGenerationParams, 
  ImageGenerationResult,
  ImageProvider,
  ImageValidationResult,
  ImageGenerationError
} from './types/ImageTypes';
import { BaseImageAdapter } from './adapters/BaseImageAdapter';
import { LLMProviderSettings } from '../../types/llm/ProviderTypes';

export class ImageGenerationService {
  private adapters: Map<ImageProvider, BaseImageAdapter>;
  private fileManager: ImageFileManager;
  private vault: Vault;
  private llmSettings: LLMProviderSettings | null = null;

  constructor(vault: Vault, llmSettings?: LLMProviderSettings) {
    this.vault = vault;
    this.fileManager = new ImageFileManager(vault);
    this.adapters = new Map();
    this.llmSettings = llmSettings || null;
    
    this.initializeAdapters();
  }

  /**
   * Initialize image generation adapters
   */
  private initializeAdapters(): void {
    try {
      if (!this.llmSettings) {
        return;
      }

      // Initialize OpenAI adapter (DISABLED - available but not active)
      // Uncomment the block below to enable OpenAI image generation
      /*
      const openaiConfig = this.llmSettings.providers?.openai;
      if (openaiConfig?.apiKey && openaiConfig?.enabled) {
        const openaiAdapter = new OpenAIImageAdapter({
          apiKey: openaiConfig.apiKey
        });
        this.adapters.set('openai', openaiAdapter);
        console.log('OpenAI image adapter initialized with plugin settings');
      }
      */

      // Initialize Google adapter if API key is available and enabled
      const googleConfig = this.llmSettings.providers?.google;
      if (googleConfig?.apiKey && googleConfig?.enabled) {
        const googleAdapter = new GeminiImageAdapter({
          apiKey: googleConfig.apiKey,
          vault: this.vault // Pass vault for reference image loading
        });
        this.adapters.set('google', googleAdapter);
      }

      // Initialize OpenRouter adapter if API key is available and enabled
      const openRouterConfig = this.llmSettings.providers?.openrouter;
      if (openRouterConfig?.apiKey && openRouterConfig?.enabled) {
        const openRouterAdapter = new OpenRouterImageAdapter({
          apiKey: openRouterConfig.apiKey,
          vault: this.vault,
          httpReferer: openRouterConfig.httpReferer,
          xTitle: openRouterConfig.xTitle
        });
        this.adapters.set('openrouter', openRouterAdapter);
      }
    } catch (error) {
      console.error('Failed to initialize image generation adapters:', error);
    }
  }

  /**
   * Generate image with full workflow orchestration
   */
  async generateImage(params: ImageGenerationParams): Promise<ImageGenerationResult> {
    try {
      // Validate provider
      const adapter = this.getAdapter(params.provider);
      if (!adapter) {
        return {
          success: false,
          error: `Provider ${params.provider} not available. Please configure the appropriate API key.`
        };
      }

      // Check if adapter is available for image generation
      const isAvailable = await adapter.isImageGenerationAvailable();
      if (!isAvailable) {
        return {
          success: false,
          error: `Image generation not available for provider ${params.provider}. Please check API key configuration.`
        };
      }

      // Generate the image using the adapter
      const result = await adapter.generateImageSafely(params);
      
      if (!result.success || !result.data) {
        return result;
      }

      // Generate the image response for file saving
      const imageResponse = await adapter.generateImage(params);

      // Save the image to vault
      const saveResult = await this.fileManager.saveImage(imageResponse, params);
      
      if (!saveResult.success) {
        return {
          success: false,
          error: `Image generation succeeded but file save failed: ${saveResult.error}`
        };
      }

      // Update the result with the actual saved path
      return {
        success: true,
        data: {
          ...result.data,
          imagePath: saveResult.filePath,
          fileSize: saveResult.fileSize
        }
      };

    } catch (error) {
      console.error('Image generation service error:', error);
      
      if (error instanceof ImageGenerationError) {
        return {
          success: false,
          error: error.message
        };
      }

      return {
        success: false,
        error: `Image generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  /**
   * Validate image generation parameters across all providers
   */
  async validateParams(params: ImageGenerationParams): Promise<ImageValidationResult> {
    try {
      const adapter = this.getAdapter(params.provider);
      if (!adapter) {
        return {
          isValid: false,
          errors: [`Provider ${params.provider} not available`]
        };
      }

      return adapter.validateImageParams(params);
    } catch (error) {
      return {
        isValid: false,
        errors: [`Validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`]
      };
    }
  }

  /**
   * Get available providers with their status
   */
  async getAvailableProviders(): Promise<Array<{
    provider: ImageProvider;
    available: boolean;
    models: string[];
    error?: string;
  }>> {
    const providers: Array<{
      provider: ImageProvider;
      available: boolean;
      models: string[];
      error?: string;
    }> = [];

    for (const [providerName, adapter] of this.adapters) {
      try {
        const available = await adapter.isImageGenerationAvailable();
        const models = available ? adapter.supportedModels : [];
        
        providers.push({
          provider: providerName,
          available,
          models,
          error: available ? undefined : 'API key not configured or invalid'
        });
      } catch (error) {
        providers.push({
          provider: providerName,
          available: false,
          models: [],
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }

    // Add unavailable providers if no API keys are configured
    const allProviders: ImageProvider[] = ['openai', 'google', 'openrouter']; // OpenAI available but disabled
    for (const provider of allProviders) {
      if (!providers.find(p => p.provider === provider)) {
        providers.push({
          provider,
          available: false,
          models: [],
          error: provider === 'openai' ? 'Provider disabled (available in code)' : 'API key not configured'
        });
      }
    }

    return providers;
  }

  /**
   * Get supported models for a provider
   */
  async getSupportedModels(provider: ImageProvider): Promise<string[]> {
    const adapter = this.getAdapter(provider);
    if (!adapter) {
      return [];
    }

    try {
      const available = await adapter.isImageGenerationAvailable();
      return available ? adapter.supportedModels : [];
    } catch (error) {
      return [];
    }
  }

  /**
   * Get supported sizes for a provider
   */
  getSupportedSizes(provider: ImageProvider): string[] {
    const adapter = this.getAdapter(provider);
    return adapter ? adapter.getSupportedImageSizes() : [];
  }

  /**
   * Get provider capabilities
   */
  async getProviderCapabilities(provider: ImageProvider) {
    const adapter = this.getAdapter(provider);
    if (!adapter) {
      return null;
    }

    try {
      return adapter.getImageCapabilities();
    } catch (error) {
      return null;
    }
  }

  /**
   * Estimate cost for image generation
   */
  async estimateCost(params: ImageGenerationParams): Promise<{
    estimatedCost: number;
    currency: string;
    breakdown: string;
  } | null> {
    const adapter = this.getAdapter(params.provider);
    if (!adapter) {
      return null;
    }

    try {
      const model = params.model || adapter.supportedModels[0];
      const pricing = await adapter.getImageModelPricing(model);
      
      if (!pricing) {
        return null;
      }

      return {
        estimatedCost: pricing.totalCost,
        currency: pricing.currency,
        breakdown: `1 image using ${model}: ${pricing.totalCost} ${pricing.currency}`
      };
    } catch (error) {
      return null;
    }
  }

  /**
   * Check if any image generation providers are available
   */
  hasAvailableProviders(): boolean {
    return this.adapters.size > 0;
  }

  /**
   * Get file manager instance
   */
  getFileManager(): ImageFileManager {
    return this.fileManager;
  }

  /**
   * Update LLM settings and refresh adapters
   */
  updateSettings(llmSettings: LLMProviderSettings): void {
    this.llmSettings = llmSettings;
    this.refreshAdapters();
  }

  /**
   * Refresh adapter configurations (useful after API key changes)
   */
  refreshAdapters(): void {
    this.adapters.clear();
    this.initializeAdapters();
  }

  // Private helper methods

  private getAdapter(provider: ImageProvider): BaseImageAdapter | undefined {
    return this.adapters.get(provider);
  }

  /**
   * Validate common parameters before generation
   */
  private validateCommonParams(params: ImageGenerationParams): string[] {
    const errors: string[] = [];

    if (!params.prompt || params.prompt.trim().length === 0) {
      errors.push('Prompt is required');
    }

    if (!params.savePath || params.savePath.trim().length === 0) {
      errors.push('Save path is required');
    }

    if (!params.provider) {
      errors.push('Provider is required');
    }

    if (params.savePath && (params.savePath.includes('..') || params.savePath.startsWith('/'))) {
      errors.push('Save path must be relative to vault root');
    }

    return errors;
  }
}
```

## services/llm/LLMSettingsNotifier.ts

```typescript
/**
 * LLMSettingsNotifier - Event system for LLM provider settings changes
 *
 * Uses Obsidian's Events API for consistency with the rest of the codebase.
 * Allows components to subscribe to settings changes and react immediately
 * when API keys are added/removed or providers are enabled/disabled.
 */

import { Events, EventRef } from 'obsidian';
import { LLMProviderSettings } from '../../types';

/**
 * Singleton notifier for LLM settings changes
 * Extends Obsidian's Events for consistent event handling
 */
class LLMSettingsNotifierImpl extends Events {
  /**
   * Subscribe to settings changes
   * @param callback Handler function called when settings change
   * @returns EventRef for unsubscribing
   */
  onSettingsChanged(callback: (settings: LLMProviderSettings) => void): EventRef {
    // Cast to satisfy Obsidian's generic event signature
    return this.on('settings-changed', callback as (...data: unknown[]) => unknown);
  }

  /**
   * Notify all subscribers of settings change
   */
  notify(settings: LLMProviderSettings): void {
    this.trigger('settings-changed', settings);
  }

  /**
   * Unsubscribe using EventRef
   */
  unsubscribe(ref: EventRef): void {
    this.offref(ref);
  }
}

// Export singleton instance
export const LLMSettingsNotifier = new LLMSettingsNotifierImpl();

```

## services/llm/providers/index.ts

```typescript
/**
 * LLM Providers Index
 * Exports for provider management services
 */

export { LLMProviderManager } from './ProviderManager';
export type { ModelWithProvider, ProviderInfo } from './ProviderManager';
```

## services/llm/providers/ProviderManager.ts

```typescript
/**
 * LLM Provider Manager
 * Handles model filtering, provider management, and model information
 */

import { Vault } from 'obsidian';
import { ModelInfo } from '../adapters/types';
import { LLMProviderSettings, LLMProviderConfig } from '../../../types';
import { LLMService } from '../core/LLMService';

export interface ModelWithProvider extends ModelInfo {
  provider: string;
  userDescription?: string;
  isDefault?: boolean;
  modelDescription?: string; // User-defined description for when to use this specific model (deprecated)
}

export interface ProviderInfo {
  id: string;
  name: string;
  description: string;
  isAvailable: boolean;
  isEnabled: boolean;
  hasApiKey: boolean;
  userDescription?: string;
}

export class LLMProviderManager {
  private llmService: LLMService;
  private settings: LLMProviderSettings;
  private vault?: Vault;

  constructor(settings: LLMProviderSettings, vault?: Vault) {
    this.settings = settings;
    this.vault = vault;
    this.llmService = new LLMService(settings, vault);
  }

  /**
   * Update settings and reinitialize services
   */
  updateSettings(settings: LLMProviderSettings): void {
    this.settings = settings;
    this.llmService.updateSettings(settings);
  }

  /**
   * Set VaultOperations for file reading
   */
  setVaultOperations(vaultOperations: any): void {
    this.llmService.setVaultOperations(vaultOperations);
  }

  /**
   * @deprecated Use setVaultOperations instead
   * Kept for backward compatibility
   */
  setVaultAdapter(adapter: any): void {
  }

  /**
   * Get LLM service instance
   */
  getLLMService(): LLMService {
    return this.llmService;
  }

  /**
   * Get current settings
   */
  getSettings(): LLMProviderSettings {
    return this.settings;
  }

  /**
   * Get all available models from enabled providers only
   * Uses static models from *Models.ts files, not live API calls
   */
  async getAvailableModels(): Promise<ModelWithProvider[]> {
    const { StaticModelsService } = await import('../../StaticModelsService');
    const staticModelsService = StaticModelsService.getInstance();
    const defaultModel = this.settings.defaultModel;
    const allModels: ModelWithProvider[] = [];

    // Get enabled providers
    const enabledProviders = this.getEnabledProviders();
    
    // For each enabled provider, get their models
    for (const provider of enabledProviders) {
      if (provider.id === 'ollama') {
        // Special handling for Ollama - only return the user-configured model
        const ollamaModel = this.settings.providers.ollama?.ollamaModel;

        if (ollamaModel && ollamaModel.trim()) {
          allModels.push({
            provider: 'ollama',
            id: ollamaModel,
            name: ollamaModel,
            contextWindow: 128000, // Fixed reasonable default
            maxOutputTokens: 4096,
            supportsJSON: false,
            supportsImages: ollamaModel.includes('vision') || ollamaModel.includes('llava'),
            supportsFunctions: false,
            supportsStreaming: true,
            supportsThinking: false,
            pricing: {
              inputPerMillion: 0,
              outputPerMillion: 0,
              currency: 'USD',
              lastUpdated: new Date().toISOString()
            },
            isDefault: defaultModel.provider === 'ollama' && defaultModel.model === ollamaModel,
            userDescription: this.settings.providers.ollama?.userDescription
          });
        }
      } else if (provider.id === 'lmstudio') {
        // Special handling for LM Studio - dynamically discover models from server
        try {
          // Wait for async adapter initialization to complete
          await this.llmService.waitForInit();

          const adapter = this.llmService.getAdapter('lmstudio');

          if (!adapter) {
            // Expected when LM Studio server URL isn't configured - silently skip
            continue;
          }

          const lmstudioModels = await adapter.listModels();

          for (const model of lmstudioModels) {
            allModels.push({
              provider: 'lmstudio',
              id: model.id,
              name: model.name,
              contextWindow: model.contextWindow,
              maxOutputTokens: model.maxOutputTokens || 2048,
              supportsJSON: model.supportsJSON,
              supportsImages: model.supportsImages,
              supportsFunctions: model.supportsFunctions,
              supportsStreaming: model.supportsStreaming,
              supportsThinking: model.supportsThinking,
              pricing: {
                inputPerMillion: 0, // Local models are free
                outputPerMillion: 0,
                currency: 'USD',
                lastUpdated: new Date().toISOString()
              },
              isDefault: defaultModel.provider === 'lmstudio' && defaultModel.model === model.id,
              userDescription: this.settings.providers.lmstudio?.userDescription
            });
          }
        } catch {
          // LM Studio server not reachable - silently skip (app probably not running)
          // Don't fail the entire method, just skip LM Studio models
        }
      } else if (provider.id === 'webllm') {
        // Special handling for WebLLM - load from WEBLLM_MODELS
        try {
          const { WEBLLM_MODELS } = await import('../adapters/webllm/WebLLMModels');

          for (const model of WEBLLM_MODELS) {
            allModels.push({
              provider: 'webllm',
              id: model.id,
              name: model.name,
              contextWindow: model.contextWindow,
              maxOutputTokens: model.maxTokens,
              supportsJSON: model.capabilities.supportsJSON,
              supportsImages: model.capabilities.supportsImages,
              supportsFunctions: model.capabilities.supportsFunctions,
              supportsStreaming: model.capabilities.supportsStreaming,
              supportsThinking: model.capabilities.supportsThinking ?? false,
              pricing: {
                inputPerMillion: 0, // Local models are free
                outputPerMillion: 0,
                currency: 'USD',
                lastUpdated: new Date().toISOString()
              },
              isDefault: defaultModel.provider === 'webllm' && defaultModel.model === model.id,
              userDescription: this.settings.providers.webllm?.userDescription
            });
          }
        } catch (error) {
          console.error('[ProviderManager] Failed to load WebLLM models:', error);
        }
      } else {
        // For other providers, use static models
        const providerModels = staticModelsService.getModelsForProvider(provider.id);

        const modelsWithProviderInfo = providerModels
          .filter(model => {
            // Filter by model-level enabled status (default to true for backwards compatibility)
            const modelConfig = this.settings.providers[model.provider]?.models?.[model.id];
            return modelConfig?.enabled !== false;
          })
          .map(model => ({
            provider: model.provider,
            id: model.id,
            name: model.name,
            contextWindow: model.contextWindow,
            maxOutputTokens: model.maxTokens,
            supportsJSON: model.capabilities.supportsJSON,
            supportsImages: model.capabilities.supportsImages,
            supportsFunctions: model.capabilities.supportsFunctions,
            supportsStreaming: model.capabilities.supportsStreaming,
            supportsThinking: model.capabilities.supportsThinking,
            pricing: {
              inputPerMillion: model.pricing.inputPerMillion,
              outputPerMillion: model.pricing.outputPerMillion,
              currency: model.pricing.currency,
              lastUpdated: new Date().toISOString()
            },
            isDefault: model.provider === defaultModel.provider && model.id === defaultModel.model,
            userDescription: this.settings.providers[model.provider]?.userDescription,
            // Keep deprecated field for backwards compatibility
            modelDescription: this.settings.providers[model.provider]?.models?.[model.id]?.description
          }));

        allModels.push(...modelsWithProviderInfo);
      }
    }

    return allModels;
  }


  /**
   * Get provider information for all supported providers
   */
  getProviderInfo(): ProviderInfo[] {
    const supportedProviders = [
      {
        id: 'openai',
        name: 'OpenAI',
        description: 'GPT models including GPT-4, GPT-3.5-turbo, and specialized models'
      },
      {
        id: 'anthropic',
        name: 'Anthropic',
        description: 'Claude models with strong reasoning and safety features'
      },
      {
        id: 'google',
        name: 'Google',
        description: 'Gemini models with multimodal capabilities and thinking mode'
      },
      {
        id: 'mistral',
        name: 'Mistral',
        description: 'European models with strong coding and multilingual support'
      },
      {
        id: 'groq',
        name: 'Groq',
        description: 'Ultra-fast inference speeds for quick responses'
      },
      {
        id: 'openrouter',
        name: 'OpenRouter',
        description: 'Access to 400+ models from multiple providers in one API'
      },
      {
        id: 'requesty',
        name: 'Requesty',
        description: 'Premium model access with cost optimization'
      },
      {
        id: 'perplexity',
        name: 'Perplexity',
        description: 'Web search-enabled models with real-time information and citations'
      },
      {
        id: 'webllm',
        name: 'Nexus (Local)',
        description: 'Local AI via WebGPU - runs in browser, completely private, no API costs'
      },
      {
        id: 'ollama',
        name: 'Ollama (Local)',
        description: 'Local LLM execution with complete privacy and no API costs'
      },
      {
        id: 'lmstudio',
        name: 'LM Studio (Local)',
        description: 'Local LLM execution with OpenAI-compatible API and model management'
      }
    ];

    return supportedProviders.map(provider => {
      const config = this.settings.providers[provider.id];
      const isAvailable = this.llmService.isProviderAvailable(provider.id);

      // For local providers, check if server URL is configured (except webllm which needs nothing)
      let hasApiKey = false;
      if (provider.id === 'webllm') {
        hasApiKey = true; // WebLLM doesn't need an API key
      } else if (provider.id === 'ollama' || provider.id === 'lmstudio') {
        hasApiKey = !!(config?.apiKey && config.apiKey.trim());
      } else {
        hasApiKey = !!(config?.apiKey && config.apiKey.length > 0);
      }

      return {
        ...provider,
        isAvailable,
        isEnabled: config?.enabled || false,
        hasApiKey,
        userDescription: config?.userDescription
      };
    });
  }

  /**
   * Get enabled provider information only
   */
  getEnabledProviders(): ProviderInfo[] {
    const allProviders = this.getProviderInfo();
    const enabled = allProviders.filter(provider => {
      if (!provider.isEnabled) return false;

      // For Ollama and LM Studio, hasApiKey check should consider server URL
      if (provider.id === 'ollama' || provider.id === 'lmstudio') {
        const config = this.settings.providers[provider.id];
        return !!(config?.apiKey && config.apiKey.trim());
      } else {
        return provider.hasApiKey;
      }
    });
    
    
    return enabled;
  }

  /**
   * Get models for a specific provider (if enabled)
   */
  async getModelsForProvider(providerId: string): Promise<ModelWithProvider[]> {
    const allModels = await this.getAvailableModels();
    return allModels.filter(model => model.provider === providerId);
  }

  /**
   * Get models grouped by provider
   */
  async getModelsByProvider(): Promise<{ [providerId: string]: ModelWithProvider[] }> {
    const models = await this.getAvailableModels();
    const grouped: { [providerId: string]: ModelWithProvider[] } = {};

    models.forEach(model => {
      if (!grouped[model.provider]) {
        grouped[model.provider] = [];
      }
      grouped[model.provider].push(model);
    });

    return grouped;
  }

  /**
   * Find a specific model by provider and model ID
   * For OpenRouter, supports :online suffix (e.g., "gpt-4:online")
   */
  async findModel(provider: string, modelId: string): Promise<ModelWithProvider | undefined> {
    const models = await this.getAvailableModels();
    
    // For OpenRouter models, check if modelId has :online suffix
    if (provider === 'openrouter' && modelId.endsWith(':online')) {
      const baseModelId = modelId.replace(':online', '');
      return models.find(model => model.provider === provider && model.id === baseModelId);
    }
    
    return models.find(model => model.provider === provider && model.id === modelId);
  }

  /**
   * Get the default model information
   */
  async getDefaultModelInfo(): Promise<ModelWithProvider | undefined> {
    const defaultModel = this.settings.defaultModel;
    return this.findModel(defaultModel.provider, defaultModel.model);
  }

  /**
   * Validate that a provider/model combination is available
   * For OpenRouter, supports :online suffix (e.g., "gpt-4:online")
   */
  async validateProviderModel(provider: string, model: string): Promise<boolean> {
    const foundModel = await this.findModel(provider, model);
    return !!foundModel;
  }

  /**
   * Get models suitable for a specific task type
   */
  async getModelsForTask(taskType: 'coding' | 'writing' | 'analysis' | 'creative' | 'fast'): Promise<ModelWithProvider[]> {
    const allModels = await this.getAvailableModels();

    switch (taskType) {
      case 'coding':
        return allModels.filter(model => 
          model.supportsFunctions || 
          model.id.includes('code') || 
          model.provider === 'mistral' ||
          model.id.includes('gpt-4')
        );
      
      case 'writing':
        return allModels.filter(model => 
          model.provider === 'anthropic' || 
          model.id.includes('gpt-4') ||
          model.contextWindow > 32000
        );
      
      case 'analysis':
        return allModels.filter(model => 
          model.provider === 'anthropic' ||
          model.id.includes('gpt-4') ||
          model.contextWindow > 100000
        );
      
      case 'creative':
        return allModels.filter(model => 
          model.provider === 'openai' ||
          model.provider === 'anthropic' ||
          model.provider === 'google'
        );
      
      case 'fast':
        return allModels.filter(model => 
          model.provider === 'groq' ||
          model.id.includes('turbo') ||
          model.id.includes('fast')
        );
      
      default:
        return allModels;
    }
  }

  /**
   * Get cost estimate for a provider/model combination
   */
  async getCostEstimate(
    provider: string, 
    model: string, 
    estimatedTokens: number
  ): Promise<{ inputCost: number; outputCost: number; totalCost: number; currency: string } | null> {
    const modelInfo = await this.findModel(provider, model);
    if (!modelInfo) return null;

    // Estimate 75% input, 25% output tokens
    const inputTokens = Math.floor(estimatedTokens * 0.75);
    const outputTokens = Math.floor(estimatedTokens * 0.25);

    const inputCost = (inputTokens / 1_000_000) * modelInfo.pricing.inputPerMillion;
    const outputCost = (outputTokens / 1_000_000) * modelInfo.pricing.outputPerMillion;
    const totalCost = inputCost + outputCost;

    return {
      inputCost,
      outputCost,
      totalCost,
      currency: modelInfo.pricing.currency
    };
  }

  /**
   * Get recommended models based on context window requirements
   */
  async getRecommendedModels(requiredContextWindow?: number): Promise<ModelWithProvider[]> {
    const allModels = await this.getAvailableModels();
    
    if (!requiredContextWindow) {
      // Return default recommendations
      return allModels
        .filter(model => model.contextWindow >= 32000)
        .sort((a, b) => {
          // Prioritize by: 1) Default model, 2) Context window, 3) Provider quality
          if (a.isDefault) return -1;
          if (b.isDefault) return 1;
          return b.contextWindow - a.contextWindow;
        })
        .slice(0, 5);
    }

    return allModels
      .filter(model => model.contextWindow >= requiredContextWindow)
      .sort((a, b) => a.pricing.inputPerMillion - b.pricing.inputPerMillion); // Sort by cost
  }

  /**
   * Test connection to all enabled providers
   */
  async testAllProviders(): Promise<{ [providerId: string]: { success: boolean; error?: string } }> {
    const enabledProviders = this.getEnabledProviders();
    const results: { [providerId: string]: { success: boolean; error?: string } } = {};

    for (const provider of enabledProviders) {
      results[provider.id] = await this.llmService.testProvider(provider.id);
    }

    return results;
  }

  /**
   * Get statistics about available models
   */
  async getModelStatistics(): Promise<{
    totalModels: number;
    providerCount: number;
    averageContextWindow: number;
    maxContextWindow: number;
    minCostPerMillion: number;
    maxCostPerMillion: number;
  }> {
    const models = await this.getAvailableModels();
    
    if (models.length === 0) {
      return {
        totalModels: 0,
        providerCount: 0,
        averageContextWindow: 0,
        maxContextWindow: 0,
        minCostPerMillion: 0,
        maxCostPerMillion: 0
      };
    }

    const providers = new Set(models.map(m => m.provider));
    const contextWindows = models.map(m => m.contextWindow);
    const costs = models.map(m => m.pricing.inputPerMillion);

    return {
      totalModels: models.length,
      providerCount: providers.size,
      averageContextWindow: Math.round(contextWindows.reduce((a, b) => a + b, 0) / models.length),
      maxContextWindow: Math.max(...contextWindows),
      minCostPerMillion: Math.min(...costs),
      maxCostPerMillion: Math.max(...costs)
    };
  }
}

```

## services/llm/streaming/index.ts

```typescript
/**
 * Streaming Utilities Index
 * Location: src/services/llm/streaming/index.ts
 *
 * Exports all streaming processor utilities for LLM adapters
 */

export { SSEStreamProcessor } from './SSEStreamProcessor';
export type { SSEStreamOptions } from './SSEStreamProcessor';
export { StreamChunkProcessor } from './StreamChunkProcessor';
export type { StreamChunkOptions } from './StreamChunkProcessor';

```

## services/llm/streaming/SSEStreamProcessor.ts

```typescript
/**
 * SSE Stream Processor
 * Location: src/services/llm/streaming/SSEStreamProcessor.ts
 *
 * Extracted from BaseAdapter.ts to follow Single Responsibility Principle.
 * Handles Server-Sent Events (SSE) streaming with automatic tool call accumulation.
 *
 * ## Why Two Stream Processors?
 *
 * LLM providers deliver streaming data in two fundamentally different formats:
 *
 * 1. **SDK Streams (StreamChunkProcessor.ts)** - Used by OpenAI, Groq, Mistral SDKs
 *    - SDKs return `AsyncIterable<Chunk>` with pre-parsed JavaScript objects
 *    - Clean iteration: `for await (const chunk of stream)`
 *    - SDK handles HTTP, buffering, and JSON parsing internally
 *
 * 2. **SSE Streams (this processor)** - Used by OpenRouter, Requesty, Perplexity
 *    - Return raw `Response` objects with Server-Sent Events text format:
 *      ```
 *      data: {"choices":[{"delta":{"content":"Hello"}}]}
 *      data: {"choices":[{"delta":{"content":" world"}}]}
 *      data: [DONE]
 *      ```
 *    - Requires manual: byte-to-text decoding, SSE protocol parsing (`data:`, newlines),
 *      JSON parsing of each event, buffer management for partial chunks
 *    - More complex error recovery and reconnection handling
 *
 * OpenRouter uses SSE because it's a proxy service (100+ models) that exposes a raw HTTP API
 * rather than a typed SDK. This allows them to:
 * - Support any HTTP client/language
 * - Add custom headers (cost tracking, routing metadata)
 * - Unify different provider formats into one consistent SSE stream
 *
 * Both processors must preserve `reasoning_details` and `thought_signature` for Gemini models
 * which require this data to be sent back in tool continuation requests.
 *
 * Usage:
 * - Used by BaseAdapter.processSSEStream()
 * - Handles buffering, parsing, and error recovery for SSE streams
 * - Accumulates tool calls incrementally with throttled yielding
 * - Uses eventsource-parser for robust SSE parsing
 *
 * Features:
 * - Automatic tool call accumulation across stream chunks
 * - Configurable throttling for tool call progress updates
 * - Usage extraction from stream events
 * - Proper finish reason handling
 */

import { createParser, type ParsedEvent, type ParseEvent } from 'eventsource-parser';
import { StreamChunk } from '../adapters/types';

export interface SSEStreamOptions {
  extractContent: (parsed: any) => string | null;
  extractToolCalls: (parsed: any) => any[] | null;
  extractFinishReason: (parsed: any) => string | null;
  extractUsage?: (parsed: any) => any;
  // Reasoning/thinking extraction for models that support it
  extractReasoning?: (parsed: any) => { text: string; complete: boolean } | null;
  onParseError?: (error: Error, rawData: string) => void;
  debugLabel?: string;
  // Tool call accumulation settings
  accumulateToolCalls?: boolean;
  toolCallThrottling?: {
    initialYield: boolean;
    progressInterval: number; // Yield every N characters of arguments
  };
}

export class SSEStreamProcessor {
  /**
   * Process SSE stream with automatic tool call accumulation
   * Handles all the complex buffering, parsing, and error recovery
   */
  static async* processSSEStream(
    response: Response,
    options: SSEStreamOptions
  ): AsyncGenerator<StreamChunk, void, unknown> {
    if (!response.body) {
      throw new Error('Response body is not readable');
    }

    const debugLabel = options.debugLabel || 'SSE';
    let tokenCount = 0;
    let usage: any = undefined;

    // Tool call accumulation system
    const toolCallsAccumulator: Map<number, any> = new Map();
    let accumulatedContent = '';

    // Event queue for handling async events in sync generator
    const eventQueue: StreamChunk[] = [];
    let isCompleted = false;
    let completionError: Error | null = null;

    const reader = response.body.getReader();
    const decoder = new TextDecoder();

    const parser = createParser((event: ParseEvent) => {
      if (isCompleted) return;

      // Handle reconnect intervals
      if (event.type === 'reconnect-interval') {
        return;
      }

      // Handle [DONE] event
      if (event.data === '[DONE]') {
        const finalUsage = usage ? {
          promptTokens: usage.prompt_tokens || 0,
          completionTokens: usage.completion_tokens || 0,
          totalTokens: usage.total_tokens || 0
        } : undefined;

        const finalToolCalls = options.accumulateToolCalls && toolCallsAccumulator.size > 0
          ? Array.from(toolCallsAccumulator.values())
          : undefined;

        eventQueue.push({
          content: '',
          complete: true,
          usage: finalUsage,
          toolCalls: finalToolCalls,
          toolCallsReady: finalToolCalls && finalToolCalls.length > 0 ? true : undefined
        });

        isCompleted = true;
        return;
      }

      try {
        const parsed = JSON.parse(event.data);

        // Extract content using adapter-specific logic
        const content = options.extractContent(parsed);
        if (content) {
          tokenCount++;
          accumulatedContent += content;

          eventQueue.push({
            content,
            complete: false
          });
        }

        // Extract reasoning/thinking using adapter-specific logic (if provided)
        if (options.extractReasoning) {
          const reasoning = options.extractReasoning(parsed);
          if (reasoning) {
            eventQueue.push({
              content: '',
              complete: false,
              reasoning: reasoning.text,
              reasoningComplete: reasoning.complete
            });
          }
        }

        // Extract tool calls using adapter-specific logic
        const toolCalls = options.extractToolCalls(parsed);
        if (toolCalls && options.accumulateToolCalls) {
          let shouldYieldToolCalls = false;

          for (const toolCall of toolCalls) {
            const index = toolCall.index || 0;

            if (!toolCallsAccumulator.has(index)) {
              // Initialize new tool call - preserve reasoning_details and thought_signature
              const accumulated: any = {
                id: toolCall.id || '',
                type: toolCall.type || 'function',
                function: {
                  name: toolCall.function?.name || '',
                  arguments: toolCall.function?.arguments || ''
                }
              };

              // Preserve reasoning data for OpenRouter Gemini and Google models
              if (toolCall.reasoning_details) {
                accumulated.reasoning_details = toolCall.reasoning_details;
              }
              if (toolCall.thought_signature) {
                accumulated.thought_signature = toolCall.thought_signature;
              }

              toolCallsAccumulator.set(index, accumulated);
              shouldYieldToolCalls = options.toolCallThrottling?.initialYield !== false;
            } else {
              // Accumulate existing tool call
              const existing = toolCallsAccumulator.get(index);
              if (toolCall.id) existing.id = toolCall.id;
              if (toolCall.function?.name) existing.function.name = toolCall.function.name;
              if (toolCall.function?.arguments) {
                existing.function.arguments += toolCall.function.arguments;

                // Check throttling conditions
                const argLength = existing.function.arguments.length;
                const interval = options.toolCallThrottling?.progressInterval || 50;
                shouldYieldToolCalls = argLength > 0 && argLength % interval === 0;
              }
              // Also preserve reasoning data if it arrives in later chunks
              if (toolCall.reasoning_details && !existing.reasoning_details) {
                existing.reasoning_details = toolCall.reasoning_details;
              }
              if (toolCall.thought_signature && !existing.thought_signature) {
                existing.thought_signature = toolCall.thought_signature;
              }
            }
          }

          if (shouldYieldToolCalls) {
            const currentToolCalls = Array.from(toolCallsAccumulator.values());

            eventQueue.push({
              content: '',
              complete: false,
              toolCalls: currentToolCalls
            });
          }
        }

        // Extract usage information
        if (options.extractUsage) {
          const extractedUsage = options.extractUsage(parsed);
          if (extractedUsage) {
            usage = extractedUsage;
          }
        }

        // Handle completion
        const finishReason = options.extractFinishReason(parsed);
        if (finishReason === 'stop' || finishReason === 'length' || finishReason === 'tool_calls') {
          // Include accumulated tool calls in completion event (same pattern as [DONE])
          const finalToolCalls = options.accumulateToolCalls && toolCallsAccumulator.size > 0
            ? Array.from(toolCallsAccumulator.values())
            : undefined;

          const finalUsageFormatted = usage ? {
            promptTokens: usage.prompt_tokens || 0,
            completionTokens: usage.completion_tokens || 0,
            totalTokens: usage.total_tokens || 0
          } : undefined;

          eventQueue.push({
            content: '',
            complete: true,
            toolCalls: finalToolCalls,
            usage: finalUsageFormatted,
            toolCallsReady: finalToolCalls && finalToolCalls.length > 0 ? true : undefined
          });

          isCompleted = true;
        }

      } catch (parseError) {
        if (options.onParseError) {
          options.onParseError(parseError as Error, event.data);
        }
        // Continue processing other events
      }
    });

    try {
      // Process the stream
      while (!isCompleted && !completionError) {
        const { done, value } = await reader.read();

        if (done) {
          isCompleted = true;
          break;
        }

        // Feed chunk to parser
        const chunk = decoder.decode(value, { stream: true });
        parser.feed(chunk);

        // Yield any queued events
        while (eventQueue.length > 0) {
          const event = eventQueue.shift()!;
          yield event;

          // If this was a completion event, we're done
          if (event.complete) {
            isCompleted = true;
            break;
          }
        }
      }

      // Yield any remaining queued events
      while (eventQueue.length > 0) {
        const event = eventQueue.shift()!;
        yield event;
      }

      // If we completed without a completion event, yield one
      if (!isCompleted || (!eventQueue.length && !completionError)) {
        yield {
          content: '',
          complete: true,
          usage: usage ? {
            promptTokens: usage.prompt_tokens || 0,
            completionTokens: usage.completion_tokens || 0,
            totalTokens: usage.total_tokens || 0
          } : undefined
        };
      }

    } catch (error) {
      throw error;
    } finally {
      try {
        reader.cancel();
      } catch (error) {
        // Ignore cancellation errors
      }
    }

    if (completionError) {
      throw completionError;
    }
  }
}

```

## services/llm/streaming/StreamChunkProcessor.ts

```typescript
/**
 * Stream Chunk Processor
 * Location: src/services/llm/streaming/StreamChunkProcessor.ts
 *
 * Extracted from BaseAdapter.ts to follow Single Responsibility Principle.
 * Handles processing of individual stream chunks with tool call accumulation.
 *
 * ## Why Two Stream Processors?
 *
 * LLM providers deliver streaming data in two fundamentally different formats:
 *
 * 1. **SDK Streams (this processor)** - Used by OpenAI, Groq, Mistral SDKs
 *    - SDKs return `AsyncIterable<Chunk>` with pre-parsed JavaScript objects
 *    - Clean iteration: `for await (const chunk of stream)`
 *    - SDK handles HTTP, buffering, and JSON parsing internally
 *
 * 2. **SSE Streams (SSEStreamProcessor.ts)** - Used by OpenRouter, Requesty, Perplexity
 *    - Return raw `Response` objects with Server-Sent Events text format
 *    - Requires manual: byte decoding, SSE protocol parsing, JSON parsing, buffer management
 *    - More complex error recovery and reconnection handling
 *
 * OpenRouter uses SSE because it's a proxy service (100+ models) that exposes a raw HTTP API
 * rather than a typed SDK, allowing support for any HTTP client/language.
 *
 * Both processors must preserve `reasoning_details` and `thought_signature` for Gemini models
 * which require this data to be sent back in tool continuation requests.
 *
 * Usage:
 * - Used by BaseAdapter.processStream() for SDK stream processing
 * - Processes delta.content and delta.tool_calls from OpenAI-compatible providers
 * - Accumulates tool calls across multiple chunks
 * - Provides throttled progress updates for long tool arguments
 */

import { StreamChunk } from '../adapters/types';

export interface StreamChunkOptions {
  extractContent: (chunk: any) => string | null;
  extractToolCalls: (chunk: any) => any[] | null;
  extractFinishReason: (chunk: any) => string | null;
  extractUsage?: (chunk: any) => any;
}

export class StreamChunkProcessor {
  /**
   * Process individual stream chunk with tool call accumulation
   * Handles delta.content and delta.tool_calls from any OpenAI-compatible provider
   */
  static* processStreamChunk(
    chunk: any,
    options: StreamChunkOptions,
    toolCallsAccumulator: Map<number, any>,
    usageRef: any
  ): Generator<StreamChunk, void, unknown> {

    // Extract text content
    const content = options.extractContent(chunk);
    if (content) {
      yield { content, complete: false };
    }

    // Extract and accumulate tool calls
    const toolCalls = options.extractToolCalls(chunk);
    if (toolCalls) {
      for (const toolCall of toolCalls) {
        const index = toolCall.index || 0;

        if (!toolCallsAccumulator.has(index)) {
          // Initialize new tool call - preserve reasoning_details and thought_signature
          const accumulated: any = {
            id: toolCall.id || '',
            type: toolCall.type || 'function',
            function: {
              name: toolCall.function?.name || '',
              arguments: toolCall.function?.arguments || ''
            }
          };

          // Preserve reasoning data for OpenRouter Gemini and Google models
          if (toolCall.reasoning_details) {
            accumulated.reasoning_details = toolCall.reasoning_details;
          }
          if (toolCall.thought_signature) {
            accumulated.thought_signature = toolCall.thought_signature;
          }

          toolCallsAccumulator.set(index, accumulated);
        } else {
          // Accumulate existing tool call arguments
          const existing = toolCallsAccumulator.get(index);
          if (toolCall.id) existing.id = toolCall.id;
          if (toolCall.function?.name) existing.function.name = toolCall.function.name;
          if (toolCall.function?.arguments) {
            existing.function.arguments += toolCall.function.arguments;
          }
          // Also preserve reasoning data if it arrives in later chunks
          if (toolCall.reasoning_details && !existing.reasoning_details) {
            existing.reasoning_details = toolCall.reasoning_details;
          }
          if (toolCall.thought_signature && !existing.thought_signature) {
            existing.thought_signature = toolCall.thought_signature;
          }
        }
      }

      // Yield progress for UI (every 50 characters of arguments)
      const currentToolCalls = Array.from(toolCallsAccumulator.values());
      const totalArgLength = currentToolCalls.reduce((sum, tc) =>
        sum + (tc.function?.arguments?.length || 0), 0
      );

      if (totalArgLength > 0 && totalArgLength % 50 === 0) {
        yield {
          content: '',
          complete: false,
          toolCalls: currentToolCalls
        };
      }
    }
  }
}

```

## services/llm/types/ImageTypes.ts

```typescript
/**
 * Location: src/services/llm/types/ImageTypes.ts
 * 
 * Purpose: Comprehensive TypeScript types for image generation functionality
 * Integration: Extends existing LLM adapter architecture with image-specific operations
 * 
 * Used by:
 * - BaseImageAdapter: Abstract base class for image adapters
 * - OpenAIImageAdapter: OpenAI gpt-image-1 implementation (available but disabled)
 * - GeminiImageAdapter: Google Imagen 4 implementation
 * - ImageGenerationService: Core orchestration service
 * - ImageFileManager: Vault file operations
 * - GenerateImageMode: MCP interface mode
 */

import { CostDetails, TokenUsage, LLMProviderError } from '../adapters/types';

// Core image generation parameter interfaces
export interface ImageGenerationParams {
  prompt: string;
  provider: 'google' | 'openrouter'; // Google direct or OpenRouter routing
  model?: string; // gemini-2.5-flash-image, gemini-3-pro-image-preview, flux-2-pro, flux-2-flex
  size?: string; // Legacy support for pixel dimensions (converted to aspectRatio)
  aspectRatio?: AspectRatio; // Nano Banana aspect ratios
  numberOfImages?: number; // 1-4 images
  imageSize?: NanoBananaImageSize; // Image resolution: 1K, 2K, or 4K
  referenceImages?: string[]; // Vault-relative paths (max 3 for 2.5-flash, max 14 for 3-pro)
  savePath: string; // vault relative path
  sessionId?: string;
  context?: string;
}

// Nano Banana image resolution sizes
export type NanoBananaImageSize = '1K' | '2K' | '4K';

// Image generation response from adapters
export interface ImageGenerationResponse {
  imageData: Buffer;
  format: 'png' | 'jpeg' | 'webp';
  dimensions: { width: number; height: number };
  metadata: Record<string, any>;
  usage?: ImageUsage;
  revisedPrompt?: string; // Some providers may revise the prompt
}

// Image-specific usage tracking
export interface ImageUsage {
  imagesGenerated: number;
  resolution: string;
  model: string;
  provider: string;
}

// Image model pricing structure
export interface ImageModelPricing {
  provider: string;
  model: string;
  costPerImage: number;
  costPerMegapixel?: number;
  currency: string;
  sizes: Record<string, number>; // size -> cost multiplier
  lastUpdated: string; // ISO date string
}

// Image cost calculation details
export interface ImageCostDetails extends Omit<CostDetails, 'rateInputPerMillion' | 'rateOutputPerMillion'> {
  ratePerImage: number;
  ratePerMegapixel?: number;
  resolution: string;
  imagesGenerated: number;
}

// Validation result for image parameters
export interface ImageValidationResult {
  isValid: boolean;
  errors: string[];
  warnings?: string[];
  adjustedParams?: Partial<ImageGenerationParams>;
}

// File save operation result
export interface ImageSaveResult {
  success: boolean;
  filePath: string;
  fileName: string;
  fileSize: number;
  dimensions: { width: number; height: number };
  format: string;
  error?: string;
}

// Complete image generation result
export interface ImageGenerationResult {
  success: boolean;
  data?: {
    imagePath: string;
    prompt: string;
    revisedPrompt?: string;
    model: string;
    provider: string;
    dimensions: { width: number; height: number };
    fileSize: number;
    format: string;
    cost?: ImageCostDetails;
    usage?: ImageUsage;
    metadata?: Record<string, any>;
  };
  error?: string;
  validationErrors?: string[];
}

// Provider-specific configuration
export interface ImageProviderConfig {
  provider: 'openai' | 'google'; // OpenAI available but not active
  apiKey: string;
  baseUrl?: string;
  defaultModel?: string;
  defaultSize?: string;
  defaultQuality?: string;
  maxFileSize?: number; // bytes
  supportedFormats?: string[];
  supportedSizes?: string[];
  supportedQualities?: string[];
}

// Image buffer with metadata for internal processing
export interface ImageBuffer {
  data: Buffer;
  format: 'png' | 'jpeg' | 'webp';
  dimensions: { width: number; height: number };
  metadata: {
    prompt: string;
    revisedPrompt?: string;
    model: string;
    provider: string;
    generatedAt: string;
    fileSize: number;
    originalResponse?: Record<string, any>;
  };
}

// OpenAI specific types (available but not active)
export namespace OpenAI {
  export interface ImageGenerationRequest {
    model: 'gpt-5.2'; // Model that supports image_generation tool
    input: string;
    tools: Array<{
      type: 'image_generation';
      size?: '1024x1024' | '1536x1024' | '1024x1536' | 'auto';
      quality?: 'low' | 'medium' | 'high' | 'auto';
      background?: 'transparent' | 'opaque' | 'auto';
    }>;
  }

  export interface ImageGenerationResponse {
    created: number;
    data: Array<{
      url?: string;
      b64_json?: string;
      revised_prompt?: string;
    }>;
  }
}

// Google Nano Banana specific types
export namespace Google {
  // Content part for reference images
  export interface InlineDataPart {
    inlineData: {
      mimeType: string;
      data: string; // base64
    };
  }

  // Content part for text
  export interface TextPart {
    text: string;
  }

  export type ContentPart = InlineDataPart | TextPart;

  // Nano Banana image generation config
  export interface ImageConfig {
    aspectRatio?: string;
    imageSize?: '1K' | '2K' | '4K';
  }

  // Request for generateContent with image generation
  export interface ImageGenerationRequest {
    model: 'gemini-2.5-flash-image' | 'gemini-3-pro-image-preview';
    contents: ContentPart[];
    config?: {
      responseModalities?: ('TEXT' | 'IMAGE')[];
      imageConfig?: ImageConfig;
    };
  }

  export interface SafetySetting {
    category: string;
    threshold: 'BLOCK_NONE' | 'BLOCK_LOW_AND_ABOVE' | 'BLOCK_MEDIUM_AND_ABOVE' | 'BLOCK_HIGH_AND_ABOVE';
  }

  export interface ImageGenerationResponse {
    candidates: Array<{
      content?: {
        parts: Array<{
          inlineData?: {
            mimeType: string;
            data: string; // base64
          };
          text?: string;
        }>;
      };
      safetyRatings?: Array<{
        category: string;
        probability: string;
      }>;
      finishReason?: string;
    }>;
    usageMetadata?: {
      promptTokenCount: number;
      candidatesTokenCount: number;
      totalTokenCount: number;
    };
  }
}

// Image generation error types
export class ImageGenerationError extends LLMProviderError {
  constructor(
    message: string,
    provider: string,
    code?: string,
    originalError?: Error,
    public imageParams?: ImageGenerationParams
  ) {
    super(message, provider, code, originalError);
    this.name = 'ImageGenerationError';
  }
}

// Supported providers and models
export type ImageProvider = 'openai' | 'google' | 'openrouter'; // OpenAI available but not active

export type ImageModel =
  | 'gpt-image-1'              // OpenAI (available but not active)
  | 'gemini-2.5-flash-image'   // Google Nano Banana (fast)
  | 'gemini-3-pro-image-preview'; // Google Nano Banana Pro (advanced)

// Aspect ratio constants for Nano Banana models
export enum AspectRatio {
  SQUARE = '1:1',
  PORTRAIT_2_3 = '2:3',
  LANDSCAPE_3_2 = '3:2',
  PORTRAIT_3_4 = '3:4',
  LANDSCAPE_4_3 = '4:3',
  PORTRAIT_4_5 = '4:5',
  LANDSCAPE_5_4 = '5:4',
  PORTRAIT_9_16 = '9:16',
  LANDSCAPE_16_9 = '16:9',
  ULTRAWIDE_21_9 = '21:9'
}

// Image size presets
export const IMAGE_SIZES = {
  SQUARE_1024: '1024x1024',
  PORTRAIT: '1024x1536',  // Supported by both providers
  LANDSCAPE: '1536x1024', // Supported by both providers
  AUTO: 'auto'            // OpenAI automatic sizing (available but not active)
} as const;

export type ImageSize = typeof IMAGE_SIZES[keyof typeof IMAGE_SIZES];

// Image quality options
export const IMAGE_QUALITIES = {
  STANDARD: 'standard',
  HD: 'hd'
} as const;

export type ImageQuality = typeof IMAGE_QUALITIES[keyof typeof IMAGE_QUALITIES];

// Supported image formats
export const IMAGE_FORMATS = {
  PNG: 'png',
  JPEG: 'jpeg', 
  WEBP: 'webp'
} as const;

export type ImageFormat = typeof IMAGE_FORMATS[keyof typeof IMAGE_FORMATS];

// Safety levels for content filtering
export const SAFETY_LEVELS = {
  STRICT: 'strict',
  STANDARD: 'standard', 
  PERMISSIVE: 'permissive'
} as const;

export type SafetyLevel = typeof SAFETY_LEVELS[keyof typeof SAFETY_LEVELS];
```

## services/llm/utils/CacheManager.ts

```typescript
/**
 * Cache Manager
 * Provides in-memory LRU cache and file-based cache implementations
 *
 * MOBILE COMPATIBILITY (Dec 2025):
 * - Uses Web Crypto API instead of Node.js crypto
 * - Uses Obsidian's Vault API instead of Node.js fs
 * - Falls back to memory-only caching if vault adapter not configured
 */

import { normalizePath } from 'obsidian';
import { logger } from './Logger';

// Browser-compatible hash function using Web Crypto API
async function generateHashAsync(input: string): Promise<string> {
  const encoder = new TextEncoder();
  const data = encoder.encode(input);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

// Synchronous fallback using simple hash (for cases where async isn't possible)
function generateHashSync(input: string): string {
  // Simple djb2 hash - not cryptographically secure but sufficient for cache keys
  let hash = 5381;
  for (let i = 0; i < input.length; i++) {
    hash = ((hash << 5) + hash) + input.charCodeAt(i);
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash).toString(16);
}

export interface CacheEntry<T> {
  value: T;
  timestamp: number;
  ttl?: number;
  hits: number;
}

export interface CacheConfig {
  maxSize: number;
  defaultTTL: number; // in milliseconds
  persistToDisk: boolean;
  cacheDir: string;
}

export interface CacheMetrics {
  hits: number;
  misses: number;
  evictions: number;
  size: number;
}

export interface VaultAdapter {
  exists(path: string): Promise<boolean>;
  read(path: string): Promise<string>;
  write(path: string, data: string): Promise<void>;
  mkdir(path: string): Promise<void>;
  remove(path: string): Promise<void>;
  list?(path: string): Promise<{ files: string[]; folders: string[] }>;
}

export abstract class BaseCache<T> {
  protected config: CacheConfig;
  protected metrics: CacheMetrics = {
    hits: 0,
    misses: 0,
    evictions: 0,
    size: 0
  };

  constructor(config: Partial<CacheConfig> = {}) {
    this.config = {
      maxSize: config.maxSize || 1000,
      defaultTTL: config.defaultTTL || 3600000, // 1 hour default
      persistToDisk: config.persistToDisk || false,
      cacheDir: config.cacheDir || '.cache'
    };
  }

  abstract get(key: string): Promise<T | null>;
  abstract set(key: string, value: T, ttl?: number): Promise<void>;
  abstract delete(key: string): Promise<boolean>;
  abstract clear(): Promise<void>;
  abstract size(): number;

  getMetrics(): CacheMetrics {
    return { ...this.metrics };
  }

  protected isExpired(entry: CacheEntry<T>): boolean {
    if (!entry.ttl) return false;
    return Date.now() - entry.timestamp > entry.ttl;
  }

  protected generateHash(input: string): string {
    // Use synchronous hash for cache keys (async not needed for this use case)
    return generateHashSync(input);
  }

  protected async generateHashSecure(input: string): Promise<string> {
    return generateHashAsync(input);
  }
}

export class LRUCache<T> extends BaseCache<T> {
  private cache = new Map<string, CacheEntry<T>>();
  private accessOrder = new Map<string, number>();
  private accessCounter = 0;

  async get(key: string): Promise<T | null> {
    const entry = this.cache.get(key);

    if (!entry) {
      this.metrics.misses++;
      return null;
    }

    if (this.isExpired(entry)) {
      await this.delete(key);
      this.metrics.misses++;
      return null;
    }

    // Update access order for LRU
    this.accessOrder.set(key, ++this.accessCounter);
    entry.hits++;
    this.metrics.hits++;

    return entry.value;
  }

  async set(key: string, value: T, ttl?: number): Promise<void> {
    // Check if we need to evict
    if (this.cache.size >= this.config.maxSize && !this.cache.has(key)) {
      await this.evictLRU();
    }

    const entry: CacheEntry<T> = {
      value,
      timestamp: Date.now(),
      ttl: ttl || this.config.defaultTTL,
      hits: 0
    };

    this.cache.set(key, entry);
    this.accessOrder.set(key, ++this.accessCounter);
    this.metrics.size = this.cache.size;

    // Persist to disk if configured and vault adapter available
    if (this.config.persistToDisk && CacheManager.vaultAdapterConfig) {
      await this.persistEntry(key, entry);
    }
  }

  async delete(key: string): Promise<boolean> {
    const deleted = this.cache.delete(key);
    this.accessOrder.delete(key);

    if (deleted) {
      this.metrics.size = this.cache.size;
    }

    return deleted;
  }

  async clear(): Promise<void> {
    this.cache.clear();
    this.accessOrder.clear();
    this.accessCounter = 0;
    this.metrics.size = 0;
  }

  size(): number {
    return this.cache.size;
  }

  private async evictLRU(): Promise<void> {
    let lruKey: string | null = null;
    let lruOrder = Infinity;

    for (const [key, order] of this.accessOrder.entries()) {
      if (order < lruOrder) {
        lruOrder = order;
        lruKey = key;
      }
    }

    if (lruKey) {
      await this.delete(lruKey);
      this.metrics.evictions++;
    }
  }

  private async persistEntry(key: string, entry: CacheEntry<T>): Promise<void> {
    if (!CacheManager.vaultAdapterConfig) {
      // No vault adapter configured - skip disk persistence
      return;
    }

    const hashed = `${this.generateHash(key)}.json`;
    const adapter = CacheManager.vaultAdapterConfig.adapter;
    const dir = normalizePath(CacheManager.vaultAdapterConfig.baseDir);
    const filePath = normalizePath(`${dir}/${hashed}`);

    try {
      await adapter.mkdir(dir);
      await adapter.write(filePath, JSON.stringify({ key, entry }));
    } catch (error) {
      logger.warn('Failed to persist cache entry via vault adapter:', { error: (error as Error).message });
    }
  }
}

export class FileCache<T> extends BaseCache<T> {
  private memoryCache = new Map<string, CacheEntry<T>>();
  private baseDir: string;

  constructor(config: Partial<CacheConfig> = {}) {
    super({ ...config, persistToDisk: true });
    this.baseDir = CacheManager.vaultAdapterConfig?.baseDir || config.cacheDir || '.cache';
    this.initializeCache();
  }

  async get(key: string): Promise<T | null> {
    // Check memory first
    let entry = this.memoryCache.get(key);

    // If not in memory, try disk
    if (!entry) {
      entry = (await this.loadFromDisk(key)) || undefined;
      if (entry) {
        this.memoryCache.set(key, entry);
      }
    }

    if (!entry) {
      this.metrics.misses++;
      return null;
    }

    if (this.isExpired(entry)) {
      await this.delete(key);
      this.metrics.misses++;
      return null;
    }

    entry.hits++;
    this.metrics.hits++;
    return entry.value;
  }

  async set(key: string, value: T, ttl?: number): Promise<void> {
    const entry: CacheEntry<T> = {
      value,
      timestamp: Date.now(),
      ttl: ttl || this.config.defaultTTL,
      hits: 0
    };

    this.memoryCache.set(key, entry);
    await this.saveToDisk(key, entry);
    this.metrics.size++;
  }

  async delete(key: string): Promise<boolean> {
    const memoryDeleted = this.memoryCache.delete(key);
    const diskDeleted = await this.deleteFromDisk(key);

    if (memoryDeleted || diskDeleted) {
      this.metrics.size--;
      return true;
    }
    return false;
  }

  async clear(): Promise<void> {
    this.memoryCache.clear();
    await this.clearVaultCache();
    this.metrics.size = 0;
  }

  size(): number {
    return this.memoryCache.size;
  }

  private async initializeCache(): Promise<void> {
    if (!CacheManager.vaultAdapterConfig) {
      // No vault adapter - memory-only mode
      return;
    }

    try {
      const dir = this.getCacheDir();
      await CacheManager.vaultAdapterConfig.adapter.mkdir(dir);
    } catch (error) {
      logger.warn('Failed to initialize cache directory via vault adapter:', { error: (error as Error).message });
    }
  }

  private async loadFromDisk(key: string): Promise<CacheEntry<T> | null> {
    if (!CacheManager.vaultAdapterConfig) {
      return null;
    }

    const hashed = `${this.generateHash(key)}.json`;
    const adapter = CacheManager.vaultAdapterConfig.adapter;
    const filePath = this.normalizeVaultPath(`${this.baseDir}/${hashed}`);

    try {
      const exists = await adapter.exists(filePath);
      if (!exists) return null;
      const data = await adapter.read(filePath);
      const parsed = JSON.parse(data);
      return parsed.entry;
    } catch {
      return null;
    }
  }

  private async saveToDisk(key: string, entry: CacheEntry<T>): Promise<void> {
    if (!CacheManager.vaultAdapterConfig) {
      return;
    }

    const hashed = `${this.generateHash(key)}.json`;
    const adapter = CacheManager.vaultAdapterConfig.adapter;
    const filePath = this.normalizeVaultPath(`${this.baseDir}/${hashed}`);

    try {
      await adapter.write(filePath, JSON.stringify({ key, entry }));
    } catch (error) {
      logger.warn('Failed to save cache entry to vault:', { error: (error as Error).message });
    }
  }

  private async deleteFromDisk(key: string): Promise<boolean> {
    if (!CacheManager.vaultAdapterConfig) {
      return false;
    }

    const hashed = `${this.generateHash(key)}.json`;
    const adapter = CacheManager.vaultAdapterConfig.adapter;
    const filePath = this.normalizeVaultPath(`${this.baseDir}/${hashed}`);

    try {
      await adapter.remove(filePath);
      return true;
    } catch {
      return false;
    }
  }

  private async clearVaultCache(): Promise<void> {
    if (!CacheManager.vaultAdapterConfig) {
      return;
    }

    const adapter = CacheManager.vaultAdapterConfig.adapter;
    const dir = this.getCacheDir();

    try {
      if (adapter.list) {
        const contents = await adapter.list(dir);
        for (const file of contents.files) {
          if (file.endsWith('.json')) {
            await adapter.remove(this.normalizeVaultPath(`${dir}/${file}`));
          }
        }
      }
    } catch (error) {
      logger.warn('Failed to clear vault cache:', { error: (error as Error).message });
    }
  }

  private getCacheDir(): string {
    return this.normalizeVaultPath(this.baseDir);
  }

  private normalizeVaultPath(p: string): string {
    return normalizePath(p);
  }
}

/**
 * CacheManager singleton
 * Manages multiple cache instances and provides centralized configuration
 */
export class CacheManager {
  private static instances = new Map<string, BaseCache<any>>();
  static vaultAdapterConfig: { adapter: VaultAdapter; baseDir: string } | null = null;

  static getLRUCache<T>(name: string, config?: Partial<CacheConfig>): LRUCache<T> {
    if (!this.instances.has(name)) {
      this.instances.set(name, new LRUCache<T>(config));
    }
    return this.instances.get(name) as LRUCache<T>;
  }

  static getFileCache<T>(name: string, config?: Partial<CacheConfig>): FileCache<T> {
    if (!this.instances.has(name)) {
      this.instances.set(name, new FileCache<T>(config));
    }
    return this.instances.get(name) as FileCache<T>;
  }

  static async clearAll(): Promise<void> {
    for (const cache of this.instances.values()) {
      await cache.clear();
    }
  }

  static getAllMetrics(): Record<string, CacheMetrics> {
    const metrics: Record<string, CacheMetrics> = {};
    for (const [name, cache] of this.instances.entries()) {
      metrics[name] = cache.getMetrics();
    }
    return metrics;
  }

  /**
   * Configure a vault adapter so cache persistence uses Obsidian API.
   * Must be called before creating file-based caches for disk persistence to work.
   */
  static configureVaultAdapter(adapter: VaultAdapter, baseDir: string = '.nexus/cache') {
    this.vaultAdapterConfig = { adapter, baseDir };
  }
}

```

## services/llm/utils/index.ts

```typescript
/**
 * Utilities module exports
 */

export { Logger, ComponentLogger, logger, createLogger, type LogLevel, type LogEntry } from './Logger';
export {
  ValidationUtils,
  CommonSchemas,
  type ValidationResult,
  type SchemaValidationRule
} from './ValidationUtils';
export {
  CacheManager,
  LRUCache,
  FileCache,
  BaseCache,
  type CacheEntry,
  type CacheConfig,
  type CacheMetrics
} from './CacheManager';
export { WebSearchUtils } from './WebSearchUtils';
export { LLMCostCalculator } from './LLMCostCalculator';
export { TokenUsageExtractor } from './TokenUsageExtractor';
export { SchemaValidator } from './SchemaValidator';
export { ThinkingEffortMapper } from './ThinkingEffortMapper';

```

## services/llm/utils/LLMCostCalculator.ts

```typescript
/**
 * LLM Cost Calculator Utility
 * Location: src/services/llm/utils/LLMCostCalculator.ts
 *
 * Extracted from BaseAdapter.ts to follow Single Responsibility Principle.
 * Handles all cost calculation logic including caching discounts for different providers.
 *
 * Usage:
 * - Used by BaseAdapter and all provider adapters
 * - Calculates input/output costs based on token usage and model pricing
 * - Applies provider-specific caching discounts (OpenAI, Anthropic, Google)
 */

import { TokenUsage, CostDetails, ModelPricing } from '../adapters/types';

export class LLMCostCalculator {
  /**
   * Calculate cost based on token usage and model pricing
   * Supports caching discounts for providers that offer them
   */
  static async calculateCost(
    usage: TokenUsage,
    model: string,
    modelPricing: ModelPricing | null
  ): Promise<CostDetails | null> {
    if (!modelPricing) {
      return null;
    }

    // Determine caching discount rate based on provider and model
    const cachingDiscount = this.getCachingDiscount(model);

    // Calculate input cost with caching discount
    let inputCost = 0;
    let cachedCost = 0;

    if (usage.cachedTokens && usage.cachedTokens > 0 && cachingDiscount < 1.0) {
      // Split input tokens into cached and fresh
      const freshTokens = usage.promptTokens - usage.cachedTokens;
      const freshCost = (freshTokens / 1_000_000) * modelPricing.rateInputPerMillion;
      cachedCost = (usage.cachedTokens / 1_000_000) * modelPricing.rateInputPerMillion * cachingDiscount;
      inputCost = freshCost + cachedCost;

    } else {
      // No cached tokens, use standard pricing
      inputCost = (usage.promptTokens / 1_000_000) * modelPricing.rateInputPerMillion;
    }

    const outputCost = (usage.completionTokens / 1_000_000) * modelPricing.rateOutputPerMillion;
    const totalCost = inputCost + outputCost;

    const costDetails: CostDetails = {
      inputCost,
      outputCost,
      totalCost,
      currency: modelPricing.currency || 'USD',
      rateInputPerMillion: modelPricing.rateInputPerMillion,
      rateOutputPerMillion: modelPricing.rateOutputPerMillion
    };

    // Add cached token details if applicable
    if (usage.cachedTokens && usage.cachedTokens > 0) {
      costDetails.cached = {
        tokens: usage.cachedTokens,
        cost: cachedCost
      };
    }

    return costDetails;
  }

  /**
   * Get caching discount multiplier for a model
   * Returns the fraction of the original price (e.g., 0.1 = 90% off, 0.25 = 75% off)
   */
  static getCachingDiscount(model: string): number {
    // OpenAI pricing as of Oct 2025:
    // GPT-5 family: 90% off cached tokens (pay 10%)
    if (model.startsWith('gpt-5')) {
      return 0.1;
    }

    // GPT-5.2 family: 75% off cached tokens (pay 25%)
    if (model.startsWith('gpt-5.2')) {
      return 0.25;
    }

    // Anthropic Claude: 90% off cached tokens
    if (model.startsWith('claude')) {
      return 0.1;
    }

    // Google Gemini: 50% off cached tokens
    if (model.startsWith('gemini')) {
      return 0.5;
    }

    // Default: no caching discount
    return 1.0;
  }
}

```

## services/llm/utils/Logger.ts

```typescript
/**
 * Enhanced Logger
 * Structured logging with multiple outputs and severity levels
 * Based on patterns from existing logging services
 *
 * MOBILE COMPATIBILITY (Dec 2025):
 * - Removed Node.js fs and path imports
 * - File logging only works via Obsidian vault adapter
 * - Falls back to console-only logging if vault adapter not configured
 */

import { normalizePath } from 'obsidian';

export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

export interface LogEntry {
  timestamp: Date;
  level: LogLevel;
  message: string;
  component?: string;
  metadata?: Record<string, any>;
  executionId?: string;
  testId?: string;
}

export interface LoggerConfig {
  level: LogLevel;
  enableConsole: boolean;
  enableFile: boolean;
  logDirectory: string;
  maxFileSize: number; // in bytes
  maxFiles: number;
  includeTimestamp: boolean;
  includeStackTrace: boolean;
}

export class Logger {
  private static instance: Logger;
  private config: LoggerConfig;
  private static vaultAdapterConfig: { adapter: any; baseDir: string } | null = null;
  private logLevels: Record<LogLevel, number> = {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3
  };

  private constructor(config?: Partial<LoggerConfig>) {
    this.config = {
      level: 'info',
      enableConsole: true,
      enableFile: false,
      logDirectory: './logs',
      maxFileSize: 10 * 1024 * 1024, // 10MB
      maxFiles: 5,
      includeTimestamp: true,
      includeStackTrace: false,
      ...config
    };

    this.ensureLogDirectory();
  }

  /**
   * Get singleton instance
   */
  static getInstance(config?: Partial<LoggerConfig>): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger(config);
    }
    return Logger.instance;
  }

  /**
   * Create a child logger with component context
   */
  child(component: string): ComponentLogger {
    return new ComponentLogger(this, component);
  }

  /**
   * Debug level logging
   */
  debug(message: string, metadata?: Record<string, any>): void {
    this.log('debug', message, metadata);
  }

  /**
   * Info level logging
   */
  info(message: string, metadata?: Record<string, any>): void {
    this.log('info', message, metadata);
  }

  /**
   * Warning level logging
   */
  warn(message: string, metadata?: Record<string, any>): void {
    this.log('warn', message, metadata);
  }

  /**
   * Error level logging
   */
  error(message: string, error?: Error | Record<string, any>): void {
    const metadata = error instanceof Error ? {
      error: error.message,
      stack: error.stack
    } : error;
    
    this.log('error', message, metadata);
  }

  /**
   * Log test execution events
   */
  testEvent(event: string, testId: string, metadata?: Record<string, any>): void {
    this.log('info', `Test Event: ${event}`, {
      testId,
      eventType: 'test',
      ...metadata
    });
  }

  /**
   * Log optimization events
   */
  optimizationEvent(event: string, generation: number, metadata?: Record<string, any>): void {
    this.log('info', `Optimization: ${event}`, {
      generation,
      eventType: 'optimization',
      ...metadata
    });
  }

  /**
   * Log provider API calls
   */
  apiCall(provider: string, method: string, latency: number, tokens?: number, cost?: number): void {
    this.log('debug', `API Call: ${provider}.${method}`, {
      provider,
      method,
      latency,
      tokens,
      cost,
      eventType: 'api'
    });
  }

  /**
   * Log performance metrics
   */
  performance(operation: string, duration: number, metadata?: Record<string, any>): void {
    this.log('info', `Performance: ${operation}`, {
      operation,
      duration,
      eventType: 'performance',
      ...metadata
    });
  }

  /**
   * Main logging method
   */
  log(level: LogLevel, message: string, metadata?: Record<string, any>, component?: string): void {
    if (!this.shouldLog(level)) {
      return;
    }

    const entry: LogEntry = {
      timestamp: new Date(),
      level,
      message
    };
    
    if (component !== undefined) entry.component = component;
    if (metadata !== undefined) entry.metadata = metadata;

    if (this.config.enableConsole) {
      this.logToConsole(entry);
    }

    if (this.config.enableFile) {
      this.logToFile(entry);
    }
  }

  /**
   * Update logger configuration
   */
  configure(config: Partial<LoggerConfig>): void {
    this.config = { ...this.config, ...config };
    this.ensureLogDirectory();
  }

  /**
   * Get current log level
   */
  getLevel(): LogLevel {
    return this.config.level;
  }

  /**
   * Set log level
   */
  setLevel(level: LogLevel): void {
    this.config.level = level;
  }

  /**
   * Enable file logging
   */
  enableFileLogging(directory?: string): void {
    this.config.enableFile = true;
    if (directory) {
      this.config.logDirectory = directory;
    }
    this.ensureLogDirectory();
  }

  /**
   * Disable file logging
   */
  disableFileLogging(): void {
    this.config.enableFile = false;
  }

  /**
   * Flush logs (useful for testing)
   */
  flush(): void {
    // In a real implementation, this would flush any buffered logs
  }

  // Private methods

  private shouldLog(level: LogLevel): boolean {
    return this.logLevels[level] >= this.logLevels[this.config.level];
  }

  private logToConsole(entry: LogEntry): void {
    const timestamp = this.config.includeTimestamp 
      ? `[${entry.timestamp.toISOString()}] `
      : '';
    
    const component = entry.component ? `[${entry.component}] ` : '';
    const level = `[${entry.level.toUpperCase()}] `;
    
    let output = `${timestamp}${level}${component}${entry.message}`;
    
    if (entry.metadata && Object.keys(entry.metadata).length > 0) {
      output += ` ${JSON.stringify(entry.metadata, null, 2)}`;
    }

    switch (entry.level) {
      case 'error':
        console.error(output);
        break;
    }
  }

  private logToFile(entry: LogEntry): void {
    if (!Logger.vaultAdapterConfig) {
      return;
    }

    const logFile = normalizePath(`${this.config.logDirectory}/lab-kit-${this.getDateString()}.log`);
    const line = JSON.stringify(entry) + '\n';
    this.writeViaVaultAdapter(logFile, line);
  }

  private ensureLogDirectory(): void {
    if (!this.config.enableFile) return;

    // File logging only works with vault adapter (mobile compatible)
    if (Logger.vaultAdapterConfig) {
      const dir = normalizePath(Logger.vaultAdapterConfig.baseDir || '.nexus/logs');
      Logger.vaultAdapterConfig.adapter.mkdir(dir).catch(() => {});
      this.config.logDirectory = dir;
    } else {
      // No vault adapter - disable file logging on mobile
      this.config.enableFile = false;
    }
  }

  private getDateString(): string {
    return new Date().toISOString().split('T')[0]!;
  }

  // Log rotation not supported on mobile - rely on manual cleanup or vault sync
  // These methods are kept as stubs for API compatibility
  private rotateLogsIfNeeded(_logFile: string): void {
    // Not supported with vault adapter approach - logs managed via vault sync
  }

  private cleanupOldLogs(): void {
    // Not supported with vault adapter approach - logs managed via vault sync
  }

  /**
   * Configure vault adapter-backed logging (uses Obsidian vault adapter for writes).
   */
  static setVaultAdapter(adapter: any, baseDir: string = '.nexus/logs') {
    Logger.vaultAdapterConfig = { adapter, baseDir };
    if (Logger.instance) {
      Logger.instance.config.logDirectory = baseDir;
      Logger.instance.ensureLogDirectory();
    }
  }

  private writeViaVaultAdapter(logFile: string, line: string) {
    const adapter = Logger.vaultAdapterConfig?.adapter;
    if (!adapter) return;
    const normalizedPath = normalizePath(logFile);
    adapter.read(normalizedPath)
      .catch(() => '')
      .then((existing: string) => adapter.write(normalizedPath, `${existing}${line}`))
      .catch((error: Error) => {
        console.error('Failed to write to vault-backed log file:', error);
      });
  }
}

/**
 * Component-specific logger that includes component context
 */
export class ComponentLogger {
  constructor(
    private parent: Logger,
    private component: string
  ) {}

  debug(message: string, metadata?: Record<string, any>): void {
    this.parent.log('debug', message, metadata, this.component);
  }

  info(message: string, metadata?: Record<string, any>): void {
    this.parent.log('info', message, metadata, this.component);
  }

  warn(message: string, metadata?: Record<string, any>): void {
    this.parent.log('warn', message, metadata, this.component);
  }

  error(message: string, error?: Error | Record<string, any>): void {
    const metadata = error instanceof Error ? {
      error: error.message,
      stack: error.stack
    } : error;
    
    this.parent.log('error', message, metadata, this.component);
  }

  testEvent(event: string, testId: string, metadata?: Record<string, any>): void {
    this.parent.testEvent(event, testId, { component: this.component, ...metadata });
  }

  apiCall(provider: string, method: string, latency: number, tokens?: number, cost?: number): void {
    this.parent.apiCall(provider, method, latency, tokens, cost);
  }

  performance(operation: string, duration: number, metadata?: Record<string, any>): void {
    this.parent.performance(operation, duration, { component: this.component, ...metadata });
  }
}

/**
 * Global logger instance
 */
export const logger = Logger.getInstance();

/**
 * Create a logger for a specific component
 */
export function createLogger(component: string): ComponentLogger {
  return logger.child(component);
}

```

## services/llm/utils/README.md

```markdown
# Utilities & Infrastructure

Essential utilities for configuration management, logging, validation, and reliability patterns across the framework.

## ðŸŽ¯ Purpose

The utilities provide the foundational infrastructure that powers the entire framework:
- **ConfigManager**: Environment and configuration management
- **Logger**: Structured logging with multiple outputs
- **RetryManager**: Retry logic with circuit breakers and exponential backoff
- **ValidationUtils**: Input validation and schema enforcement
- **Performance monitoring** and setup utilities

## âš™ï¸ ConfigManager

Centralized configuration management with environment variables, config files, and validation.

> Note: In Obsidian/mobile-safe builds, file-backed config is loaded/saved via the vault adapter (not Node `fs`). Call `ConfigManager.setVaultAdapter(app.vault.adapter)` to enable `.nexus/config/lab-kit.config.json`.

### Quick Setup
```typescript
import { ConfigManager, quickSetup } from './utils';

// Automatic setup with validation
const { config, logger, isReady, summary } = await quickSetup({
  logLevel: 'info',
  enableFileLogging: true,
  validateConfig: true
});

if (!isReady) {
  console.log('âŒ Setup incomplete. Please check configuration.');
  console.log(summary);
  process.exit(1);
}

console.log('âœ… Lab Kit ready for testing!');
```

### Manual Configuration
```typescript
const config = ConfigManager.getInstance();

// Check provider configuration
const configuredProviders = config.getConfiguredProviders();
console.log(`Configured providers: ${configuredProviders.join(', ')}`);

// Get specific provider config
const openaiConfig = config.getProvider('openai');
if (openaiConfig.apiKey) {
  console.log('âœ… OpenAI configured');
} else {
  console.log('âŒ OpenAI API key missing');
}

// Check database configuration
if (config.isDatabaseConfigured()) {
  console.log('âœ… Database configured');
} else {
  console.log('âš ï¸ Database not configured - some features unavailable');
}
```

### Configuration Sources
The ConfigManager loads configuration from multiple sources in order of priority:

1. **Environment Variables** (highest priority)
2. **Vault-backed config file** (`.nexus/config/lab-kit.config.json`, when `ConfigManager.setVaultAdapter(...)` is used)
3. **Default Values** (lowest priority)

```typescript
// Environment variables
OPENAI_API_KEY=sk-...
GOOGLE_API_KEY=AIza...
SUPABASE_URL=https://project.supabase.co
LAB_KIT_LOG_LEVEL=debug

// Vault-backed config file (.nexus/config/lab-kit.config.json)
{
  "defaults": {
    "timeout": 30000,
    "retries": 3,
    "concurrency": 5
  },
  "logging": {
    "level": "info",
    "enableFileLogging": true
  }
}
```

### Configuration Validation
```typescript
// Get configuration summary
const summary = config.getConfigSummary();
console.log({
  providers: summary.providers.configured,     // ['openai', 'anthropic']
  database: summary.database.configured,      // true/false
  readyForTesting: summary.providers.configured.length > 0
});

// Validate environment
import { validateEnvironment } from './utils';
const envValidation = validateEnvironment();

if (!envValidation.isValid) {
  console.log('âŒ Environment validation failed:');
  envValidation.errors.forEach(error => console.log(`  â€¢ ${error}`));
}

if (envValidation.warnings.length > 0) {
  console.log('âš ï¸ Warnings:');
  envValidation.warnings.forEach(warning => console.log(`  â€¢ ${warning}`));
}
```

## ðŸ“ Logger

Structured logging with multiple outputs, component isolation, and performance tracking.

### Basic Logging
```typescript
import { logger, createLogger } from './utils';

// Global logger
logger.info('Application started');
logger.warn('High memory usage detected');
logger.error('Failed to connect to database', { 
  error: 'Connection timeout',
  retryCount: 3 
});

// Component-specific logger
const testLogger = createLogger('TestRunner');
testLogger.info('Starting test execution', { 
  testId: 'test_123',
  scenarios: 15 
});
```

### Advanced Logging Features
```typescript
// Event-specific logging methods
logger.testEvent('test_started', 'test_123', {
  provider: 'openai',
  scenarios: 15,
  personas: 3
});

logger.optimizationEvent('generation_complete', 5, {
  bestScore: 0.85,
  improvement: 0.12
});

logger.apiCall('openai', 'chat.completions', 1234, 150, 0.003);

logger.performance('prompt_optimization', 45000, {
  generations: 10,
  improvements: 3
});
```

### File Logging & Configuration
```typescript
import { Logger, logger } from './utils';

// In Obsidian, enable vault-backed file logging (writes into the vault)
Logger.setVaultAdapter(app.vault.adapter, '.nexus/logs');
logger.enableFileLogging();

// Configure logging levels and outputs
logger.configure({
  level: 'debug',
  enableFile: true,
  // logDirectory is treated as vault-relative when using the vault adapter
  logDirectory: '.nexus/logs',
  maxFileSize: 10 * 1024 * 1024, // 10MB
  maxFiles: 5
});

// Component logger with context
const optimizerLogger = logger.child('PromptOptimizer');
optimizerLogger.info('Starting optimization', {
  basePrompt: 'Help users...',
  generations: 10,
  populationSize: 12
});
```

### Log Structure
```json
{
  "timestamp": "2025-01-10T15:30:45.123Z",
  "level": "info",
  "message": "Test completed successfully",
  "component": "TestRunner",
  "metadata": {
    "testId": "test_123",
    "accuracy": 0.85,
    "duration": 45000,
    "eventType": "test"
  }
}
```

## ðŸ”„ RetryManager

Sophisticated retry logic with circuit breakers, exponential backoff, and failure pattern recognition.

### Basic Retry Usage
```typescript
import { RetryManager, RetryPatterns } from './utils';

const retryManager = RetryManager.getInstance();

// Basic retry with default configuration
const result = await retryManager.withRetry(
  async () => {
    // Operation that might fail
    return await unstableApiCall();
  },
  {
    maxAttempts: 3,
    baseDelay: 1000,
    exponentialBase: 2
  },
  'unstable_api_call'
);
```

### Convenient Retry Patterns
```typescript
// API calls with smart retry logic
const apiResult = await RetryPatterns.apiCall(async () => {
  return await llmProvider.generate(prompt);
}, 'llm_generation');

// Database operations
const dbResult = await RetryPatterns.databaseOperation(async () => {
  return await database.query('SELECT * FROM users');
}, 'user_query');

// File operations
const fileResult = await RetryPatterns.fileOperation(async () => {
  return await fs.writeFile('report.json', data);
}, 'report_write');
```

### Circuit Breaker Pattern
```typescript
// Protect against cascading failures
const result = await retryManager.withCircuitBreaker(
  async () => {
    return await externalService.call();
  },
  'external_service',
  {
    failureThreshold: 5,      // Open after 5 failures
    resetTimeout: 60000,      // Try again after 1 minute
    monitoringPeriod: 120000  // Monitor over 2 minutes
  }
);

// Check circuit breaker status
const state = retryManager.getCircuitState('external_service');
// 'closed' (normal) | 'open' (failing) | 'half-open' (testing)

// Get statistics
const stats = retryManager.getCircuitStats('external_service');
console.log({
  state: stats.state,
  failureRate: stats.failureRate,
  totalRequests: stats.totalRequests
});
```

### Combined Retry + Circuit Breaker
```typescript
// Ultimate reliability pattern
const result = await retryManager.withRetryAndCircuitBreaker(
  async () => {
    return await criticalOperation();
  },
  'critical_operation',
  // Retry config
  {
    maxAttempts: 3,
    baseDelay: 1000,
    retryCondition: (error) => error.status >= 500
  },
  // Circuit breaker config
  {
    failureThreshold: 5,
    resetTimeout: 30000
  }
);
```

### Custom Retry Conditions
```typescript
const result = await retryManager.withRetry(
  async () => {
    return await llmProvider.generate(prompt);
  },
  {
    maxAttempts: 5,
    baseDelay: 1000,
    maxDelay: 30000,
    jitter: true,
    retryCondition: (error) => {
      // Retry on rate limits and server errors
      if (error.status === 429) return true;
      if (error.status >= 500) return true;
      
      // Retry on network errors
      if (error.code === 'ECONNRESET') return true;
      if (error.code === 'ETIMEDOUT') return true;
      
      // Don't retry on client errors
      return false;
    },
    onRetry: (attempt, error) => {
      logger.warn(`Retry attempt ${attempt}`, { 
        error: error.message,
        operation: 'llm_generation'
      });
    }
  },
  'llm_generation'
);
```

## âœ… ValidationUtils

Comprehensive validation for all framework inputs with detailed error reporting.

### Test Configuration Validation
```typescript
import { ValidationUtils } from './utils';

// Validate test configuration
const testConfig = {
  name: 'Customer Service Test',
  provider: 'openai',
  scenarios: [
    {
      id: 'return_policy',
      userInput: 'How do I return a product?',
      expectedOutput: 'Should mention return process'
    }
  ],
  evaluation: {
    criteria: [
      { name: 'accuracy', type: 'llm_judge', weight: 0.4 }
    ]
  }
};

const validation = ValidationUtils.validateTestConfig(testConfig);
if (!validation.isValid) {
  console.log('âŒ Test configuration invalid:');
  validation.errors.forEach(error => console.log(`  â€¢ ${error}`));
}

if (validation.warnings.length > 0) {
  console.log('âš ï¸ Warnings:');
  validation.warnings.forEach(warning => console.log(`  â€¢ ${warning}`));
}
```

### Provider Configuration Validation
```typescript
// Validate provider configurations
const providers = ['openai', 'anthropic', 'google'];

for (const provider of providers) {
  const config = configManager.getProvider(provider);
  const validation = ValidationUtils.validateProviderConfig(provider, config);
  
  if (validation.isValid) {
    console.log(`âœ… ${provider} configuration valid`);
  } else {
    console.log(`âŒ ${provider} configuration invalid:`);
    validation.errors.forEach(error => console.log(`  â€¢ ${error}`));
  }
}
```

### Schema Validation
```typescript
import { CommonSchemas } from './utils';

// Use pre-built schemas
const scenarioValidation = ValidationUtils.validateSchema(
  scenario,
  CommonSchemas.scenario
);

// Custom schema validation
const customSchema = [
  { field: 'name', type: 'string', required: true, minLength: 1 },
  { field: 'email', type: 'email', required: true },
  { field: 'age', type: 'number', required: false, min: 18, max: 120 },
  { field: 'preferences', type: 'array', required: false },
  { 
    field: 'role', 
    type: 'string', 
    required: true,
    allowedValues: ['admin', 'user', 'guest']
  }
];

const result = ValidationUtils.validateSchema(userData, customSchema);
```

### API Response Validation
```typescript
// Validate API responses
const response = await llmProvider.generate(prompt);

const validation = ValidationUtils.validateAPIResponse(response, [
  'content',
  'tokens', 
  'cost',
  'latency'
]);

if (!validation.isValid) {
  throw new Error(`Invalid API response: ${validation.errors.join(', ')}`);
}

// Validate test results
const testResult = {
  id: 'test_123',
  response: { content: 'Response text', tokens: 150 },
  evaluation: { overall: 0.85, passed: true },
  timestamp: new Date()
};

const resultValidation = ValidationUtils.validateTestResult(testResult);
```

## ðŸ”§ Performance Monitoring

### Built-in Performance Utilities
```typescript
import { PerformanceMonitor } from './utils';

// Time operations
PerformanceMonitor.startTimer('test_execution');
await runTests();
const duration = PerformanceMonitor.endTimer('test_execution');
console.log(`Tests completed in ${duration}ms`);

// Time async operations
const result = await PerformanceMonitor.timeAsync('prompt_optimization', async () => {
  return await optimizer.optimize();
});

// Time synchronous operations
const parsed = PerformanceMonitor.time('json_parsing', () => {
  return JSON.parse(largeJsonString);
});
```

### Environment Setup Report
```typescript
import { createSetupReport } from './utils';

// Generate comprehensive setup report
const report = createSetupReport();
console.log(report);

// Example output:
/*
# Synaptic Lab Kit Setup Report

## Environment Validation
âœ… Environment validation passed

## Configuration Summary
**LLM Providers:** openai, anthropic, google
**Database:** Configured
**Log Level:** info

## Readiness Status
âœ… Ready for testing
*/
```

## ðŸ› ï¸ Integration Examples

### Complete Setup Flow
```typescript
async function setupLabKit() {
  try {
    // 1. Quick setup with validation
    const { config, logger, isReady, summary } = await quickSetup({
      logLevel: 'info',
      enableFileLogging: true,
      validateConfig: true
    });

    if (!isReady) {
      logger.error('Setup failed', summary);
      return false;
    }

    // 2. Setup retry patterns for reliability
    const retryManager = RetryManager.getInstance();
    
    // 3. Configure performance monitoring
    const testLogger = createLogger('TestRunner');
    
    // 4. Validate critical configurations
    const providers = config.getConfiguredProviders();
    for (const provider of providers) {
      const providerConfig = config.getProvider(provider);
      const validation = ValidationUtils.validateProviderConfig(provider, providerConfig);
      
      if (!validation.isValid) {
        logger.error(`Invalid ${provider} configuration`, validation.errors);
        return false;
      }
    }

    logger.info('ðŸš€ Lab Kit setup complete', {
      providers: providers.length,
      database: config.isDatabaseConfigured(),
      embeddings: config.getConfiguredProviders().length
    });

    return true;
  } catch (error) {
    console.error('Setup failed:', error);
    return false;
  }
}
```

### Error Handling Pipeline
```typescript
async function robustTestExecution(testConfig: any) {
  const logger = createLogger('RobustTestRunner');
  const retryManager = RetryManager.getInstance();

  try {
    // 1. Validate configuration
    const validation = ValidationUtils.validateTestConfig(testConfig);
    if (!validation.isValid) {
      throw new Error(`Invalid config: ${validation.errors.join(', ')}`);
    }

    // 2. Execute with retry and circuit breaker
    const results = await retryManager.withRetryAndCircuitBreaker(
      async () => {
        return await executeTests(testConfig);
      },
      'test_execution',
      {
        maxAttempts: 3,
        baseDelay: 5000,
        retryCondition: (error) => {
          // Retry on temporary failures, not configuration errors
          return error.temporary === true;
        }
      },
      {
        failureThreshold: 3,
        resetTimeout: 300000 // 5 minutes
      }
    );

    logger.info('Test execution completed', {
      testId: testConfig.id,
      accuracy: results.summary.accuracy,
      duration: results.duration
    });

    return results;
  } catch (error) {
    logger.error('Test execution failed', {
      testId: testConfig.id,
      error: error.message,
      stack: error.stack
    });
    throw error;
  }
}
```

## ðŸŽ¯ Best Practices

### 1. Configuration Management
- **Environment first** - Use environment variables for secrets
- **Validate early** - Check configuration at startup
- **Fail fast** - Don't continue with invalid configuration
- **Document requirements** - Clear documentation of required env vars

### 2. Logging Strategy
- **Structured logging** - Use consistent metadata fields
- **Component isolation** - Use component-specific loggers
- **Appropriate levels** - Debug for development, info for production
- **Include context** - Add relevant metadata to all log entries

### 3. Retry Patterns
- **Know your errors** - Different retry strategies for different error types
- **Avoid retry storms** - Use jitter and circuit breakers
- **Monitor patterns** - Track retry rates and failure patterns
- **Graceful degradation** - Have fallback plans

### 4. Validation Philosophy
- **Validate at boundaries** - Check all external inputs
- **Fail early** - Validate before expensive operations
- **Clear error messages** - Help users fix validation errors
- **Schema evolution** - Plan for changing requirements

The utilities layer provides the rock-solid foundation that makes the entire framework reliable, observable, and maintainable! ðŸ› ï¸âœ¨

```

## services/llm/utils/SchemaValidator.ts

```typescript
/**
 * Schema Validator Utility
 * Location: src/services/llm/utils/SchemaValidator.ts
 *
 * Extracted from BaseAdapter.ts to follow Single Responsibility Principle.
 * Provides basic JSON schema validation for LLM responses and tool parameters.
 *
 * Usage:
 * - Used by BaseAdapter.generateJSON() for response schema validation
 * - Can be used by provider adapters for validating tool schemas
 * - Basic recursive validation - can be enhanced with a proper validator library
 */

export class SchemaValidator {
  /**
   * Validate data against a JSON schema
   * Basic implementation that checks:
   * - Type matching
   * - Required properties
   * - Nested object validation
   */
  static validateSchema(data: any, schema: any): boolean {
    // Basic schema validation - could be enhanced with a proper validator
    if (typeof schema !== 'object' || schema === null) {
      return true;
    }

    if (schema.type) {
      const expectedType = schema.type;
      const actualType = Array.isArray(data) ? 'array' : typeof data;

      if (expectedType !== actualType) {
        return false;
      }
    }

    if (schema.properties && typeof data === 'object') {
      for (const [key, propSchema] of Object.entries(schema.properties)) {
        if (schema.required?.includes(key) && !(key in data)) {
          return false;
        }

        if (key in data && !this.validateSchema(data[key], propSchema)) {
          return false;
        }
      }
    }

    return true;
  }

  /**
   * Sanitize JSON Schema for Google's simplified schema format
   * Based on official Gemini API documentation (ai.google.dev/gemini-api/docs/structured-output)
   *
   * SUPPORTED Properties:
   * - Universal: type, title, description
   * - Object: properties, required, additionalProperties
   * - String: enum, format (date-time, date, time)
   * - Number/Integer: enum, minimum, maximum
   * - Array: items, prefixItems, minItems, maxItems
   *
   * NOT SUPPORTED (will be removed):
   * - default, examples, nullable, $ref, $schema, $id, $defs
   * - allOf, anyOf, oneOf, not
   * - minLength, maxLength, pattern
   * - uniqueItems, minProperties, maxProperties
   * - const, if/then/else, and other advanced features
   *
   * Note: For nullable types, use type arrays like ["string", "null"] instead of nullable property
   */
  static sanitizeSchemaForGoogle(schema: any): any {
    if (!schema || typeof schema !== 'object') {
      return schema;
    }

    // Create a clean copy
    const sanitized: any = {};

    // Properties officially supported by Google Gemini (as per docs)
    const allowedProperties = [
      'type',
      'title',
      'description',
      'properties',
      'required',
      'items',
      'prefixItems',
      'enum',
      'format',
      'minimum',
      'maximum',
      'minItems',
      'maxItems',
      'additionalProperties'
    ];

    // Copy allowed properties
    for (const key of allowedProperties) {
      if (key in schema) {
        sanitized[key] = schema[key];
      }
    }

    // Handle nullable types - convert to type array if needed
    if (schema.nullable === true && sanitized.type && sanitized.type !== 'null') {
      if (Array.isArray(sanitized.type)) {
        if (!sanitized.type.includes('null')) {
          sanitized.type = [...sanitized.type, 'null'];
        }
      } else {
        sanitized.type = [sanitized.type, 'null'];
      }
      delete sanitized.nullable; // Remove after converting to type array
    }

    // Recursively sanitize nested properties
    if (sanitized.properties && typeof sanitized.properties === 'object') {
      const cleanProps: any = {};
      for (const [propName, propSchema] of Object.entries(sanitized.properties)) {
        cleanProps[propName] = this.sanitizeSchemaForGoogle(propSchema);
      }
      sanitized.properties = cleanProps;
    }

    // Recursively sanitize array items
    if (sanitized.items) {
      if (Array.isArray(sanitized.items)) {
        // Convert array of schemas to prefixItems (tuple validation)
        sanitized.prefixItems = sanitized.items.map((itemSchema: any) =>
          this.sanitizeSchemaForGoogle(itemSchema)
        );
        delete sanitized.items;
      } else if (typeof sanitized.items === 'object') {
        sanitized.items = this.sanitizeSchemaForGoogle(sanitized.items);
      }
    }

    // Recursively sanitize prefixItems (tuple schemas)
    if (sanitized.prefixItems && Array.isArray(sanitized.prefixItems)) {
      sanitized.prefixItems = sanitized.prefixItems.map((itemSchema: any) =>
        this.sanitizeSchemaForGoogle(itemSchema)
      );
    }

    // Recursively sanitize additionalProperties if it's a schema
    if (sanitized.additionalProperties && typeof sanitized.additionalProperties === 'object') {
      sanitized.additionalProperties = this.sanitizeSchemaForGoogle(sanitized.additionalProperties);
    }

    // CRITICAL: Validate required array - remove any properties that don't exist in sanitized.properties
    if (sanitized.required && Array.isArray(sanitized.required) && sanitized.properties) {
      sanitized.required = sanitized.required.filter((propName: string) => {
        return propName in sanitized.properties;
      });

      // If required array is now empty, remove it
      if (sanitized.required.length === 0) {
        delete sanitized.required;
      }
    }

    return sanitized;
  }

  /**
   * Validate that a schema is suitable for Google Gemini
   * Returns validation result with error details if invalid
   */
  static validateGoogleSchema(schema: any, schemaName?: string): { valid: boolean; error?: string } {
    if (!schema || typeof schema !== 'object') {
      return { valid: false, error: 'Schema must be an object' };
    }

    // Check for unsupported properties at top level
    // Based on official Gemini API documentation - these are explicitly NOT supported
    const unsupportedProperties = [
      'default', 'examples', 'nullable', '$ref', '$schema', '$id', '$defs',
      'allOf', 'anyOf', 'oneOf', 'not',
      'minLength', 'maxLength', 'pattern',
      'uniqueItems',
      'minProperties', 'maxProperties',
      'const', 'if', 'then', 'else'
    ];

    const foundUnsupported = unsupportedProperties.filter(prop => prop in schema);
    if (foundUnsupported.length > 0) {
      return {
        valid: false,
        error: `Schema "${schemaName || 'unknown'}" contains unsupported properties: ${foundUnsupported.join(', ')}`
      };
    }

    // Check schema complexity (deep nesting can cause issues)
    const maxDepth = this.calculateSchemaDepth(schema);
    if (maxDepth > 10) {
      return {
        valid: false,
        error: `Schema "${schemaName || 'unknown'}" is too deeply nested (depth: ${maxDepth}, max: 10)`
      };
    }

    // Recursively validate nested properties
    if (schema.properties && typeof schema.properties === 'object') {
      for (const [propName, propSchema] of Object.entries(schema.properties)) {
        const result = this.validateGoogleSchema(propSchema, `${schemaName}.${propName}`);
        if (!result.valid) {
          return result;
        }
      }
    }

    // Validate array items
    if (schema.items && typeof schema.items === 'object' && !Array.isArray(schema.items)) {
      const result = this.validateGoogleSchema(schema.items, `${schemaName}.items`);
      if (!result.valid) {
        return result;
      }
    }

    return { valid: true };
  }

  /**
   * Calculate the maximum depth of a schema (for complexity checking)
   */
  private static calculateSchemaDepth(schema: any, currentDepth: number = 0): number {
    if (!schema || typeof schema !== 'object' || currentDepth > 20) {
      return currentDepth;
    }

    let maxDepth = currentDepth;

    // Check nested properties
    if (schema.properties && typeof schema.properties === 'object') {
      for (const propSchema of Object.values(schema.properties)) {
        const depth = this.calculateSchemaDepth(propSchema, currentDepth + 1);
        maxDepth = Math.max(maxDepth, depth);
      }
    }

    // Check array items
    if (schema.items && typeof schema.items === 'object') {
      const depth = this.calculateSchemaDepth(schema.items, currentDepth + 1);
      maxDepth = Math.max(maxDepth, depth);
    }

    // Check additionalProperties
    if (schema.additionalProperties && typeof schema.additionalProperties === 'object') {
      const depth = this.calculateSchemaDepth(schema.additionalProperties, currentDepth + 1);
      maxDepth = Math.max(maxDepth, depth);
    }

    return maxDepth;
  }
}

```

## services/llm/utils/ThinkingEffortMapper.ts

```typescript
/**
 * ThinkingEffortMapper - Converts unified thinking effort levels to provider-specific parameters
 *
 * Different providers implement thinking/reasoning features with different parameter names
 * and value ranges. This utility provides a consistent interface for all providers.
 */

import { ThinkingEffort, ThinkingSettings } from '../../../types/llm/ProviderTypes';

/**
 * Provider-specific thinking configuration
 */
export interface ProviderThinkingConfig {
  // Anthropic: budget_tokens
  anthropic?: {
    budget_tokens: number;
  };
  // OpenAI: reasoning.effort
  openai?: {
    reasoning: {
      effort: 'low' | 'medium' | 'high';
    };
  };
  // Google Gemini: thinkingBudget
  google?: {
    thinkingBudget: number;
  };
  // OpenRouter: reasoning.max_tokens
  openrouter?: {
    reasoning: {
      max_tokens: number;
    };
  };
  // Groq: reasoning_effort
  groq?: {
    reasoning_effort: 'low' | 'medium' | 'high';
  };
}

/**
 * Token budgets for each effort level by provider
 */
const ANTHROPIC_BUDGETS: Record<ThinkingEffort, number> = {
  low: 4000,
  medium: 16000,
  high: 32000
};

const GOOGLE_BUDGETS: Record<ThinkingEffort, number> = {
  low: 4096,
  medium: 8192,
  high: 24576
};

const OPENROUTER_BUDGETS: Record<ThinkingEffort, number> = {
  low: 4096,
  medium: 8192,
  high: 16384
};

export class ThinkingEffortMapper {
  /**
   * Get Anthropic thinking parameters
   */
  static getAnthropicParams(settings: ThinkingSettings): { budget_tokens?: number } | null {
    if (!settings.enabled) {
      return null;
    }
    return {
      budget_tokens: ANTHROPIC_BUDGETS[settings.effort]
    };
  }

  /**
   * Get OpenAI reasoning parameters
   */
  static getOpenAIParams(settings: ThinkingSettings): { reasoning?: { effort: string } } | null {
    if (!settings.enabled) {
      return null;
    }
    return {
      reasoning: {
        effort: settings.effort
      }
    };
  }

  /**
   * Get Google Gemini thinking parameters
   */
  static getGoogleParams(settings: ThinkingSettings): { thinkingBudget?: number } | null {
    if (!settings.enabled) {
      return null;
    }
    return {
      thinkingBudget: GOOGLE_BUDGETS[settings.effort]
    };
  }

  /**
   * Get OpenRouter reasoning parameters
   */
  static getOpenRouterParams(settings: ThinkingSettings): { reasoning?: { max_tokens: number } } | null {
    if (!settings.enabled) {
      return null;
    }
    return {
      reasoning: {
        max_tokens: OPENROUTER_BUDGETS[settings.effort]
      }
    };
  }

  /**
   * Get Groq reasoning parameters
   */
  static getGroqParams(settings: ThinkingSettings): { reasoning_effort?: string } | null {
    if (!settings.enabled) {
      return null;
    }
    return {
      reasoning_effort: settings.effort
    };
  }

  /**
   * Get provider-specific thinking configuration based on provider ID
   */
  static getProviderConfig(providerId: string, settings: ThinkingSettings): ProviderThinkingConfig | null {
    if (!settings.enabled) {
      return null;
    }

    switch (providerId.toLowerCase()) {
      case 'anthropic':
        return {
          anthropic: {
            budget_tokens: ANTHROPIC_BUDGETS[settings.effort]
          }
        };
      case 'openai':
        return {
          openai: {
            reasoning: {
              effort: settings.effort
            }
          }
        };
      case 'google':
      case 'gemini':
        return {
          google: {
            thinkingBudget: GOOGLE_BUDGETS[settings.effort]
          }
        };
      case 'openrouter':
        return {
          openrouter: {
            reasoning: {
              max_tokens: OPENROUTER_BUDGETS[settings.effort]
            }
          }
        };
      case 'groq':
        return {
          groq: {
            reasoning_effort: settings.effort
          }
        };
      default:
        // Unknown provider - return null
        return null;
    }
  }

  /**
   * Check if a provider supports thinking/reasoning features
   */
  static providerSupportsThinking(providerId: string): boolean {
    const supportedProviders = ['anthropic', 'openai', 'google', 'gemini', 'openrouter', 'groq'];
    return supportedProviders.includes(providerId.toLowerCase());
  }

  /**
   * Get the budget value for a given effort level and provider
   */
  static getBudget(providerId: string, effort: ThinkingEffort): number {
    switch (providerId.toLowerCase()) {
      case 'anthropic':
        return ANTHROPIC_BUDGETS[effort];
      case 'google':
      case 'gemini':
        return GOOGLE_BUDGETS[effort];
      case 'openrouter':
        return OPENROUTER_BUDGETS[effort];
      default:
        // Default to Anthropic-style budgets
        return ANTHROPIC_BUDGETS[effort];
    }
  }
}

```

## services/llm/utils/TokenUsageExtractor.ts

```typescript
/**
 * Token Usage Extractor Utility
 * Location: src/services/llm/utils/TokenUsageExtractor.ts
 *
 * Extracted from BaseAdapter.ts to follow Single Responsibility Principle.
 * Handles extraction of token usage information from different provider response formats.
 *
 * Usage:
 * - Used by BaseAdapter and all provider adapters
 * - Normalizes token usage data from different provider formats (OpenAI, Anthropic, Google, etc.)
 * - Extracts detailed token breakdowns (cached, reasoning, audio tokens)
 */

import { TokenUsage } from '../adapters/types';

export class TokenUsageExtractor {
  /**
   * Extract token usage from provider response
   * Supports multiple provider formats and detailed token breakdowns
   */
  static extractUsage(response: any): TokenUsage | undefined {
    // Check for usage data
    if (!response.usage) {
      return undefined;
    }

    const usage: TokenUsage = {
      promptTokens: response.usage.prompt_tokens || response.usage.input_tokens || 0,
      completionTokens: response.usage.completion_tokens || response.usage.output_tokens || 0,
      totalTokens: response.usage.total_tokens || 0
    };

    // Extract detailed token breakdowns (OpenAI format)
    if (response.usage.prompt_tokens_details?.cached_tokens) {
      usage.cachedTokens = response.usage.prompt_tokens_details.cached_tokens;
    }

    if (response.usage.completion_tokens_details?.reasoning_tokens) {
      usage.reasoningTokens = response.usage.completion_tokens_details.reasoning_tokens;
    }

    // Audio tokens (sum of input and output if present)
    const inputAudio = response.usage.prompt_tokens_details?.audio_tokens || 0;
    const outputAudio = response.usage.completion_tokens_details?.audio_tokens || 0;
    if (inputAudio + outputAudio > 0) {
      usage.audioTokens = inputAudio + outputAudio;
    }

    return usage;
  }

  /**
   * Format usage for streaming context (convert snake_case to camelCase)
   */
  static formatStreamingUsage(rawUsage: any): TokenUsage | undefined {
    if (!rawUsage) {
      return undefined;
    }

    return {
      promptTokens: rawUsage.prompt_tokens || rawUsage.promptTokens || 0,
      completionTokens: rawUsage.completion_tokens || rawUsage.completionTokens || 0,
      totalTokens: rawUsage.total_tokens || rawUsage.totalTokens || 0,
      cachedTokens: rawUsage.cached_tokens || rawUsage.cachedTokens,
      reasoningTokens: rawUsage.reasoning_tokens || rawUsage.reasoningTokens,
      audioTokens: rawUsage.audio_tokens || rawUsage.audioTokens
    };
  }
}

```

## services/llm/utils/ValidationUtils.ts

```typescript
/**
 * Validation Utilities
 * Comprehensive validation functions for lab kit operations
 * Based on patterns from existing validation services
 */


export interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

export interface SchemaValidationRule {
  field: string;
  type: 'string' | 'number' | 'boolean' | 'array' | 'object' | 'email' | 'url';
  required?: boolean;
  minLength?: number;
  maxLength?: number;
  min?: number;
  max?: number;
  pattern?: RegExp;
  allowedValues?: any[];
  customValidator?: (value: any) => string | null;
}

export class ValidationUtils {
  /**
   * Validate test configuration
   */
  static validateTestConfig(config: any): ValidationResult {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    // Required fields
    if (!config.name || typeof config.name !== 'string') {
      result.errors.push('Test name is required and must be a string');
      result.isValid = false;
    }

    if (!config.provider || typeof config.provider !== 'string') {
      result.errors.push('Provider is required and must be a string');
      result.isValid = false;
    }

    if (!config.scenarios || !Array.isArray(config.scenarios) || config.scenarios.length === 0) {
      result.errors.push('At least one test scenario is required');
      result.isValid = false;
    }

    // Validate scenarios
    if (config.scenarios && Array.isArray(config.scenarios)) {
      config.scenarios.forEach((scenario: any, index: number) => {
        const scenarioResult = this.validateTestScenario(scenario);
        if (!scenarioResult.isValid) {
          result.errors.push(...scenarioResult.errors.map(err => `Scenario ${index + 1}: ${err}`));
          result.isValid = false;
        }
        result.warnings.push(...scenarioResult.warnings.map(warn => `Scenario ${index + 1}: ${warn}`));
      });
    }

    // Validate evaluation criteria
    if (config.evaluation) {
      const evalResult = this.validateEvaluationConfig(config.evaluation);
      if (!evalResult.isValid) {
        result.errors.push(...evalResult.errors);
        result.isValid = false;
      }
      result.warnings.push(...evalResult.warnings);
    }

    return result;
  }

  /**
   * Validate test scenario
   */
  static validateTestScenario(scenario: any): ValidationResult {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    if (!scenario.id || typeof scenario.id !== 'string') {
      result.errors.push('Scenario ID is required and must be a string');
      result.isValid = false;
    }

    if (!scenario.userInput || typeof scenario.userInput !== 'string') {
      result.errors.push('User input is required and must be a string');
      result.isValid = false;
    }

    if (scenario.expectedOutput && typeof scenario.expectedOutput !== 'string') {
      result.errors.push('Expected output must be a string if provided');
      result.isValid = false;
    }

    // Validate metadata
    if (scenario.metadata && typeof scenario.metadata !== 'object') {
      result.errors.push('Scenario metadata must be an object');
      result.isValid = false;
    }

    // Check for overly long inputs
    if (scenario.userInput && scenario.userInput.length > 10000) {
      result.warnings.push('User input is very long (>10,000 characters) - may affect performance');
    }

    return result;
  }

  /**
   * Validate evaluation configuration
   */
  static validateEvaluationConfig(evaluation: any): ValidationResult {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    if (!evaluation.criteria || !Array.isArray(evaluation.criteria)) {
      result.errors.push('Evaluation criteria must be an array');
      result.isValid = false;
      return result;
    }

    evaluation.criteria.forEach((criterion: any, index: number) => {
      if (!criterion.name || typeof criterion.name !== 'string') {
        result.errors.push(`Criterion ${index + 1}: name is required and must be a string`);
        result.isValid = false;
      }

      if (!criterion.type || typeof criterion.type !== 'string') {
        result.errors.push(`Criterion ${index + 1}: type is required and must be a string`);
        result.isValid = false;
      }

      if (criterion.weight !== undefined) {
        if (typeof criterion.weight !== 'number' || criterion.weight < 0 || criterion.weight > 1) {
          result.errors.push(`Criterion ${index + 1}: weight must be a number between 0 and 1`);
          result.isValid = false;
        }
      }
    });

    return result;
  }

  /**
   * Validate optimization configuration
   */
  static validateOptimizationConfig(config: any): ValidationResult {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    if (!config.basePrompt || typeof config.basePrompt !== 'string') {
      result.errors.push('Base prompt is required and must be a string');
      result.isValid = false;
    }

    if (!config.testScenarios || !Array.isArray(config.testScenarios)) {
      result.errors.push('Test scenarios are required and must be an array');
      result.isValid = false;
    }

    if (config.generations && (typeof config.generations !== 'number' || config.generations < 1)) {
      result.errors.push('Generations must be a positive number');
      result.isValid = false;
    }

    if (config.populationSize && (typeof config.populationSize !== 'number' || config.populationSize < 2)) {
      result.errors.push('Population size must be at least 2');
      result.isValid = false;
    }

    if (config.mutationRate && (typeof config.mutationRate !== 'number' || config.mutationRate < 0 || config.mutationRate > 1)) {
      result.errors.push('Mutation rate must be a number between 0 and 1');
      result.isValid = false;
    }

    return result;
  }

  /**
   * Validate provider configuration
   */
  static validateProviderConfig(provider: string, config: any): ValidationResult {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    const providerValidators: Record<string, (config: any) => ValidationResult> = {
      openai: this.validateOpenAIConfig,
      google: this.validateGoogleConfig,
      anthropic: this.validateAnthropicConfig,
      mistral: this.validateMistralConfig,
      openrouter: this.validateOpenRouterConfig,
      requesty: this.validateRequestyConfig
    };

    const validator = providerValidators[provider.toLowerCase()];
    if (!validator) {
      result.errors.push(`Unknown provider: ${provider}`);
      result.isValid = false;
      return result;
    }

    return validator(config);
  }

  /**
   * Validate using custom schema
   */
  static validateSchema(data: any, rules: SchemaValidationRule[]): ValidationResult {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    for (const rule of rules) {
      const value = this.getNestedValue(data, rule.field);
      const validation = this.validateField(value, rule);
      
      if (validation.error) {
        result.errors.push(`${rule.field}: ${validation.error}`);
        result.isValid = false;
      }

      if (validation.warning) {
        result.warnings.push(`${rule.field}: ${validation.warning}`);
      }
    }

    return result;
  }

  /**
   * Validate API response format
   */
  static validateAPIResponse(response: any, expectedFields: string[]): ValidationResult {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    if (!response || typeof response !== 'object') {
      result.errors.push('Response must be an object');
      result.isValid = false;
      return result;
    }

    for (const field of expectedFields) {
      if (!(field in response)) {
        result.errors.push(`Missing required field: ${field}`);
        result.isValid = false;
      }
    }

    return result;
  }

  /**
   * Validate test result
   */
  static validateTestResult(result: any): ValidationResult {
    const validationResult: ValidationResult = {
      isValid: true,
      errors: [],
      warnings: []
    };

    const requiredFields = ['id', 'response', 'evaluation', 'timestamp'];
    const fieldValidation = this.validateAPIResponse(result, requiredFields);
    
    if (!fieldValidation.isValid) {
      validationResult.errors.push(...fieldValidation.errors);
      validationResult.isValid = false;
    }

    // Validate response structure
    if (result.response) {
      if (!result.response.content || typeof result.response.content !== 'string') {
        validationResult.errors.push('Response content is required and must be a string');
        validationResult.isValid = false;
      }

      if (result.response.tokens && typeof result.response.tokens !== 'number') {
        validationResult.errors.push('Response tokens must be a number');
        validationResult.isValid = false;
      }
    }

    // Validate evaluation structure
    if (result.evaluation) {
      if (typeof result.evaluation.overall !== 'number' || result.evaluation.overall < 0 || result.evaluation.overall > 1) {
        validationResult.errors.push('Evaluation overall score must be a number between 0 and 1');
        validationResult.isValid = false;
      }

      if (typeof result.evaluation.passed !== 'boolean') {
        validationResult.errors.push('Evaluation passed must be a boolean');
        validationResult.isValid = false;
      }
    }

    return validationResult;
  }

  // Private validation methods for specific providers

  private static validateOpenAIConfig(config: any): ValidationResult {
    const result: ValidationResult = { isValid: true, errors: [], warnings: [] };

    if (!config.apiKey || typeof config.apiKey !== 'string') {
      result.errors.push('OpenAI API key is required');
      result.isValid = false;
    }

    if (config.organization && typeof config.organization !== 'string') {
      result.errors.push('OpenAI organization must be a string');
      result.isValid = false;
    }

    return result;
  }

  private static validateGoogleConfig(config: any): ValidationResult {
    const result: ValidationResult = { isValid: true, errors: [], warnings: [] };

    if (!config.apiKey || typeof config.apiKey !== 'string') {
      result.errors.push('Google API key is required');
      result.isValid = false;
    }

    return result;
  }

  private static validateAnthropicConfig(config: any): ValidationResult {
    const result: ValidationResult = { isValid: true, errors: [], warnings: [] };

    if (!config.apiKey || typeof config.apiKey !== 'string') {
      result.errors.push('Anthropic API key is required');
      result.isValid = false;
    }

    return result;
  }

  private static validateMistralConfig(config: any): ValidationResult {
    const result: ValidationResult = { isValid: true, errors: [], warnings: [] };

    if (!config.apiKey || typeof config.apiKey !== 'string') {
      result.errors.push('Mistral API key is required');
      result.isValid = false;
    }

    return result;
  }

  private static validateOpenRouterConfig(config: any): ValidationResult {
    const result: ValidationResult = { isValid: true, errors: [], warnings: [] };

    if (!config.apiKey || typeof config.apiKey !== 'string') {
      result.errors.push('OpenRouter API key is required');
      result.isValid = false;
    }

    return result;
  }

  private static validateRequestyConfig(config: any): ValidationResult {
    const result: ValidationResult = { isValid: true, errors: [], warnings: [] };

    if (!config.apiKey || typeof config.apiKey !== 'string') {
      result.errors.push('Requesty API key is required');
      result.isValid = false;
    }

    return result;
  }

  // Helper methods

  private static validateField(value: any, rule: SchemaValidationRule): { error?: string; warning?: string } {
    // Check required
    if (rule.required && (value === undefined || value === null)) {
      return { error: 'is required' };
    }

    if (value === undefined || value === null) {
      return {}; // Optional field, skip validation
    }

    // Check type
    const actualType = Array.isArray(value) ? 'array' : typeof value;
    if (rule.type === 'email' && actualType === 'string') {
      if (!this.isValidEmail(value)) {
        return { error: 'must be a valid email address' };
      }
    } else if (rule.type === 'url' && actualType === 'string') {
      if (!this.isValidUrl(value)) {
        return { error: 'must be a valid URL' };
      }
    } else if (rule.type !== actualType) {
      return { error: `must be of type ${rule.type}` };
    }

    // Check string constraints
    if (rule.type === 'string' && typeof value === 'string') {
      if (rule.minLength && value.length < rule.minLength) {
        return { error: `must be at least ${rule.minLength} characters long` };
      }
      if (rule.maxLength && value.length > rule.maxLength) {
        return { error: `must be no more than ${rule.maxLength} characters long` };
      }
      if (rule.pattern && !rule.pattern.test(value)) {
        return { error: 'does not match the required pattern' };
      }
    }

    // Check number constraints
    if (rule.type === 'number' && typeof value === 'number') {
      if (rule.min !== undefined && value < rule.min) {
        return { error: `must be at least ${rule.min}` };
      }
      if (rule.max !== undefined && value > rule.max) {
        return { error: `must be no more than ${rule.max}` };
      }
    }

    // Check allowed values
    if (rule.allowedValues && !rule.allowedValues.includes(value)) {
      return { error: `must be one of: ${rule.allowedValues.join(', ')}` };
    }

    // Custom validation
    if (rule.customValidator) {
      const customError = rule.customValidator(value);
      if (customError) {
        return { error: customError };
      }
    }

    return {};
  }

  private static getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => current?.[key], obj);
  }

  private static isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  private static isValidUrl(url: string): boolean {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }
}

/**
 * Common validation schemas
 */
export const CommonSchemas = {
  testConfig: [
    { field: 'name', type: 'string' as const, required: true, minLength: 1 },
    { field: 'provider', type: 'string' as const, required: true },
    { field: 'scenarios', type: 'array' as const, required: true },
    { field: 'description', type: 'string' as const, required: false },
    { field: 'timeout', type: 'number' as const, required: false, min: 1000 }
  ],

  scenario: [
    { field: 'id', type: 'string' as const, required: true, minLength: 1 },
    { field: 'userInput', type: 'string' as const, required: true, minLength: 1 },
    { field: 'expectedOutput', type: 'string' as const, required: false },
    { field: 'metadata', type: 'object' as const, required: false }
  ],

  optimizationConfig: [
    { field: 'basePrompt', type: 'string' as const, required: true, minLength: 10 },
    { field: 'testScenarios', type: 'array' as const, required: true },
    { field: 'generations', type: 'number' as const, required: false, min: 1, max: 100 },
    { field: 'populationSize', type: 'number' as const, required: false, min: 2, max: 50 },
    { field: 'mutationRate', type: 'number' as const, required: false, min: 0, max: 1 }
  ]
};
```

## services/llm/utils/WebSearchUtils.ts

```typescript
/**
 * Location: src/services/llm/utils/WebSearchUtils.ts
 * Summary: Utility functions for web search source extraction and formatting
 * Used by: LLM adapters for standardized source extraction and markdown formatting
 */

import { SearchResult } from '../adapters/types';

export class WebSearchUtils {
  /**
   * Format web search sources as markdown
   */
  static formatSourcesAsMarkdown(sources: SearchResult[]): string {
    if (!sources || sources.length === 0) {
      return '';
    }

    return sources
      .map(source =>
        `- [${source.title}](${source.url})${source.date ? ` - ${source.date}` : ''}`
      )
      .join('\n');
  }

  /**
   * Validate and normalize a search result
   */
  static validateSearchResult(result: any): SearchResult | null {
    if (!result || typeof result !== 'object') {
      return null;
    }

    if (!result.title || !result.url) {
      return null;
    }

    // Validate URL format
    try {
      new URL(result.url);
    } catch {
      return null;
    }

    return {
      title: String(result.title).trim(),
      url: String(result.url).trim(),
      date: result.date ? String(result.date).trim() : undefined
    };
  }

  /**
   * Extract and validate multiple search results
   */
  static extractSearchResults(results: any[]): SearchResult[] {
    if (!Array.isArray(results)) {
      return [];
    }

    return results
      .map(result => this.validateSearchResult(result))
      .filter((result): result is SearchResult => result !== null);
  }

  /**
   * Generate sources section for markdown content
   */
  static generateSourcesSection(sources: SearchResult[]): string {
    if (!sources || sources.length === 0) {
      return '';
    }

    const sourcesMarkdown = this.formatSourcesAsMarkdown(sources);
    return `\n\n---\n\n## Sources\n\n${sourcesMarkdown}`;
  }

  /**
   * Check if provider supports web search
   */
  static isWebSearchSupported(provider: string): boolean {
    const supportedProviders = [
      'perplexity',
      'openrouter',
      'openai',
      'google',
      'anthropic',
      'groq',
      'mistral'
    ];

    return supportedProviders.includes(provider.toLowerCase());
  }

  /**
   * Validate web search request
   */
  static validateWebSearchRequest(provider: string, webSearchRequested: boolean): void {
    if (webSearchRequested && !this.isWebSearchSupported(provider)) {
      const supportedProviders = [
        'perplexity', 'openrouter', 'openai',
        'google', 'anthropic', 'groq', 'mistral'
      ];

      throw new Error(
        `Web search not supported by ${provider}. ` +
        `Supported providers: ${supportedProviders.join(', ')}`
      );
    }
  }
}
```

## services/llm/validation/index.ts

```typescript
/**
 * LLM Validation Services Index
 * Exports for API key validation functionality
 */

export { LLMValidationService } from './ValidationService';
```

## services/llm/validation/ValidationService.ts

```typescript
/**
 * LLM Validation Service
 * Direct API key validation without full adapter initialization
 *
 * MOBILE COMPATIBILITY (Dec 2025):
 * - Removed Node.js crypto import
 * - Uses simple djb2 hash for validation caching (not cryptographic, but sufficient)
 * - All validation uses Obsidian's requestUrl (no SDK imports)
 */

import { requestUrl } from 'obsidian';
import { BRAND_NAME } from '../../../constants/branding';

// Browser-compatible hash function (djb2 algorithm)
// Not cryptographically secure but sufficient for cache key validation
function generateHash(input: string): string {
  let hash = 5381;
  for (let i = 0; i < input.length; i++) {
    hash = ((hash << 5) + hash) + input.charCodeAt(i);
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash).toString(16);
}

export class LLMValidationService {
  private static readonly VALIDATION_TIMEOUT = 10000; // 10 seconds
  private static readonly VALIDATION_DELAY = 2000; // 2 seconds delay before validation

  /**
   * Create a hash of the API key for validation caching
   */
  private static createKeyHash(apiKey: string): string {
    return generateHash(apiKey).substring(0, 16);
  }

  /**
   * Check if cached validation is still fresh (< 24 hours old and key unchanged)
   */
  private static isValidationCacheFresh(
    provider: string,
    apiKey: string,
    providerConfig?: { lastValidated?: number; validationHash?: string }
  ): boolean {
    if (!providerConfig?.lastValidated || !providerConfig?.validationHash) {
      return false; // No cache exists
    }
    
    // Check if key has changed
    const currentHash = this.createKeyHash(apiKey);
    if (currentHash !== providerConfig.validationHash) {
      return false; // Key changed since last validation
    }
    
    // Check if validation is less than 24 hours old
    const twentyFourHoursMs = 24 * 60 * 60 * 1000;
    const age = Date.now() - providerConfig.lastValidated;
    
    return age < twentyFourHoursMs;
  }

  /**
   * Wrapper for requestUrl with timeout support
   */
  private static async requestWithTimeout(config: any): Promise<any> {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error('Request timeout'));
      }, this.VALIDATION_TIMEOUT);

      requestUrl(config)
        .then(response => {
          clearTimeout(timeoutId);
          resolve(response);
        })
        .catch(error => {
          clearTimeout(timeoutId);
          reject(error);
        });
    });
  }

  /**
   * Validate an API key by making a simple test request
   */
  static async validateApiKey(
    provider: string,
    apiKey: string,
    options?: {
      forceValidation?: boolean;  // Set true to bypass cache
      providerConfig?: { lastValidated?: number; validationHash?: string };
      onValidationSuccess?: (hash: string, timestamp: number) => void;  // Callback to save validation state
    }
  ): Promise<{ success: boolean; error?: string }> {
    try {
      // Check cache first (unless forced)
      if (!options?.forceValidation && options?.providerConfig) {
        if (this.isValidationCacheFresh(provider, apiKey, options.providerConfig)) {
          return { success: true };
        }
      }
      
      // Wait before validation
      await new Promise(resolve => setTimeout(resolve, this.VALIDATION_DELAY));
      
      // Perform actual validation
      let result: { success: boolean; error?: string };
      
      switch (provider) {
        case 'openai':
          result = await this.validateOpenAI(apiKey);
          break;
        case 'anthropic':
          result = await this.validateAnthropic(apiKey);
          break;
        case 'google':
          result = await this.validateGoogle(apiKey);
          break;
        case 'mistral':
          result = await this.validateMistral(apiKey);
          break;
        case 'groq':
          result = await this.validateGroq(apiKey);
          break;
        case 'openrouter':
          result = await this.validateOpenRouter(apiKey);
          break;
        case 'perplexity':
          result = await this.validatePerplexity(apiKey);
          break;
        case 'requesty':
          result = await this.validateRequesty(apiKey);
          break;
        default:
          return { success: false, error: `Unsupported provider: ${provider}` };
      }
      
      // If validation succeeded, update cache via callback
      if (result.success && options?.onValidationSuccess) {
        const hash = this.createKeyHash(apiKey);
        const timestamp = Date.now();
        options.onValidationSuccess(hash, timestamp);
      }
      
      return result;
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  }

  private static async validateOpenAI(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      // Use Obsidian's requestUrl instead of SDK for mobile compatibility
      const response = await this.requestWithTimeout({
        url: 'https://api.openai.com/v1/chat/completions',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: 'gpt-5-nano',
          messages: [{ role: 'user', content: 'Hi' }],
          max_tokens: 5
        })
      });

      if (response.status >= 200 && response.status < 300) {
        return { success: true };
      } else {
        const errorData = response.json || {};
        return {
          success: false,
          error: errorData.error?.message || `HTTP ${response.status}`
        };
      }
    } catch (error: any) {
      return {
        success: false,
        error: error.message || 'OpenAI API key validation failed'
      };
    }
  }

  private static async validateAnthropic(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      // Use Obsidian's requestUrl to bypass CORS restrictions
      const response = await this.requestWithTimeout({
        url: 'https://api.anthropic.com/v1/messages',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': apiKey,
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model: 'claude-3-5-haiku-latest',
          max_tokens: 5,
          messages: [{ role: 'user', content: 'Hi' }]
        })
      });

      if (response.status >= 200 && response.status < 300) {
        return { success: true };
      } else {
        const errorData = response.json || {};
        return { 
          success: false, 
          error: errorData.error?.message || `HTTP ${response.status}` 
        };
      }
    } catch (error: any) {
      return { 
        success: false, 
        error: error.message || 'Anthropic API key validation failed' 
      };
    }
  }

  private static async validateGoogle(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await this.requestWithTimeout({
        url: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-goog-api-key': apiKey
        },
        body: JSON.stringify({
          contents: [{ parts: [{ text: 'Hi' }] }],
          generationConfig: { maxOutputTokens: 5 }
        })
      });

      if (response.status >= 200 && response.status < 300) {
        return { success: true };
      } else {
        const errorData = response.json || {};
        return { 
          success: false, 
          error: errorData.error?.message || `HTTP ${response.status}` 
        };
      }
    } catch (error: any) {
      return { 
        success: false, 
        error: error.message || 'Google API key validation failed' 
      };
    }
  }

  private static async validateMistral(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await this.requestWithTimeout({
        url: 'https://api.mistral.ai/v1/chat/completions',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: 'mistral-tiny',
          messages: [{ role: 'user', content: 'Hi' }],
          max_tokens: 5
        })
      });

      if (response.status >= 200 && response.status < 300) {
        return { success: true };
      } else {
        const errorData = response.json || {};
        return { 
          success: false, 
          error: errorData.error?.message || `HTTP ${response.status}` 
        };
      }
    } catch (error: any) {
      return { 
        success: false, 
        error: error.message || 'Mistral API key validation failed' 
      };
    }
  }

  private static async validateGroq(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await this.requestWithTimeout({
        url: 'https://api.groq.com/openai/v1/chat/completions',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: 'llama3-8b-8192',
          messages: [{ role: 'user', content: 'Hi' }],
          max_tokens: 5
        })
      });

      if (response.status >= 200 && response.status < 300) {
        return { success: true };
      } else {
        const errorData = response.json || {};
        return { 
          success: false, 
          error: errorData.error?.message || `HTTP ${response.status}` 
        };
      }
    } catch (error: any) {
      return { 
        success: false, 
        error: error.message || 'Groq API key validation failed' 
      };
    }
  }

  private static async validateOpenRouter(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      const requestBody = {
        model: 'openai/gpt-5-nano',
        messages: [{ role: 'user', content: 'Hi' }],
        max_tokens: 5
      };
      
      const response = await this.requestWithTimeout({
        url: 'https://openrouter.ai/api/v1/chat/completions',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`,
          'HTTP-Referer': 'https://synapticlabs.ai',
          'X-Title': BRAND_NAME
        },
        body: JSON.stringify(requestBody)
      });

      if (response.status >= 200 && response.status < 300) {
        return { success: true };
      } else {
        const errorData = response.json || {};
        const errorMessage = errorData.error?.message || JSON.stringify(errorData) || `HTTP ${response.status}`;
        console.error('OpenRouter validation error:', errorMessage);
        return { 
          success: false, 
          error: errorMessage
        };
      }
    } catch (error: any) {
      console.error('OpenRouter validation exception:', error);
      return { 
        success: false, 
        error: error.message || 'OpenRouter API key validation failed' 
      };
    }
  }

  private static async validatePerplexity(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await this.requestWithTimeout({
        url: 'https://api.perplexity.ai/chat/completions',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: 'sonar',
          messages: [{ role: 'user', content: 'Hi' }],
          max_tokens: 5
        })
      });

      if (response.status >= 200 && response.status < 300) {
        return { success: true };
      } else {
        const errorData = response.json || {};
        return { 
          success: false, 
          error: errorData.error?.message || `HTTP ${response.status}` 
        };
      }
    } catch (error: any) {
      return { 
        success: false, 
        error: error.message || 'Perplexity API key validation failed' 
      };
    }
  }

  private static async validateRequesty(apiKey: string): Promise<{ success: boolean; error?: string }> {
    try {
      const response = await this.requestWithTimeout({
        url: 'https://router.requesty.ai/v1/chat/completions',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: 'openai/gpt-5-nano',
          messages: [{ role: 'user', content: 'Hi' }],
          max_tokens: 5
        })
      });

      if (response.status >= 200 && response.status < 300) {
        return { success: true };
      } else {
        const errorData = response.json || {};
        return { 
          success: false, 
          error: errorData.error?.message || `HTTP ${response.status}` 
        };
      }
    } catch (error: any) {
      return { 
        success: false, 
        error: error.message || 'Requesty API key validation failed' 
      };
    }
  }
}

```

## services/mcp/MCPConnectionManager.ts

```typescript
import { App, Plugin, Events } from 'obsidian';
import { MCPServer } from '../../server';
import { SessionContextManager } from '../SessionContextManager';
import { CustomPromptStorageService } from "../../agents/promptManager/services/CustomPromptStorageService";
import { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';
import { logger } from '../../utils/logger';

/**
 * Location: src/services/mcp/MCPConnectionManager.ts
 * 
 * This service manages the MCP server connection lifecycle, including:
 * - Server creation and initialization
 * - Connection handling and management
 * - Server lifecycle (start/stop/shutdown)
 * 
 * Used by: MCPConnector
 * Dependencies: MCPServer, Obsidian Events, SessionContextManager
 */

export interface MCPConnectionManagerInterface {
    /**
     * Initializes MCP connection manager
     * @throws InitializationError when initialization fails
     */
    initialize(): Promise<void>;

    /**
     * Creates and configures MCP server
     * @returns Configured MCP server instance
     * @throws ServerCreationError when server creation fails
     */
    createServer(): Promise<MCPServer>;

    /**
     * Starts the MCP server
     * @throws ServerStartError when server start fails
     */
    start(): Promise<void>;

    /**
     * Stops the MCP server
     * @throws ServerStopError when server stop fails
     */
    stop(): Promise<void>;

    /**
     * Shuts down connection manager and cleans up resources
     */
    shutdown(): Promise<void>;

    /**
     * Gets current MCP server instance
     * @returns Current server instance or null if not initialized
     */
    getServer(): MCPServer | null;

    /**
     * Gets connection status information
     * @returns Connection status details
     */
    getConnectionStatus(): MCPConnectionStatus;

    /**
     * Reinitializes the request router
     * Used after agent registration changes
     */
    reinitializeRequestRouter(): void;
}

export interface MCPConnectionStatus {
    /** Whether manager is initialized */
    isInitialized: boolean;
    
    /** Whether server is running */
    isServerRunning: boolean;
    
    /** Server creation timestamp */
    serverCreatedAt?: Date;
    
    /** Last error encountered */
    lastError?: {
        message: string;
        timestamp: Date;
    };
}

export class MCPConnectionManager implements MCPConnectionManagerInterface {
    private server: MCPServer | null = null;
    private isInitialized = false;
    private isServerRunning = false;
    private serverCreatedAt?: Date;
    private lastError?: { message: string; timestamp: Date };
    private sessionContextManager: SessionContextManager | null = null;
    private serviceManager: any = null;

    constructor(
        private app: App,
        private plugin: Plugin,
        private events: Events,
        serviceManager: any,
        private customPromptStorage?: CustomPromptStorageService,
        private onToolCall?: (toolName: string, params: any) => Promise<void>,
        private onToolResponse?: (toolName: string, params: any, response: any, success: boolean, executionTime: number) => Promise<void>
    ) {
        this.serviceManager = serviceManager;
    }

    /**
     * Lazy getter for SessionContextManager from ServiceManager
     * Ensures we use the properly initialized instance with SessionService injected
     */
    private getSessionContextManagerFromService(): SessionContextManager {
        if (!this.sessionContextManager) {
            if (!this.serviceManager) {
                throw new Error('[MCPConnectionManager] ServiceManager not available - cannot get SessionContextManager');
            }

            this.sessionContextManager = this.serviceManager.getServiceIfReady('sessionContextManager');

            if (!this.sessionContextManager) {
                throw new Error('[MCPConnectionManager] SessionContextManager not available from ServiceManager');
            }
        }
        return this.sessionContextManager;
    }

    /**
     * Initializes MCP connection manager
     */
    async initialize(): Promise<void> {
        if (this.isInitialized) {
            return; // Already initialized
        }

        try {
            // Wire up ToolCallTraceService to onToolResponse callback
            await this.initializeToolCallTracing();

            // Create the MCP server
            this.server = await this.createServer();
            this.isInitialized = true;

            logger.systemLog('MCP Connection Manager initialized successfully');
        } catch (error) {
            this.lastError = {
                message: (error as Error).message,
                timestamp: new Date()
            };

            logger.systemError(error as Error, 'MCP Connection Manager Initialization');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to initialize MCP connection manager',
                error
            );
        }
    }

    /**
     * Initialize tool call tracing by wrapping onToolResponse callback
     */
    private async initializeToolCallTracing(): Promise<void> {
        try {
            // Get ToolCallTraceService from service manager
            const pluginWithServices = this.plugin as Plugin & { getService?: (name: string) => Promise<unknown> };
            if (!pluginWithServices.getService) {
                logger.systemWarn('Plugin does not support getService - tool call tracing disabled');
                return;
            }

            const toolCallTraceService = await pluginWithServices.getService('toolCallTraceService') as { captureToolCall: (toolName: string, params: unknown, response: unknown, success: boolean, executionTime: number) => Promise<void> } | null;
            if (!toolCallTraceService) {
                logger.systemWarn('ToolCallTraceService not available - tool call tracing disabled');
                return;
            }

            // Wrap the existing onToolResponse callback to include tracing
            const originalOnToolResponse = this.onToolResponse;
            this.onToolResponse = async (toolName, params, response, success, executionTime) => {
                // Call original callback first (if exists)
                if (originalOnToolResponse) {
                    await originalOnToolResponse(toolName, params, response, success, executionTime);
                }

                // Capture tool call trace (non-blocking, errors handled internally)
                await toolCallTraceService.captureToolCall(toolName, params, response, success, executionTime);
            };

            logger.systemLog('Tool call tracing initialized successfully');
        } catch (error) {
            // Don't throw - tracing is optional
            logger.systemWarn('Failed to initialize tool call tracing: ' + (error as Error).message);
        }
    }

    /**
     * Creates and configures MCP server
     */
    async createServer(): Promise<MCPServer> {
        try {
            const server = new MCPServer(
                this.app,
                this.plugin,
                this.events,
                this.getSessionContextManagerFromService(),
                undefined, // serviceContainer will be set later if needed
                this.customPromptStorage,
                this.onToolCall,
                this.onToolResponse
            );

            this.serverCreatedAt = new Date();
            
            logger.systemLog('MCP Server created successfully');
            return server;
        } catch (error) {
            this.lastError = {
                message: (error as Error).message,
                timestamp: new Date()
            };
            
            logger.systemError(error as Error, 'MCP Server Creation');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to create MCP server',
                error
            );
        }
    }

    /**
     * Starts the MCP server
     */
    async start(): Promise<void> {
        if (!this.server) {
            logger.systemError(new Error('Server not initialized'), 'Cannot start server: server not initialized');
            throw new McpError(
                ErrorCode.InternalError,
                'Cannot start server: server not initialized'
            );
        }

        try {
            await this.server.start();
            this.isServerRunning = true;
            
            logger.systemLog('MCP Server started successfully');
        } catch (error) {
            this.lastError = {
                message: (error as Error).message,
                timestamp: new Date()
            };
            
            logger.systemError(error as Error, 'MCP Server Start');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to start MCP server',
                error
            );
        }
    }

    /**
     * Stops the MCP server
     */
    async stop(): Promise<void> {
        if (!this.server) {
            return; // No server to stop
        }

        try {
            await this.server.stop();
            this.isServerRunning = false;
            
            logger.systemLog('MCP Server stopped successfully');
        } catch (error) {
            this.lastError = {
                message: (error as Error).message,
                timestamp: new Date()
            };
            
            logger.systemError(error as Error, 'MCP Server Stop');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to stop MCP server',
                error
            );
        }
    }

    /**
     * Shuts down connection manager and cleans up resources
     */
    async shutdown(): Promise<void> {
        try {
            if (this.isServerRunning) {
                await this.stop();
            }

            this.server = null;
            this.isInitialized = false;
            this.isServerRunning = false;
            this.serverCreatedAt = undefined;
            this.lastError = undefined;
            
            logger.systemLog('MCP Connection Manager shut down successfully');
        } catch (error) {
            this.lastError = {
                message: (error as Error).message,
                timestamp: new Date()
            };
            
            logger.systemError(error as Error, 'MCP Connection Manager Shutdown');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to shutdown MCP connection manager',
                error
            );
        }
    }

    /**
     * Gets current MCP server instance
     */
    getServer(): MCPServer | null {
        return this.server;
    }

    /**
     * Gets connection status information
     */
    getConnectionStatus(): MCPConnectionStatus {
        return {
            isInitialized: this.isInitialized,
            isServerRunning: this.isServerRunning,
            serverCreatedAt: this.serverCreatedAt,
            lastError: this.lastError
        };
    }

    /**
     * Reinitializes the request router
     */
    reinitializeRequestRouter(): void {
        if (!this.server) {
            logger.systemWarn('Cannot reinitialize request router: server not initialized');
            return;
        }

        try {
            this.server.reinitializeRequestRouter();
            logger.systemLog('Request router reinitialized successfully');
        } catch (error) {
            logger.systemError(error as Error, 'Request Router Reinitialization');
            throw new McpError(
                ErrorCode.InternalError,
                'Failed to reinitialize request router',
                error
            );
        }
    }
}
```

## services/mcp/ToolCallRouter.ts

```typescript
import { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js';
import { logger } from '../../utils/logger';

/**
 * Location: src/services/mcp/ToolCallRouter.ts
 * 
 * This service handles routing tool calls to appropriate agents and modes, including:
 * - Tool call request validation
 * - Agent/mode resolution and execution
 * - Error handling and response formatting
 * - Tool call capture coordination
 * 
 * Used by: MCPConnector
 * Dependencies: Agent implementations, ToolCallCaptureService
 */

export interface AgentToolParams {
    agent: string;
    tool: string;
    params: Record<string, unknown>;
}

export interface ToolCallRequest {
    params: {
        name: string;
        arguments: Record<string, any>;
    };
    meta?: {
        requestId?: string;
        timestamp?: Date;
        source?: string;
    };
}

export interface ToolCallResponse {
    content: Array<{
        type: 'text' | 'resource';
        text?: string;
        resource?: any;
    }>;
    isError?: boolean;
    error?: {
        code: string;
        message: string;
        data?: any;
    };
}

export interface ToolCallRouterInterface {
    /**
     * Routes tool call request to appropriate agent/mode
     * @param request MCP tool call request
     * @returns Promise resolving to tool call response
     * @throws RoutingError when routing fails
     * @throws ValidationError when request is invalid
     */
    route(request: ToolCallRequest): Promise<ToolCallResponse>;

    /**
     * Executes agent tool directly
     * @param agent Agent name
     * @param tool Tool name
     * @param params Tool parameters
     * @returns Promise resolving to execution result
     */
    executeAgentTool(agent: string, tool: string, params: Record<string, unknown>): Promise<unknown>;

    /**
     * Validates tool call request
     * @param request Request to validate
     * @returns Validation result
     */
    validateRequest(request: ToolCallRequest): ValidationResult;

    /**
     * Validates batch operations if present
     * @param params Parameters that may contain batch operations
     * @throws ValidationError when batch operations are invalid
     */
    validateBatchOperations(params: Record<string, any>): void;

    /**
     * Sets the server reference for agent tool execution
     * @param server Server instance that handles agent tool execution
     */
    setServer(server: unknown): void;
}

export interface ValidationResult {
    isValid: boolean;
    errors: string[];
}

export class ToolCallRouter implements ToolCallRouterInterface {
    private server: { executeAgentTool: (agent: string, tool: string, params: Record<string, unknown>) => Promise<unknown> } | null = null;

    constructor() {}

    /**
     * Routes tool call request to appropriate agent/tool
     */
    async route(request: ToolCallRequest): Promise<ToolCallResponse> {
        try {
            // Validate the request
            const validation = this.validateRequest(request);
            if (!validation.isValid) {
                throw new McpError(
                    ErrorCode.InvalidRequest,
                    `Invalid tool call: ${validation.errors.join(', ')}`
                );
            }

            // Parse tool name to get agent (strip vault suffix)
            const { agentName } = this.parseToolName(request.params.name);

            // Get tool from arguments
            const toolName = request.params.arguments.tool;
            if (!toolName) {
                throw new McpError(
                    ErrorCode.InvalidParams,
                    'Tool parameter is required in tool arguments'
                );
            }

            // Validate batch operations if present
            this.validateBatchOperations(request.params.arguments);

            // Execute the agent tool
            const result = await this.executeAgentTool(
                agentName,
                toolName,
                request.params.arguments
            );

            return this.buildSuccessResponse(result);

        } catch (error) {
            return this.buildErrorResponse(error);
        }
    }

    /**
     * Executes agent tool directly
     */
    async executeAgentTool(agent: string, tool: string, params: Record<string, unknown>): Promise<unknown> {
        if (!this.server) {
            throw new McpError(
                ErrorCode.InternalError,
                'Server not initialized for tool call routing'
            );
        }

        try {
            // Delegate to server's executeAgentTool method
            return await this.server.executeAgentTool(agent, tool, params);
        } catch (error) {
            if (error instanceof McpError) {
                throw error;
            }
            
            logger.systemError(error as Error, 'Agent Tool Execution');
            throw new McpError(
                ErrorCode.InternalError,
                `Failed to execute ${agent}_${tool}`,
                error
            );
        }
    }

    /**
     * Validates tool call request
     */
    validateRequest(request: ToolCallRequest): ValidationResult {
        const errors: string[] = [];

        if (!request.params?.name) {
            errors.push('Tool name is required');
        }

        if (!request.params?.arguments) {
            errors.push('Tool arguments are required');
        }

        // Validate tool name format
        if (request.params?.name) {
            try {
                this.parseToolName(request.params.name);
            } catch (error) {
                errors.push((error as Error).message);
            }
        }

        return { isValid: errors.length === 0, errors };
    }

    /**
     * Validates batch operations if present in parameters
     */
    validateBatchOperations(params: Record<string, any>): void {
        // Validate batch operations if they exist
        if (params && params.operations && Array.isArray(params.operations)) {
            params.operations.forEach((operation: any, index: number) => {
                if (!operation || typeof operation !== 'object') {
                    throw new McpError(
                        ErrorCode.InvalidParams,
                        `Invalid operation at index ${index} in batch operations: operation must be an object`
                    );
                }

                if (!operation.type) {
                    throw new McpError(
                        ErrorCode.InvalidParams,
                        `Invalid operation at index ${index} in batch operations: missing 'type' property`
                    );
                }

                // Check for either filePath in params or path at the operation level
                if ((!operation.params || !operation.params.filePath) && !operation.path) {
                    throw new McpError(
                        ErrorCode.InvalidParams,
                        `Invalid operation at index ${index} in batch operations: missing 'filePath' property in params`
                    );
                }
            });
        }

        // Validate batch read paths if they exist
        if (params && params.paths && Array.isArray(params.paths)) {
            params.paths.forEach((path: any, index: number) => {
                if (typeof path !== 'string') {
                    throw new McpError(
                        ErrorCode.InvalidParams,
                        `Invalid path at index ${index} in batch paths: path must be a string`
                    );
                }
            });
        }
    }

    /**
     * Sets the server reference for agent tool execution
     */
    setServer(server: { executeAgentTool: (agent: string, tool: string, params: Record<string, unknown>) => Promise<unknown> }): void {
        this.server = server;
    }

    /**
     * Parses tool name into agent and tool components
     * Tool name format: agentName (vault context is implicit from IPC connection)
     * Mode is extracted from request parameters, not tool name
     * @private
     */
    private parseToolName(toolName: string): { agentName: string; modeName: string } {
        // Tool name is just the agent name
        // Mode is passed separately in the request arguments
        return { agentName: toolName, modeName: '' };
    }

    /**
     * Builds successful response
     * @private
     */
    private buildSuccessResponse(result: any): ToolCallResponse {
        return {
            content: [{
                type: 'text',
                text: typeof result === 'string' ? result : JSON.stringify(result, null, 2)
            }],
            isError: false
        };
    }

    /**
     * Builds error response
     * @private
     */
    private buildErrorResponse(error: any): ToolCallResponse {
        const errorMessage = error instanceof Error ? error.message : String(error);
        const errorCode = error instanceof McpError ? error.code : ErrorCode.InternalError;

        return {
            content: [{
                type: 'text',
                text: `Error: ${errorMessage}`
            }],
            isError: true,
            error: {
                code: String(errorCode),
                message: errorMessage,
                data: error instanceof McpError ? error.data : undefined
            }
        };
    }
}
```

## services/memory/index.ts

```typescript
/**
 * Memory Management Services - Simplified Implementation
 * 
 * Provides basic memory monitoring with hardcoded balanced approach.
 * No user configuration needed - uses optimal settings by default.
 */

import { SimpleMemoryMonitor } from './SimpleMemoryMonitor';
import { TraceMetadataBuilder, buildTraceMetadata } from './TraceMetadataBuilder';

export { SimpleMemoryMonitor, TraceMetadataBuilder, buildTraceMetadata };

// Create singleton instance for easy access
export const memoryMonitor = SimpleMemoryMonitor.getInstance();

```

## services/memory/LegacyTraceMetadataNormalizer.ts

```typescript
import {
  TraceContextMetadata,
  TraceInputMetadata,
  TraceMetadata,
  TraceOutcomeMetadata,
  TraceToolMetadata
} from '../../database/workspace-types';
import { TraceMetadataBuilder } from './TraceMetadataBuilder';

export interface LegacyTraceNormalizationInput {
  workspaceId: string;
  sessionId: string;
  traceType?: string;
  metadata?: any;
}

export function normalizeLegacyTraceMetadata(
  input: LegacyTraceNormalizationInput
): TraceMetadata | undefined {
  const rawMetadata = input.metadata;
  if (!rawMetadata) {
    return undefined;
  }

  if ((rawMetadata as TraceMetadata).schemaVersion) {
    return rawMetadata as TraceMetadata;
  }

  const toolMetadata = buildToolMetadata(rawMetadata.tool || input.traceType || 'unknown');
  const context = buildContextMetadata(input.workspaceId, input.sessionId, rawMetadata);
  const inputFiles =
    Array.isArray(rawMetadata.relatedFiles) && rawMetadata.relatedFiles.length > 0
      ? rawMetadata.relatedFiles
      : undefined;
  const inputSection = buildInputMetadata(rawMetadata, inputFiles);
  const outcome = buildOutcome(rawMetadata);

  return TraceMetadataBuilder.create({
    tool: toolMetadata,
    context,
    input: inputSection,
    outcome,
    legacy: TraceMetadataBuilder.extractLegacyFromMetadata(rawMetadata)
  });
}

function buildToolMetadata(toolId: string): TraceToolMetadata {
  const normalizedId = toolId.includes('.') ? toolId : toolId.replace(/_/g, '.');
  const [agent, mode] = normalizedId.split('.', 2);

  return {
    id: normalizedId,
    agent: agent || normalizedId || 'unknown',
    mode: mode || 'unknown'
  };
}

function buildContextMetadata(
  workspaceId: string,
  sessionId: string,
  rawMetadata: any
): TraceContextMetadata {
  const legacyContext = rawMetadata?.params?.context || rawMetadata?.context || {};

  // Check if new format (memory/goal/constraints) is present
  const hasNewFormat = legacyContext.memory || legacyContext.goal;

  if (hasNewFormat) {
    // Return new format (TraceContextMetadataV2)
    return {
      workspaceId,
      sessionId,
      memory: legacyContext.memory || '',
      goal: legacyContext.goal || '',
      constraints: legacyContext.constraints,
      tags: legacyContext.tags
    };
  }

  // Return legacy format (LegacyTraceContextMetadata) for backward compatibility
  const additionalContext = legacyContext.additionalContext || rawMetadata?.additionalContext;
  return {
    workspaceId,
    sessionId,
    sessionDescription: legacyContext.sessionDescription,
    sessionMemory: legacyContext.sessionMemory,
    toolContext: legacyContext.toolContext,
    primaryGoal: legacyContext.primaryGoal,
    subgoal: legacyContext.subgoal,
    tags: legacyContext.tags,
    additionalContext
  };
}

function buildInputMetadata(rawMetadata: any, files?: string[]): TraceInputMetadata | undefined {
  let normalizedArgs = rawMetadata?.params;
  if (
    normalizedArgs &&
    typeof normalizedArgs === 'object' &&
    !Array.isArray(normalizedArgs)
  ) {
    const { context, ...rest } = normalizedArgs;
    normalizedArgs = Object.keys(rest).length > 0 ? rest : undefined;
  }

  const hasArguments = normalizedArgs !== undefined;
  const hasFiles = Array.isArray(files) && files.length > 0;

  if (!hasArguments && !hasFiles) {
    return undefined;
  }

  return {
    arguments: normalizedArgs,
    files: hasFiles ? files : undefined
  };
}

function buildOutcome(rawMetadata: any): TraceOutcomeMetadata {
  const success =
    typeof rawMetadata?.result?.success === 'boolean'
      ? rawMetadata.result.success
      : typeof rawMetadata?.response?.success === 'boolean'
        ? rawMetadata.response.success
        : true;

  const errorSource = rawMetadata?.result?.error || rawMetadata?.response?.error;

  const error =
    errorSource && (errorSource.message || typeof errorSource === 'string')
      ? {
          type: errorSource.type,
          message:
            errorSource.message || (typeof errorSource === 'string' ? errorSource : 'Unknown error'),
          code: errorSource.code
        }
      : undefined;

  return {
    success,
    error
  };
}

```

## services/memory/SimpleMemoryMonitor.ts

```typescript
/**
 * Simple Memory Monitor - Hardcoded Balanced Approach
 * 
 * Provides basic memory monitoring without complex configuration.
 * Uses hardcoded balanced settings as requested by user.
 */

/**
 * Chrome-specific memory API (non-standard)
 * Only available in Chromium-based browsers
 */
interface ChromeMemoryInfo {
  usedJSHeapSize?: number;
  totalJSHeapSize?: number;
  jsHeapSizeLimit?: number;
}

interface PerformanceWithMemory extends Performance {
  memory?: ChromeMemoryInfo;
}

interface MemoryInfo {
  used: number;
  total: number;
  jsHeapSizeLimit?: number;
  usagePercent: number;
}

interface MemoryPressureLevel {
  level: 'normal' | 'warning' | 'high' | 'critical';
  threshold: number;
}

export class SimpleMemoryMonitor {
  private static instance: SimpleMemoryMonitor | null = null;
  private isMonitoring = false;
  private checkInterval: NodeJS.Timeout | null = null;
  
  // Hardcoded balanced thresholds
  private readonly thresholds = {
    warning: 60,   // 60% memory usage
    high: 75,      // 75% memory usage  
    critical: 85   // 85% memory usage
  };

  private constructor() {}

  static getInstance(): SimpleMemoryMonitor {
    if (!SimpleMemoryMonitor.instance) {
      SimpleMemoryMonitor.instance = new SimpleMemoryMonitor();
    }
    return SimpleMemoryMonitor.instance;
  }

  startMonitoring(): void {
    if (this.isMonitoring) return;
    
    this.isMonitoring = true;
    
    // Check memory every 30 seconds
    this.checkInterval = setInterval(() => {
      this.checkMemoryPressure();
    }, 30000);
  }

  stopMonitoring(): void {
    if (!this.isMonitoring) return;
    
    this.isMonitoring = false;
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
  }

  getCurrentMemoryInfo(): MemoryInfo {
    const perfWithMemory = performance as PerformanceWithMemory;
    const memInfo = perfWithMemory.memory;

    if (!memInfo) {
      // Fallback if memory API not available
      return {
        used: 0,
        total: 0,
        usagePercent: 0
      };
    }

    const used = memInfo.usedJSHeapSize || 0;
    const total = memInfo.jsHeapSizeLimit || memInfo.totalJSHeapSize || 0;
    const usagePercent = total > 0 ? (used / total) * 100 : 0;

    return {
      used,
      total,
      jsHeapSizeLimit: memInfo.jsHeapSizeLimit,
      usagePercent
    };
  }

  getPressureLevel(): MemoryPressureLevel {
    const memInfo = this.getCurrentMemoryInfo();
    const usage = memInfo.usagePercent;

    if (usage >= this.thresholds.critical) {
      return { level: 'critical', threshold: this.thresholds.critical };
    } else if (usage >= this.thresholds.high) {
      return { level: 'high', threshold: this.thresholds.high };
    } else if (usage >= this.thresholds.warning) {
      return { level: 'warning', threshold: this.thresholds.warning };
    }
    
    return { level: 'normal', threshold: 0 };
  }

  private checkMemoryPressure(): void {
    const memInfo = this.getCurrentMemoryInfo();
    const pressure = this.getPressureLevel();

    // Log memory stats periodically
    if (pressure.level !== 'normal') {
      const usedMB = Math.round(memInfo.used / (1024 * 1024));
      const totalMB = Math.round(memInfo.total / (1024 * 1024));
      
      
      // Basic cleanup recommendations
      if (pressure.level === 'critical') {
      }
    }
  }

  // Utility method for other services to check if they should perform cleanup
  shouldPerformCleanup(): boolean {
    const pressure = this.getPressureLevel();
    return pressure.level === 'high' || pressure.level === 'critical';
  }

  getMemoryStats(): string {
    const memInfo = this.getCurrentMemoryInfo();
    const pressure = this.getPressureLevel();
    const usedMB = Math.round(memInfo.used / (1024 * 1024));
    const totalMB = Math.round(memInfo.total / (1024 * 1024));
    
    return `Memory: ${usedMB}MB / ${totalMB}MB (${Math.round(memInfo.usagePercent)}%) - ${pressure.level.toUpperCase()}`;
  }
}
```

## services/memory/TraceMetadataBuilder.ts

```typescript
import {
  TraceMetadata,
  TraceContextMetadata,
  TraceInputMetadata,
  TraceLegacyMetadata,
  TraceOutcomeMetadata,
  TraceToolMetadata,
  isLegacyTraceContextFormat,
  LegacyTraceContextMetadata
} from '../../database/types/memory/MemoryTypes';

export interface TraceMetadataBuilderOptions {
  tool: TraceToolMetadata;
  context: TraceContextMetadata;
  input?: TraceInputMetadata;
  outcome: TraceOutcomeMetadata;
  legacy?: TraceLegacyMetadata;
}

/**
 * Helper responsible for producing canonical metadata objects for memory traces.
 * Centralizing this logic keeps all writers aligned and makes future schema
 * evolution straightforward.
 */
export class TraceMetadataBuilder {
  public static readonly CURRENT_SCHEMA_VERSION = 1;

  static create(options: TraceMetadataBuilderOptions): TraceMetadata {
    const context = TraceMetadataBuilder.ensureContext(options.context);

    return {
      schemaVersion: TraceMetadataBuilder.CURRENT_SCHEMA_VERSION,
      tool: { ...options.tool },
      context,
      input: TraceMetadataBuilder.normalizeInput(options.input),
      outcome: { ...options.outcome },
      legacy: TraceMetadataBuilder.normalizeLegacy(options.legacy)
    };
  }

  /**
   * Extracts legacy params/result blobs from existing metadata structures so
   * we can persist them under metadata.legacy for backward compatibility.
   */
  static extractLegacyFromMetadata(rawMetadata: any): TraceLegacyMetadata | undefined {
    if (!rawMetadata) {
      return undefined;
    }

    const legacy: TraceLegacyMetadata = {};

    if (rawMetadata.params !== undefined) {
      legacy.params = rawMetadata.params;
    }

    if (rawMetadata.result !== undefined) {
      legacy.result = rawMetadata.result;
    } else if (rawMetadata.response?.result !== undefined) {
      legacy.result = rawMetadata.response.result;
    }

    if (Array.isArray(rawMetadata.relatedFiles) && rawMetadata.relatedFiles.length > 0) {
      legacy.relatedFiles = rawMetadata.relatedFiles;
    }

    return TraceMetadataBuilder.normalizeLegacy(legacy);
  }

  private static ensureContext(context: TraceContextMetadata): TraceContextMetadata {
    if (!context.workspaceId) {
      throw new Error('[TraceMetadataBuilder] workspaceId is required in context');
    }

    if (!context.sessionId) {
      throw new Error('[TraceMetadataBuilder] sessionId is required in context');
    }

    // Handle both legacy and V2 context formats
    if (isLegacyTraceContextFormat(context)) {
      const legacyContext = context as LegacyTraceContextMetadata;
      return {
        ...legacyContext,
        additionalContext: legacyContext.additionalContext ? { ...legacyContext.additionalContext } : undefined
      };
    }

    // V2 format - just copy as-is (no additionalContext field)
    return { ...context };
  }

  private static normalizeInput(input?: TraceInputMetadata): TraceInputMetadata | undefined {
    if (!input) {
      return undefined;
    }

    const hasArguments = input.arguments !== undefined;
    const hasFiles = Array.isArray(input.files) && input.files.length > 0;
    const hasNotes = Boolean(input.notes);

    if (!hasArguments && !hasFiles && !hasNotes) {
      return undefined;
    }

    return {
      arguments: input.arguments,
      files: hasFiles ? [...(input.files as string[])] : undefined,
      notes: input.notes
    };
  }

  private static normalizeLegacy(legacy?: TraceLegacyMetadata): TraceLegacyMetadata | undefined {
    if (!legacy) {
      return undefined;
    }

    const hasParams = legacy.params !== undefined;
    const hasResult = legacy.result !== undefined;
    const hasFiles = Array.isArray(legacy.relatedFiles) && legacy.relatedFiles.length > 0;

    if (!hasParams && !hasResult && !hasFiles) {
      return undefined;
    }

    return {
      params: legacy.params,
      result: legacy.result,
      relatedFiles: hasFiles ? [...(legacy.relatedFiles as string[])] : undefined
    };
  }
}

export const buildTraceMetadata = TraceMetadataBuilder.create.bind(TraceMetadataBuilder);

```

## services/migration/ChromaDataLoader.ts

```typescript
// Location: src/services/migration/ChromaDataLoader.ts
// Loads data from existing ChromaDB collections for migration to new JSON structure
// Used by: DataMigrationService to read legacy ChromaDB collection data
// Dependencies: FileSystemService for ChromaDB collection file reading

import { FileSystemService } from '../storage/FileSystemService';
import { BRAND_NAME } from '../../constants/branding';

export interface ChromaCollectionData {
  memoryTraces: any[];
  sessions: any[];
  conversations: any[];
  workspaces: any[];
  snapshots: any[];
}

export class ChromaDataLoader {
  private fileSystem: FileSystemService;

  constructor(fileSystem: FileSystemService) {
    this.fileSystem = fileSystem;
  }

  async loadAllCollections(): Promise<ChromaCollectionData> {
    const [memoryTraces, sessions, conversations, workspaces, snapshots] = await Promise.all([
      this.fileSystem.readChromaCollection('memory_traces'),
      this.fileSystem.readChromaCollection('sessions'),
      this.fileSystem.readChromaCollection('chat_conversations'),
      this.fileSystem.readChromaCollection('workspaces'),
      this.fileSystem.readChromaCollection('snapshots')
    ]);

    return {
      memoryTraces,
      sessions,
      conversations,
      workspaces,
      snapshots
    };
  }

  async detectLegacyData(): Promise<boolean> {
    try {
      const collections = await this.loadAllCollections();
      return Object.values(collections).some(collection =>
        Array.isArray(collection) && collection.length > 0
      );
    } catch {
      return false;
    }
  }

  /**
   * Get summary statistics about the legacy data
   */
  async getDataSummary(): Promise<{
    totalItems: number;
    collections: Record<string, number>;
    oldestItem?: number;
    newestItem?: number;
  }> {
    const collections = await this.loadAllCollections();

    let totalItems = 0;
    let oldestTimestamp: number | undefined;
    let newestTimestamp: number | undefined;

    const collectionCounts: Record<string, number> = {};

    for (const [collectionName, items] of Object.entries(collections)) {
      collectionCounts[collectionName] = items.length;
      totalItems += items.length;

      // Find timestamp ranges
      for (const item of items) {
        const timestamp = item.metadata?.timestamp ||
                         item.metadata?.created ||
                         item.metadata?.created;

        if (timestamp) {
          if (!oldestTimestamp || timestamp < oldestTimestamp) {
            oldestTimestamp = timestamp;
          }
          if (!newestTimestamp || timestamp > newestTimestamp) {
            newestTimestamp = timestamp;
          }
        }
      }
    }

    return {
      totalItems,
      collections: collectionCounts,
      oldestItem: oldestTimestamp,
      newestItem: newestTimestamp
    };
  }

  /**
   * Test if ChromaDB collection files are accessible
   */
  async testCollectionAccess(): Promise<{
    accessible: string[];
    missing: string[];
    errors: string[];
  }> {
    const collectionNames = ['memory_traces', 'sessions', 'chat_conversations', 'workspaces', 'snapshots'];
    const accessible: string[] = [];
    const missing: string[] = [];
    const errors: string[] = [];

    for (const collectionName of collectionNames) {
      try {
        const items = await this.fileSystem.readChromaCollection(collectionName);
        if (Array.isArray(items)) {
          accessible.push(collectionName);
        } else {
          missing.push(collectionName);
        }
      } catch (error) {
        errors.push(`${collectionName}: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    }

    return { accessible, missing, errors };
  }
}

```

## services/migration/DataMigrationService.ts

```typescript
// Location: src/services/migration/DataMigrationService.ts
// Migration service for converting ChromaDB to split-file architecture
// Used by: main.ts during plugin initialization to migrate from ChromaDB to conversations/ and workspaces/
// Dependencies: FileSystemService, IndexManager, ChromaDataLoader, DataTransformer

import { Plugin } from 'obsidian';
import { FileSystemService } from '../storage/FileSystemService';
import { IndexManager } from '../storage/IndexManager';
import { ChromaDataLoader } from './ChromaDataLoader';
import { DataTransformer } from './DataTransformer';

export interface MigrationStatus {
  isRequired: boolean;
  hasLegacyData: boolean;
  migrationComplete: boolean;
}

export interface MigrationResult {
  success: boolean;
  conversationsMigrated: number;
  workspacesMigrated: number;
  sessionsMigrated: number;
  tracesMigrated: number;
  errors: string[];
  migrationTime: number;
}

export class DataMigrationService {
  private chromaLoader: ChromaDataLoader;
  private transformer: DataTransformer;

  constructor(
    private plugin: Plugin,
    private fileSystem: FileSystemService,
    private indexManager: IndexManager
  ) {
    this.chromaLoader = new ChromaDataLoader(fileSystem);
    this.transformer = new DataTransformer();
  }

  /**
   * Check if migration is needed
   */
  async checkMigrationStatus(): Promise<MigrationStatus> {
    // Check if new structure already exists
    const conversationsExist = await this.fileSystem.conversationsDirectoryExists();
    const workspacesExist = await this.fileSystem.workspacesDirectoryExists();

    if (conversationsExist && workspacesExist) {
      return {
        isRequired: false,
        hasLegacyData: false,
        migrationComplete: true
      };
    }

    // Check for legacy ChromaDB data
    const hasLegacyData = await this.chromaLoader.detectLegacyData();

    return {
      isRequired: hasLegacyData,
      hasLegacyData,
      migrationComplete: false
    };
  }

  /**
   * Initialize fresh directories and empty index files for first-time users
   */
  async initializeFreshDirectories(): Promise<void> {
    // Create conversations/ and workspaces/ directories
    await this.fileSystem.ensureConversationsDirectory();
    await this.fileSystem.ensureWorkspacesDirectory();

    // Create empty index files with proper structure
    const emptyConversationIndex = {
      conversations: {},
      byTitle: {},
      byContent: {},
      byVault: {},
      byDateRange: [],
      lastUpdated: Date.now()
    };
    await this.fileSystem.writeConversationIndex(emptyConversationIndex);

    const emptyWorkspaceIndex = {
      workspaces: {},
      byName: {},
      byDescription: {},
      byFolder: {},
      sessionsByWorkspace: {},
      lastUpdated: Date.now()
    };
    await this.fileSystem.writeWorkspaceIndex(emptyWorkspaceIndex);
  }

  /**
   * Perform migration from ChromaDB to split-file structure
   */
  async performMigration(): Promise<MigrationResult> {
    const startTime = Date.now();
    const result: MigrationResult = {
      success: false,
      conversationsMigrated: 0,
      workspacesMigrated: 0,
      sessionsMigrated: 0,
      tracesMigrated: 0,
      errors: [],
      migrationTime: 0
    };

    try {
      // Step 1: Create conversations/ and workspaces/ directories
      await this.fileSystem.ensureConversationsDirectory();
      await this.fileSystem.ensureWorkspacesDirectory();

      // Step 2: Get data summary for reporting
      const dataSummary = await this.chromaLoader.getDataSummary();

      // Step 3: Load all ChromaDB collections
      const chromaData = await this.chromaLoader.loadAllCollections();

      // Step 4: Transform to split-file structure
      const { conversations, workspaces } = this.transformer.transformToNewStructure(chromaData);

      // Step 5: Write conversation files
      for (const conversation of conversations) {
        try {
          await this.fileSystem.writeConversation(conversation.id, conversation);
          result.conversationsMigrated++;
        } catch (error) {
          console.error(`[DataMigrationService] Failed to write conversation ${conversation.id}:`, error);
          result.errors.push(`Failed to write conversation ${conversation.id}`);
        }
      }

      // Step 6: Build and write conversation index
      const conversationIndex = this.indexManager.buildConversationSearchIndices(conversations);
      await this.fileSystem.writeConversationIndex(conversationIndex);

      // Step 7: Write workspace files
      for (const workspace of workspaces) {
        try {
          await this.fileSystem.writeWorkspace(workspace.id, workspace);
          result.workspacesMigrated++;

          // Count sessions and traces
          result.sessionsMigrated += Object.keys(workspace.sessions).length;
          for (const session of Object.values(workspace.sessions)) {
            result.tracesMigrated += Object.keys(session.memoryTraces).length;
          }
        } catch (error) {
          console.error(`[DataMigrationService] Failed to write workspace ${workspace.id}:`, error);
          result.errors.push(`Failed to write workspace ${workspace.id}`);
        }
      }

      // Step 8: Build and write workspace index
      const workspaceIndex = this.indexManager.buildWorkspaceSearchIndices(workspaces);
      await this.fileSystem.writeWorkspaceIndex(workspaceIndex);

      // Step 9: Clean up legacy data folder (optional - can be done manually)

      result.success = true;
      result.migrationTime = Date.now() - startTime;

    } catch (error) {
      console.error('[DataMigrationService] Migration failed:', error);
      result.errors.push(`Migration failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }

    result.migrationTime = Date.now() - startTime;
    return result;
  }

  /**
   * Ensure all conversations have metadata field (idempotent)
   * Can be run multiple times safely - only updates conversations without metadata
   */
  async ensureConversationMetadata(): Promise<{ updated: number; errors: string[] }> {
    const result = {
      updated: 0,
      errors: [] as string[]
    };

    try {
      const conversationIds = await this.fileSystem.listConversationIds();

      for (const id of conversationIds) {
        try {
          const conversation = await this.fileSystem.readConversation(id);

          if (conversation && !conversation.metadata) {
            conversation.metadata = {};
            await this.fileSystem.writeConversation(id, conversation);
            result.updated++;
          }
        } catch (error) {
          const errorMsg = `Failed to update conversation ${id}: ${error instanceof Error ? error.message : String(error)}`;
          console.error('[DataMigrationService]', errorMsg);
          result.errors.push(errorMsg);
        }
      }

    } catch (error) {
      const errorMsg = `Failed to list conversations: ${error instanceof Error ? error.message : String(error)}`;
      console.error('[DataMigrationService]', errorMsg);
      result.errors.push(errorMsg);
    }

    return result;
  }

  /**
   * Get detailed information about the migration for debugging
   */
  async getMigrationInfo(): Promise<{
    chromaDataSummary?: any;
    conversationsExist: boolean;
    workspacesExist: boolean;
    accessTest?: any;
    errors: string[];
  }> {
    const info: {
      chromaDataSummary?: any;
      conversationsExist: boolean;
      workspacesExist: boolean;
      accessTest?: any;
      errors: string[];
    } = {
      conversationsExist: false,
      workspacesExist: false,
      errors: []
    };

    try {
      // Check if new structure exists
      info.conversationsExist = await this.fileSystem.conversationsDirectoryExists();
      info.workspacesExist = await this.fileSystem.workspacesDirectoryExists();

      // Test ChromaDB access
      info.accessTest = await this.chromaLoader.testCollectionAccess();

      // Get data summary if possible
      if (info.accessTest && info.accessTest.accessible.length > 0) {
        info.chromaDataSummary = await this.chromaLoader.getDataSummary();
      }
    } catch (error) {
      info.errors.push(`Error getting migration info: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }

    return info;
  }

  /**
   * Rebuild indexes from existing split-file structure
   */
  async rebuildIndexes(): Promise<{ success: boolean; error?: string }> {
    try {
      // Rebuild conversation index
      await this.indexManager.rebuildConversationIndex();

      // Rebuild workspace index
      await this.indexManager.rebuildWorkspaceIndex();

      return { success: true };
    } catch (error) {
      console.error('[DataMigrationService] Failed to rebuild indexes:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }
}
```

## services/migration/DataTransformer.ts

```typescript
// Location: src/services/migration/DataTransformer.ts
// Transforms ChromaDB collection data into individual conversation and workspace files
// Used by: DataMigrationService to convert legacy data to split-file architecture
// Dependencies: ChromaDataLoader for source data, StorageTypes for target structure

import { IndividualConversation, IndividualWorkspace } from '../../types/storage/StorageTypes';
import { ChromaCollectionData } from './ChromaDataLoader';
import { normalizeLegacyTraceMetadata } from '../memory/LegacyTraceMetadataNormalizer';

export class DataTransformer {

  transformToNewStructure(chromaData: ChromaCollectionData): {
    conversations: IndividualConversation[];
    workspaces: IndividualWorkspace[];
  } {
    const conversations = this.transformConversations(chromaData.conversations);
    const workspaces = this.transformWorkspaceHierarchy(
      chromaData.workspaces,
      chromaData.sessions,
      chromaData.memoryTraces,
      chromaData.snapshots
    );
    return { conversations, workspaces };
  }

  private transformConversations(conversations: any[]): IndividualConversation[] {
    const result: IndividualConversation[] = [];

    for (const conv of conversations) {
      try {
        const conversationData = conv.metadata?.conversation || {};
        const messages = conversationData.messages || [];

        const transformed: IndividualConversation = {
          id: conv.id,
          title: conv.metadata?.title || conversationData.title || 'Untitled Conversation',
          created: conv.metadata?.created || conversationData.created || Date.now(),
          updated: conv.metadata?.updated || conversationData.updated || Date.now(),
          vault_name: conv.metadata?.vault_name || conversationData.vault_name || 'Unknown',
          message_count: messages.length,
          messages: this.transformMessages(messages)
        };

        result.push(transformed);
      } catch (error) {
        console.error(`[DataTransformer] Error transforming conversation ${conv.id}:`, error);
      }
    }

    return result;
  }

  private transformMessages(messages: any[]): any[] {
    if (!Array.isArray(messages)) return [];

    return messages.map(msg => ({
      id: msg.id || `msg_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`,
      role: msg.role || 'user',
      content: msg.content || '',
      timestamp: msg.timestamp || Date.now(),
      toolCalls: msg.toolCalls,
      toolName: msg.toolName,
      toolParams: msg.toolParams,
      toolResult: msg.toolResult
    }));
  }

  private transformWorkspaceHierarchy(
    workspaces: any[],
    sessions: any[],
    memoryTraces: any[],
    snapshots: any[]
  ): IndividualWorkspace[] {
    // Group data by relationships
    const sessionsByWorkspace = this.groupBy(sessions, s => s.metadata?.workspaceId || 'unknown');
    const tracesBySession = this.groupBy(memoryTraces, t => t.metadata?.sessionId || 'orphan');
    const statesBySession = this.groupBy(snapshots, s => s.metadata?.sessionId || 'orphan');

    const result: IndividualWorkspace[] = [];

    // Build workspace metadata lookup
    const workspaceMetadata = this.keyBy(workspaces, 'id');

    // Process each workspace
    for (const [workspaceId, workspaceSessions] of Object.entries(sessionsByWorkspace)) {
      const wsMetadata = workspaceMetadata[workspaceId];

      try {
        // Parse context if it's a string
        let context;
        if (wsMetadata?.metadata?.context) {
          context = this.parseJSONString(wsMetadata.metadata.context);
          // Apply workspace context migration to new structure
          context = this.migrateWorkspaceContext(context);
        }

        const workspace: IndividualWorkspace = {
          id: workspaceId,
          name: wsMetadata?.metadata?.name || `Workspace ${workspaceId}`,
          description: wsMetadata?.metadata?.description || '',
          rootFolder: wsMetadata?.metadata?.rootFolder || '/',
          created: wsMetadata?.metadata?.created || Date.now(),
          lastAccessed: wsMetadata?.metadata?.lastAccessed || Date.now(),
          isActive: wsMetadata?.metadata?.isActive ?? true,
          context,
          sessions: {}
        };

        // Process sessions within workspace
        for (const session of workspaceSessions) {
          const sessionTraces = tracesBySession[session.id] || [];
          const sessionStates = statesBySession[session.id] || [];

          workspace.sessions[session.id] = {
            id: session.id,
            name: session.metadata?.name,
            description: session.metadata?.description,
            startTime: session.metadata?.startTime || session.metadata?.created || Date.now(),
            endTime: session.metadata?.endTime,
            isActive: session.metadata?.isActive ?? true,
            memoryTraces: this.transformTraces(sessionTraces, workspaceId, session.id),
            states: this.transformStates(sessionStates)
          };
        }

        result.push(workspace);
      } catch (error) {
        console.error(`[DataTransformer] Error processing workspace ${workspaceId}:`, error);
      }
    }

    return result;
  }

  private transformTraces(traces: any[], workspaceId: string, sessionId: string): Record<string, any> {
    const result: Record<string, any> = {};

    for (const trace of traces) {
      try {
        // Extract content from either document.content or direct content
        const content = trace.document?.content || trace.content || trace.metadata?.content || '';
        const legacyParams = this.parseJSONString(trace.metadata?.params);
        const legacyResult = this.parseJSONString(trace.metadata?.result);
        const legacyFiles = this.parseJSONString(trace.metadata?.relatedFiles) || [];
        const mergedMetadata = {
          ...(trace.metadata || {}),
          params: legacyParams,
          result: legacyResult,
          relatedFiles: legacyFiles
        };

        const metadata = normalizeLegacyTraceMetadata({
          workspaceId,
          sessionId,
          traceType: trace.metadata?.activityType || trace.metadata?.type,
          metadata: mergedMetadata
        });

        result[trace.id] = {
          id: trace.id,
          timestamp: trace.metadata?.timestamp || trace.document?.timestamp || Date.now(),
          type: trace.metadata?.activityType || trace.metadata?.type || 'unknown',
          content: content,
          metadata
        };
      } catch (error) {
        console.error(`[DataTransformer] Error transforming trace ${trace.id}:`, error);
      }
    }

    return result;
  }

  private transformStates(states: any[]): Record<string, any> {
    const result: Record<string, any> = {};

    for (const state of states) {
      try {
        result[state.id] = {
          id: state.id,
          name: state.metadata?.name || 'Unnamed State',
          created: state.metadata?.created || Date.now(),
          snapshot: state.metadata?.snapshot || state.snapshot || {}
        };
      } catch (error) {
        console.error(`[DataTransformer] Error transforming state ${state.id}:`, error);
      }
    }

    return result;
  }

  // Utility methods
  private groupBy<T>(array: T[], keyFn: (item: T) => string): Record<string, T[]> {
    return array.reduce((groups, item) => {
      const key = keyFn(item);
      if (!groups[key]) groups[key] = [];
      groups[key].push(item);
      return groups;
    }, {} as Record<string, T[]>);
  }

  private keyBy<T extends Record<string, unknown>>(array: T[], key: keyof T): Record<string, T> {
    return array.reduce((result, item) => {
      const keyValue = item[key];
      if (keyValue && typeof keyValue === 'string') result[keyValue] = item;
      return result;
    }, {} as Record<string, T>);
  }

  private parseJSONString(str: string | undefined): any {
    if (!str) return undefined;
    if (typeof str !== 'string') return str;

    try {
      return JSON.parse(str);
    } catch {
      return str;
    }
  }

  /**
   * Migrate workspace context from old structure to new structure
   */
  private migrateWorkspaceContext(context: any): any {
    if (!context || typeof context !== 'object') {
      return context;
    }

    const migratedContext = { ...context };

    // Migrate agents array to dedicatedAgent
    if (context.agents && Array.isArray(context.agents) && context.agents.length > 0) {
      const firstAgent = context.agents[0];
      if (firstAgent && firstAgent.name) {
        migratedContext.dedicatedAgent = {
          agentId: firstAgent.id || firstAgent.name,
          agentName: firstAgent.name
        };
      }
      delete migratedContext.agents;
    }

    // Migrate keyFiles from complex categorized structure to simple array
    if (context.keyFiles && Array.isArray(context.keyFiles)) {
      const simpleKeyFiles: string[] = [];
      context.keyFiles.forEach((category: any) => {
        if (category.files && typeof category.files === 'object') {
          Object.values(category.files).forEach((filePath: any) => {
            if (typeof filePath === 'string') {
              simpleKeyFiles.push(filePath);
            }
          });
        }
      });
      migratedContext.keyFiles = simpleKeyFiles;
    }

    // Migrate preferences from array to string
    if (context.preferences && Array.isArray(context.preferences)) {
      const preferencesString = context.preferences
        .filter((pref: any) => typeof pref === 'string' && pref.trim())
        .join('. ') + (context.preferences.length > 0 ? '.' : '');
      migratedContext.preferences = preferencesString;
    }

    // Remove status field
    if (context.status) {
      delete migratedContext.status;
    }

    return migratedContext;
  }
}

```

## services/migration/TraceSchemaMigrationService.ts

```typescript
import { normalizePath, Plugin } from 'obsidian';
import { FileSystemService } from '../storage/FileSystemService';
import { normalizeLegacyTraceMetadata } from '../memory/LegacyTraceMetadataNormalizer';
import { VaultOperations } from '../../core/VaultOperations';

const TRACE_SCHEMA_VERSION = 1;

interface TraceSchemaStatus {
  version: number;
  migratedAt: number;
}

export class TraceSchemaMigrationService {
  private markerPath = normalizePath('.workspaces/.trace-schema.json');
  private workspacesPath = normalizePath('.workspaces');
  private backupsPath = normalizePath('.workspaces/backups');

  constructor(
    private plugin: Plugin,
    private fileSystem: FileSystemService,
    private vaultOperations: VaultOperations
  ) {}

  async migrateIfNeeded(): Promise<{ migratedWorkspaces: number; skipped: boolean }> {
    try {
      const status = await this.readStatus();
      if (status && status.version >= TRACE_SCHEMA_VERSION) {
        // Schema already up-to-date - silently skip
        return { migratedWorkspaces: 0, skipped: true };
      }

      // Starting trace schema migration
      const workspaceIds = await this.fileSystem.listWorkspaceIds();
      let migratedCount = 0;

      for (const workspaceId of workspaceIds) {
        const workspace = await this.fileSystem.readWorkspace(workspaceId);
        if (!workspace) continue;

        let workspaceUpdated = false;

        for (const session of Object.values(workspace.sessions)) {
          for (const trace of Object.values(session.memoryTraces)) {
            const metadata = trace.metadata as Record<string, unknown> | undefined;
            if (metadata && typeof metadata.schemaVersion === 'number' && metadata.schemaVersion >= TRACE_SCHEMA_VERSION) {
              continue;
            }

            const normalized = normalizeLegacyTraceMetadata({
              workspaceId: workspace.id,
              sessionId: session.id,
              traceType: trace.type,
              metadata: trace.metadata
            });

            if (normalized) {
              trace.metadata = normalized;
              workspaceUpdated = true;
            }
          }
        }

        if (workspaceUpdated) {
          await this.createBackup(workspaceId);
          await this.fileSystem.writeWorkspace(workspaceId, workspace);
          migratedCount++;
        }
      }

      await this.writeStatus({
        version: TRACE_SCHEMA_VERSION,
        migratedAt: Date.now()
      });

      return { migratedWorkspaces: migratedCount, skipped: false };
    } catch (error) {
      console.error('[TraceSchemaMigrationService] Migration failed:', error);
      return { migratedWorkspaces: 0, skipped: false };
    }
  }

  private async readStatus(): Promise<TraceSchemaStatus | null> {
    try {
      const content = await this.vaultOperations.readFile(this.markerPath);
      if (!content) {
        return null;
      }
      return JSON.parse(content);
    } catch {
      return null;
    }
  }

  private async writeStatus(status: TraceSchemaStatus): Promise<void> {
    const json = JSON.stringify(status, null, 2);
    await this.vaultOperations.writeFile(this.markerPath, json);
  }

  private async ensureBackupsDir(): Promise<void> {
    await this.vaultOperations.ensureDirectory(this.backupsPath);
  }

  private async createBackup(workspaceId: string): Promise<void> {
    try {
      const filePath = normalizePath(`${this.workspacesPath}/${workspaceId}.json`);
      const content = await this.vaultOperations.readFile(filePath);
      if (!content) {
        return;
      }

      await this.ensureBackupsDir();
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupPath = normalizePath(`${this.backupsPath}/${workspaceId}-${timestamp}.json.bak`);
      await this.vaultOperations.writeFile(backupPath, content);
    } catch (error) {
      console.error(`[TraceSchemaMigration] Failed to backup workspace ${workspaceId}:`, error);
    }
  }
}

```

## services/session/SessionService.ts

```typescript
export interface SessionData {
  id: string;
  workspaceId: string;
  name?: string;
  description?: string;
  metadata?: Record<string, unknown>;
}

/**
 * Interface for the memory service dependency
 */
export interface IMemoryService {
  createSession(data: { workspaceId: string; id: string; name?: string; description?: string }): Promise<void>;
  getSession(workspaceId: string, sessionId: string): Promise<SessionData | null>;
  getSessions(workspaceId: string): Promise<SessionData[]>;
  updateSession(workspaceId: string, sessionId: string, data: { name?: string; description?: string }): Promise<void>;
  deleteSession(workspaceId: string, sessionId: string): Promise<void>;
}

/**
 * Session management service that delegates to MemoryService/WorkspaceService
 * Provides session tracking across workspaces with proper persistence
 */
export class SessionService {
  private sessions = new Map<string, SessionData>();

  constructor(private memoryService: IMemoryService) {
  }

  /**
   * Create a new session
   */
  async createSession(sessionData: Omit<SessionData, 'id'> | SessionData): Promise<SessionData> {
    // Use provided ID if available, otherwise generate one
    const id = ('id' in sessionData && sessionData.id) ? sessionData.id : this.generateSessionId();
    const workspaceId = sessionData.workspaceId || 'default';

    const session: SessionData = {
      ...sessionData,
      id,
      workspaceId
    };

    // Store in memory cache
    this.sessions.set(id, session);

    // Persist to workspace via MemoryService
    try {
      await this.memoryService.createSession({
        workspaceId: session.workspaceId,
        id: session.id,
        name: session.name,
        description: session.description
      });
    } catch (error) {
      console.error(`[SessionService] Failed to persist session ${id}:`, error);
      // Keep in memory even if persistence fails
    }

    return session;
  }

  /**
   * Get session by ID
   * Note: This searches across all workspaces since we don't have workspaceId
   */
  async getSession(sessionId: string): Promise<SessionData | null> {
    // Check memory cache first
    let session = this.sessions.get(sessionId);
    if (session) {
      return session;
    }

    // Try to load from workspaces via MemoryService
    // We need to check the default workspace first, then others
    try {
      const workspaceSession = await this.memoryService.getSession('default', sessionId);
      if (workspaceSession) {
        session = {
          id: workspaceSession.id,
          workspaceId: 'default',
          name: workspaceSession.name,
          description: workspaceSession.description
        };
        this.sessions.set(sessionId, session);
        return session;
      }
    } catch (error) {
      // Session not found in default workspace
    }

    return null;
  }

  /**
   * Get all sessions from a workspace
   */
  async getAllSessions(workspaceId: string = 'default'): Promise<SessionData[]> {
    try {
      const workspaceSessions = await this.memoryService.getSessions(workspaceId);
      // Convert to SessionData format and cache
      const sessions = workspaceSessions.map((ws: SessionData) => ({
        id: ws.id,
        workspaceId,
        name: ws.name,
        description: ws.description
      }));

      for (const session of sessions) {
        this.sessions.set(session.id, session);
      }

      return sessions;
    } catch (error) {
      return [];
    }
  }

  /**
   * Update session data
   */
  async updateSession(session: SessionData): Promise<void> {
    const workspaceId = session.workspaceId || 'default';

    // Update memory cache
    this.sessions.set(session.id, session);

    // Persist to workspace via MemoryService
    try {
      await this.memoryService.updateSession(workspaceId, session.id, {
        name: session.name,
        description: session.description
      });
    } catch (error) {
      console.error(`[SessionService] Failed to update session ${session.id}:`, error);
    }
  }

  /**
   * Delete a session
   */
  async deleteSession(sessionId: string, workspaceId: string = 'default'): Promise<void> {
    // Remove from memory cache
    this.sessions.delete(sessionId);

    // Delete from workspace via MemoryService
    try {
      await this.memoryService.deleteSession(workspaceId, sessionId);
    } catch (error) {
      console.error(`[SessionService] Failed to delete session ${sessionId}:`, error);
    }
  }
  
  /**
   * Generate a unique session ID
   */
  private generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  /**
   * Get session statistics
   */
  getStats(): { totalSessions: number } {
    const allSessions = Array.from(this.sessions.values());
    return {
      totalSessions: allSessions.length
    };
  }
}
```

## services/SessionContextManager.ts

```typescript
import { CommonResult } from '../types';
import { logger } from '../utils/logger';
import { parseWorkspaceContext } from '../utils/contextUtils';
import { generateSessionId, isStandardSessionId } from '../utils/sessionUtils';

/**
 * Interface for workspace context
 */
export interface WorkspaceContext {
  workspaceId: string;
  workspacePath?: string[];
  activeWorkspace?: boolean;
}

/**
 * SessionContextManager
 * 
 * Provides a centralized service for managing and persisting workspace context
 * across tool calls within sessions. This helps maintain context continuity
 * without requiring explicit context passing between every operation.
 */
export class SessionContextManager {
  // Reference to session service for database validation
  private sessionService: any = null;
  
  // Map of sessionId -> workspace context
  private sessionContextMap: Map<string, WorkspaceContext> = new Map();
  
  // Default workspace context for new sessions (global)
  private defaultWorkspaceContext: WorkspaceContext | null = null;
  
  // Set of session IDs that have already received instructions
  private instructedSessions: Set<string> = new Set();
  
  /**
   * Set the session service for database validation
   * This is called during plugin initialization
   */
  setSessionService(sessionService: any): void {
    this.sessionService = sessionService;
  }
  
  /**
   * Get workspace context for a specific session
   * 
   * @param sessionId The session ID to retrieve context for
   * @returns The workspace context for the session, or null if not found
   */
  getWorkspaceContext(sessionId: string): WorkspaceContext | null {
    return this.sessionContextMap.get(sessionId) || this.defaultWorkspaceContext;
  }
  
  /**
   * Set workspace context for a specific session
   * 
   * @param sessionId The session ID to set context for
   * @param context The workspace context to associate with the session
   */
  setWorkspaceContext(sessionId: string, context: WorkspaceContext): void {
    if (!sessionId) {
      logger.systemWarn('Attempted to set workspace context with empty sessionId');
      return;
    }
    
    if (!context.workspaceId) {
      logger.systemWarn('Attempted to set workspace context with empty workspaceId');
      return;
    }
    
    this.sessionContextMap.set(sessionId, context);
    logger.systemLog(`Set workspace context for session ${sessionId}: ${context.workspaceId}`);
  }
  
  /**
   * Set the default workspace context used for new sessions
   * 
   * @param context The default workspace context or null to clear
   */
  setDefaultWorkspaceContext(context: WorkspaceContext | null): void {
    this.defaultWorkspaceContext = context;
    if (context) {
      logger.systemLog(`Set default workspace context: ${context.workspaceId}`);
    } else {
      logger.systemLog('Cleared default workspace context');
    }
  }
  
  /**
   * Clear workspace context for a specific session
   * 
   * @param sessionId The session ID to clear context for
   */
  clearWorkspaceContext(sessionId: string): void {
    this.sessionContextMap.delete(sessionId);
  }
  
  /**
   * Update workspace context from a result
   * Extracts and saves workspace context from mode execution results
   * 
   * @param sessionId The session ID to update context for
   * @param result The result containing workspace context
   */
  updateFromResult(sessionId: string, result: CommonResult): void {
    if (!result.workspaceContext || !result.workspaceContext.workspaceId) {
      return;
    }
    
    this.setWorkspaceContext(sessionId, result.workspaceContext);
  }
  
  /**
   * Apply workspace context to parameters if not already specified
   * 
   * @param sessionId The session ID to get context for
   * @param params The parameters to apply context to
   * @returns The parameters with workspace context applied
   */
  applyWorkspaceContext<T extends { workspaceContext?: WorkspaceContext }>(
    sessionId: string, 
    params: T
  ): T {
    // Don't override existing context if specified
    const parsedContext = parseWorkspaceContext(params.workspaceContext);
  if (parsedContext?.workspaceId) {
      return params;
    }
    
    const context = this.getWorkspaceContext(sessionId);
    if (!context) {
      return params;
    }
    
    // Create new params object to avoid mutation
    return {
      ...params,
      workspaceContext: context
    };
  }
  
  /**
   * Check if workspace context exists for a session
   * 
   * @param sessionId The session ID to check
   * @returns True if context exists for the session
   */
  hasWorkspaceContext(sessionId: string): boolean {
    return this.sessionContextMap.has(sessionId);
  }
  
  /**
   * Get all active sessions with their workspace contexts
   * 
   * @returns Map of all session IDs to their workspace contexts
   */
  getAllSessionContexts(): Map<string, WorkspaceContext> {
    return new Map(this.sessionContextMap);
  }
  
  /**
   * Clear all session contexts
   */
  clearAll(): void {
    this.sessionContextMap.clear();
    this.defaultWorkspaceContext = null;
  }
  
  /**
   * Set the memory service for session validation
   * 
   * @param memoryService The memory service instance
   */
  setMemoryService(_memoryService: any): void {
    // Placeholder for future implementation
    // Memory service will be used for session validation in future releases
  }
  
  /**
   * Validate a session ID and auto-create session if needed
   * 
   * @param sessionId The session ID to validate (can be friendly name or standard ID)
   * @param sessionDescription Optional session description for auto-creation
   * @returns Object with validated session ID and creation status
   */
  async validateSessionId(sessionId: string, sessionDescription?: string): Promise<{id: string, created: boolean}> {
    
    // If no session ID is provided, generate a new one in our standard format
    if (!sessionId) {
      logger.systemWarn('Empty sessionId provided for validation, generating a new one');
      const newId = generateSessionId();
      await this.createAutoSession(newId, 'Default Session', sessionDescription);
      return {id: newId, created: true};
    }
    
    // If the session ID doesn't match our standard format, it's a friendly name - create session
    if (!isStandardSessionId(sessionId)) {
      const newId = generateSessionId();
      await this.createAutoSession(newId, sessionId, sessionDescription);
      return {id: newId, created: true};
    }
    
    // Session ID is in standard format - check if it exists in our context map first
    // âœ… CRITICAL FIX: If we already have workspace context for this session,
    // it means the session was already bound - no need to check database
    if (this.sessionContextMap.has(sessionId)) {
      logger.systemLog(`Session ${sessionId} found in context map - already bound to workspace`);
      return {id: sessionId, created: false};
    }

    // Check database if not in context map
    if (!this.sessionService) {
      console.error('[SessionContextManager] SessionService is NULL during validation!');
      throw new Error('SessionService not initialized - cannot validate session');
    }

    try {
      const existingSession = await this.sessionService.getSession(sessionId);
      if (existingSession) {
        return {id: sessionId, created: false};
      } else {
        await this.createAutoSession(sessionId, `Session ${sessionId}`, sessionDescription);
        return {id: sessionId, created: true};
      }
    } catch (error) {
      logger.systemWarn(`Error checking session existence: ${error instanceof Error ? error.message : String(error)}`);
      // Fallback to returning the session ID without verification
      return {id: sessionId, created: false};
    }
  }

  /**
   * Auto-create a session with given parameters
   *
   * @param sessionId Generated standard session ID
   * @param sessionName Friendly name provided by LLM
   * @param sessionDescription Optional session description
   */
  private async createAutoSession(sessionId: string, sessionName: string, sessionDescription?: string): Promise<void> {
    // âœ… CRITICAL FIX: Use workspace from sessionContextMap if available
    const context = this.sessionContextMap.get(sessionId);
    const workspaceId = context?.workspaceId || 'default';

    logger.systemLog(`Auto-created session: ${sessionId} with name "${sessionName}", workspace "${workspaceId}", and description "${sessionDescription || 'No description'}"`);

    // Create session using the injected session service
    if (this.sessionService) {
      try {
        const sessionData = {
          name: sessionName,
          description: sessionDescription || '',
          workspaceId: workspaceId, // âœ… Use correct workspace from context
          id: sessionId
        };

        const createdSession = await this.sessionService.createSession(sessionData);
        logger.systemLog(`Session ${sessionId} successfully created in database with workspace ${workspaceId}`);
      } catch (error) {
        logger.systemError(error as Error, `Failed to create session ${sessionId}`);
      }
    } else {
      logger.systemWarn(`SessionService not available - session ${sessionId} not saved to database`);
    }
  }
  
  /**
   * Update session description if it has changed
   * 
   * @param sessionId Standard session ID
   * @param sessionDescription New session description
   */
  async updateSessionDescription(sessionId: string, sessionDescription: string): Promise<void> {
    logger.systemLog(`Updating session description for ${sessionId}: "${sessionDescription}"`);
    
    // Update session using the injected session service
    if (this.sessionService) {
      try {
        // Get the workspace context for this session to determine workspaceId
        const workspaceContext = this.getWorkspaceContext(sessionId);
        const workspaceId = workspaceContext?.workspaceId || 'default';
        
        // Fetch existing session to get current data
        const existingSession = await this.sessionService.getSession(sessionId);
        
        // Update session with correct SessionData structure
        if (existingSession) {
          await this.sessionService.updateSession({
            id: sessionId,
            workspaceId: existingSession.workspaceId || workspaceId,
            name: existingSession.name,
            description: sessionDescription,
            metadata: existingSession.metadata
          });
          logger.systemLog(`Session ${sessionId} description updated in database`);
        } else {
          logger.systemWarn(`Session ${sessionId} not found - cannot update description`);
        }
      } catch (error) {
        logger.systemError(error as Error, `Failed to update session ${sessionId} description`);
      }
    } else {
      logger.systemWarn(`SessionService not available - session ${sessionId} description update not saved`);
    }
  }

  /**
   * Check if a session ID appears to be generated by Claude or not in our standard format
   * 
   * @param sessionId The session ID to check
   * @returns Boolean indicating if this appears to be a non-standard ID
   */
  isNonStandardSessionId(sessionId: string): boolean {
    return !isStandardSessionId(sessionId);
  }
  
  /**
   * Check if a session has already received instructions
   * 
   * @param sessionId The session ID to check
   * @returns Whether instructions have been sent for this session
   */
  hasReceivedInstructions(sessionId: string): boolean {
    return this.instructedSessions.has(sessionId);
  }
  
  /**
   * Mark a session as having received instructions
   * 
   * @param sessionId The session ID to mark
   */
  markInstructionsReceived(sessionId: string): void {
    this.instructedSessions.add(sessionId);
    logger.systemLog(`Marked session ${sessionId} as having received instructions`);
  }
}
```

## services/StaticModelsService.ts

```typescript
/**
 * Static Models Service
 * Loads model information from static adapter files instead of making API calls
 */

import { ModelSpec } from './llm/adapters/modelTypes';
import { OPENAI_MODELS } from './llm/adapters/openai/OpenAIModels';
import { ANTHROPIC_MODELS } from './llm/adapters/anthropic/AnthropicModels';
import { GOOGLE_MODELS } from './llm/adapters/google/GoogleModels';
import { MISTRAL_MODELS } from './llm/adapters/mistral/MistralModels';
import { GROQ_MODELS } from './llm/adapters/groq/GroqModels';
import { OPENROUTER_MODELS } from './llm/adapters/openrouter/OpenRouterModels';
import { REQUESTY_MODELS } from './llm/adapters/requesty/RequestyModels';
import { PERPLEXITY_MODELS } from './llm/adapters/perplexity/PerplexityModels';

export interface ModelWithProvider {
  provider: string;
  id: string;
  name: string;
  contextWindow: number;
  maxTokens: number;
  pricing: {
    inputPerMillion: number;
    outputPerMillion: number;
    currency: string;
  };
  capabilities: {
    supportsJSON: boolean;
    supportsImages: boolean;
    supportsFunctions: boolean;
    supportsStreaming: boolean;
    supportsThinking: boolean;
  };
  userDescription?: string; // User-defined description
  isDefault?: boolean;
}

export class StaticModelsService {
  private static instance: StaticModelsService;
  private modelCache: Map<string, ModelWithProvider[]> = new Map();

  /**
   * Get singleton instance
   */
  static getInstance(): StaticModelsService {
    if (!StaticModelsService.instance) {
      StaticModelsService.instance = new StaticModelsService();
    }
    return StaticModelsService.instance;
  }

  /**
   * Get all models for all providers
   */
  getAllModels(): ModelWithProvider[] {
    const allModels: ModelWithProvider[] = [];
    
    const providerModels = [
      { provider: 'openai', models: OPENAI_MODELS },
      { provider: 'anthropic', models: ANTHROPIC_MODELS },
      { provider: 'google', models: GOOGLE_MODELS },
      { provider: 'mistral', models: MISTRAL_MODELS },
      { provider: 'groq', models: GROQ_MODELS },
      { provider: 'openrouter', models: OPENROUTER_MODELS },
      { provider: 'requesty', models: REQUESTY_MODELS },
      { provider: 'perplexity', models: PERPLEXITY_MODELS }
    ];

    providerModels.forEach(({ provider, models }) => {
      models.forEach(model => {
        allModels.push(this.convertModelSpec(model));
      });
    });

    return allModels;
  }

  /**
   * Get models for a specific provider
   */
  getModelsForProvider(providerId: string): ModelWithProvider[] {
    if (this.modelCache.has(providerId)) {
      return this.modelCache.get(providerId)!;
    }

    let providerModels: ModelSpec[] = [];
    
    switch (providerId) {
      case 'openai':
        providerModels = OPENAI_MODELS;
        break;
      case 'anthropic':
        providerModels = ANTHROPIC_MODELS;
        break;
      case 'google':
        providerModels = GOOGLE_MODELS;
        break;
      case 'mistral':
        providerModels = MISTRAL_MODELS;
        break;
      case 'groq':
        providerModels = GROQ_MODELS;
        break;
      case 'openrouter':
        providerModels = OPENROUTER_MODELS;
        break;
      case 'requesty':
        providerModels = REQUESTY_MODELS;
        break;
      case 'perplexity':
        providerModels = PERPLEXITY_MODELS;
        break;
      default:
        return [];
    }

    const convertedModels = providerModels.map(model => this.convertModelSpec(model));
    this.modelCache.set(providerId, convertedModels);
    
    return convertedModels;
  }

  /**
   * Convert ModelSpec to ModelWithProvider format
   */
  private convertModelSpec(model: ModelSpec): ModelWithProvider {
    return {
      provider: model.provider,
      id: model.apiName,
      name: model.name,
      contextWindow: model.contextWindow,
      maxTokens: model.maxTokens,
      pricing: {
        inputPerMillion: model.inputCostPerMillion,
        outputPerMillion: model.outputCostPerMillion,
        currency: 'USD'
      },
      capabilities: {
        supportsJSON: model.capabilities.supportsJSON,
        supportsImages: model.capabilities.supportsImages,
        supportsFunctions: model.capabilities.supportsFunctions,
        supportsStreaming: model.capabilities.supportsStreaming,
        supportsThinking: model.capabilities.supportsThinking
      }
    };
  }

  /**
   * Get provider information
   */
  getAvailableProviders(): string[] {
    return ['openai', 'anthropic', 'google', 'mistral', 'groq', 'openrouter', 'requesty', 'perplexity'];
  }

  /**
   * Check if a provider has models available
   */
  hasModelsForProvider(providerId: string): boolean {
    const models = this.getModelsForProvider(providerId);
    return models.length > 0;
  }

  /**
   * Find a specific model by provider and model ID
   * For OpenRouter, supports :online suffix (e.g., "gpt-4:online")
   */
  findModel(provider: string, modelId: string): ModelWithProvider | undefined {
    const providerModels = this.getModelsForProvider(provider);
    
    // For OpenRouter models, check if modelId has :online suffix
    if (provider === 'openrouter' && modelId.endsWith(':online')) {
      const baseModelId = modelId.replace(':online', '');
      return providerModels.find(model => model.id === baseModelId);
    }
    
    return providerModels.find(model => model.id === modelId);
  }

  /**
   * Get models suitable for specific tasks
   */
  getModelsForTask(taskType: 'coding' | 'writing' | 'analysis' | 'creative' | 'fast'): ModelWithProvider[] {
    const allModels = this.getAllModels();

    switch (taskType) {
      case 'coding':
        return allModels.filter(model => 
          model.capabilities.supportsFunctions || 
          model.id.includes('code') || 
          model.provider === 'mistral' ||
          model.id.includes('gpt-5')
        );
      
      case 'writing':
        return allModels.filter(model => 
          model.provider === 'anthropic' || 
          model.id.includes('gpt-5') ||
          model.contextWindow > 32000
        );
      
      case 'analysis':
        return allModels.filter(model => 
          model.provider === 'anthropic' ||
          model.id.includes('gpt-5') ||
          model.contextWindow > 100000
        );
      
      case 'creative':
        return allModels.filter(model => 
          model.provider === 'openai' ||
          model.provider === 'anthropic' ||
          model.provider === 'google'
        );
      
      case 'fast':
        return allModels.filter(model => 
          model.provider === 'groq' ||
          model.id.includes('turbo') ||
          model.id.includes('fast') ||
          model.id.includes('mini')
        );
      
      default:
        return allModels;
    }
  }

  /**
   * Get model statistics
   */
  getModelStatistics(): {
    totalModels: number;
    providerCount: number;
    averageContextWindow: number;
    maxContextWindow: number;
    minCostPerMillion: number;
    maxCostPerMillion: number;
  } {
    const allModels = this.getAllModels();
    
    if (allModels.length === 0) {
      return {
        totalModels: 0,
        providerCount: 0,
        averageContextWindow: 0,
        maxContextWindow: 0,
        minCostPerMillion: 0,
        maxCostPerMillion: 0
      };
    }

    const providers = new Set(allModels.map(m => m.provider));
    const contextWindows = allModels.map(m => m.contextWindow);
    const costs = allModels.map(m => m.pricing.inputPerMillion);

    return {
      totalModels: allModels.length,
      providerCount: providers.size,
      averageContextWindow: Math.round(contextWindows.reduce((a, b) => a + b, 0) / allModels.length),
      maxContextWindow: Math.max(...contextWindows),
      minCostPerMillion: Math.min(...costs),
      maxCostPerMillion: Math.max(...costs)
    };
  }
}
```

## services/storage/FileSystemService.ts

```typescript
// Location: src/services/storage/FileSystemService.ts
// File system utility for managing conversations/ and workspaces/ directories
// Used by: IndexManager, ConversationService, WorkspaceService, DataMigrationService
// Dependencies: Obsidian Plugin API for file system operations

import { normalizePath, Plugin } from 'obsidian';
import { VaultOperations } from '../../core/VaultOperations';
import { IndividualConversation, IndividualWorkspace, ConversationIndex, WorkspaceIndex } from '../../types/storage/StorageTypes';

export class FileSystemService {
  private plugin: Plugin;
  private conversationsPath: string;
  private workspacesPath: string;

  constructor(plugin: Plugin, private vaultOperations: VaultOperations) {
    this.plugin = plugin;
    // Store in vault root for Obsidian Sync compatibility
    this.conversationsPath = normalizePath('.conversations');
    this.workspacesPath = normalizePath('.workspaces');
  }

  /**
   * Ensure conversations/ directory exists
   */
  async ensureConversationsDirectory(): Promise<void> {
    await this.vaultOperations.ensureDirectory(this.conversationsPath);
  }

  /**
   * Ensure workspaces/ directory exists
   */
  async ensureWorkspacesDirectory(): Promise<void> {
    await this.vaultOperations.ensureDirectory(this.workspacesPath);
  }

  /**
   * Write individual conversation file
   */
  async writeConversation(id: string, data: IndividualConversation): Promise<void> {
    await this.ensureConversationsDirectory();
    const filePath = normalizePath(`${this.conversationsPath}/${id}.json`);
    const jsonString = JSON.stringify(data, null, 2);
    await this.vaultOperations.writeFile(filePath, jsonString);
  }

  /**
   * Read individual conversation file
   */
  async readConversation(id: string): Promise<IndividualConversation | null> {
    const filePath = normalizePath(`${this.conversationsPath}/${id}.json`);
    const content = await this.vaultOperations.readFile(filePath);
    
    if (!content) return null;
    
    try {
      const data = JSON.parse(content);
      return data;
    } catch (error) {
      return null;
    }
  }

  /**
   * Delete individual conversation file
   */
  async deleteConversation(id: string): Promise<void> {
    const filePath = normalizePath(`${this.conversationsPath}/${id}.json`);
    await this.vaultOperations.deleteFile(filePath);
  }

  /**
   * List all conversation IDs
   */
  async listConversationIds(): Promise<string[]> {
    try {
      const files = await this.vaultOperations.listDirectory(this.conversationsPath);
      const conversationIds = files.files
        .filter(file => file.endsWith('.json') && !file.endsWith('index.json'))
        .map(file => {
          const filename = file.split('/').pop() || '';
          return filename.replace('.json', '');
        });
      return conversationIds;
    } catch (error) {
      return [];
    }
  }

  /**
   * Write individual workspace file
   */
  async writeWorkspace(id: string, data: IndividualWorkspace): Promise<void> {
    const filePath = normalizePath(`${this.workspacesPath}/${id}.json`);
    const jsonString = JSON.stringify(data, null, 2);
    await this.vaultOperations.writeFile(filePath, jsonString);
  }

  /**
   * Read individual workspace file
   */
  async readWorkspace(id: string): Promise<IndividualWorkspace | null> {
    const filePath = normalizePath(`${this.workspacesPath}/${id}.json`);
    const content = await this.vaultOperations.readFile(filePath);
    
    if (!content) return null;

    try {
      const data = JSON.parse(content);
      return data;
    } catch (error) {
      return null;
    }
  }

  /**
   * Delete individual workspace file
   */
  async deleteWorkspace(id: string): Promise<void> {
    const filePath = normalizePath(`${this.workspacesPath}/${id}.json`);
    await this.vaultOperations.deleteFile(filePath);
  }

  /**
   * List all workspace IDs
   */
  async listWorkspaceIds(): Promise<string[]> {
    try {
      const files = await this.vaultOperations.listDirectory(this.workspacesPath);
      const workspaceIds = files.files
        .filter(file => file.endsWith('.json') && !file.endsWith('index.json'))
        .map(file => {
          const filename = file.split('/').pop() || '';
          return filename.replace('.json', '');
        });
      return workspaceIds;
    } catch (error) {
      return [];
    }
  }

  /**
   * Read conversation index file
   */
  async readConversationIndex(): Promise<ConversationIndex | null> {
    const filePath = normalizePath(`${this.conversationsPath}/index.json`);
    const content = await this.vaultOperations.readFile(filePath);
    
    if (!content) return null;

    try {
      const data = JSON.parse(content);
      return data;
    } catch (error) {
      return null;
    }
  }

  /**
   * Write conversation index file
   */
  async writeConversationIndex(index: ConversationIndex): Promise<void> {
    const filePath = normalizePath(`${this.conversationsPath}/index.json`);
    const jsonString = JSON.stringify(index, null, 2);
    await this.vaultOperations.writeFile(filePath, jsonString);
  }

  /**
   * Read workspace index file
   */
  async readWorkspaceIndex(): Promise<WorkspaceIndex | null> {
    const filePath = normalizePath(`${this.workspacesPath}/index.json`);
    const content = await this.vaultOperations.readFile(filePath);
    
    if (!content) return null;

    try {
      const data = JSON.parse(content);
      return data;
    } catch (error) {
      return null;
    }
  }

  /**
   * Write workspace index file
   */
  async writeWorkspaceIndex(index: WorkspaceIndex): Promise<void> {
    const filePath = normalizePath(`${this.workspacesPath}/index.json`);
    const jsonString = JSON.stringify(index, null, 2);
    await this.vaultOperations.writeFile(filePath, jsonString);
  }

  /**
   * Check if conversations directory exists
   */
  async conversationsDirectoryExists(): Promise<boolean> {
    return await this.vaultOperations.folderExists(this.conversationsPath);
  }

  /**
   * Check if workspaces directory exists
   */
  async workspacesDirectoryExists(): Promise<boolean> {
    return await this.vaultOperations.folderExists(this.workspacesPath);
  }

  /**
   * Read legacy ChromaDB collection for migration
   */
  async readChromaCollection(collectionName: string): Promise<any[]> {
    const chromaPath = normalizePath(`${this.plugin.manifest.dir}/data/chroma-db/collections/${collectionName}/items.json`);
    const content = await this.vaultOperations.readFile(chromaPath);
    
    if (!content) return [];

    try {
      const data = JSON.parse(content);
      const items = data.items || [];
      return items;
    } catch (error) {
      return [];
    }
  }

  /**
   * Get conversations directory path
   */
  getConversationsPath(): string {
    return this.conversationsPath;
  }

  /**
   * Get workspaces directory path
   */
  getWorkspacesPath(): string {
    return this.workspacesPath;
  }

  /**
   * Get ChromaDB path for migration detection
   */
  getChromaPath(): string {
    return normalizePath(`${this.plugin.manifest.dir}/data/chroma-db`);
  }
}
```

## services/storage/IndexManager.ts

```typescript
// Location: src/services/storage/IndexManager.ts
// Manages conversation and workspace index files with incremental updates
// Used by: ConversationService, WorkspaceService, DataMigrationService
// Dependencies: FileSystemService for index I/O, StorageTypes for structures

import { FileSystemService } from './FileSystemService';
import {
  ConversationIndex,
  WorkspaceIndex,
  IndividualConversation,
  IndividualWorkspace,
  ConversationMetadata,
  WorkspaceMetadata
} from '../../types/storage/StorageTypes';

export class IndexManager {
  constructor(private fileSystem: FileSystemService) {}

  /**
   * Load conversation index (creates empty if not exists)
   */
  async loadConversationIndex(): Promise<ConversationIndex> {
    const index = await this.fileSystem.readConversationIndex();

    if (!index) {
      const emptyIndex: ConversationIndex = {
        conversations: {},
        byTitle: {},
        byContent: {},
        byVault: {},
        byDateRange: [],
        lastUpdated: Date.now()
      };
      return emptyIndex;
    }

    return index;
  }

  /**
   * Update single conversation in index
   */
  async updateConversationInIndex(conversation: IndividualConversation): Promise<void> {
    const index = await this.loadConversationIndex();

    // Update metadata
    const metadata: ConversationMetadata = {
      id: conversation.id,
      title: conversation.title,
      created: conversation.created,
      updated: conversation.updated,
      vault_name: conversation.vault_name,
      message_count: conversation.message_count
    };

    index.conversations[conversation.id] = metadata;

    // Update search indices
    this.updateSearchIndicesForConversation(index, conversation);

    // Update timestamp
    index.lastUpdated = Date.now();

    // Save index
    await this.fileSystem.writeConversationIndex(index);
  }

  /**
   * Remove conversation from index
   */
  async removeConversationFromIndex(id: string): Promise<void> {
    const index = await this.loadConversationIndex();

    // Remove metadata
    delete index.conversations[id];

    // Remove from search indices
    this.removeFromSearchIndices(index, id);

    // Update timestamp
    index.lastUpdated = Date.now();

    // Save index
    await this.fileSystem.writeConversationIndex(index);
  }

  /**
   * Rebuild entire conversation index from all conversation files
   */
  async rebuildConversationIndex(): Promise<void> {
    const conversationIds = await this.fileSystem.listConversationIds();
    const conversations: IndividualConversation[] = [];

    // Load all conversations
    for (const id of conversationIds) {
      const conversation = await this.fileSystem.readConversation(id);
      if (conversation) {
        conversations.push(conversation);
      }
    }

    // Build index from scratch
    const index = this.buildConversationSearchIndices(conversations);

    // Save index
    await this.fileSystem.writeConversationIndex(index);
  }

  /**
   * Load workspace index (creates empty if not exists)
   */
  async loadWorkspaceIndex(): Promise<WorkspaceIndex> {
    const index = await this.fileSystem.readWorkspaceIndex();

    if (!index) {
      const emptyIndex: WorkspaceIndex = {
        workspaces: {},
        byName: {},
        byDescription: {},
        byFolder: {},
        sessionsByWorkspace: {},
        lastUpdated: Date.now()
      };
      return emptyIndex;
    }

    return index;
  }

  /**
   * Update single workspace in index
   */
  async updateWorkspaceInIndex(workspace: IndividualWorkspace): Promise<void> {
    const index = await this.loadWorkspaceIndex();

    // Calculate counts
    const sessionCount = Object.keys(workspace.sessions).length;
    let traceCount = 0;
    for (const session of Object.values(workspace.sessions)) {
      traceCount += Object.keys(session.memoryTraces).length;
    }

    // Update metadata
    const metadata: WorkspaceMetadata = {
      id: workspace.id,
      name: workspace.name,
      description: workspace.description,
      rootFolder: workspace.rootFolder,
      created: workspace.created,
      lastAccessed: workspace.lastAccessed,
      isActive: workspace.isActive,
      sessionCount,
      traceCount
    };

    index.workspaces[workspace.id] = metadata;

    // Update search indices
    this.updateSearchIndicesForWorkspace(index, workspace);

    // Update timestamp
    index.lastUpdated = Date.now();

    // Save index
    await this.fileSystem.writeWorkspaceIndex(index);
  }

  /**
   * Remove workspace from index
   */
  async removeWorkspaceFromIndex(id: string): Promise<void> {
    const index = await this.loadWorkspaceIndex();

    // Remove metadata
    delete index.workspaces[id];

    // Remove from search indices
    this.removeFromWorkspaceSearchIndices(index, id);

    // Update timestamp
    index.lastUpdated = Date.now();

    // Save index
    await this.fileSystem.writeWorkspaceIndex(index);
  }

  /**
   * Rebuild entire workspace index from all workspace files
   */
  async rebuildWorkspaceIndex(): Promise<void> {
    const workspaceIds = await this.fileSystem.listWorkspaceIds();
    const workspaces: IndividualWorkspace[] = [];

    // Load all workspaces
    for (const id of workspaceIds) {
      const workspace = await this.fileSystem.readWorkspace(id);
      if (workspace) {
        workspaces.push(workspace);
      }
    }

    // Build index from scratch
    const index = this.buildWorkspaceSearchIndices(workspaces);

    // Save index
    await this.fileSystem.writeWorkspaceIndex(index);
  }

  /**
   * Build complete conversation search indices from conversation array
   */
  buildConversationSearchIndices(conversations: IndividualConversation[]): ConversationIndex {
    const index: ConversationIndex = {
      conversations: {},
      byTitle: {},
      byContent: {},
      byVault: {},
      byDateRange: this.createDateRangeBuckets(),
      lastUpdated: Date.now()
    };

    for (const conversation of conversations) {
      // Add metadata
      index.conversations[conversation.id] = {
        id: conversation.id,
        title: conversation.title,
        created: conversation.created,
        updated: conversation.updated,
        vault_name: conversation.vault_name,
        message_count: conversation.message_count
      };

      // Add to search indices
      this.updateSearchIndicesForConversation(index, conversation);
    }

    return index;
  }

  /**
   * Build complete workspace search indices from workspace array
   */
  buildWorkspaceSearchIndices(workspaces: IndividualWorkspace[]): WorkspaceIndex {
    const index: WorkspaceIndex = {
      workspaces: {},
      byName: {},
      byDescription: {},
      byFolder: {},
      sessionsByWorkspace: {},
      lastUpdated: Date.now()
    };

    for (const workspace of workspaces) {
      // Calculate counts
      const sessionCount = Object.keys(workspace.sessions).length;
      let traceCount = 0;
      for (const session of Object.values(workspace.sessions)) {
        traceCount += Object.keys(session.memoryTraces).length;
      }

      // Add metadata
      index.workspaces[workspace.id] = {
        id: workspace.id,
        name: workspace.name,
        description: workspace.description,
        rootFolder: workspace.rootFolder,
        created: workspace.created,
        lastAccessed: workspace.lastAccessed,
        isActive: workspace.isActive,
        sessionCount,
        traceCount
      };

      // Add to search indices
      this.updateSearchIndicesForWorkspace(index, workspace);
    }

    return index;
  }

  /**
   * Update search indices for a single conversation
   */
  private updateSearchIndicesForConversation(index: ConversationIndex, conversation: IndividualConversation): void {
    const id = conversation.id;

    // Index by title
    this.addToIndex(index.byTitle, conversation.title, id);

    // Index by vault
    this.addToIndex(index.byVault, conversation.vault_name, id);

    // Index by message content
    for (const message of conversation.messages) {
      if (message.content) {
        this.addToIndex(index.byContent, message.content, id);
      }
    }

    // Add to date range bucket
    this.addToDateRangeBucket(index.byDateRange, conversation.created, id);
  }

  /**
   * Update search indices for a single workspace
   */
  private updateSearchIndicesForWorkspace(index: WorkspaceIndex, workspace: IndividualWorkspace): void {
    const id = workspace.id;

    // Index by name
    this.addToIndex(index.byName, workspace.name, id);

    // Index by description
    if (workspace.description) {
      this.addToIndex(index.byDescription, workspace.description, id);
    }

    // Index by folder
    index.byFolder[workspace.rootFolder] = id;

    // Index sessions by workspace
    index.sessionsByWorkspace[id] = Object.keys(workspace.sessions);
  }

  /**
   * Remove conversation from search indices
   */
  private removeFromSearchIndices(index: ConversationIndex, id: string): void {
    // Remove from all search index arrays
    for (const titleKey in index.byTitle) {
      index.byTitle[titleKey] = index.byTitle[titleKey].filter(convId => convId !== id);
      if (index.byTitle[titleKey].length === 0) {
        delete index.byTitle[titleKey];
      }
    }

    for (const contentKey in index.byContent) {
      index.byContent[contentKey] = index.byContent[contentKey].filter(convId => convId !== id);
      if (index.byContent[contentKey].length === 0) {
        delete index.byContent[contentKey];
      }
    }

    for (const vaultKey in index.byVault) {
      index.byVault[vaultKey] = index.byVault[vaultKey].filter(convId => convId !== id);
      if (index.byVault[vaultKey].length === 0) {
        delete index.byVault[vaultKey];
      }
    }

    // Remove from date range buckets
    for (const bucket of index.byDateRange) {
      bucket.conversationIds = bucket.conversationIds.filter(convId => convId !== id);
    }
  }

  /**
   * Remove workspace from search indices
   */
  private removeFromWorkspaceSearchIndices(index: WorkspaceIndex, id: string): void {
    // Remove from all search index arrays
    for (const nameKey in index.byName) {
      index.byName[nameKey] = index.byName[nameKey].filter(wsId => wsId !== id);
      if (index.byName[nameKey].length === 0) {
        delete index.byName[nameKey];
      }
    }

    for (const descKey in index.byDescription) {
      index.byDescription[descKey] = index.byDescription[descKey].filter(wsId => wsId !== id);
      if (index.byDescription[descKey].length === 0) {
        delete index.byDescription[descKey];
      }
    }

    // Remove from folder index
    for (const folder in index.byFolder) {
      if (index.byFolder[folder] === id) {
        delete index.byFolder[folder];
      }
    }

    // Remove from sessions index
    delete index.sessionsByWorkspace[id];
  }

  /**
   * Add text to search index (tokenizes and indexes words)
   */
  private addToIndex(index: Record<string, string[]>, text: string, id: string): void {
    if (!text || typeof text !== 'string') return;

    // Split text into words and clean them
    const words = text.toLowerCase()
      .replace(/[^\w\s]/g, ' ')
      .split(/\s+/)
      .filter(word => word.length > 2);

    for (const word of words) {
      if (!index[word]) index[word] = [];
      if (!index[word].includes(id)) {
        index[word].push(id);
      }
    }
  }

  /**
   * Create monthly date range buckets for the last 12 months
   */
  private createDateRangeBuckets(): Array<{ start: number; end: number; conversationIds: string[] }> {
    const buckets = [];
    const now = Date.now();
    const oneMonth = 30 * 24 * 60 * 60 * 1000;

    for (let i = 0; i < 12; i++) {
      const end = now - (i * oneMonth);
      const start = end - oneMonth;
      buckets.push({
        start,
        end,
        conversationIds: []
      });
    }

    return buckets;
  }

  /**
   * Add conversation to appropriate date range bucket
   */
  private addToDateRangeBucket(buckets: any[], timestamp: number, id: string): void {
    for (const bucket of buckets) {
      if (timestamp >= bucket.start && timestamp < bucket.end) {
        if (!bucket.conversationIds.includes(id)) {
          bucket.conversationIds.push(id);
        }
        break;
      }
    }
  }
}
```

## services/trace/ToolCallTraceService.ts

```typescript
// Location: src/services/trace/ToolCallTraceService.ts
// Captures tool call executions and saves them as memory traces
// Used by: MCPConnectionManager via onToolResponse callback
// Dependencies: MemoryService, SessionContextManager, WorkspaceService

import { Plugin } from 'obsidian';
import { MemoryService } from '../../agents/memoryManager/services/MemoryService';
import { SessionContextManager } from '../SessionContextManager';
import { WorkspaceService } from '../WorkspaceService';
import { TraceMetadataBuilder } from '../memory/TraceMetadataBuilder';
import { TraceContextMetadata, TraceOutcomeMetadata } from '../../database/workspace-types';

export interface ToolCallCaptureData {
  toolName: string;
  params: any;
  response: any;
  success: boolean;
  executionTime: number;
}

/**
 * ToolCallTraceService
 *
 * Captures tool call executions and persists them as memory traces within
 * the appropriate workspace/session context. Provides searchable history
 * of all tool interactions.
 *
 * Features:
 * - Extracts agent/mode from tool names
 * - Retrieves workspace/session context automatically
 * - Transforms tool call data into WorkspaceMemoryTrace format
 * - Extracts affected files from responses
 * - Non-blocking error handling (traces are nice-to-have)
 */
export class ToolCallTraceService {
  constructor(
    private memoryService: MemoryService,
    private sessionContextManager: SessionContextManager,
    private workspaceService: WorkspaceService,
    private plugin: Plugin
  ) {}

  /**
   * Capture a tool call execution and save as memory trace
   * This is the main entry point called by MCPConnectionManager
   */
  async captureToolCall(
    toolName: string,
    params: any,
    response: any,
    success: boolean,
    executionTime: number
  ): Promise<void> {
    try {
      // 1. Extract agent and mode from tool name
      const { agent, mode } = this.parseToolName(toolName);

      // 2. Get session ID from params
      const sessionId = this.extractSessionId(params);
      if (!sessionId) {
        return;
      }

      // 3. Get workspace context from SessionContextManager
      const workspaceContext = this.sessionContextManager.getWorkspaceContext(sessionId);
      const workspaceId = workspaceContext?.workspaceId ||
                         params?.workspaceContext?.workspaceId ||
                         params?.context?.workspaceId ||
                         'default';

      if (!workspaceId) {
        return;
      }

      // 4. Build trace content (human-readable description)
      const traceContent = this.buildTraceContent(agent, mode, params, response, success);

      // 5. Build trace metadata (structured data)
      const relatedFiles = this.extractRelatedFiles(response, params);
      const traceMetadata = this.buildCanonicalMetadata({
        toolName,
        agent,
        mode,
        params,
        response,
        success,
        sessionId,
        workspaceId,
        relatedFiles
      });

      // 6. Record the trace via MemoryService
      await this.memoryService.recordActivityTrace({
        workspaceId: workspaceId,
        sessionId: sessionId,
        type: 'tool_call',
        content: traceContent,
        timestamp: Date.now(),
        metadata: traceMetadata
      });

    } catch (error) {
      // Don't throw - tracing is a secondary operation that shouldn't break the main flow
      console.error('[ToolCallTraceService] Failed to capture tool call:', error);
    }
  }

  /**
   * Parse tool name into agent and mode components
   * Format: "agentName_modeName" -> { agent: "agentName", mode: "modeName" }
   */
  private parseToolName(toolName: string): { agent: string; mode: string } {
    const lastUnderscore = toolName.lastIndexOf('_');
    if (lastUnderscore === -1) {
      return { agent: toolName, mode: 'unknown' };
    }

    return {
      agent: toolName.substring(0, lastUnderscore),
      mode: toolName.substring(lastUnderscore + 1)
    };
  }

  /**
   * Extract session ID from various possible locations in params
   */
  private extractSessionId(params: any): string | null {
    // Try different locations where sessionId might be
    if (params?.sessionId) return params.sessionId;
    if (params?.context?.sessionId) return params.context.sessionId;
    if (params?.params?.sessionId) return params.params.sessionId;

    return null;
  }

  /**
   * Build human-readable trace content
   */
  private buildTraceContent(
    agent: string,
    mode: string,
    params: any,
    response: any,
    success: boolean
  ): string {
    const status = success ? 'Successfully executed' : 'Failed to execute';
    let description = `${status} ${agent}_${mode}`;

    // Add context-specific details
    if (params?.filePath) {
      description += ` on file: ${params.filePath}`;
    } else if (params?.params?.filePath) {
      description += ` on file: ${params.params.filePath}`;
    } else if (params?.query) {
      description += ` with query: "${params.query}"`;
    } else if (params?.params?.query) {
      description += ` with query: "${params.params.query}"`;
    }

    return description;
  }

  private buildCanonicalMetadata(options: {
    toolName: string;
    agent: string;
    mode: string;
    params: any;
    response: any;
    success: boolean;
    sessionId: string;
    workspaceId: string;
    relatedFiles: string[];
  }) {
    const context = this.buildContextMetadata(options.workspaceId, options.sessionId, options.params);
    const sanitizedParams = this.sanitizeParams(options.params);
    const input =
      sanitizedParams || options.relatedFiles.length > 0
        ? {
            arguments: sanitizedParams,
            files: options.relatedFiles.length > 0 ? options.relatedFiles : undefined
          }
        : undefined;

    const outcome = this.buildOutcomeMetadata(options.success, options.response);

    return TraceMetadataBuilder.create({
      tool: {
        id: `${options.agent}_${options.mode}`,
        agent: options.agent,
        mode: options.mode
      },
      context,
      input,
      outcome,
      legacy: {
        params: options.params,
        result: options.response,
        relatedFiles: options.relatedFiles
      }
    });
  }

  private buildContextMetadata(
    workspaceId: string,
    sessionId: string,
    params: any
  ): TraceContextMetadata {
    const contextSource = params?.context || {};

    // Use new V2 format: memory, goal, constraints
    // These come from the ToolContext provided via getTools/useTool
    return {
      workspaceId,
      sessionId,
      memory: contextSource.memory || '',
      goal: contextSource.goal || '',
      constraints: contextSource.constraints
    };
  }

  private sanitizeParams(params: any): any {
    if (!params || typeof params !== 'object' || Array.isArray(params)) {
      return params;
    }

    const { context, workspaceContext, ...rest } = params;
    return Object.keys(rest).length > 0 ? rest : undefined;
  }

  private buildOutcomeMetadata(success: boolean, response: any): TraceOutcomeMetadata {
    if (success) {
      return { success: true };
    }

    const errorSource = response?.error || response?.result?.error;
    return {
      success: false,
      error: {
        type: errorSource?.type,
        message:
          errorSource?.message || (typeof errorSource === 'string' ? errorSource : 'Unknown error'),
        code: errorSource?.code
      }
    };
  }

  /**
   * Extract file paths from response and params
   * Looks in multiple locations to capture all affected files
   */
  private extractRelatedFiles(response: any, params: any): string[] {
    const files: string[] = [];

    // From params
    if (params?.filePath) files.push(params.filePath);
    if (params?.params?.filePath) files.push(params.params.filePath);
    if (params?.paths && Array.isArray(params.paths)) {
      files.push(...params.paths);
    }
    if (params?.params?.paths && Array.isArray(params.params.paths)) {
      files.push(...params.params.paths);
    }

    // From batch operations
    if (params?.operations && Array.isArray(params.operations)) {
      for (const op of params.operations) {
        if (op.params?.filePath) files.push(op.params.filePath);
        if (op.path) files.push(op.path);
      }
    }

    // From response
    if (response?.filePath) files.push(response.filePath);
    if (response?.files && Array.isArray(response.files)) {
      files.push(...response.files);
    }
    if (response?.affectedFiles && Array.isArray(response.affectedFiles)) {
      files.push(...response.affectedFiles);
    }
    if (response?.createdFiles && Array.isArray(response.createdFiles)) {
      files.push(...response.createdFiles);
    }
    if (response?.modifiedFiles && Array.isArray(response.modifiedFiles)) {
      files.push(...response.modifiedFiles);
    }

    // Deduplicate and filter empty strings
    return [...new Set(files.filter(f => f && f.trim()))];
  }

}

```

## services/UsageTracker.ts

```typescript
/**
 * Shared Usage Tracking Service
 * Handles cost tracking for LLM usage with provider-level breakdown
 */

export type UsageType = 'llm';

export interface ProviderUsage {
    [provider: string]: number; // Cost in USD
}

export interface UsageData {
    monthly: ProviderUsage;
    allTime: ProviderUsage;
    monthlyTotal: number;
    allTimeTotal: number;
    currentMonth: string;
    lastUpdated: string;
}

export interface BudgetStatus {
    monthlyBudget: number;
    currentSpending: number;
    percentageUsed: number;
    budgetExceeded: boolean;
    remainingBudget: number;
}

export interface UsageResponse {
    provider: string;
    cost: number;
    budgetStatus: BudgetStatus;
}

/**
 * Shared service for tracking usage costs by provider
 * Supports tracking for LLM usage
 */
export class UsageTracker {
    private readonly storageKeyPrefix: string;
    private readonly budgetKey: string;
    private readonly legacyStorageKeys: string[];
    private readonly legacyBudgetKeys: string[];
    
    constructor(
        private usageType: UsageType,
        private settings: any
    ) {
        this.storageKeyPrefix = `nexus-usage-${usageType}`;
        this.budgetKey = `nexus-budget-${usageType}`;
        this.legacyStorageKeys = [`claudesidian-usage-${usageType}`];
        this.legacyBudgetKeys = [`claudesidian-budget-${usageType}`];
    }

    /**
     * Track usage for a specific provider
     */
    async trackUsage(provider: string, cost: number): Promise<UsageResponse> {
        const usage = await this.loadUsageData();
        const currentMonth = this.getCurrentMonthKey();
        
        // Reset monthly stats if new month
        if (usage.currentMonth !== currentMonth) {
            usage.monthly = {};
            usage.monthlyTotal = 0;
            usage.currentMonth = currentMonth;
        }
        
        // Update monthly usage
        usage.monthly[provider] = (usage.monthly[provider] || 0) + cost;
        usage.monthlyTotal += cost;
        
        // Update all-time usage
        usage.allTime[provider] = (usage.allTime[provider] || 0) + cost;
        usage.allTimeTotal += cost;
        
        usage.lastUpdated = new Date().toISOString();
        
        await this.saveUsageData(usage);
        
        const budgetStatus = this.getBudgetStatus(usage.monthlyTotal);
        
        return {
            provider,
            cost,
            budgetStatus
        };
    }

    /**
     * Check if budget allows for a specific cost
     */
    async canAfford(cost: number): Promise<boolean> {
        const usage = await this.loadUsageData();
        const budget = this.getMonthlyBudget();
        
        if (budget <= 0) return true; // No budget set
        
        return (usage.monthlyTotal + cost) <= budget;
    }

    /**
     * Get current budget status
     */
    async getBudgetStatusAsync(): Promise<BudgetStatus> {
        const usage = await this.loadUsageData();
        return this.getBudgetStatus(usage.monthlyTotal);
    }

    /**
     * Get usage data for display
     */
    async getUsageData(): Promise<UsageData> {
        return await this.loadUsageData();
    }

    /**
     * Reset monthly usage
     */
    async resetMonthlyUsage(): Promise<void> {
        const usage = await this.loadUsageData();
        usage.monthly = {};
        usage.monthlyTotal = 0;
        usage.currentMonth = this.getCurrentMonthKey();
        usage.lastUpdated = new Date().toISOString();
        
        await this.saveUsageData(usage);
    }

    /**
     * Set monthly budget
     */
    setMonthlyBudget(budget: number): void {
        if (typeof localStorage === 'undefined') return;
        
        try {
            localStorage.setItem(this.budgetKey, budget.toString());
            this.cleanupLegacyKeys(this.legacyBudgetKeys);
        } catch (error) {
        }
    }

    /**
     * Get monthly budget
     */
    getMonthlyBudget(): number {
        if (typeof localStorage === 'undefined') return 0;
        
        try {
            const budget = this.getWithLegacyKeys(this.budgetKey, this.legacyBudgetKeys);
            return budget ? parseFloat(budget) : 0;
        } catch (error) {
            return 0;
        }
    }

    /**
     * Load usage data from storage
     */
    private async loadUsageData(): Promise<UsageData> {
        const defaultData: UsageData = {
            monthly: {},
            allTime: {},
            monthlyTotal: 0,
            allTimeTotal: 0,
            currentMonth: this.getCurrentMonthKey(),
            lastUpdated: new Date().toISOString()
        };

        if (typeof localStorage === 'undefined') {
            return defaultData;
        }

        try {
            const stored = this.getWithLegacyKeys(this.storageKeyPrefix, this.legacyStorageKeys);
            if (!stored) return defaultData;

            const parsed = JSON.parse(stored) as UsageData;
            
            // Ensure all required fields exist
            return {
                monthly: parsed.monthly || {},
                allTime: parsed.allTime || {},
                monthlyTotal: parsed.monthlyTotal || 0,
                allTimeTotal: parsed.allTimeTotal || 0,
                currentMonth: parsed.currentMonth || this.getCurrentMonthKey(),
                lastUpdated: parsed.lastUpdated || new Date().toISOString()
            };
        } catch (error) {
            return defaultData;
        }
    }

    /**
     * Save usage data to storage
     */
    private async saveUsageData(data: UsageData): Promise<void> {
        if (typeof localStorage === 'undefined') return;

        try {
            localStorage.setItem(this.storageKeyPrefix, JSON.stringify(data));
            this.cleanupLegacyKeys(this.legacyStorageKeys);
        } catch (error) {
        }
    }

    private getWithLegacyKeys(primaryKey: string, legacyKeys: string[]): string | null {
        if (typeof localStorage === 'undefined') return null;

        const primaryValue = localStorage.getItem(primaryKey);
        if (primaryValue) {
            return primaryValue;
        }

        for (const key of legacyKeys) {
            const legacyValue = localStorage.getItem(key);
            if (legacyValue) {
                try {
                    localStorage.setItem(primaryKey, legacyValue);
                    this.cleanupLegacyKeys(legacyKeys);
                } catch (error) {
                }
                return legacyValue;
            }
        }

        return null;
    }

    private cleanupLegacyKeys(keys: string[]): void {
        if (typeof localStorage === 'undefined') return;

        for (const key of keys) {
            try {
                localStorage.removeItem(key);
            } catch {
                // Ignore cleanup errors
            }
        }
    }

    /**
     * Get budget status for current spending
     */
    private getBudgetStatus(currentSpending: number): BudgetStatus {
        const monthlyBudget = this.getMonthlyBudget();
        const percentageUsed = monthlyBudget > 0 ? (currentSpending / monthlyBudget) * 100 : 0;
        const budgetExceeded = monthlyBudget > 0 && currentSpending >= monthlyBudget;
        const remainingBudget = Math.max(0, monthlyBudget - currentSpending);

        return {
            monthlyBudget,
            currentSpending,
            percentageUsed: Math.round(percentageUsed * 100) / 100, // Round to 2 decimal places
            budgetExceeded,
            remainingBudget
        };
    }

    /**
     * Get current month key (YYYY-MM format)
     */
    private getCurrentMonthKey(): string {
        const now = new Date();
        return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
    }
}

```

## services/workspace/DefaultWorkspaceManager.ts

```typescript
/**
 * Default Workspace Manager
 *
 * Manages the default workspace for tool calls that don't specify a workspace.
 * Ensures all tool calls have a valid workspace association for memory traces.
 */

import { App } from 'obsidian';
import type { WorkspaceService } from '../WorkspaceService';

export interface DefaultWorkspaceConfig {
  id: string;
  name: string;
  rootFolder: string;
  description: string;
}

/**
 * Service to manage default workspace fallback for tool call associations
 */
export class DefaultWorkspaceManager {
  private defaultWorkspaceId = 'default';
  private defaultConfig: DefaultWorkspaceConfig;
  private initialized = false;
  private workspaceService?: WorkspaceService;

  constructor(private app: App, workspaceService?: WorkspaceService) {
    this.defaultConfig = {
      id: this.defaultWorkspaceId,
      name: 'Default Workspace',
      rootFolder: '/',
      description: 'Default workspace for tool calls without explicit workspace context'
    };
    this.workspaceService = workspaceService;
  }

  /**
   * Set workspace service (for lazy injection after construction)
   */
  setWorkspaceService(workspaceService: WorkspaceService): void {
    this.workspaceService = workspaceService;
  }

  /**
   * Initialize the default workspace manager
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;
    
    try {
      // Ensure default workspace exists
      await this.ensureDefaultWorkspace();
      this.initialized = true;
    } catch (error) {
      console.error('[DefaultWorkspaceManager] Failed to initialize:', error);
      // Continue with basic functionality even if workspace creation fails
      this.initialized = true;
    }
  }

  /**
   * Get the default workspace ID
   */
  getDefaultWorkspaceId(): string {
    return this.defaultWorkspaceId;
  }

  /**
   * Get the default workspace configuration
   */
  getDefaultWorkspaceConfig(): DefaultWorkspaceConfig {
    return { ...this.defaultConfig };
  }

  /**
   * Set a custom default workspace ID
   */
  setDefaultWorkspaceId(workspaceId: string): void {
    if (!workspaceId || workspaceId.trim() === '') {
      return;
    }

    this.defaultWorkspaceId = workspaceId.trim();
    this.defaultConfig.id = this.defaultWorkspaceId;
  }

  /**
   * Validate if a workspace ID exists, return default if not
   */
  async validateWorkspaceId(workspaceId: string | undefined): Promise<string> {
    // If no workspace ID provided, use default
    if (!workspaceId || workspaceId.trim() === '') {
      return this.defaultWorkspaceId;
    }

    // If it's already the default, return as-is
    if (workspaceId === this.defaultWorkspaceId) {
      return workspaceId;
    }

    // For now, return the provided workspace ID
    // In the future, we could validate against actual workspace storage
    return workspaceId.trim();
  }

  /**
   * Ensure the default workspace exists - creates workspace JSON if missing
   */
  private async ensureDefaultWorkspace(): Promise<void> {
    if (!this.workspaceService) {
      return;
    }

    try {
      // Check if default workspace JSON already exists
      const existingWorkspace = await this.workspaceService.getWorkspace(this.defaultWorkspaceId);

      if (existingWorkspace) {
        return;
      }

      // Create default workspace JSON
      await this.workspaceService.createWorkspace({
        id: this.defaultWorkspaceId,
        name: this.defaultConfig.name,
        description: this.defaultConfig.description,
        rootFolder: this.defaultConfig.rootFolder,
        created: Date.now(),
        lastAccessed: Date.now(),
        isActive: true,
        sessions: {}
      });

    } catch (error) {
      console.error('[DefaultWorkspaceManager] Failed to create default workspace:', error);
      // Don't throw - allow plugin to continue even if workspace creation fails
    }
  }

  /**
   * Check if this is the default workspace
   */
  isDefaultWorkspace(workspaceId: string): boolean {
    return workspaceId === this.defaultWorkspaceId;
  }

  /**
   * Get workspace info for tool call context
   */
  getWorkspaceContextInfo(workspaceId: string): { workspaceId: string; isDefault: boolean } {
    const validatedId = workspaceId || this.defaultWorkspaceId;
    return {
      workspaceId: validatedId,
      isDefault: this.isDefaultWorkspace(validatedId)
    };
  }
}
```

## services/WorkspaceService.ts

```typescript
// Location: src/services/WorkspaceService.ts
// Centralized workspace management service with split-file storage
// Used by: MemoryManager agents, WorkspaceEditModal, UI components
// Dependencies: FileSystemService, IndexManager for data access (legacy)
//               IStorageAdapter for new hybrid storage backend

import { Plugin } from 'obsidian';
import { FileSystemService } from './storage/FileSystemService';
import { IndexManager } from './storage/IndexManager';
import { IndividualWorkspace, WorkspaceMetadata, SessionData, MemoryTrace, StateData } from '../types/storage/StorageTypes';
import { IStorageAdapter } from '../database/interfaces/IStorageAdapter';
import * as HybridTypes from '../types/storage/HybridStorageTypes';
import { TraceMetadata, LegacyWorkspaceTraceMetadata } from '../database/types/memory/MemoryTypes';
import { WorkspaceState } from '../database/types/session/SessionTypes';

// Export constant for backward compatibility
export const GLOBAL_WORKSPACE_ID = 'default';

export class WorkspaceService {
  constructor(
    private plugin: Plugin,
    private fileSystem: FileSystemService,
    private indexManager: IndexManager,
    private storageAdapter?: IStorageAdapter
  ) {}

  // ============================================================================
  // Type Conversion Helpers
  // ============================================================================

  /**
   * Convert HybridStorageTypes.WorkspaceMetadata to StorageTypes.WorkspaceMetadata
   */
  private convertWorkspaceMetadata(hybrid: HybridTypes.WorkspaceMetadata): WorkspaceMetadata {
    return {
      id: hybrid.id,
      name: hybrid.name,
      description: hybrid.description,
      rootFolder: hybrid.rootFolder,
      created: hybrid.created,
      lastAccessed: hybrid.lastAccessed,
      isActive: hybrid.isActive,
      sessionCount: 0, // Will be calculated if needed
      traceCount: 0    // Will be calculated if needed
    };
  }

  /**
   * Convert StorageTypes.WorkspaceMetadata to HybridStorageTypes.WorkspaceMetadata
   */
  private convertToHybridWorkspaceMetadata(legacy: WorkspaceMetadata): Omit<HybridTypes.WorkspaceMetadata, 'id'> {
    return {
      name: legacy.name,
      description: legacy.description,
      rootFolder: legacy.rootFolder,
      created: legacy.created,
      lastAccessed: legacy.lastAccessed,
      isActive: legacy.isActive ?? true
    };
  }

  // ============================================================================
  // Public API Methods (dual-backend support)
  // ============================================================================

  /**
   * List workspaces (uses index only - lightweight and fast)
   */
  async listWorkspaces(limit?: number): Promise<WorkspaceMetadata[]> {
    // Use new adapter if available
    if (this.storageAdapter) {
      const result = await this.storageAdapter.getWorkspaces({
        pageSize: limit,
        sortBy: 'lastAccessed',
        sortOrder: 'desc'
      });
      return result.items.map(w => this.convertWorkspaceMetadata(w));
    }

    // Fall back to legacy implementation
    const index = await this.indexManager.loadWorkspaceIndex();

    let workspaces = Object.values(index.workspaces);

    // Sort by last accessed (most recent first)
    workspaces.sort((a, b) => b.lastAccessed - a.lastAccessed);

    // Apply limit if specified
    if (limit) {
      workspaces = workspaces.slice(0, limit);
    }

    return workspaces;
  }

  /**
   * Get workspaces with flexible sorting and filtering (uses index only - lightweight and fast)
   */
  async getWorkspaces(options?: {
    sortBy?: 'name' | 'created' | 'lastAccessed',
    sortOrder?: 'asc' | 'desc',
    limit?: number
  }): Promise<WorkspaceMetadata[]> {
    // Use new adapter if available
    if (this.storageAdapter) {
      const result = await this.storageAdapter.getWorkspaces({
        pageSize: options?.limit,
        sortBy: options?.sortBy || 'lastAccessed',
        sortOrder: options?.sortOrder || 'desc'
      });
      return result.items.map(w => this.convertWorkspaceMetadata(w));
    }

    // Fall back to legacy implementation
    const index = await this.indexManager.loadWorkspaceIndex();
    let workspaces = Object.values(index.workspaces);

    // Apply sorting
    const sortBy = options?.sortBy || 'lastAccessed';
    const sortOrder = options?.sortOrder || 'desc';

    workspaces.sort((a, b) => {
      let comparison = 0;

      switch (sortBy) {
        case 'name':
          comparison = a.name.localeCompare(b.name);
          break;
        case 'created':
          comparison = a.created - b.created;
          break;
        case 'lastAccessed':
        default:
          comparison = a.lastAccessed - b.lastAccessed;
          break;
      }

      // Apply sort order
      return sortOrder === 'asc' ? comparison : -comparison;
    });

    // Apply limit if specified
    if (options?.limit) {
      workspaces = workspaces.slice(0, options.limit);
    }

    return workspaces;
  }

  /**
   * Get full workspace with sessions and traces (loads individual file)
   * NOTE: When using IStorageAdapter, this only returns metadata.
   * Use getSessions/getTraces methods separately for full data.
   */
  async getWorkspace(id: string): Promise<IndividualWorkspace | null> {
    // Use new adapter if available
    if (this.storageAdapter) {
      const metadata = await this.storageAdapter.getWorkspace(id);
      if (!metadata) {
        return null;
      }

      // Convert to IndividualWorkspace format (without sessions - those must be fetched separately)
      return {
        id: metadata.id,
        name: metadata.name,
        description: metadata.description,
        rootFolder: metadata.rootFolder,
        created: metadata.created,
        lastAccessed: metadata.lastAccessed,
        isActive: metadata.isActive,
        context: metadata.context,
        sessions: {} // Sessions must be loaded separately with getSessions
      };
    }

    // Fall back to legacy implementation
    const workspace = await this.fileSystem.readWorkspace(id);

    if (!workspace) {
      return null;
    }

    // Migrate legacy array-based workflow steps to string format
    const migrated = this.migrateWorkflowSteps(workspace);
    if (migrated) {
      // Save migrated workspace back to storage
      await this.fileSystem.writeWorkspace(id, workspace);
    }

    return workspace;
  }

  /**
   * Get all workspaces with full data (expensive - avoid if possible)
   */
  async getAllWorkspaces(): Promise<IndividualWorkspace[]> {
    // Use new adapter if available
    if (this.storageAdapter) {
      const result = await this.storageAdapter.getWorkspaces({
        pageSize: 1000, // Get all workspaces
        sortBy: 'lastAccessed',
        sortOrder: 'desc'
      });

      return result.items.map(w => ({
        id: w.id,
        name: w.name,
        description: w.description,
        rootFolder: w.rootFolder,
        created: w.created,
        lastAccessed: w.lastAccessed,
        isActive: w.isActive,
        context: w.context,
        sessions: {} // Sessions must be loaded separately
      }));
    }

    // Fall back to legacy implementation
    const workspaceIds = await this.fileSystem.listWorkspaceIds();
    const workspaces: IndividualWorkspace[] = [];

    for (const id of workspaceIds) {
      const workspace = await this.fileSystem.readWorkspace(id);
      if (workspace) {
        // Migrate legacy array-based workflow steps to string format
        const migrated = this.migrateWorkflowSteps(workspace);
        if (migrated) {
          // Save migrated workspace back to storage
          await this.fileSystem.writeWorkspace(id, workspace);
        }
        workspaces.push(workspace);
      }
    }

    return workspaces;
  }

  /**
   * Create new workspace (writes file + updates index)
   */
  async createWorkspace(data: Partial<IndividualWorkspace>): Promise<IndividualWorkspace> {
    // Use new adapter if available
    if (this.storageAdapter) {
      // Convert context to HybridTypes format if provided
      const hybridContext = data.context ? {
        purpose: data.context.purpose,
        workflows: data.context.workflows,
        keyFiles: data.context.keyFiles,
        preferences: data.context.preferences,
        dedicatedAgent: data.context.dedicatedAgent
      } : undefined;

      const hybridData: Omit<HybridTypes.WorkspaceMetadata, 'id'> & { id?: string } = {
        id: data.id, // Pass optional ID (e.g., 'default')
        name: data.name || 'Untitled Workspace',
        description: data.description,
        rootFolder: data.rootFolder || '/',
        created: data.created || Date.now(),
        lastAccessed: data.lastAccessed || Date.now(),
        isActive: data.isActive ?? true,
        context: hybridContext
      };

      const id = await this.storageAdapter.createWorkspace(hybridData);

      return {
        id,
        name: hybridData.name,
        description: hybridData.description,
        rootFolder: hybridData.rootFolder,
        created: hybridData.created,
        lastAccessed: hybridData.lastAccessed,
        isActive: hybridData.isActive,
        context: data.context,
        sessions: {}
      };
    }

    // Fall back to legacy implementation
    const id = data.id || `ws_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const workspace: IndividualWorkspace = {
      id,
      name: data.name || 'Untitled Workspace',
      description: data.description,
      rootFolder: data.rootFolder || '/',
      created: data.created || Date.now(),
      lastAccessed: data.lastAccessed || Date.now(),
      isActive: data.isActive ?? true,
      context: data.context,
      sessions: data.sessions || {}
    };

    // Write workspace file
    await this.fileSystem.writeWorkspace(id, workspace);

    // Update index
    await this.indexManager.updateWorkspaceInIndex(workspace);

    return workspace;
  }

  /**
   * Update workspace (updates file + index metadata)
   */
  async updateWorkspace(id: string, updates: Partial<IndividualWorkspace>): Promise<void> {
    // Use new adapter if available
    if (this.storageAdapter) {
      // Only update metadata fields that exist in HybridTypes
      const hybridUpdates: Partial<HybridTypes.WorkspaceMetadata> = {};

      if (updates.name !== undefined) hybridUpdates.name = updates.name;
      if (updates.description !== undefined) hybridUpdates.description = updates.description;
      if (updates.rootFolder !== undefined) hybridUpdates.rootFolder = updates.rootFolder;
      if (updates.isActive !== undefined) hybridUpdates.isActive = updates.isActive;
      if (updates.isArchived !== undefined) hybridUpdates.isArchived = updates.isArchived;

      // Handle context update
      if (updates.context !== undefined) {
        hybridUpdates.context = {
          purpose: updates.context.purpose,
          workflows: updates.context.workflows,
          keyFiles: updates.context.keyFiles,
          preferences: updates.context.preferences,
          dedicatedAgent: updates.context.dedicatedAgent
        };
      }

      // Always update lastAccessed
      hybridUpdates.lastAccessed = Date.now();

      await this.storageAdapter.updateWorkspace(id, hybridUpdates);
      return;
    }

    // Fall back to legacy implementation
    // Load existing workspace
    const workspace = await this.fileSystem.readWorkspace(id);

    if (!workspace) {
      throw new Error(`Workspace ${id} not found`);
    }

    // Apply updates
    const updatedWorkspace: IndividualWorkspace = {
      ...workspace,
      ...updates,
      id, // Preserve ID
      lastAccessed: Date.now()
    };

    // Write updated workspace
    await this.fileSystem.writeWorkspace(id, updatedWorkspace);

    // Update index
    await this.indexManager.updateWorkspaceInIndex(updatedWorkspace);
  }

  /**
   * Update last accessed timestamp for a workspace
   * Lightweight operation that only updates the timestamp in both file and index
   */
  async updateLastAccessed(id: string): Promise<void> {
    // Use new adapter if available
    if (this.storageAdapter) {
      await this.storageAdapter.updateWorkspace(id, { lastAccessed: Date.now() });
      return;
    }

    // Fall back to legacy implementation
    // Load existing workspace
    const workspace = await this.fileSystem.readWorkspace(id);

    if (!workspace) {
      throw new Error(`Workspace ${id} not found`);
    }

    // Update only the lastAccessed timestamp
    workspace.lastAccessed = Date.now();

    // Write updated workspace
    await this.fileSystem.writeWorkspace(id, workspace);

    // Update index
    await this.indexManager.updateWorkspaceInIndex(workspace);
  }

  /**
   * Delete workspace (deletes file + removes from index)
   */
  async deleteWorkspace(id: string): Promise<void> {
    // Use new adapter if available
    if (this.storageAdapter) {
      await this.storageAdapter.deleteWorkspace(id);
      return;
    }

    // Fall back to legacy implementation
    // Delete workspace file
    await this.fileSystem.deleteWorkspace(id);

    // Remove from index
    await this.indexManager.removeWorkspaceFromIndex(id);
  }

  /**
   * Add session to workspace
   * Ensures the workspace exists before creating session
   */
  async addSession(workspaceId: string, sessionData: Partial<SessionData>): Promise<SessionData> {
    // Use new adapter if available
    if (this.storageAdapter) {
      // Ensure workspace exists before creating session (referential integrity)
      const existingWorkspace = await this.getWorkspace(workspaceId);
      if (!existingWorkspace) {
        // For 'default' workspace, create it automatically
        if (workspaceId === GLOBAL_WORKSPACE_ID) {
          await this.createWorkspace({
            id: GLOBAL_WORKSPACE_ID,
            name: 'Default Workspace',
            description: 'Default workspace for general use',
            rootFolder: '/'
          });
        } else {
          throw new Error(`Workspace ${workspaceId} not found. Create it first or use the default workspace.`);
        }
      }

      const hybridSession: Omit<HybridTypes.SessionMetadata, 'id' | 'workspaceId'> = {
        name: sessionData.name || 'Untitled Session',
        description: sessionData.description,
        startTime: sessionData.startTime || Date.now(),
        endTime: sessionData.endTime,
        isActive: sessionData.isActive ?? true
      };

      const sessionId = await this.storageAdapter.createSession(workspaceId, hybridSession);

      // Update workspace lastAccessed
      await this.storageAdapter.updateWorkspace(workspaceId, { lastAccessed: Date.now() });

      return {
        id: sessionId,
        name: hybridSession.name,
        description: hybridSession.description,
        startTime: hybridSession.startTime,
        endTime: hybridSession.endTime,
        isActive: hybridSession.isActive,
        memoryTraces: {},
        states: {}
      };
    }

    // Fall back to legacy implementation
    // Load workspace
    const workspace = await this.fileSystem.readWorkspace(workspaceId);

    if (!workspace) {
      throw new Error(`Workspace ${workspaceId} not found`);
    }

    // Create session
    const sessionId = sessionData.id || `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const session: SessionData = {
      id: sessionId,
      name: sessionData.name,
      description: sessionData.description,
      startTime: sessionData.startTime || Date.now(),
      endTime: sessionData.endTime,
      isActive: sessionData.isActive ?? true,
      memoryTraces: sessionData.memoryTraces || {},
      states: sessionData.states || {}
    };

    // Add to workspace
    workspace.sessions[sessionId] = session;
    workspace.lastAccessed = Date.now();

    // Save workspace
    await this.fileSystem.writeWorkspace(workspaceId, workspace);

    // Update index
    await this.indexManager.updateWorkspaceInIndex(workspace);

    return session;
  }

  /**
   * Update session in workspace
   */
  async updateSession(workspaceId: string, sessionId: string, updates: Partial<SessionData>): Promise<void> {
    // Use new adapter if available
    if (this.storageAdapter) {
      const hybridUpdates: Partial<HybridTypes.SessionMetadata> = {};
      if (updates.name !== undefined) hybridUpdates.name = updates.name;
      if (updates.description !== undefined) hybridUpdates.description = updates.description;
      if (updates.endTime !== undefined) hybridUpdates.endTime = updates.endTime;
      if (updates.isActive !== undefined) hybridUpdates.isActive = updates.isActive;

      await this.storageAdapter.updateSession(workspaceId, sessionId, hybridUpdates);
      await this.storageAdapter.updateWorkspace(workspaceId, { lastAccessed: Date.now() });
      return;
    }

    // Fall back to legacy implementation
    // Load workspace
    const workspace = await this.fileSystem.readWorkspace(workspaceId);

    if (!workspace) {
      throw new Error(`Workspace ${workspaceId} not found`);
    }

    if (!workspace.sessions[sessionId]) {
      throw new Error(`Session ${sessionId} not found in workspace ${workspaceId}`);
    }

    // Apply updates
    workspace.sessions[sessionId] = {
      ...workspace.sessions[sessionId],
      ...updates,
      id: sessionId // Preserve ID
    };

    workspace.lastAccessed = Date.now();

    // Save workspace
    await this.fileSystem.writeWorkspace(workspaceId, workspace);

    // Update index
    await this.indexManager.updateWorkspaceInIndex(workspace);
  }

  /**
   * Delete session from workspace
   */
  async deleteSession(workspaceId: string, sessionId: string): Promise<void> {
    // Use new adapter if available
    if (this.storageAdapter) {
      await this.storageAdapter.deleteSession(sessionId);
      await this.storageAdapter.updateWorkspace(workspaceId, { lastAccessed: Date.now() });
      return;
    }

    // Fall back to legacy implementation
    // Load workspace
    const workspace = await this.fileSystem.readWorkspace(workspaceId);

    if (!workspace) {
      throw new Error(`Workspace ${workspaceId} not found`);
    }

    // Delete session
    delete workspace.sessions[sessionId];
    workspace.lastAccessed = Date.now();

    // Save workspace
    await this.fileSystem.writeWorkspace(workspaceId, workspace);

    // Update index
    await this.indexManager.updateWorkspaceInIndex(workspace);
  }

  /**
   * Get session from workspace
   */
  async getSession(workspaceId: string, sessionId: string): Promise<SessionData | null> {
    // Use new adapter if available
    if (this.storageAdapter) {
      const session = await this.storageAdapter.getSession(sessionId);
      if (!session) {
        return null;
      }

      return {
        id: session.id,
        name: session.name,
        description: session.description,
        startTime: session.startTime,
        endTime: session.endTime,
        isActive: session.isActive,
        memoryTraces: {}, // Must be loaded separately
        states: {}        // Must be loaded separately
      };
    }

    // Fall back to legacy implementation
    const workspace = await this.fileSystem.readWorkspace(workspaceId);

    if (!workspace) {
      return null;
    }

    const session = workspace.sessions[sessionId];

    if (!session) {
      return null;
    }

    return session;
  }

  /**
   * Add memory trace to session
   * Ensures the session exists before saving (creates it if needed)
   */
  async addMemoryTrace(workspaceId: string, sessionId: string, traceData: Partial<MemoryTrace>): Promise<MemoryTrace> {
    // Use new adapter if available
    if (this.storageAdapter) {
      // Ensure session exists before saving trace (referential integrity)
      const existingSession = await this.getSession(workspaceId, sessionId);
      if (!existingSession) {
        await this.addSession(workspaceId, {
          id: sessionId,
          name: `Session ${new Date().toLocaleString()}`,
          description: `Auto-created session for trace storage`,
          startTime: Date.now(),
          isActive: true
        });
      }

      const hybridTrace: Omit<HybridTypes.MemoryTraceData, 'id' | 'workspaceId' | 'sessionId'> = {
        timestamp: traceData.timestamp || Date.now(),
        type: traceData.type,
        content: traceData.content || '',
        metadata: traceData.metadata
      };

      const traceId = await this.storageAdapter.addTrace(workspaceId, sessionId, hybridTrace);
      await this.storageAdapter.updateWorkspace(workspaceId, { lastAccessed: Date.now() });

      return {
        id: traceId,
        timestamp: hybridTrace.timestamp,
        type: hybridTrace.type || 'generic',
        content: hybridTrace.content,
        // Safe conversion: HybridTypes.MemoryTraceData.metadata (Record<string, any>)
        // is cast to TraceMetadata which is the expected type for MemoryTrace.metadata
        // Note: This metadata may be either TraceMetadata or LegacyWorkspaceTraceMetadata at runtime
        metadata: hybridTrace.metadata as TraceMetadata | undefined
      };
    }

    // Fall back to legacy implementation
    // Load workspace
    const workspace = await this.fileSystem.readWorkspace(workspaceId);

    if (!workspace) {
      throw new Error(`Workspace ${workspaceId} not found`);
    }

    if (!workspace.sessions[sessionId]) {
      throw new Error(`Session ${sessionId} not found in workspace ${workspaceId}`);
    }

    // Create trace
    const traceId = traceData.id || `trace_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const trace: MemoryTrace = {
      id: traceId,
      timestamp: traceData.timestamp || Date.now(),
      type: traceData.type || 'generic',
      content: traceData.content || '',
      metadata: traceData.metadata
    };

    // Add to session
    workspace.sessions[sessionId].memoryTraces[traceId] = trace;
    workspace.lastAccessed = Date.now();

    // Save workspace
    await this.fileSystem.writeWorkspace(workspaceId, workspace);

    // Update index
    await this.indexManager.updateWorkspaceInIndex(workspace);

    return trace;
  }

  /**
   * Get memory traces from session
   */
  async getMemoryTraces(workspaceId: string, sessionId: string): Promise<MemoryTrace[]> {
    // Use new adapter if available
    if (this.storageAdapter) {
      const result = await this.storageAdapter.getTraces(workspaceId, sessionId);
      return result.items.map(t => ({
        id: t.id,
        timestamp: t.timestamp,
        type: t.type || 'generic',
        content: t.content,
        // Safe conversion: HybridTypes.MemoryTraceData.metadata (Record<string, any>)
        // is cast to TraceMetadata which is the expected type for MemoryTrace.metadata
        // Note: This metadata may be either TraceMetadata or LegacyWorkspaceTraceMetadata at runtime
        metadata: t.metadata as TraceMetadata | undefined
      }));
    }

    // Fall back to legacy implementation
    const workspace = await this.fileSystem.readWorkspace(workspaceId);

    if (!workspace || !workspace.sessions[sessionId]) {
      return [];
    }

    return Object.values(workspace.sessions[sessionId].memoryTraces);
  }

  /**
   * Add state to session
   * Ensures the session exists before saving (creates it if needed)
   */
  async addState(workspaceId: string, sessionId: string, stateData: Partial<StateData>): Promise<StateData> {
    // Use new adapter if available
    if (this.storageAdapter) {
      // Ensure session exists before saving state (referential integrity)
      const existingSession = await this.getSession(workspaceId, sessionId);
      if (!existingSession) {
        await this.addSession(workspaceId, {
          id: sessionId,
          name: `Session ${new Date().toLocaleString()}`,
          description: `Auto-created session for state storage`,
          startTime: Date.now(),
          isActive: true
        });
      }

      // Support both new 'state' property and legacy 'snapshot' property
      const stateContent = stateData.state ||
        (stateData as Partial<StateData> & { snapshot?: WorkspaceState }).snapshot ||
        {};

      const hybridState: Omit<HybridTypes.StateData, 'id' | 'workspaceId' | 'sessionId'> = {
        name: stateData.name || 'Untitled State',
        created: stateData.created || Date.now(),
        description: undefined,
        tags: undefined,
        content: stateContent
      };

      const stateId = await this.storageAdapter.saveState(workspaceId, sessionId, hybridState);
      await this.storageAdapter.updateWorkspace(workspaceId, { lastAccessed: Date.now() });

      return {
        id: stateId,
        name: hybridState.name,
        created: hybridState.created,
        state: hybridState.content
      };
    }

    // Fall back to legacy implementation
    // Load workspace
    const workspace = await this.fileSystem.readWorkspace(workspaceId);

    if (!workspace) {
      throw new Error(`Workspace ${workspaceId} not found`);
    }

    if (!workspace.sessions[sessionId]) {
      throw new Error(`Session ${sessionId} not found in workspace ${workspaceId}`);
    }

    // Create state
    const stateId = stateData.id || `state_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // Support both new 'state' property and legacy 'snapshot' property
    const stateContent = stateData.state ||
      (stateData as Partial<StateData> & { snapshot?: WorkspaceState }).snapshot ||
      {} as WorkspaceState;

    const state: StateData = {
      id: stateId,
      name: stateData.name || 'Untitled State',
      created: stateData.created || Date.now(),
      state: stateContent
    };

    // Add to session
    workspace.sessions[sessionId].states[stateId] = state;
    workspace.lastAccessed = Date.now();

    // Save workspace
    await this.fileSystem.writeWorkspace(workspaceId, workspace);

    // Update index
    await this.indexManager.updateWorkspaceInIndex(workspace);

    return state;
  }

  /**
   * Get state from session
   */
  async getState(workspaceId: string, sessionId: string, stateId: string): Promise<StateData | null> {
    // Use new adapter if available
    if (this.storageAdapter) {
      const state = await this.storageAdapter.getState(stateId);
      if (!state) {
        return null;
      }

      return {
        id: state.id,
        name: state.name,
        created: state.created,
        state: state.content
      };
    }

    // Fall back to legacy implementation
    const workspace = await this.fileSystem.readWorkspace(workspaceId);

    if (!workspace || !workspace.sessions[sessionId]) {
      return null;
    }

    const state = workspace.sessions[sessionId].states[stateId];
    return state || null;
  }

  /**
   * Search workspaces (uses index search data)
   */
  async searchWorkspaces(query: string, limit?: number): Promise<WorkspaceMetadata[]> {
    // Use new adapter if available
    if (this.storageAdapter) {
      if (!query) {
        return this.listWorkspaces(limit);
      }

      const results = await this.storageAdapter.searchWorkspaces(query);
      const converted = results.map(w => this.convertWorkspaceMetadata(w));

      return limit ? converted.slice(0, limit) : converted;
    }

    // Fall back to legacy implementation
    if (!query) {
      return this.listWorkspaces(limit);
    }

    const index = await this.indexManager.loadWorkspaceIndex();
    const words = query.toLowerCase().split(/\s+/).filter(word => word.length > 2);
    const matchedIds = new Set<string>();

    // Search name and description indices
    for (const word of words) {
      // Search names
      if (index.byName[word]) {
        index.byName[word].forEach(id => matchedIds.add(id));
      }

      // Search descriptions
      if (index.byDescription[word]) {
        index.byDescription[word].forEach(id => matchedIds.add(id));
      }
    }

    // Get metadata for matched workspaces
    const results = Array.from(matchedIds)
      .map(id => index.workspaces[id])
      .filter(ws => ws !== undefined)
      .sort((a, b) => b.lastAccessed - a.lastAccessed);

    // Apply limit
    const limited = limit ? results.slice(0, limit) : results;

    return limited;
  }

  /**
   * Get workspace by folder (uses index)
   */
  async getWorkspaceByFolder(folder: string): Promise<WorkspaceMetadata | null> {
    // Use new adapter if available
    if (this.storageAdapter) {
      const result = await this.storageAdapter.getWorkspaces({
        filter: { rootFolder: folder },
        pageSize: 1
      });

      if (result.items.length === 0) {
        return null;
      }

      return this.convertWorkspaceMetadata(result.items[0]);
    }

    // Fall back to legacy implementation
    const index = await this.indexManager.loadWorkspaceIndex();
    const workspaceId = index.byFolder[folder];

    if (!workspaceId) {
      return null;
    }

    return index.workspaces[workspaceId] || null;
  }

  /**
   * Get active workspace (uses index)
   */
  async getActiveWorkspace(): Promise<WorkspaceMetadata | null> {
    // Use new adapter if available
    if (this.storageAdapter) {
      const result = await this.storageAdapter.getWorkspaces({
        filter: { isActive: true },
        pageSize: 1
      });

      if (result.items.length === 0) {
        return null;
      }

      return this.convertWorkspaceMetadata(result.items[0]);
    }

    // Fall back to legacy implementation
    const index = await this.indexManager.loadWorkspaceIndex();
    const workspaces = Object.values(index.workspaces);
    const active = workspaces.find(ws => ws.isActive);

    return active || null;
  }

  /**
   * Get workspace by name or ID (unified lookup)
   * Tries ID lookup first (more specific), then falls back to name lookup (case-insensitive)
   * @param identifier Workspace name or ID
   * @returns Full workspace data or null if not found
   */
  async getWorkspaceByNameOrId(identifier: string): Promise<IndividualWorkspace | null> {
    // Try ID lookup first (more specific)
    const byId = await this.getWorkspace(identifier);
    if (byId) {
      return byId;
    }

    // Use new adapter if available for name lookup
    if (this.storageAdapter) {
      const result = await this.storageAdapter.getWorkspaces({
        search: identifier,
        pageSize: 100
      });

      const match = result.items.find(
        ws => ws.name.toLowerCase() === identifier.toLowerCase()
      );

      if (!match) {
        return null;
      }

      return this.getWorkspace(match.id);
    }

    // Fall back to legacy implementation
    const index = await this.indexManager.loadWorkspaceIndex();
    const workspaces = Object.values(index.workspaces);
    const matchingWorkspace = workspaces.find(
      ws => ws.name.toLowerCase() === identifier.toLowerCase()
    );

    if (!matchingWorkspace) {
      return null;
    }

    return this.getWorkspace(matchingWorkspace.id);
  }

  /**
   * Get session by name or ID within a workspace (unified lookup)
   * Tries ID lookup first, then falls back to name lookup (case-insensitive)
   * @param workspaceId Workspace ID to search in
   * @param identifier Session name or ID
   * @returns Session data or null if not found
   */
  async getSessionByNameOrId(workspaceId: string, identifier: string): Promise<SessionData | null> {
    // Try ID lookup first
    const byId = await this.getSession(workspaceId, identifier);
    if (byId) {
      return byId;
    }

    // Use new adapter if available for name lookup
    if (this.storageAdapter) {
      const result = await this.storageAdapter.getSessions(workspaceId, { pageSize: 100 });
      const match = result.items.find(
        session => session.name?.toLowerCase() === identifier.toLowerCase()
      );

      if (!match) {
        return null;
      }

      return this.getSession(workspaceId, match.id);
    }

    // Fall back to legacy implementation
    const workspace = await this.fileSystem.readWorkspace(workspaceId);
    if (!workspace) {
      return null;
    }

    const sessions = Object.values(workspace.sessions);
    return sessions.find(
      session => session.name?.toLowerCase() === identifier.toLowerCase()
    ) || null;
  }

  /**
   * Get state by name or ID within a session (unified lookup)
   * Tries ID lookup first, then falls back to name lookup (case-insensitive)
   * @param workspaceId Workspace ID
   * @param sessionId Session ID to search in
   * @param identifier State name or ID
   * @returns State data or null if not found
   */
  async getStateByNameOrId(workspaceId: string, sessionId: string, identifier: string): Promise<StateData | null> {
    // Try ID lookup first
    const byId = await this.getState(workspaceId, sessionId, identifier);
    if (byId) {
      return byId;
    }

    // Use new adapter if available for name lookup
    if (this.storageAdapter) {
      const result = await this.storageAdapter.getStates(workspaceId, sessionId, { pageSize: 100 });
      const match = result.items.find(
        state => state.name?.toLowerCase() === identifier.toLowerCase()
      );

      if (!match) {
        return null;
      }

      return this.getState(workspaceId, sessionId, match.id);
    }

    // Fall back to legacy implementation
    const workspace = await this.fileSystem.readWorkspace(workspaceId);
    if (!workspace || !workspace.sessions[sessionId]) {
      return null;
    }

    const states = Object.values(workspace.sessions[sessionId].states);
    return states.find(
      state => state.name?.toLowerCase() === identifier.toLowerCase()
    ) || null;
  }

  /**
   * Migrate legacy array-based workflow steps to string format
   * @param workspace Workspace to migrate
   * @returns true if migration was performed, false otherwise
   */
  private migrateWorkflowSteps(workspace: IndividualWorkspace): boolean {
    if (!workspace.context?.workflows || workspace.context.workflows.length === 0) {
      return false;
    }

    let migrated = false;

    for (const workflow of workspace.context.workflows) {
      // Check if steps is an array (legacy format)
      if (Array.isArray(workflow.steps)) {
        // Convert array to string with newlines
        // Type assertion needed: workflow.steps is typed as string but legacy data may have string[]
        (workflow as { steps: string | string[] }).steps = (workflow.steps as string[]).join('\n');
        migrated = true;
      }
    }

    return migrated;
  }
}
```

## settings.ts

```typescript
import { Plugin } from 'obsidian';
import { MCPSettings, DEFAULT_SETTINGS } from './types';

/**
 * Settings manager
 * Handles loading and saving plugin settings
 */
export class Settings {
    private plugin: Plugin;
    settings: MCPSettings;

    /**
     * Create a new settings manager
     * @param plugin Plugin instance
     */
    constructor(plugin: Plugin) {
        this.plugin = plugin;
        this.settings = DEFAULT_SETTINGS;
    }

    /**
     * Load settings from plugin data
     * Now synchronous with minimal validation for fast startup
     */
    async loadSettings() {
        try {
            const loadedData = await this.plugin.loadData();
            this.applyLoadedData(loadedData);
        } catch (error) {
            // Continue with defaults - plugin should still function
        }
    }
    
    /**
     * Apply loaded data with minimal validation for fast startup
     */
    private applyLoadedData(loadedData: any) {
        if (!loadedData) {
            return; // Use defaults
        }
        
        // Start with default settings (includes memory)
        this.settings = Object.assign({}, DEFAULT_SETTINGS);
        
        // Quick shallow merge for startup - detailed validation deferred
        try {
            const { memory, llmProviders, ...otherSettings } = loadedData;
            Object.assign(this.settings, otherSettings);
            
            // Ensure memory settings exist
            this.settings.memory = DEFAULT_SETTINGS.memory;

            // Basic LLM provider settings merge
            if (llmProviders && DEFAULT_SETTINGS.llmProviders) {
                this.settings.llmProviders = {
                    ...DEFAULT_SETTINGS.llmProviders,
                    ...llmProviders,
                    // Ensure providers exists with all default providers
                    providers: {
                        ...DEFAULT_SETTINGS.llmProviders.providers,
                        ...(llmProviders.providers || {})
                    }
                };
            }
        } catch (error) {
            // Continue with defaults - plugin should still function
        }
    }

    /**
     * Save settings to plugin data
     */
    async saveSettings() {
        // Simple JSON-based storage
        await this.plugin.saveData(this.settings);
    }
}

// Re-export types and constants from types.ts
export type { MCPSettings };
export { DEFAULT_SETTINGS };
```

## settings/components/BackButton.ts

```typescript
/**
 * BackButton - Consistent back navigation component for detail views
 * Uses Obsidian-native styling patterns
 */

import { Component, setIcon } from 'obsidian';

export class BackButton {
    private element: HTMLElement;

    /**
     * Create a back button
     * @param container Parent element to attach to
     * @param label Text to display (e.g., "Back to Workspaces")
     * @param onClick Callback when clicked
     * @param component Optional Component for registerDomEvent
     */
    constructor(container: HTMLElement, label: string, onClick: () => void, component?: Component) {
        this.element = container.createDiv('nexus-back-button');

        const iconSpan = this.element.createSpan({ cls: 'nexus-back-button-icon' });
        setIcon(iconSpan, 'chevron-left');

        // Label text
        this.element.createSpan({ text: label });

        // Click handler
        component!.registerDomEvent(this.element, 'click', onClick);
    }

    /**
     * Get the underlying element
     */
    getElement(): HTMLElement {
        return this.element;
    }

    /**
     * Remove the button from DOM
     */
    destroy(): void {
        this.element.remove();
    }
}

```

## settings/components/StatusBadge.ts

```typescript
/**
 * StatusBadge - Shows configured/not configured status indicator
 * Uses Obsidian-native styling with CSS classes
 */

export class StatusBadge {
    /**
     * Render a status badge
     * @param container Parent element to attach to
     * @param configured Whether the item is configured
     * @returns The created badge element
     */
    static render(container: HTMLElement, configured: boolean): HTMLElement {
        const badge = container.createSpan('nexus-status-badge');
        badge.addClass(configured ? 'configured' : 'not-configured');
        badge.setText(configured ? 'âœ“' : 'â—‹');
        return badge;
    }

    /**
     * Render a status badge with custom text
     * @param container Parent element to attach to
     * @param configured Whether the item is configured
     * @param configuredText Text to show when configured
     * @param notConfiguredText Text to show when not configured
     */
    static renderWithText(
        container: HTMLElement,
        configured: boolean,
        configuredText: string = 'Configured',
        notConfiguredText: string = 'Not configured'
    ): HTMLElement {
        const badge = container.createSpan('nexus-status-badge');
        badge.addClass(configured ? 'configured' : 'not-configured');
        badge.setText(configured ? configuredText : notConfiguredText);
        return badge;
    }

    /**
     * Update an existing badge's status
     * @param badge The badge element to update
     * @param configured New configuration status
     */
    static update(badge: HTMLElement, configured: boolean): void {
        badge.removeClass('configured', 'not-configured');
        badge.addClass(configured ? 'configured' : 'not-configured');
        badge.setText(configured ? 'âœ“' : 'â—‹');
    }
}

```

## settings/SettingsRouter.ts

```typescript
/**
 * SettingsRouter - Manages navigation state for settings UI
 * Handles tab switching and list/detail view navigation
 */

export type SettingsTab = 'defaults' | 'workspaces' | 'prompts' | 'providers' | 'data' | 'getstarted';
export type SettingsView = 'list' | 'detail';

export interface RouterState {
    tab: SettingsTab;
    view: SettingsView;
    detailId?: string;  // workspace/prompt/provider ID when in detail view
}

export class SettingsRouter {
    private state: RouterState = { tab: 'defaults', view: 'list' };
    private listeners: Set<(state: RouterState) => void> = new Set();

    /**
     * Get current router state
     */
    getState(): RouterState {
        return { ...this.state };
    }

    /**
     * Switch to a different tab (resets to list view)
     */
    setTab(tab: SettingsTab): void {
        this.state = { tab, view: 'list', detailId: undefined };
        this.notify();
    }

    /**
     * Navigate to detail view for a specific item
     */
    showDetail(id: string): void {
        this.state = {
            ...this.state,
            view: 'detail',
            detailId: id
        };
        this.notify();
    }

    /**
     * Go back to list view (from detail view)
     */
    back(): void {
        this.state = {
            ...this.state,
            view: 'list',
            detailId: undefined
        };
        this.notify();
    }

    /**
     * Check if currently in detail view
     */
    isDetailView(): boolean {
        return this.state.view === 'detail';
    }

    /**
     * Subscribe to navigation changes
     */
    onNavigate(callback: (state: RouterState) => void): () => void {
        this.listeners.add(callback);
        // Return unsubscribe function
        return () => this.listeners.delete(callback);
    }

    /**
     * Notify all listeners of state change
     */
    private notify(): void {
        const currentState = this.getState();
        this.listeners.forEach(callback => callback(currentState));
    }

    /**
     * Cleanup - remove all listeners
     */
    destroy(): void {
        this.listeners.clear();
    }
}

```

## settings/SettingsView.ts

```typescript
import { App, Plugin, PluginSettingTab, Setting, Notice, ButtonComponent, FileSystemAdapter } from 'obsidian';
import { Settings } from '../settings';
import { UnifiedTabs, UnifiedTabConfig } from '../components/UnifiedTabs';
import { SettingsRouter, RouterState, SettingsTab } from './SettingsRouter';
import { UpdateManager } from '../utils/UpdateManager';
import { supportsMCPBridge } from '../utils/platform';

// Type to access private method (should be refactored to make fetchLatestRelease public in UpdateManager)
type UpdateManagerWithFetchRelease = {
    fetchLatestRelease(): Promise<{ tag_name: string; assets: Array<{ name: string; browser_download_url: string }> }>;
};

// Services
import { WorkspaceService } from '../services/WorkspaceService';
import { MemoryService } from '../agents/memoryManager/services/MemoryService';
import { CustomPromptStorageService } from '../agents/promptManager/services/CustomPromptStorageService';
import type { ServiceManager } from '../core/ServiceManager';

// Agents
import { SearchManagerAgent } from '../agents/searchManager/searchManager';
import { MemoryManagerAgent } from '../agents/memoryManager/memoryManager';

// Tab implementations
import { DefaultsTab } from './tabs/DefaultsTab';
import { WorkspacesTab } from './tabs/WorkspacesTab';
import { PromptsTab } from './tabs/PromptsTab';
import { ProvidersTab } from './tabs/ProvidersTab';
// GetStartedTab is dynamically imported (desktop-only, requires Node.js)
type GetStartedTabType = import('./tabs/GetStartedTab').GetStartedTab;
// import { DataTab } from './tabs/DataTab'; // TODO: Re-enable when Data tab is ready

/**
 * SettingsView - New unified settings interface with tab-based navigation
 * Replaces the accordion-based SettingsTab
 */
export class SettingsView extends PluginSettingTab {
    private settingsManager: Settings;
    private plugin: Plugin;

    // Services
    private memoryService: MemoryService | undefined;
    private workspaceService: WorkspaceService | undefined;
    private customPromptStorage: CustomPromptStorageService | undefined;

    // Agents
    private searchManager: SearchManagerAgent | undefined;
    private memoryManager: MemoryManagerAgent | undefined;

    // Managers
    private serviceManager: ServiceManager | undefined;
    private pluginLifecycleManager: any;

    // UI Components
    private tabs: UnifiedTabs | undefined;
    private router: SettingsRouter;
    private unsubscribeRouter: (() => void) | undefined;

    // Tab instances
    private defaultsTab: DefaultsTab | undefined;
    private workspacesTab: WorkspacesTab | undefined;
    private promptsTab: PromptsTab | undefined;
    private providersTab: ProvidersTab | undefined;
    private getStartedTab: GetStartedTabType | undefined;
    // private dataTab: DataTab | undefined; // TODO: Re-enable when Data tab is ready

    // Prefetched data cache
    private prefetchedWorkspaces: any[] | null = null;
    private isPrefetching: boolean = false;

    constructor(
        app: App,
        plugin: Plugin,
        settingsManager: Settings,
        services?: {
            workspaceService?: WorkspaceService;
            memoryService?: MemoryService;
        },
        searchManager?: SearchManagerAgent,
        memoryManager?: MemoryManagerAgent,
        serviceManager?: ServiceManager,
        pluginLifecycleManager?: any
    ) {
        super(app, plugin);
        this.plugin = plugin;
        this.settingsManager = settingsManager;

        // Initialize services
        if (services) {
            this.memoryService = services.memoryService;
            this.workspaceService = services.workspaceService;
        }

        // Store agent references
        this.searchManager = searchManager;
        this.memoryManager = memoryManager;

        // Store managers
        this.serviceManager = serviceManager;
        this.pluginLifecycleManager = pluginLifecycleManager;

        // Initialize router
        this.router = new SettingsRouter();
    }

    /**
     * Update services when they become available
     */
    updateServices(services: {
        workspaceService?: WorkspaceService;
        memoryService?: MemoryService;
    }): void {
        this.memoryService = services.memoryService;
        this.workspaceService = services.workspaceService;

        // Refresh the UI
        this.display();
    }

    /**
     * Cleanup resources
     */
    cleanup(): void {
        if (this.unsubscribeRouter) {
            this.unsubscribeRouter();
        }
        this.router.destroy();
        if (this.tabs) {
            this.tabs.destroy();
        }
        // Cleanup tab instances
        this.defaultsTab?.destroy();
        this.workspacesTab?.destroy();
        this.promptsTab?.destroy();
        this.providersTab?.destroy();
        this.getStartedTab?.destroy();
        // Clear prefetch cache
        this.prefetchedWorkspaces = null;
    }

    /**
     * Prefetch workspaces data in the background
     * Called when settings are opened to reduce perceived load time
     */
    private async prefetchWorkspaces(): Promise<void> {
        if (this.isPrefetching || this.prefetchedWorkspaces !== null) {
            return; // Already prefetching or already cached
        }

        const services = this.getCurrentServices();
        if (!services.workspaceService) {
            return;
        }

        this.isPrefetching = true;
        try {
            this.prefetchedWorkspaces = await services.workspaceService.getAllWorkspaces();
        } catch (error) {
            console.error('[SettingsView] Failed to prefetch workspaces:', error);
            this.prefetchedWorkspaces = null;
        } finally {
            this.isPrefetching = false;
        }
    }

    /**
     * Main display method - renders the settings UI
     */
    display(): void {
        const { containerEl } = this;
        containerEl.empty();
        containerEl.addClass('nexus-settings');

        // Start prefetching workspaces in background (non-blocking)
        this.prefetchWorkspaces();

        // 1. Render header (About + Update button)
        this.renderHeader(containerEl);

        // 2. Create tabs
        const tabConfigs: UnifiedTabConfig[] = [
            { key: 'defaults', label: 'Defaults' },
            { key: 'workspaces', label: 'Workspaces' },
            { key: 'prompts', label: 'Prompts' },
            { key: 'providers', label: 'Providers' },
            // { key: 'data', label: 'Data' }, // TODO: Re-enable when Data tab is ready
        ];

        // Get Started tab is desktop-only (MCP setup requires Node.js)
        if (supportsMCPBridge()) {
            tabConfigs.push({ key: 'getstarted', label: 'Get Started' });
        }

        this.tabs = new UnifiedTabs({
            containerEl,
            tabs: tabConfigs,
            defaultTab: this.router.getState().tab,
            onTabChange: (tabKey) => {
                this.router.setTab(tabKey as SettingsTab);
            },
            component: this.plugin
        });

        // 3. Subscribe to router changes
        if (this.unsubscribeRouter) {
            this.unsubscribeRouter();
        }
        this.unsubscribeRouter = this.router.onNavigate((state) => {
            this.renderTabContent(state);
        });

        // 4. Render initial content
        this.renderTabContent(this.router.getState());
    }

    /**
     * Render the header section with About info and Update button
     */
    private renderHeader(containerEl: HTMLElement): void {
        const header = containerEl.createDiv('nexus-settings-header');

        // Title and description
        header.createEl('h2', { text: 'Nexus' });
        header.createEl('p', {
            text: 'AI-powered assistant for your Obsidian vault',
            cls: 'nexus-settings-desc'
        });

        // Version and update button
        const versionRow = header.createDiv('nexus-settings-version-row');

        versionRow.createSpan({
            text: `Version ${this.plugin.manifest.version}`,
            cls: 'nexus-settings-version'
        });

        // Update notification if available
        if (this.settingsManager.settings.availableUpdateVersion) {
            const updateBadge = versionRow.createSpan({ cls: 'nexus-update-badge' });
            updateBadge.setText(`Update available: v${this.settingsManager.settings.availableUpdateVersion}`);
        }

        // Update button
        const updateBtn = new ButtonComponent(versionRow);
        updateBtn
            .setButtonText(
                this.settingsManager.settings.availableUpdateVersion
                    ? `Install v${this.settingsManager.settings.availableUpdateVersion}`
                    : 'Check for Updates'
            )
            .onClick(async () => {
                await this.handleUpdateCheck(updateBtn);
            });
    }

    /**
     * Handle update check and installation
     */
    private async handleUpdateCheck(button: ButtonComponent): Promise<void> {
        button.setDisabled(true);
        try {
            const updateManager = new UpdateManager(this.plugin);
            const hasUpdate = await updateManager.checkForUpdate();

            this.settingsManager.settings.lastUpdateCheckDate = new Date().toISOString();

            if (hasUpdate) {
                const release = await (updateManager as unknown as UpdateManagerWithFetchRelease).fetchLatestRelease();
                const availableVersion = release.tag_name.replace('v', '');
                this.settingsManager.settings.availableUpdateVersion = availableVersion;

                await updateManager.updatePlugin();
                this.settingsManager.settings.availableUpdateVersion = undefined;
                this.display();
            } else {
                this.settingsManager.settings.availableUpdateVersion = undefined;
                new Notice('You are already on the latest version!');
            }

            await this.settingsManager.saveSettings();
            this.display();
        } catch (error) {
            new Notice(`Update failed: ${(error as Error).message}`);
        } finally {
            button.setDisabled(false);
        }
    }

    /**
     * Render content for the current tab based on router state
     */
    private renderTabContent(state: RouterState): void {
        if (!this.tabs) return;

        const pane = this.tabs.getTabContent(state.tab);
        if (!pane) return;

        pane.empty();

        // Get current service instances
        const services = this.getCurrentServices();

        switch (state.tab) {
            case 'defaults':
                this.renderDefaultsTab(pane, state, services);
                break;
            case 'workspaces':
                this.renderWorkspacesTab(pane, state, services);
                break;
            case 'prompts':
                this.renderPromptsTab(pane, state, services);
                break;
            case 'providers':
                this.renderProvidersTab(pane, state, services);
                break;
            // case 'data': // TODO: Re-enable when Data tab is ready
            //     this.renderDataTab(pane);
            //     break;
            case 'getstarted':
                this.renderGetStartedTab(pane, services);
                break;
        }
    }

    /**
     * Get current service instances from ServiceManager or stored references
     */
    private getCurrentServices(): {
        memoryService?: MemoryService;
        workspaceService?: WorkspaceService;
        customPromptStorage?: CustomPromptStorageService;
    } {
        let memoryService = this.memoryService;
        let workspaceService = this.workspaceService;

        if (this.serviceManager) {
            const memoryFromManager = this.serviceManager.getServiceIfReady('memoryService') as MemoryService | undefined;
            const workspaceFromManager = this.serviceManager.getServiceIfReady('workspaceService') as WorkspaceService | undefined;

            if (memoryFromManager) memoryService = memoryFromManager;
            if (workspaceFromManager) workspaceService = workspaceFromManager;
        }

        // Initialize custom prompt storage if needed
        if (!this.customPromptStorage) {
            this.customPromptStorage = new CustomPromptStorageService(this.settingsManager);
        }

        return {
            memoryService,
            workspaceService,
            customPromptStorage: this.customPromptStorage
        };
    }

    /**
     * Render Defaults tab content
     */
    private renderDefaultsTab(
        container: HTMLElement,
        state: RouterState,
        services: { workspaceService?: WorkspaceService; customPromptStorage?: CustomPromptStorageService }
    ): void {
        // Destroy previous tab instance if exists
        this.defaultsTab?.destroy();

        // Create new DefaultsTab
        this.defaultsTab = new DefaultsTab(
            container,
            this.router,
            {
                app: this.app,
                settings: this.settingsManager,
                llmProviderSettings: this.settingsManager.settings.llmProviders,
                workspaceService: services.workspaceService,
                customPromptStorage: services.customPromptStorage
            }
        );
    }

    /**
     * Render Workspaces tab content
     */
    private renderWorkspacesTab(
        container: HTMLElement,
        state: RouterState,
        services: { workspaceService?: WorkspaceService; memoryService?: MemoryService }
    ): void {
        // Destroy previous tab instance if exists
        this.workspacesTab?.destroy();

        // Create new WorkspacesTab with prefetched data if available
        this.workspacesTab = new WorkspacesTab(
            container,
            this.router,
            {
                app: this.app,
                workspaceService: services.workspaceService,
                customPromptStorage: this.customPromptStorage,
                prefetchedWorkspaces: this.prefetchedWorkspaces,
                component: this.plugin
            }
        );
    }

    /**
     * Render Prompts tab content
     */
    private renderPromptsTab(
        container: HTMLElement,
        state: RouterState,
        services: { customPromptStorage?: CustomPromptStorageService }
    ): void {
        // Destroy previous tab instance if exists
        this.promptsTab?.destroy();

        // Create new PromptsTab
        this.promptsTab = new PromptsTab(
            container,
            this.router,
            {
                customPromptStorage: services.customPromptStorage
            }
        );
    }

    /**
     * Render Providers tab content
     */
    private renderProvidersTab(
        container: HTMLElement,
        state: RouterState,
        services: any
    ): void {
        // Destroy previous tab instance if exists
        this.providersTab?.destroy();

        // Create new ProvidersTab
        this.providersTab = new ProvidersTab(
            container,
            this.router,
            {
                app: this.app,
                settings: this.settingsManager,
                llmProviderSettings: this.settingsManager.settings.llmProviders
            }
        );
    }

    // TODO: Re-enable when Data tab is ready
    // /**
    //  * Render Data tab content
    //  */
    // private renderDataTab(container: HTMLElement): void {
    //     if (!this.serviceManager) {
    //         container.createEl('div', { text: 'Service Manager not available.' });
    //         return;
    //     }
    //     this.dataTab = new DataTab(container, this.router, this.serviceManager);
    //     this.dataTab.render();
    // }

    /**
     * Render Get Started tab content
     * Uses dynamic import to avoid loading Node.js modules on mobile
     */
    private async renderGetStartedTab(container: HTMLElement, services: any): Promise<void> {
        // Desktop-only - don't render on mobile
        if (!supportsMCPBridge()) {
            container.createEl('p', { text: 'MCP setup is only available on desktop.' });
            return;
        }

        // Destroy previous tab instance if exists
        this.getStartedTab?.destroy();

        // Get plugin path for MCP config
        const vaultBasePath = this.getVaultBasePath();
        const pluginDir = this.plugin.manifest.dir;
        // Extract just the folder name in case manifest.dir contains a full path
        // (e.g., ".obsidian/plugins/claudesidian-mcp" instead of just "claudesidian-mcp")
        const pluginFolderName = pluginDir ? pluginDir.split('/').pop() || pluginDir : '';
        const pluginPath = vaultBasePath && pluginFolderName
            ? `${vaultBasePath}/.obsidian/plugins/${pluginFolderName}`
            : '';
        const vaultPath = vaultBasePath || '';

        // Dynamic import to avoid loading Node.js modules on mobile
        const { GetStartedTab } = await import('./tabs/GetStartedTab');

        // Create new GetStartedTab
        this.getStartedTab = new GetStartedTab(
            container,
            {
                app: this.app,
                pluginPath,
                vaultPath,
                onOpenProviders: () => {
                    this.router.setTab('providers');
                    if (this.tabs) {
                        this.tabs.activateTab('providers');
                    }
                },
                component: this.plugin
            }
        );
    }

    /**
     * Resolve vault base path when running on desktop FileSystemAdapter
     */
    private getVaultBasePath(): string | null {
        const adapter = this.app.vault.adapter;
        if (adapter instanceof FileSystemAdapter) {
            return adapter.getBasePath();
        }
        return null;
    }
}

```

## settings/tabs/DataTab.ts

```typescript
import { Setting, Notice, ButtonComponent } from 'obsidian';
import { SettingsRouter } from '../SettingsRouter';
import { IStorageAdapter } from '../../database/interfaces/IStorageAdapter';
import { ServiceManager } from '../../core/ServiceManager';

export class DataTab {
    private container: HTMLElement;
    private router: SettingsRouter;
    private serviceManager: ServiceManager;
    private storageAdapter: IStorageAdapter | null = null;

    constructor(container: HTMLElement, router: SettingsRouter, serviceManager: ServiceManager) {
        this.container = container;
        this.router = router;
        this.serviceManager = serviceManager;
    }

    async render(): Promise<void> {
        this.container.empty();
        this.container.addClass('nexus-settings-tab-content');

        // Header
        this.container.createEl('h3', { text: 'Data Management' });
        this.container.createEl('p', { 
            text: 'Manage your conversation data, exports, and backups.',
            cls: 'nexus-settings-desc'
        });

        // Initialize Storage Adapter
        await this.initStorageAdapter();

        // Export Section
        this.renderExportSection();
    }

    private async initStorageAdapter() {
        if (this.storageAdapter) return;

        try {
            // Try to get storageAdapter from ServiceManager
            // It might be registered as 'storageAdapter' or 'hybridStorage'
            // I'll try 'storageAdapter' first, then check if I can find it
            this.storageAdapter = await this.serviceManager.getService<IStorageAdapter>('storageAdapter');
        } catch (error) {
            console.error('Failed to initialize StorageAdapter:', error);
        }
    }

    private renderExportSection() {
        const section = this.container.createDiv('nexus-settings-section');
        section.createEl('h4', { text: 'Export' });

        new Setting(section)
            .setName('Export to ChatML')
            .setDesc('Export all conversations in ChatML JSONL format (compatible with OpenAI fine-tuning).')
            .addButton(button => button
                .setButtonText('Export Dataset')
                .setIcon('download')
                .onClick(async () => {
                    if (!this.storageAdapter) {
                        new Notice('Storage adapter not available. Please try again later.');
                        await this.initStorageAdapter();
                        return;
                    }

                    button.setButtonText('Exporting...').setDisabled(true);
                    try {
                        const jsonl = await this.storageAdapter.exportConversationsForFineTuning();
                        
                        // Create a download
                        const blob = new Blob([jsonl], { type: 'application/jsonl' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `nexus-export-${new Date().toISOString().slice(0, 10)}.jsonl`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        new Notice('Export complete!');
                    } catch (error) {
                        console.error('Export failed:', error);
                        new Notice('Export failed. Check console for details.');
                    } finally {
                        button.setButtonText('Export Dataset').setDisabled(false);
                    }
                }));
    }
}

```

## settings/tabs/DefaultsTab.ts

```typescript
/**
 * DefaultsTab - Default settings for new chats
 *
 * Uses ChatSettingsRenderer for identical UI to ChatSettingsModal.
 * Saves to plugin settings (defaults for all new chats).
 */

import { App } from 'obsidian';
import { SettingsRouter } from '../SettingsRouter';
import { LLMProviderSettings } from '../../types/llm/ProviderTypes';
import { Settings } from '../../settings';
import { WorkspaceService } from '../../services/WorkspaceService';
import { CustomPromptStorageService } from '../../agents/promptManager/services/CustomPromptStorageService';
import { ChatSettingsRenderer, ChatSettings } from '../../components/shared/ChatSettingsRenderer';

export interface DefaultsTabServices {
  app: App;
  settings: Settings;
  llmProviderSettings?: LLMProviderSettings;
  workspaceService?: WorkspaceService;
  customPromptStorage?: CustomPromptStorageService;
}

export class DefaultsTab {
  private container: HTMLElement;
  private router: SettingsRouter;
  private services: DefaultsTabServices;
  private renderer: ChatSettingsRenderer | null = null;

  constructor(
    container: HTMLElement,
    router: SettingsRouter,
    services: DefaultsTabServices
  ) {
    this.container = container;
    this.router = router;
    this.services = services;

    this.loadDataAndRender();
  }

  /**
   * Load workspaces and prompts, then render
   */
  private async loadDataAndRender(): Promise<void> {
    const workspaces = await this.loadWorkspaces();
    const prompts = this.loadPrompts();

    this.render(workspaces, prompts);
  }

  private async loadWorkspaces(): Promise<Array<{ id: string; name: string }>> {
    if (!this.services.workspaceService) return [];

    try {
      const workspaces = await this.services.workspaceService.getAllWorkspaces();
      return workspaces.map(w => ({ id: w.id, name: w.name }));
    } catch {
      return [];
    }
  }

  private loadPrompts(): Array<{ id: string; name: string }> {
    if (!this.services.customPromptStorage) return [];

    try {
      const prompts = this.services.customPromptStorage.getAllPrompts();
      return prompts.map(p => ({ id: p.name, name: p.name }));
    } catch {
      return [];
    }
  }

  /**
   * Get current defaults from settings
   */
  private getCurrentSettings(): ChatSettings {
    const llmSettings = this.services.llmProviderSettings;
    const pluginSettings = this.services.settings.settings;

    return {
      provider: llmSettings?.defaultModel?.provider || '',
      model: llmSettings?.defaultModel?.model || '',
      agentProvider: llmSettings?.agentModel?.provider || undefined,
      agentModel: llmSettings?.agentModel?.model || undefined,
      thinking: {
        enabled: llmSettings?.defaultThinking?.enabled ?? false,
        effort: llmSettings?.defaultThinking?.effort ?? 'medium'
      },
      temperature: llmSettings?.defaultTemperature ?? 0.5,
      imageProvider: llmSettings?.defaultImageModel?.provider || 'google',
      imageModel: llmSettings?.defaultImageModel?.model || 'gemini-2.5-flash-image',
      workspaceId: pluginSettings.defaultWorkspaceId || null,
      promptId: pluginSettings.defaultPromptId || null,
      contextNotes: pluginSettings.defaultContextNotes || []
    };
  }

  /**
   * Save settings to plugin
   */
  private async saveSettings(settings: ChatSettings): Promise<void> {
    const llmSettings = this.services.llmProviderSettings;
    const pluginSettings = this.services.settings.settings;

    if (llmSettings) {
      llmSettings.defaultModel = {
        provider: settings.provider,
        model: settings.model
      };
      // Save agent model (for executePrompt when using local chat model)
      if (settings.agentProvider && settings.agentModel) {
        llmSettings.agentModel = {
          provider: settings.agentProvider,
          model: settings.agentModel
        };
      } else {
        llmSettings.agentModel = undefined;
      }
      llmSettings.defaultThinking = {
        enabled: settings.thinking.enabled,
        effort: settings.thinking.effort
      };
      llmSettings.defaultTemperature = settings.temperature;
      llmSettings.defaultImageModel = {
        provider: settings.imageProvider,
        model: settings.imageModel
      };
      pluginSettings.llmProviders = llmSettings;
    }

    pluginSettings.defaultWorkspaceId = settings.workspaceId || undefined;
    pluginSettings.defaultPromptId = settings.promptId || undefined;
    pluginSettings.defaultContextNotes = settings.contextNotes;

    await this.services.settings.saveSettings();
  }

  /**
   * Main render method
   */
  private render(
    workspaces: Array<{ id: string; name: string }>,
    prompts: Array<{ id: string; name: string }>
  ): void {
    this.container.empty();

    if (!this.services.llmProviderSettings) {
      this.container.createEl('p', { text: 'Settings not available' });
      return;
    }

    // Header
    this.container.createEl('h2', { text: 'Defaults' });
    this.container.createEl('p', {
      text: 'These settings are used when starting a new chat.',
      cls: 'setting-item-description'
    });

    // Shared renderer
    const rendererContainer = this.container.createDiv('defaults-renderer');

    this.renderer = new ChatSettingsRenderer(rendererContainer, {
      app: this.services.app,
      llmProviderSettings: this.services.llmProviderSettings,
      initialSettings: this.getCurrentSettings(),
      options: { workspaces, prompts },
      callbacks: {
        onSettingsChange: (settings) => this.saveSettings(settings)
      }
    });

    this.renderer.render();
  }

  /**
   * Cleanup
   */
  destroy(): void {
    this.renderer = null;
  }
}

```

## settings/tabs/GetStartedTab.ts

```typescript
/**
 * GetStartedTab - Two setup paths and MCP configuration helper
 *
 * Features:
 * - Two setup paths: Internal Chat and MCP Integration
 * - Internal Chat: Configure providers, enable chat view
 * - MCP Integration: Zero-friction setup with one-click config
 * - Platform-specific config file paths
 * - Auto-detect and create Claude config
 */

import { App, Setting, Notice, Platform, Component } from 'obsidian';
import { BackButton } from '../components/BackButton';
import { BRAND_NAME, getPrimaryServerKey } from '../../constants/branding';
import * as path from 'path';
import * as fs from 'fs';

type GetStartedView = 'paths' | 'internal-chat' | 'mcp-setup';

export interface GetStartedTabServices {
    app: App;
    pluginPath: string;
    vaultPath: string;
    onOpenProviders: () => void;
    component?: Component;
}

export class GetStartedTab {
    private container: HTMLElement;
    private services: GetStartedTabServices;
    private currentView: GetStartedView = 'paths';

    constructor(
        container: HTMLElement,
        services: GetStartedTabServices
    ) {
        this.container = container;
        this.services = services;

        this.render();
    }

    /**
     * Main render method
     */
    render(): void {
        this.container.empty();

        switch (this.currentView) {
            case 'paths':
                this.renderPathsView();
                break;
            case 'internal-chat':
                this.renderInternalChatSetup();
                break;
            case 'mcp-setup':
                this.renderMCPSetup();
                break;
        }
    }

    /**
     * Render the initial two-path view
     */
    private renderPathsView(): void {
        this.container.createEl('h3', { text: 'How would you like to use Nexus?' });

        const paths = this.container.createDiv('nexus-setup-paths');

        // Path 1: Internal Chat
        const chatPath = paths.createDiv('nexus-setup-path');
        chatPath.createDiv('nexus-setup-path-icon').setText('ðŸ’¬');
        chatPath.createDiv('nexus-setup-path-title').setText('Internal Chat');
        chatPath.createDiv('nexus-setup-path-desc').setText('Use Nexus directly inside Obsidian');
        const chatClickHandler = () => {
            this.currentView = 'internal-chat';
            this.render();
        };
        this.services.component!.registerDomEvent(chatPath, 'click', chatClickHandler);

        // Path 2: MCP Integration
        const mcpPath = paths.createDiv('nexus-setup-path');
        mcpPath.createDiv('nexus-setup-path-icon').setText('ðŸ”—');
        mcpPath.createDiv('nexus-setup-path-title').setText('MCP Integration');
        mcpPath.createDiv('nexus-setup-path-desc').setText('Connect Claude Desktop, LM Studio, etc.');
        const mcpClickHandler = () => {
            this.currentView = 'mcp-setup';
            this.render();
        };
        this.services.component!.registerDomEvent(mcpPath, 'click', mcpClickHandler);
    }

    /**
     * Render Internal Chat setup view
     */
    private renderInternalChatSetup(): void {
        new BackButton(this.container, 'Back', () => {
            this.currentView = 'paths';
            this.render();
        }, this.services.component);

        this.container.createEl('h3', { text: 'Internal Chat Setup' });
        this.container.createEl('p', {
            text: 'Use Nexus as an AI chat assistant directly in Obsidian.',
            cls: 'setting-item-description'
        });

        // Step 1: Configure a provider
        const step1 = this.container.createDiv('nexus-setup-step');
        step1.createEl('h4', { text: 'Step 1: Configure an LLM Provider' });
        step1.createEl('p', {
            text: 'You need at least one LLM provider configured to use the chat.',
            cls: 'setting-item-description'
        });

        new Setting(step1)
            .addButton(btn => btn
                .setButtonText('Configure Providers')
                .setCta()
                .onClick(() => {
                    this.services.onOpenProviders();
                }));

        // Step 2: Open chat view
        const step2 = this.container.createDiv('nexus-setup-step');
        step2.createEl('h4', { text: 'Step 2: Open the Chat View' });
        step2.createEl('p', {
            text: 'Once a provider is configured, you can open the chat view:',
            cls: 'setting-item-description'
        });

        const instructions = step2.createEl('ul', { cls: 'nexus-setup-instructions' });
        instructions.createEl('li', { text: 'Click the chat icon in the left ribbon' });
        instructions.createEl('li', { text: 'Or use the command palette: "Nexus: Open Chat"' });
        instructions.createEl('li', { text: 'Or use the hotkey: Ctrl/Cmd + Shift + C' });

        // Step 3: Start chatting
        const step3 = this.container.createDiv('nexus-setup-step');
        step3.createEl('h4', { text: 'Step 3: Start Chatting!' });
        step3.createEl('p', {
            text: 'Your AI assistant has full access to your vault. Ask questions, take notes, and get help with your writing.',
            cls: 'setting-item-description'
        });
    }

    /**
     * Render MCP Integration setup view
     */
    private renderMCPSetup(): void {
        new BackButton(this.container, 'Back', () => {
            this.currentView = 'paths';
            this.render();
        }, this.services.component);

        this.container.createEl('h3', { text: 'Claude Desktop Setup' });

        const configPath = this.getClaudeDesktopConfigPath();
        const configDir = path.dirname(configPath);
        const configStatus = this.checkConfigStatus(configPath, configDir);

        // Compact status + action in one row
        if (configStatus === 'no-claude-folder') {
            // Claude not installed - show inline warning with action
            const row = this.container.createDiv('nexus-mcp-row');
            row.createEl('span', {
                text: 'âš ï¸ Claude Desktop not found',
                cls: 'nexus-mcp-status nexus-mcp-warning'
            });

            const actions = row.createDiv('nexus-mcp-actions');
            const downloadBtn = actions.createEl('button', { text: 'Download', cls: 'mod-cta' });
            const downloadHandler = () => window.open('https://claude.ai/download', '_blank');
            this.services.component!.registerDomEvent(downloadBtn, 'click', downloadHandler);

            const refreshBtn = actions.createEl('button', { text: 'Refresh' });
            const refreshHandler = () => this.render();
            this.services.component!.registerDomEvent(refreshBtn, 'click', refreshHandler);

            // Help text below
            this.container.createEl('p', {
                text: 'Install Claude Desktop, open it once, then enable Settings â†’ Developer â†’ MCP Servers',
                cls: 'nexus-mcp-help'
            });
        } else if (configStatus === 'nexus-configured') {
            // Already configured - success state
            const row = this.container.createDiv('nexus-mcp-row');
            row.createEl('span', {
                text: 'âœ“ Connected',
                cls: 'nexus-mcp-status nexus-mcp-success'
            });

            const actions = row.createDiv('nexus-mcp-actions');
            const openBtn = actions.createEl('button', { text: 'Open Config' });
            const openHandler = () => this.openConfigFile(configPath);
            this.services.component!.registerDomEvent(openBtn, 'click', openHandler);

            const revealBtn = actions.createEl('button', { text: this.getRevealButtonText() });
            const revealHandler = () => this.revealInFolder(configPath);
            this.services.component!.registerDomEvent(revealBtn, 'click', revealHandler);

            this.container.createEl('p', {
                text: 'Restart Claude Desktop if you haven\'t already.',
                cls: 'nexus-mcp-help'
            });
        } else {
            // Ready to configure
            const row = this.container.createDiv('nexus-mcp-row');
            row.createEl('span', {
                text: configStatus === 'no-config-file' ? 'Ready to configure' : 'Claude Desktop found',
                cls: 'nexus-mcp-status'
            });

            const actions = row.createDiv('nexus-mcp-actions');
            const configBtn = actions.createEl('button', { text: 'Add Nexus to Claude', cls: 'mod-cta' });
            const configHandler = () => this.autoConfigureNexus(configPath);
            this.services.component!.registerDomEvent(configBtn, 'click', configHandler);
        }
    }

    /**
     * Check the status of the Claude config
     */
    private checkConfigStatus(configPath: string, configDir: string): 'no-claude-folder' | 'no-config-file' | 'nexus-configured' | 'config-exists' {
        try {
            // Check if Claude folder exists
            if (!fs.existsSync(configDir)) {
                return 'no-claude-folder';
            }

            // Check if config file exists
            if (!fs.existsSync(configPath)) {
                return 'no-config-file';
            }

            // Check if Nexus is already configured
            const content = fs.readFileSync(configPath, 'utf-8');
            const config = JSON.parse(content);
            const vaultName = this.services.app.vault.getName();
            const serverKey = getPrimaryServerKey(vaultName);

            if (config.mcpServers && config.mcpServers[serverKey]) {
                return 'nexus-configured';
            }

            return 'config-exists';
        } catch (error) {
            console.error('[GetStartedTab] Error checking config status:', error);
            return 'no-claude-folder';
        }
    }

    /**
     * Auto-configure Nexus in Claude Desktop config
     */
    private async autoConfigureNexus(configPath: string): Promise<void> {
        try {
            let config: any = { mcpServers: {} };

            // Read existing config if it exists
            if (fs.existsSync(configPath)) {
                const content = fs.readFileSync(configPath, 'utf-8');
                try {
                    config = JSON.parse(content);
                    if (!config.mcpServers) {
                        config.mcpServers = {};
                    }
                } catch (e) {
                    // Invalid JSON, start fresh but warn user
                    new Notice('Existing config was invalid JSON. Creating new config.');
                    config = { mcpServers: {} };
                }
            }

            // Add Nexus server config
            const vaultName = this.services.app.vault.getName();
            const serverKey = getPrimaryServerKey(vaultName);
            const connectorPath = path.normalize(path.join(this.services.pluginPath, 'connector.js'));

            config.mcpServers[serverKey] = {
                command: 'node',
                args: [connectorPath]
            };

            // Ensure directory exists
            const configDir = path.dirname(configPath);
            if (!fs.existsSync(configDir)) {
                fs.mkdirSync(configDir, { recursive: true });
            }

            // Write config
            fs.writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf-8');

            new Notice('âœ… Nexus has been added to Claude Desktop config! Please restart Claude Desktop.');

            // Re-render to show updated status
            this.render();
        } catch (error) {
            console.error('[GetStartedTab] Error auto-configuring:', error);
            new Notice(`Failed to configure: ${(error as Error).message}`);
        }
    }

    /**
     * Open the config file in the default editor
     */
    private openConfigFile(configPath: string): void {
        try {
            // Use Electron's shell to open the file
            const { shell } = require('electron');
            shell.openPath(configPath);
        } catch (error) {
            console.error('[GetStartedTab] Error opening config file:', error);
            new Notice('Failed to open config file. Please open it manually.');
        }
    }

    /**
     * Reveal the config file in the system file manager
     */
    private revealInFolder(configPath: string): void {
        try {
            const { shell } = require('electron');
            shell.showItemInFolder(configPath);
        } catch (error) {
            console.error('[GetStartedTab] Error revealing in folder:', error);
            new Notice('Failed to reveal in folder. Please navigate manually.');
        }
    }

    /**
     * Get OS-specific text for the reveal button
     */
    private getRevealButtonText(): string {
        if (Platform.isWin) {
            return 'Reveal in Explorer';
        } else if (Platform.isMacOS) {
            return 'Reveal in Finder';
        } else {
            return 'Reveal in Files';
        }
    }

    /**
     * Get Claude Desktop config file path based on platform
     */
    private getClaudeDesktopConfigPath(): string {
        if (Platform.isWin) {
            return path.join(process.env.APPDATA || '', 'Claude', 'claude_desktop_config.json');
        } else if (Platform.isMacOS) {
            return path.join(process.env.HOME || '', 'Library', 'Application Support', 'Claude', 'claude_desktop_config.json');
        } else {
            // Linux
            return path.join(process.env.HOME || '', '.config', 'Claude', 'claude_desktop_config.json');
        }
    }

    /**
     * Cleanup
     */
    destroy(): void {
        // No resources to clean up
    }
}

```

## settings/tabs/PromptsTab.ts

```typescript
/**
 * PromptsTab - Custom prompts list and detail view
 *
 * Features:
 * - List view showing all custom prompts with status badges
 * - Detail view for editing prompt configuration
 * - Create/Edit/Delete prompts
 * - Auto-save on all changes
 */

import { Notice, TextComponent, TextAreaComponent, ButtonComponent } from 'obsidian';
import { SettingsRouter } from '../SettingsRouter';
import { BackButton } from '../components/BackButton';
import { CustomPrompt } from '../../types/mcp/CustomPromptTypes';
import { CustomPromptStorageService } from '../../agents/promptManager/services/CustomPromptStorageService';
import { CardManager, CardItem } from '../../components/CardManager';

export interface PromptsTabServices {
    customPromptStorage?: CustomPromptStorageService;
}

type PromptsView = 'list' | 'detail';

export class PromptsTab {
    private container: HTMLElement;
    private router: SettingsRouter;
    private services: PromptsTabServices;
    private prompts: CustomPrompt[] = [];
    private currentPrompt: Partial<CustomPrompt> | null = null;
    private currentView: PromptsView = 'list';
    private isNewPrompt: boolean = false;

    // Auto-save debounce
    private saveTimeout?: ReturnType<typeof setTimeout>;

    // Card manager for list view
    private cardManager?: CardManager<CardItem>;

    constructor(
        container: HTMLElement,
        router: SettingsRouter,
        services: PromptsTabServices
    ) {
        this.container = container;
        this.router = router;
        this.services = services;

        this.loadPrompts();
        this.render();
    }

    /**
     * Load prompts from storage service
     */
    private loadPrompts(): void {
        if (!this.services.customPromptStorage) return;
        this.prompts = this.services.customPromptStorage.getAllPrompts();
    }

    /**
     * Main render method
     */
    render(): void {
        this.container.empty();

        const state = this.router.getState();

        // Check router state for navigation
        if (state.view === 'detail' && state.detailId) {
            this.currentView = 'detail';
            const prompt = this.prompts.find(p => p.id === state.detailId);
            if (prompt) {
                this.currentPrompt = { ...prompt };
                this.isNewPrompt = false;
                this.renderDetail();
                return;
            }
        }

        // Default to list view
        this.currentView = 'list';
        this.renderList();
    }

    /**
     * Render list view using CardManager
     */
    private renderList(): void {
        this.container.empty();

        // Header
        this.container.createEl('h3', { text: 'Custom Prompts' });
        this.container.createEl('p', {
            text: 'Create specialized prompts with custom system instructions',
            cls: 'setting-item-description'
        });

        // Check if service is available
        if (!this.services.customPromptStorage) {
            this.container.createEl('p', {
                text: 'Prompt service is initializing...',
                cls: 'nexus-loading-message'
            });
            return;
        }

        // Convert prompts to CardItem format
        const cardItems: CardItem[] = this.prompts.map(prompt => ({
            id: prompt.id,
            name: prompt.name,
            description: prompt.description || 'No description',
            isEnabled: prompt.isEnabled
        }));

        // Create card manager
        this.cardManager = new CardManager({
            containerEl: this.container,
            title: 'Custom Prompts',
            addButtonText: '+ New Prompt',
            emptyStateText: 'No custom prompts yet. Create one to get started.',
            items: cardItems,
            showToggle: true,
            onAdd: () => this.createNewPrompt(),
            onToggle: async (item, enabled) => {
                const prompt = this.prompts.find(p => p.id === item.id);
                if (prompt && this.services.customPromptStorage) {
                    await this.services.customPromptStorage.updatePrompt(item.id, { isEnabled: enabled });
                    prompt.isEnabled = enabled;
                }
            },
            onEdit: (item) => {
                this.router.showDetail(item.id);
            },
            onDelete: async (item) => {
                const confirmed = confirm(`Delete prompt "${item.name}"? This cannot be undone.`);
                if (!confirmed) return;

                try {
                    if (this.services.customPromptStorage) {
                        await this.services.customPromptStorage.deletePrompt(item.id);
                        this.prompts = this.prompts.filter(p => p.id !== item.id);
                        this.cardManager?.updateItems(this.prompts.map(p => ({
                            id: p.id,
                            name: p.name,
                            description: p.description || 'No description',
                            isEnabled: p.isEnabled
                        })));
                        new Notice('Prompt deleted');
                    }
                } catch (error) {
                    console.error('[PromptsTab] Failed to delete prompt:', error);
                    new Notice('Failed to delete prompt');
                }
            }
        });
    }

    /**
     * Render detail view
     */
    private renderDetail(): void {
        this.container.empty();

        const prompt = this.currentPrompt;
        if (!prompt) {
            this.router.back();
            return;
        }

        // Back button
        new BackButton(this.container, 'Back to Prompts', () => {
            this.saveCurrentPrompt();
            this.router.back();
        });

        // Form container with modern stacked layout
        const form = this.container.createDiv('nexus-modern-form');

        // Name field
        const nameField = form.createDiv('nexus-form-field');
        nameField.createEl('label', { text: 'Name', cls: 'nexus-form-label' });
        const nameInput = new TextComponent(nameField);
        nameInput.setPlaceholder('e.g., Code Reviewer');
        nameInput.setValue(prompt.name || '');
        nameInput.onChange((value) => {
            prompt.name = value;
            this.debouncedSave();
        });

        // Description field
        const descField = form.createDiv('nexus-form-field');
        descField.createEl('label', { text: 'Description', cls: 'nexus-form-label' });
        descField.createEl('span', {
            text: 'A brief description of what this prompt does',
            cls: 'nexus-form-hint'
        });
        const descInput = new TextAreaComponent(descField);
        descInput.setPlaceholder('e.g., Reviews code for best practices and potential issues');
        descInput.setValue(prompt.description || '');
        descInput.onChange((value) => {
            prompt.description = value;
            this.debouncedSave();
        });

        // System Prompt field
        const promptField = form.createDiv('nexus-form-field');
        promptField.createEl('label', { text: 'System Prompt', cls: 'nexus-form-label' });
        promptField.createEl('span', {
            text: 'Instructions that define this prompt\'s behavior and expertise',
            cls: 'nexus-form-hint'
        });
        const promptInput = new TextAreaComponent(promptField);
        promptInput.setPlaceholder('You are an expert code reviewer. When reviewing code, focus on...');
        promptInput.setValue(prompt.prompt || '');
        promptInput.onChange((value) => {
            prompt.prompt = value;
            this.debouncedSave();
        });
        // Make the system prompt textarea larger
        promptInput.inputEl.rows = 8;
        promptInput.inputEl.addClass('nexus-form-textarea-large');

        // Action buttons
        const actions = form.createDiv('nexus-form-actions');

        new ButtonComponent(actions)
            .setButtonText('Save')
            .setCta()
            .onClick(async () => {
                // Cancel any pending debounced save to prevent double-save
                if (this.saveTimeout) {
                    clearTimeout(this.saveTimeout);
                    this.saveTimeout = undefined;
                }
                await this.saveCurrentPrompt();
                new Notice('Prompt saved');
                this.router.back();
            });

        if (!this.isNewPrompt && prompt.id) {
            new ButtonComponent(actions)
                .setButtonText('Delete')
                .setWarning()
                .onClick(() => this.deleteCurrentPrompt());
        }
    }

    /**
     * Create a new prompt
     */
    private createNewPrompt(): void {
        this.currentPrompt = {
            name: '',
            description: '',
            prompt: '',
            isEnabled: true
        };
        this.isNewPrompt = true;
        this.currentView = 'detail';
        this.renderDetail();
    }

    /**
     * Save the current prompt
     */
    private async saveCurrentPrompt(): Promise<void> {
        if (!this.currentPrompt || !this.services.customPromptStorage) return;

        // Validate required fields
        if (!this.currentPrompt.name?.trim()) {
            new Notice('Prompt name is required');
            return;
        }

        try {
            if (this.isNewPrompt) {
                // Create new prompt
                const created = await this.services.customPromptStorage.createPrompt({
                    name: this.currentPrompt.name,
                    description: this.currentPrompt.description || '',
                    prompt: this.currentPrompt.prompt || '',
                    isEnabled: this.currentPrompt.isEnabled ?? true
                });
                this.prompts.push(created);
                this.currentPrompt = created;
                this.isNewPrompt = false;
            } else if (this.currentPrompt.id) {
                // Update existing prompt
                await this.services.customPromptStorage.updatePrompt(
                    this.currentPrompt.id,
                    {
                        name: this.currentPrompt.name,
                        description: this.currentPrompt.description,
                        prompt: this.currentPrompt.prompt,
                        isEnabled: this.currentPrompt.isEnabled
                    }
                );
                // Update local cache
                const index = this.prompts.findIndex(p => p.id === this.currentPrompt?.id);
                if (index >= 0) {
                    this.prompts[index] = this.currentPrompt as CustomPrompt;
                }
            }
        } catch (error) {
            console.error('[PromptsTab] Failed to save prompt:', error);
            new Notice(`Failed to save prompt: ${(error as Error).message}`);
        }
    }

    /**
     * Delete the current prompt
     */
    private async deleteCurrentPrompt(): Promise<void> {
        if (!this.currentPrompt?.id || !this.services.customPromptStorage) return;

        const confirmed = confirm(`Delete prompt "${this.currentPrompt.name}"? This cannot be undone.`);
        if (!confirmed) return;

        try {
            await this.services.customPromptStorage.deletePrompt(this.currentPrompt.id);
            this.prompts = this.prompts.filter(p => p.id !== this.currentPrompt?.id);
            this.currentPrompt = null;
            this.router.back();
            new Notice('Prompt deleted');
        } catch (error) {
            console.error('[PromptsTab] Failed to delete prompt:', error);
            new Notice('Failed to delete prompt');
        }
    }

    /**
     * Debounced auto-save
     */
    private debouncedSave(): void {
        if (this.saveTimeout) {
            clearTimeout(this.saveTimeout);
        }

        this.saveTimeout = setTimeout(() => {
            this.saveCurrentPrompt();
        }, 500);
    }

    /**
     * Cleanup
     */
    destroy(): void {
        if (this.saveTimeout) {
            clearTimeout(this.saveTimeout);
        }
    }
}

```

## settings/tabs/ProvidersTab.ts

```typescript
/**
 * ProvidersTab - LLM providers configuration
 *
 * Features:
 * - Grouped provider list (Local vs Cloud)
 * - Status badges (configured/not configured)
 * - Detail view opens LLMProviderModal
 * - Auto-save on all changes
 *
 * Note: Default provider/model/thinking settings moved to DefaultsTab
 */

import { App, Notice } from 'obsidian';
import { SettingsRouter } from '../SettingsRouter';
import { LLMProviderSettings, LLMProviderConfig } from '../../types/llm/ProviderTypes';
import { LLMProviderModal, LLMProviderModalConfig } from '../../components/LLMProviderModal';
import { LLMProviderManager } from '../../services/llm/providers/ProviderManager';
import { Settings } from '../../settings';
import { Card, CardConfig } from '../../components/Card';
import { LLMSettingsNotifier } from '../../services/llm/LLMSettingsNotifier';
import { isDesktop, supportsLocalLLM, MOBILE_COMPATIBLE_PROVIDERS } from '../../utils/platform';

/**
 * Provider display configuration
 */
interface ProviderDisplayConfig {
    name: string;
    keyFormat: string;
    signupUrl: string;
    category: 'local' | 'cloud';
}

export interface ProvidersTabServices {
    app: App;
    settings: Settings;
    llmProviderSettings?: LLMProviderSettings;
}

export class ProvidersTab {
    private container: HTMLElement;
    private router: SettingsRouter;
    private services: ProvidersTabServices;
    private providerManager: LLMProviderManager;

    // Provider configurations
    private readonly providerConfigs: Record<string, ProviderDisplayConfig> = {
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // NEXUS/WEBLLM (Re-enabled Dec 2025)
        // Local LLM inference via WebGPU - Nexus models are fine-tuned on toolset
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        webllm: {
            name: 'Nexus (Local)',
            keyFormat: 'No API key required',
            signupUrl: '',
            category: 'local'
        },
        // Local providers
        ollama: {
            name: 'Ollama',
            keyFormat: 'http://127.0.0.1:11434',
            signupUrl: 'https://ollama.com/download',
            category: 'local'
        },
        lmstudio: {
            name: 'LM Studio',
            keyFormat: 'http://127.0.0.1:1234',
            signupUrl: 'https://lmstudio.ai',
            category: 'local'
        },
        // Cloud providers
        openai: {
            name: 'OpenAI',
            keyFormat: 'sk-proj-...',
            signupUrl: 'https://platform.openai.com/api-keys',
            category: 'cloud'
        },
        anthropic: {
            name: 'Anthropic',
            keyFormat: 'sk-ant-...',
            signupUrl: 'https://console.anthropic.com/login',
            category: 'cloud'
        },
        google: {
            name: 'Google AI',
            keyFormat: 'AIza...',
            signupUrl: 'https://aistudio.google.com/app/apikey',
            category: 'cloud'
        },
        mistral: {
            name: 'Mistral AI',
            keyFormat: 'msak_...',
            signupUrl: 'https://console.mistral.ai/api-keys',
            category: 'cloud'
        },
        groq: {
            name: 'Groq',
            keyFormat: 'gsk_...',
            signupUrl: 'https://console.groq.com/keys',
            category: 'cloud'
        },
        openrouter: {
            name: 'OpenRouter',
            keyFormat: 'sk-or-...',
            signupUrl: 'https://openrouter.ai/keys',
            category: 'cloud'
        },
        requesty: {
            name: 'Requesty',
            keyFormat: 'req_...',
            signupUrl: 'https://requesty.com/api-keys',
            category: 'cloud'
        },
        perplexity: {
            name: 'Perplexity',
            keyFormat: 'pplx-...',
            signupUrl: 'https://www.perplexity.ai/settings/api',
            category: 'cloud'
        }
    };

    constructor(
        container: HTMLElement,
        router: SettingsRouter,
        services: ProvidersTabServices
    ) {
        this.container = container;
        this.router = router;
        this.services = services;

        // Initialize provider manager with vault for local provider support
        if (this.services.llmProviderSettings) {
            this.providerManager = new LLMProviderManager(this.services.llmProviderSettings, this.services.app.vault);
        } else {
            this.providerManager = new LLMProviderManager({
                providers: {},
                defaultModel: { provider: '', model: '' }
            }, this.services.app.vault);
        }

        this.render();
    }

    /**
     * Get current LLM settings
     */
    private getSettings(): LLMProviderSettings {
        return this.services.llmProviderSettings || {
            providers: {},
            defaultModel: { provider: '', model: '' }
        };
    }

    /**
     * Save settings and notify subscribers
     */
    private async saveSettings(): Promise<void> {
        if (this.services.settings && this.services.llmProviderSettings) {
            this.services.settings.settings.llmProviders = this.services.llmProviderSettings;
            await this.services.settings.saveSettings();

            // Notify all subscribers of the settings change
            LLMSettingsNotifier.notify(this.services.llmProviderSettings);
        }
    }

    /**
     * Main render method
     */
    render(): void {
        this.container.empty();

        // Provider groups only - defaults moved to DefaultsTab
        this.renderProviderGroups();
    }

    /**
     * Render provider groups (Local and Cloud)
     */
    private renderProviderGroups(): void {
        const settings = this.getSettings();

        // Mobile: Only fetch-based providers work (no Node.js/Electron SDKs)
        if (!isDesktop()) {
            this.container.createEl('p', {
                cls: 'setting-item-description',
                text: 'On mobile, only OpenRouter, Requesty, and Perplexity are supported. Configure local providers and SDK-based providers on desktop.'
            });
            this.container.createDiv('nexus-provider-group-title').setText('MOBILE PROVIDERS');
            this.renderProviderList([...MOBILE_COMPATIBLE_PROVIDERS], settings);
            return;
        }

        // Desktop: Local providers (require localhost servers or WebGPU)
        if (supportsLocalLLM()) {
            this.container.createDiv('nexus-provider-group-title').setText('LOCAL PROVIDERS');
            this.renderProviderList(['webllm', 'ollama', 'lmstudio'], settings);
        }

        // Desktop: Cloud providers (SDK + fetch-based)
        this.container.createDiv('nexus-provider-group-title').setText('CLOUD PROVIDERS');
        this.renderProviderList(
            ['openai', 'anthropic', 'google', 'mistral', 'groq', 'openrouter', 'requesty', 'perplexity'],
            settings
        );
    }

    /**
     * Render a list of providers as cards
     */
    private renderProviderList(providerIds: string[], settings: LLMProviderSettings): void {
        const grid = this.container.createDiv('card-manager-grid');

        providerIds.forEach(providerId => {
            const displayConfig = this.providerConfigs[providerId];
            if (!displayConfig) return;

            const providerConfig = settings.providers[providerId] || {
                apiKey: '',
                enabled: false
            };

            const isConfigured = this.isProviderConfigured(providerId, providerConfig);

            // Create card for this provider
            const cardConfig: CardConfig = {
                title: displayConfig.name,
                description: isConfigured ? 'Configured' : 'Not configured',
                isEnabled: providerConfig.enabled,
                showToggle: true,
                onToggle: async (enabled: boolean) => {
                    settings.providers[providerId] = {
                        ...providerConfig,
                        enabled
                    };
                    await this.saveSettings();
                    this.render(); // Re-render to update defaults dropdown
                },
                onEdit: () => {
                    this.openProviderModal(providerId, displayConfig, providerConfig);
                }
            };

            new Card(grid, cardConfig);
        });
    }

    /**
     * Check if a provider is configured
     */
    private isProviderConfigured(providerId: string, config: LLMProviderConfig): boolean {
        if (!config.enabled) return false;
        // WebLLM doesn't need an API key
        if (providerId === 'webllm') return true;
        // Other providers need an API key
        return !!config.apiKey;
    }

    /**
     * Open provider configuration modal
     */
    private openProviderModal(
        providerId: string,
        displayConfig: ProviderDisplayConfig,
        providerConfig: LLMProviderConfig
    ): void {
        const settings = this.getSettings();

        const modalConfig: LLMProviderModalConfig = {
            providerId,
            providerName: displayConfig.name,
            keyFormat: displayConfig.keyFormat,
            signupUrl: displayConfig.signupUrl,
            config: { ...providerConfig },
            onSave: async (updatedConfig: LLMProviderConfig) => {
                settings.providers[providerId] = updatedConfig;

                // Handle Ollama model update
                if (providerId === 'ollama' && '__ollamaModel' in updatedConfig) {
                    const ollamaModel = (updatedConfig as LLMProviderConfig & { __ollamaModel: string }).__ollamaModel;
                    if (ollamaModel) {
                        delete (updatedConfig as LLMProviderConfig & { __ollamaModel?: string }).__ollamaModel;
                        if (settings.defaultModel.provider === 'ollama') {
                            settings.defaultModel.model = ollamaModel;
                        }
                    }
                }

                await this.saveSettings();
                this.render(); // Refresh the view
                new Notice(`${displayConfig.name} settings saved`);
            }
        };

        new LLMProviderModal(this.services.app, modalConfig, this.providerManager).open();
    }

    /**
     * Cleanup
     */
    destroy(): void {
        // No resources to clean up
    }
}

```

## settings/tabs/WorkspacesTab.ts

```typescript
/**
 * WorkspacesTab - Workspace list and detail view
 *
 * Features:
 * - List view showing all workspaces with status badges
 * - Detail view with 3 sub-tabs (Basic Info, Context, Agent & Files)
 * - Workflow editing with dedicated view
 * - Auto-save on all changes
 */

import { App, Setting, Notice, ButtonComponent, Component } from 'obsidian';
import { SettingsRouter, RouterState } from '../SettingsRouter';
import { BackButton } from '../components/BackButton';
import { WorkspaceFormRenderer } from '../../components/workspace/WorkspaceFormRenderer';
import { WorkflowEditorRenderer, Workflow } from '../../components/workspace/WorkflowEditorRenderer';
import { FilePickerRenderer } from '../../components/workspace/FilePickerRenderer';
import { ProjectWorkspace } from '../../database/workspace-types';
import { WorkspaceService } from '../../services/WorkspaceService';
import { CustomPromptStorageService } from '../../agents/promptManager/services/CustomPromptStorageService';
import { CustomPrompt } from '../../types/mcp/CustomPromptTypes';
import { CardManager, CardItem } from '../../components/CardManager';
import { v4 as uuidv4 } from '../../utils/uuid';

export interface WorkspacesTabServices {
    app: App;
    workspaceService?: WorkspaceService;
    customPromptStorage?: CustomPromptStorageService;
    prefetchedWorkspaces?: ProjectWorkspace[] | null;
    component?: Component;
}

type WorkspacesView = 'list' | 'detail' | 'workflow' | 'filepicker';

export class WorkspacesTab {
    private container: HTMLElement;
    private router: SettingsRouter;
    private services: WorkspacesTabServices;
    private workspaces: ProjectWorkspace[] = [];
    private currentWorkspace: Partial<ProjectWorkspace> | null = null;
    private currentWorkflowIndex: number = -1;
    private currentFileIndex: number = -1;
    private currentView: WorkspacesView = 'list';

    // Renderers
    private formRenderer?: WorkspaceFormRenderer;
    private workflowRenderer?: WorkflowEditorRenderer;
    private filePickerRenderer?: FilePickerRenderer;

    // Auto-save debounce
    private saveTimeout?: ReturnType<typeof setTimeout>;

    // Card manager for list view
    private cardManager?: CardManager<CardItem>;

    // Loading state
    private isLoading: boolean = true;

    constructor(
        container: HTMLElement,
        router: SettingsRouter,
        services: WorkspacesTabServices
    ) {
        this.container = container;
        this.router = router;
        this.services = services;

        // Check if we have prefetched data (array, even if empty)
        if (Array.isArray(services.prefetchedWorkspaces)) {
            // Use prefetched data - no loading needed
            this.workspaces = services.prefetchedWorkspaces;
            this.isLoading = false;
            this.render();
        } else {
            // Render immediately with loading state
            this.render();

            // Load data in background
            this.loadWorkspaces().then(() => {
                this.isLoading = false;
                this.render();
            });
        }
    }

    /**
     * Load workspaces from service
     */
    private async loadWorkspaces(): Promise<void> {
        if (!this.services.workspaceService) return;

        try {
            this.workspaces = await this.services.workspaceService.getAllWorkspaces();
        } catch (error) {
            console.error('[WorkspacesTab] Failed to load workspaces:', error);
            this.workspaces = [];
        }
    }

    /**
     * Main render method
     */
    render(): void {
        this.container.empty();

        const state = this.router.getState();

        // Check router state for navigation
        if (state.view === 'detail' && state.detailId) {
            this.currentView = 'detail';
            const workspace = this.workspaces.find(w => w.id === state.detailId);
            if (workspace) {
                this.currentWorkspace = { ...workspace };
                this.renderDetail();
                return;
            }
        }

        // Default to list view
        this.currentView = 'list';
        this.renderList();
    }

    /**
     * Render list view using CardManager
     */
    private renderList(): void {
        this.container.empty();

        // Header
        this.container.createEl('h3', { text: 'Workspaces' });
        this.container.createEl('p', {
            text: 'Organize your vault into focused workspaces',
            cls: 'setting-item-description'
        });

        // Show loading skeleton while loading
        if (this.isLoading) {
            this.renderLoadingSkeleton();
            return;
        }

        // Check if service is available
        if (!this.services.workspaceService) {
            this.container.createEl('p', {
                text: 'Workspace service is initializing...',
                cls: 'nexus-loading-message'
            });
            return;
        }

        // Convert workspaces to CardItem format
        const cardItems: CardItem[] = this.workspaces.map(workspace => ({
            id: workspace.id,
            name: workspace.name,
            description: workspace.rootFolder || '/',
            isEnabled: workspace.isActive ?? true
        }));

        // Create card manager
        this.cardManager = new CardManager({
            containerEl: this.container,
            title: 'Workspaces',
            addButtonText: '+ New Workspace',
            emptyStateText: 'No workspaces yet. Create one to get started.',
            items: cardItems,
            showToggle: true,
            onAdd: () => this.createNewWorkspace(),
            onToggle: async (item, enabled) => {
                const workspace = this.workspaces.find(w => w.id === item.id);
                if (workspace && this.services.workspaceService) {
                    await this.services.workspaceService.updateWorkspace(item.id, { isActive: enabled });
                    workspace.isActive = enabled;
                }
            },
            onEdit: (item) => {
                this.router.showDetail(item.id);
            },
            onDelete: async (item) => {
                const confirmed = confirm(`Delete workspace "${item.name}"? This cannot be undone.`);
                if (!confirmed) return;

                try {
                    if (this.services.workspaceService) {
                        await this.services.workspaceService.deleteWorkspace(item.id);
                        this.workspaces = this.workspaces.filter(w => w.id !== item.id);
                        this.cardManager?.updateItems(this.workspaces.map(w => ({
                            id: w.id,
                            name: w.name,
                            description: w.rootFolder || '/',
                            isEnabled: w.isActive ?? true
                        })));
                        new Notice('Workspace deleted');
                    }
                } catch (error) {
                    console.error('[WorkspacesTab] Failed to delete workspace:', error);
                    new Notice('Failed to delete workspace');
                }
            }
        });
    }

    /**
     * Render loading skeleton cards
     */
    private renderLoadingSkeleton(): void {
        const grid = this.container.createDiv('card-manager-grid');

        // Create 3 skeleton cards
        for (let i = 0; i < 3; i++) {
            const skeleton = grid.createDiv('nexus-skeleton-card');
            skeleton.createDiv('nexus-skeleton-title');
            skeleton.createDiv('nexus-skeleton-description');
            skeleton.createDiv('nexus-skeleton-actions');
        }
    }

    /**
     * Render detail view
     */
    private renderDetail(): void {
        this.container.empty();

        if (!this.currentWorkspace) {
            this.router.back();
            return;
        }

        // Back button
        new BackButton(this.container, 'Back to Workspaces', () => {
            this.saveCurrentWorkspace();
            this.router.back();
        });

        // Workspace name as title
        this.container.createEl('h3', {
            text: this.currentWorkspace.name || 'New Workspace',
            cls: 'nexus-detail-title'
        });

        // Get available agents
        const agents = this.getAvailableAgents();

        // Create form renderer
        const formContainer = this.container.createDiv('workspace-form-container');

        this.formRenderer = new WorkspaceFormRenderer(
            this.services.app,
            this.currentWorkspace,
            agents,
            (index) => this.openWorkflowEditor(index),
            (index) => this.openFilePicker(index),
            () => this.refreshDetail()
        );

        this.formRenderer.render(formContainer);

        // Action buttons
        const actions = this.container.createDiv('nexus-form-actions');

        // Save button
        new ButtonComponent(actions)
            .setButtonText('Save')
            .setCta()
            .onClick(async () => {
                // Cancel any pending debounced save to prevent double-save
                if (this.saveTimeout) {
                    clearTimeout(this.saveTimeout);
                    this.saveTimeout = undefined;
                }
                await this.saveCurrentWorkspace();
                new Notice('Workspace saved');
                this.router.back();
            });

        // Delete button (only for existing workspaces)
        if (this.currentWorkspace.id && this.workspaces.some(w => w.id === this.currentWorkspace?.id)) {
            new ButtonComponent(actions)
                .setButtonText('Delete')
                .setWarning()
                .onClick(() => this.deleteCurrentWorkspace());
        }
    }

    /**
     * Render workflow editor view
     */
    private renderWorkflowEditor(): void {
        this.container.empty();

        if (!this.currentWorkspace || !this.currentWorkspace.context) {
            this.currentView = 'detail';
            this.renderDetail();
            return;
        }

        const workflows = this.currentWorkspace.context.workflows || [];
        const isNew = this.currentWorkflowIndex >= workflows.length || this.currentWorkflowIndex < 0;
        const workflow: Workflow = isNew
            ? { name: '', when: '', steps: '' }
            : workflows[this.currentWorkflowIndex];

        this.workflowRenderer = new WorkflowEditorRenderer(
            (savedWorkflow) => {
                this.saveWorkflow(savedWorkflow);
            },
            () => {
                this.currentView = 'detail';
                this.renderDetail();
            }
        );

        this.workflowRenderer.render(this.container, workflow, isNew);
    }

    /**
     * Get available custom agents
     */
    private getAvailableAgents(): CustomPrompt[] {
        if (!this.services.customPromptStorage) return [];
        return this.services.customPromptStorage.getAllPrompts();
    }

    /**
     * Create a new workspace
     */
    private createNewWorkspace(): void {
        this.currentWorkspace = {
            id: uuidv4(),
            name: '',
            description: '',
            rootFolder: '/',
            isActive: true,
            context: {
                purpose: '',
                workflows: [],
                keyFiles: [],
                preferences: ''
            },
            created: Date.now(),
            lastAccessed: Date.now()
        };

        this.currentView = 'detail';
        this.renderDetail();
    }

    /**
     * Save the current workspace
     */
    private async saveCurrentWorkspace(): Promise<void> {
        if (!this.currentWorkspace || !this.services.workspaceService) return;

        try {
            const existingIndex = this.workspaces.findIndex(w => w.id === this.currentWorkspace?.id);

            if (existingIndex >= 0) {
                // Update existing
                await this.services.workspaceService.updateWorkspace(
                    this.currentWorkspace.id!,
                    this.currentWorkspace
                );
                this.workspaces[existingIndex] = this.currentWorkspace as ProjectWorkspace;
            } else {
                // Create new
                const created = await this.services.workspaceService.createWorkspace(
                    this.currentWorkspace
                );
                this.workspaces.push(created);
                this.currentWorkspace = created;
            }
        } catch (error) {
            console.error('[WorkspacesTab] Failed to save workspace:', error);
            new Notice('Failed to save workspace');
        }
    }

    /**
     * Delete the current workspace
     */
    private async deleteCurrentWorkspace(): Promise<void> {
        if (!this.currentWorkspace?.id || !this.services.workspaceService) return;

        const confirmed = confirm(`Delete workspace "${this.currentWorkspace.name}"? This cannot be undone.`);
        if (!confirmed) return;

        try {
            await this.services.workspaceService.deleteWorkspace(this.currentWorkspace.id);
            this.workspaces = this.workspaces.filter(w => w.id !== this.currentWorkspace?.id);
            this.currentWorkspace = null;
            this.router.back();
            new Notice('Workspace deleted');
        } catch (error) {
            console.error('[WorkspacesTab] Failed to delete workspace:', error);
            new Notice('Failed to delete workspace');
        }
    }

    /**
     * Open workflow editor
     */
    private openWorkflowEditor(index?: number): void {
        this.currentWorkflowIndex = index ?? -1;
        this.currentView = 'workflow';
        this.renderWorkflowEditor();
    }

    /**
     * Save workflow and return to detail view
     */
    private saveWorkflow(workflow: Workflow): void {
        if (!this.currentWorkspace?.context) return;

        if (!this.currentWorkspace.context.workflows) {
            this.currentWorkspace.context.workflows = [];
        }

        if (this.currentWorkflowIndex >= 0 && this.currentWorkflowIndex < this.currentWorkspace.context.workflows.length) {
            // Update existing workflow
            this.currentWorkspace.context.workflows[this.currentWorkflowIndex] = workflow;
        } else {
            // Add new workflow
            this.currentWorkspace.context.workflows.push(workflow);
        }

        this.currentView = 'detail';
        this.renderDetail();

        // Auto-save
        this.debouncedSave();
    }

    /**
     * Open file picker
     */
    private openFilePicker(index: number): void {
        this.currentFileIndex = index;
        this.currentView = 'filepicker';
        this.renderFilePicker();
    }

    /**
     * Render file picker view
     */
    private renderFilePicker(): void {
        this.container.empty();

        const currentPath = this.currentWorkspace?.context?.keyFiles?.[this.currentFileIndex] || '';
        const workspaceRoot = this.currentWorkspace?.rootFolder || '/';

        this.filePickerRenderer = new FilePickerRenderer(
            this.services.app,
            (path) => {
                if (this.currentWorkspace?.context?.keyFiles) {
                    this.currentWorkspace.context.keyFiles[this.currentFileIndex] = path;
                    this.debouncedSave();
                }
                this.currentView = 'detail';
                this.renderDetail();
            },
            () => {
                this.currentView = 'detail';
                this.renderDetail();
            },
            currentPath,
            workspaceRoot,
            undefined, // title
            this.services.component
        );

        this.filePickerRenderer.render(this.container);
    }

    /**
     * Refresh the detail view
     */
    private refreshDetail(): void {
        if (this.currentView === 'detail') {
            this.renderDetail();
        }
    }

    /**
     * Debounced auto-save
     */
    private debouncedSave(): void {
        if (this.saveTimeout) {
            clearTimeout(this.saveTimeout);
        }

        this.saveTimeout = setTimeout(() => {
            this.saveCurrentWorkspace();
        }, 500);
    }

    /**
     * Cleanup
     */
    destroy(): void {
        if (this.saveTimeout) {
            clearTimeout(this.saveTimeout);
        }
        this.formRenderer?.destroy();
    }
}

```

## types.ts

```typescript
/**
 * Legacy Types File - Refactored for Modular Organization
 * 
 * This file now re-exports all types from the organized modular structure.
 * The original types.ts file has been broken down into domain-specific modules:
 * 
 * - src/types/llm/: LLM provider types
 * - src/types/mcp/: MCP protocol and agent types
 * - src/types/search/: Search and memory query types
 * - src/types/plugin/: Plugin configuration types
 * - src/types/common/: Shared/common types
 * 
 * This approach follows SOLID principles:
 * - Single Responsibility: Each module handles one domain
 * - Open/Closed: Easy to extend without modifying existing code
 * - Interface Segregation: Clients depend only on what they use
 * - Dependency Inversion: Modules depend on abstractions
 */

// Re-export all types from the modular structure for backward compatibility
// Import from specific modules to avoid circular dependency

// LLM-related types
export type {
  ModelConfig,
  LLMProviderConfig,
  DefaultModelSettings,
  LLMProviderSettings
} from './types/llm';

export {
  DEFAULT_LLM_PROVIDER_SETTINGS
} from './types/llm';

// Memory management settings
export interface MemorySettings {
  // Workspace management interface
}

export const DEFAULT_MEMORY_SETTINGS: MemorySettings = {
};

// MCP protocol types
export type {
  ModeCall,
  CommonParameters,
  CommonResult,
  ModeCallResult,
  CustomPrompt,
  CustomPromptsSettings,
  ServerStatus,
  IMCPServer,
  MutualTLSOptions,
  ServerState
} from './types/mcp';

export {
  DEFAULT_CUSTOM_PROMPTS_SETTINGS
} from './types/mcp';

// Search and memory types - simplified for JSON-based storage
export type {
  MemoryQueryParams,
  MemoryQueryResult
} from './types/search';

// Plugin configuration types
export type {
  MCPSettings
} from './types/plugin/PluginTypes';

// Common/shared types
export type {
  IVaultManager,
  NoteInfo,
  FolderInfo,
  WorkspaceSessionInfo,
  WorkspaceStateInfo
} from './types/common';

// Create default settings object
import { DEFAULT_CUSTOM_PROMPTS_SETTINGS } from './types/mcp';
import { DEFAULT_LLM_PROVIDER_SETTINGS } from './types/llm';
import { MCPSettings } from './types/plugin';
// DEFAULT_MEMORY_SETTINGS defined above in this file

/**
 * Default plugin settings
 */
export const DEFAULT_SETTINGS: MCPSettings = {
  enabledVault: true,
  configFilePath: undefined,
  memory: DEFAULT_MEMORY_SETTINGS,
  customPrompts: DEFAULT_CUSTOM_PROMPTS_SETTINGS,
  llmProviders: DEFAULT_LLM_PROVIDER_SETTINGS,
  lastUpdateVersion: undefined,
  lastUpdateDate: undefined,
  availableUpdateVersion: undefined,
  lastUpdateCheckDate: undefined
};

// Extend Obsidian App interface (module augmentation)
declare module 'obsidian' {
  interface App {
    commands: {
      listCommands(): Command[];
      executeCommandById(id: string): Promise<void>;
      commands: { [id: string]: Command };
    };
    plugins: {
      getPlugin(id: string): any;
      enablePlugin(id: string): Promise<void>;
      disablePlugin(id: string): Promise<void>;
      plugins: { [id: string]: any };
    };
  }
}
```

## types/agent/AgentTypes.ts

```typescript
/**
 * Location: src/types/agent/AgentTypes.ts
 *
 * Type definitions for agent-related interfaces and data structures.
 * Used throughout the agent system for type safety and consistency.
 */

/**
 * Interface for agent tool call parameters
 */
export interface AgentToolParams {
    agent: string;
    tool: string;
    params: Record<string, unknown>;
}

/**
 * @deprecated Use AgentToolParams instead
 */
export type AgentModeParams = AgentToolParams;

/**
 * Agent registration status information
 */
export interface AgentRegistrationStatus {
    /** Total number of registered agents */
    totalAgents: number;
    
    /** Number of successfully initialized agents */
    initializedAgents: number;
    
    /** Number of failed agent initializations */
    failedAgents: number;
    
    /** Agent initialization errors */
    initializationErrors: Record<string, Error>;
    
    /** Registration timestamp */
    registrationTime: Date;
    
    /** Time taken for registration in milliseconds */
    registrationDuration: number;
}

/**
 * Workspace context information for tool calls
 */
export interface WorkspaceContext {
    workspaceId: string;
    workspacePath?: string[];
    activeWorkspace?: boolean;
}

/**
 * Tool call request information for capture
 */
export interface ToolCallRequest {
    toolCallId: string;
    agent: string;
    mode: string;
    params: Record<string, any>;
    timestamp: number;
    source: 'mcp-client' | 'internal' | 'api';
    workspaceContext?: WorkspaceContext | null;
}

/**
 * Tool call response information for capture
 */
export interface ToolCallResponse {
    result: any;
    success: boolean;
    executionTime: number;
    timestamp: number;
    resultType?: string;
    resultSummary?: string;
    affectedResources?: string[];
    error?: {
        type: string;
        message: string;
        code?: string;
        stack?: string;
    };
}

/**
 * Agent factory function type
 */
export type AgentFactory = () => Promise<any> | any;

/**
 * Agent constructor type
 */
export type AgentConstructor = new (...args: any[]) => any;

/**
 * Agent configuration options
 */
export interface AgentConfig {
    enabled?: boolean;
    modes?: string[];
    settings?: Record<string, any>;
    dependencies?: string[];
}

/**
 * Validation result structure
 */
export interface ValidationResult {
    isValid: boolean;
    errors: string[];
    warnings?: string[];
}
```

## types/branch/BranchTypes.ts

```typescript
/**
 * Branch Types - Unified branching model for human and subagent branches
 *
 * Both human and subagent branches use the same data structure.
 * The key difference is the `inheritContext` flag:
 * - Human branch: inheritContext=true -> LLM sees parent context + branch messages
 * - Subagent branch: inheritContext=false -> LLM sees only branch messages (fresh start)
 */

import type { ChatMessage } from '../chat/ChatTypes';

/**
 * Branch state for tracking lifecycle
 */
export type BranchState =
  | 'running'        // Subagent actively executing
  | 'complete'       // Finished successfully (no tool calls in final response)
  | 'cancelled'      // User or parent cancelled
  | 'abandoned'      // Parent conversation closed while running
  | 'max_iterations'; // Hit iteration limit, can be continued

/**
 * Branch type discriminator
 */
export type BranchType = 'human' | 'subagent';

/**
 * Metadata specific to subagent branches
 */
export interface SubagentBranchMetadata {
  task: string;
  subagentId: string;
  state: BranchState;
  iterations: number;
  maxIterations: number;
  startedAt: number;
  completedAt?: number;
  error?: string;
  // Tool schemas that were pre-fetched for this subagent
  prefetchedTools?: Record<string, string[]>;
}

/**
 * Metadata for human branches (minimal)
 */
export interface HumanBranchMetadata {
  // Human branches are simple - just an alternative conversation path
  description?: string;
}

/**
 * Unified branch structure
 * Lives in message.branches[] array
 */
export interface ConversationBranch {
  id: string;
  type: BranchType;

  /**
   * Context inheritance flag:
   * - true: LLM context includes parent messages 0-N + branch messages
   * - false: LLM context includes only branch messages (fresh start)
   */
  inheritContext: boolean;

  /**
   * The branch's own conversation history
   */
  messages: ChatMessage[];

  created: number;
  updated: number;

  /**
   * Type-specific metadata
   */
  metadata?: SubagentBranchMetadata | HumanBranchMetadata;
}

/**
 * Parameters for spawning a subagent
 * Includes ALL inherited settings from parent conversation
 */
export interface SubagentParams {
  task: string;
  parentConversationId: string;
  parentMessageId: string;
  agent?: string;
  // Pre-fetched tools: { agentName: [toolSlug1, toolSlug2] }
  tools?: Record<string, string[]>;
  contextFiles?: string[];
  context?: string;
  workspaceId?: string;
  sessionId?: string;
  maxIterations?: number;
  continueBranchId?: string;
  // Inherited from parent conversation - Model settings
  provider?: string;  // LLM provider (inherits parent's model)
  model?: string;     // LLM model (inherits parent's model)
  // Inherited from parent conversation - Agent settings
  agentPrompt?: string;  // Custom agent's full system prompt (merged into subagent prompt)
  agentName?: string;    // Custom agent name for reference
  // Inherited from parent conversation - Workspace data
  workspaceData?: any;   // Full comprehensive workspace data (sessions, states, files, etc.)
  // Inherited from parent conversation - Context notes (file paths)
  inheritedContextNotes?: string[];  // Note paths from parent's context notes
  // Inherited from parent conversation - Thinking settings
  thinkingEnabled?: boolean;
  thinkingEffort?: 'low' | 'medium' | 'high';
}

/**
 * Result from subagent execution
 */
export interface SubagentResult {
  success: boolean;
  content: string;
  branchId: string;
  conversationId: string;
  iterations: number;
  error?: string;
}

/**
 * Queued message for async processing
 */
export interface QueuedMessage {
  id: string;
  type: 'user' | 'subagent_result' | 'system';
  content: string;
  metadata?: {
    subagentId?: string;
    subagentTask?: string;
    branchId?: string;
    conversationId?: string;
    parentMessageId?: string;
    error?: boolean;
  };
  queuedAt: number;
}

/**
 * Agent status item for UI display
 */
export interface AgentStatusItem {
  subagentId: string;
  branchId: string;
  conversationId: string;
  parentMessageId: string;
  task: string;
  state: BranchState;
  iterations: number;
  maxIterations: number;
  startedAt: number;
  completedAt?: number;
  lastToolUsed?: string;
}

/**
 * Context for viewing a branch in the UI
 */
export interface BranchViewContext {
  conversationId: string;
  branchId: string;
  parentMessageId: string;
  branchType: BranchType;
  metadata?: SubagentBranchMetadata | HumanBranchMetadata;
}

/**
 * Events emitted by SubagentExecutor
 */
export interface SubagentExecutorEvents {
  onSubagentStarted: (subagentId: string, task: string, branchId: string) => void;
  onSubagentProgress: (subagentId: string, message: string, iteration: number) => void;
  onSubagentComplete: (subagentId: string, result: SubagentResult) => void;
  onSubagentError: (subagentId: string, error: string) => void;
  /**
   * Streaming update with incremental chunks (like parent chat)
   * Uses same StreamingController infrastructure for smooth updates
   * @param branchId - The branch being streamed
   * @param messageId - The assistant message ID being streamed
   * @param chunk - The NEW content chunk (incremental, not full content)
   * @param isComplete - Whether streaming is complete
   * @param fullContent - Full content so far (for finalization)
   */
  onStreamingUpdate: (branchId: string, messageId: string, chunk: string, isComplete: boolean, fullContent: string) => void;
  /**
   * Tool calls detected - SAME event as parent chat uses
   * Routes to ToolEventCoordinator.handleToolCallsDetected() for dynamic tool bubble creation
   */
  onToolCallsDetected: (branchId: string, messageId: string, toolCalls: any[]) => void;
}

/**
 * Events emitted by MessageQueueService
 */
export interface MessageQueueEvents {
  'message:queued': (data: { count: number; message: QueuedMessage }) => void;
  'message:processing': (data: { message: QueuedMessage }) => void;
  'queue:empty': () => void;
}

/**
 * Tool call structure from LLM responses
 */
export interface SubagentToolCall {
  id: string;
  type?: string;
  function: {
    name: string;
    arguments: string;
  };
}

/**
 * Tool schema for pre-fetched tools
 */
export interface ToolSchemaInfo {
  agent: string;
  slug?: string;
  name?: string;
  description: string;
  parameters?: Record<string, unknown>;
}

/**
 * Tool execution result
 */
export interface ToolExecutionResult {
  success: boolean;
  result?: unknown;
  error?: string;
}

/**
 * Type guard for subagent metadata
 */
export function isSubagentMetadata(
  metadata: SubagentBranchMetadata | HumanBranchMetadata | undefined
): metadata is SubagentBranchMetadata {
  return metadata !== undefined && 'subagentId' in metadata;
}

/**
 * Type guard for checking if branch is a subagent branch
 */
export function isSubagentBranch(branch: ConversationBranch): boolean {
  return branch.type === 'subagent';
}

/**
 * Create a human branch with default values
 */
export function createHumanBranch(id: string): ConversationBranch {
  const now = Date.now();
  return {
    id,
    type: 'human',
    inheritContext: true,
    messages: [],
    created: now,
    updated: now,
  };
}

/**
 * Create a subagent branch with default values
 */
export function createSubagentBranch(
  id: string,
  subagentId: string,
  task: string,
  maxIterations: number = 10
): ConversationBranch {
  const now = Date.now();
  return {
    id,
    type: 'subagent',
    inheritContext: false,
    messages: [],
    created: now,
    updated: now,
    metadata: {
      task,
      subagentId,
      state: 'running',
      iterations: 0,
      maxIterations,
      startedAt: now,
    } satisfies SubagentBranchMetadata,
  };
}

```

## types/branch/index.ts

```typescript
/**
 * Branch Types Module
 */
export * from './BranchTypes';

```

## types/chat/ChatTypes.ts

```typescript
/**
 * Chat Types - Minimal type definitions for native chatbot
 * Pure JSON-based chat
 */

import type { ConversationBranch } from '../branch/BranchTypes';

export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
  timestamp: number;
  conversationId: string;
  state?: 'draft' | 'streaming' | 'complete' | 'aborted' | 'invalid'; // Message lifecycle state
  toolCalls?: ToolCall[];
  tokens?: number;
  isLoading?: boolean;
  metadata?: Record<string, any>;
  // Reasoning/thinking content from LLMs that support it (Claude, GPT-5, Gemini)
  reasoning?: string;

  /**
   * Conversation branches from this message point.
   * Replaces the old alternatives[] system with unified branching.
   * - Human branches: inheritContext=true (includes parent context)
   * - Subagent branches: inheritContext=false (fresh start)
   */
  branches?: ConversationBranch[];

  /** Inline message alternatives for human regeneration (retry/regenerate) */
  alternatives?: ChatMessage[];

  /** Which alternative is active: 0 = original, 1+ = alternative index + 1 */
  activeAlternativeIndex?: number;
}

/** Format the model used to output tool calls */
export type ToolCallFormat = 'bracket' | 'xml' | 'native';

export interface ToolCall {
  id: string;
  type: string;
  name?: string;
  displayName?: string;
  technicalName?: string;
  function: {
    name: string;
    arguments: string;
  };
  result?: any;
  success?: boolean;
  error?: string;
  parameters?: any;
  executionTime?: number;
  /** Format the model used: 'bracket' = [TOOL_CALLS], 'xml' = <tool_call>, 'native' = OpenAI tool_calls */
  sourceFormat?: ToolCallFormat;
}

export interface Conversation {
  id: string;
  title: string;
  messages: ChatMessage[];
  created: number;
  updated: number;
  cost?: {
    totalCost: number;
    currency: string;
  };
  metadata?: {
    previousResponseId?: string; // OpenAI Responses API: Track last response ID for continuations
    cost?: {
      totalCost: number;
      currency: string;
    };
    totalCost?: number;
    currency?: string;
    // Branch support: when set, this conversation is a branch of another
    parentConversationId?: string;  // The parent conversation this branched from
    parentMessageId?: string;       // The specific message this branched from
    branchType?: 'subagent' | 'alternative';  // Type of branch
    subagentTask?: string;          // For subagent branches: the task description
    [key: string]: any;
  };
}

export interface ChatContext {
  conversationId: string;
  currentMessage?: ChatMessage;
  previousMessages: ChatMessage[];
  tokens: {
    input: number;
    output: number;
    total: number;
  };
}

// Legacy type aliases for compatibility
export type ConversationData = Conversation;
export type ConversationMessage = ChatMessage;

// Branch helper functions
export function isBranchConversation(conversation: Conversation): boolean {
  return !!conversation.metadata?.parentConversationId;
}

export function getBranchParent(conversation: Conversation): { parentConversationId: string; parentMessageId: string } | null {
  if (!conversation.metadata?.parentConversationId) {
    return null;
  }
  return {
    parentConversationId: conversation.metadata.parentConversationId,
    parentMessageId: conversation.metadata.parentMessageId || '',
  };
}

export interface ConversationDocument {
  id: string;
  data: Conversation;
}

export interface ConversationSearchOptions {
  query?: string;
  limit?: number;
  offset?: number;
}

export interface ConversationSearchResult {
  conversations: Conversation[];
  total: number;
}

export interface CreateConversationParams {
  title?: string;
  initialMessage?: string;
  provider?: string;
  model?: string;
  systemPrompt?: string;
  workspaceId?: string;
  sessionId?: string;
}

export interface AddMessageParams {
  conversationId: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
  toolCalls?: ToolCall[];
  metadata?: Record<string, any>;
}

export interface UpdateConversationParams {
  id: string;
  title?: string;
  metadata?: Record<string, any>;
}

export function documentToConversationData(doc: ConversationDocument): Conversation {
  return doc.data;
}

```

## types/chat/index.ts

```typescript
/**
 * Chat Types Index - Export all chat-related type definitions
 */

export * from './ChatTypes';
```

## types/common/index.ts

```typescript
/**
 * Common types export barrel
 * Centralizes all common/shared type exports
 */

export type {
  IVaultManager,
  NoteInfo,
  FolderInfo,
  WorkspaceSessionInfo,
  WorkspaceStateInfo
} from './VaultTypes';
```

## types/common/VaultTypes.ts

```typescript
/**
 * Vault and File System Types
 * Extracted from types.ts for better organization
 */

import { App, TFile } from 'obsidian';

/**
 * Vault manager interface
 */
export interface IVaultManager {
  app: App;
  ensureFolder(path: string): Promise<void>;
  folderExists(path: string): Promise<boolean>;
  createFolder(path: string): Promise<void>;
  createNote(path: string, content: string, options?: any): Promise<TFile>;
  readNote(path: string): Promise<string>;
  updateNote(path: string, content: string, options?: any): Promise<void>;
  deleteNote(path: string): Promise<void>;
  getNoteMetadata(path: string): Promise<any>;
}

/**
 * Note information structure
 */
export interface NoteInfo {
  path: string;
  name: string;
  extension: string;
  created: number;
  modified: number;
  size: number;
}

/**
 * Folder information structure
 */
export interface FolderInfo {
  path: string;
  name: string;
  children: (FolderInfo | NoteInfo)[];
}

/**
 * Memory Manager Types
 */
export interface WorkspaceSessionInfo {
  id: string;
  name: string;
  workspaceId: string;
  startTime: number;
  endTime?: number;
  isActive: boolean;
  description?: string;
  toolCalls: number;
  tags?: string[];
}

export interface WorkspaceStateInfo {
  id: string;
  name: string;
  workspaceId: string;
  sessionId: string;
  timestamp: number;
  description?: string;
  context?: {
    files: string[];
    traceCount: number;
    tags: string[];
    summary?: string;
  };
}
```

## types/google-genai.d.ts

```typescript
/**
 * Type declarations for @google/genai module
 * This provides basic typing to resolve TypeScript compilation errors
 */

declare module '@google/genai' {
  export interface GenerativeModel {
    generateContent(prompt: string | any): Promise<any>;
    generateContentStream(prompt: string | any): AsyncIterable<any>;
  }

  export interface ModelsAPI {
    generateContent(request: any): Promise<any>;
    generateContentStream(request: any): AsyncIterable<any>;
  }

  export interface GoogleGenAI {
    getGenerativeModel(options: { model: string }): GenerativeModel;
    models: ModelsAPI;
  }

  export class GoogleGenAI {
    constructor(options: { apiKey: string });
    getGenerativeModel(options: { model: string }): GenerativeModel;
    models: ModelsAPI;
  }

  export const GoogleGenAI: {
    new (options: { apiKey: string }): GoogleGenAI;
  };

  // Export other commonly used types as any for now
  export const HarmCategory: any;
  export const HarmBlockThreshold: any;
  export const GenerativeModel: any;
}
```

## types/index.ts

```typescript
/**
 * Main types export barrel
 * Provides a clean interface for importing types throughout the application
 * Organized by domain for better maintainability
 */

// LLM-related types
export type {
  ModelConfig,
  LLMProviderConfig,
  DefaultModelSettings,
  LLMProviderSettings
} from './llm';

export {
  DEFAULT_LLM_PROVIDER_SETTINGS
} from './llm';

// Simple memory management now uses JSON-based storage
export interface MemorySettings {
  enabled: boolean;
  dataPath?: string;
}

export const DEFAULT_MEMORY_SETTINGS: MemorySettings = {
  enabled: true,
  dataPath: '.data'
};

// MCP protocol types
export {
  type ToolContext,
  type ModeCall,
  type CommonParameters,
  type CommonResult,
  type ModeCallResult,
  type CustomPrompt,
  type CustomPromptsSettings,
  type ServerStatus,
  type IMCPServer,
  type MutualTLSOptions,
  type ServerState
} from './mcp';

export {
  DEFAULT_CUSTOM_PROMPTS_SETTINGS
} from './mcp';

// Search and memory types - simplified for JSON-based storage
export type {
  MemoryQueryParams,
  MemoryQueryResult
} from './search';

// Plugin configuration types
export type {
  MCPSettings
} from './plugin';

// Common/shared types
export type {
  IVaultManager,
  NoteInfo,
  FolderInfo,
  WorkspaceSessionInfo,
  WorkspaceStateInfo
} from './common';

// Chat types
export type {
  ConversationData,
  ConversationMessage,
  ToolCall,
  ConversationDocument,
  ConversationSearchOptions,
  ConversationSearchResult,
  CreateConversationParams,
  AddMessageParams,
  UpdateConversationParams
} from './chat/ChatTypes';

// Pagination types
export type {
  PaginationParams,
  PaginatedResult
} from './pagination/PaginationTypes';

export {
  createEmptyPaginatedResult,
  calculatePaginationMetadata
} from './pagination/PaginationTypes';

// Storage types
export type {
  DeviceInfo,
  SyncState,
  WorkspaceMetadata,
  SessionMetadata,
  StateMetadata,
  StateData,
  ConversationMetadata,
  MessageData,
  MemoryTraceData,
  ExportFilter,
  ExportData,
  WorkspaceExportData,
  ConversationExportData,
  SearchResult,
  SyncResult,
  StorageEvent,
  StorageEventType
} from './storage/HybridStorageTypes';

// Create default settings object
import { DEFAULT_CUSTOM_PROMPTS_SETTINGS } from './mcp';
import { DEFAULT_LLM_PROVIDER_SETTINGS } from './llm';
import { MCPSettings } from './plugin';
// DEFAULT_MEMORY_SETTINGS defined above in this file

/**
 * Default plugin settings
 */
export const DEFAULT_SETTINGS: MCPSettings = {
  enabledVault: true,
  configFilePath: undefined,
  memory: DEFAULT_MEMORY_SETTINGS,
  customPrompts: DEFAULT_CUSTOM_PROMPTS_SETTINGS,
  llmProviders: DEFAULT_LLM_PROVIDER_SETTINGS,
  lastUpdateVersion: undefined,
  lastUpdateDate: undefined,
  availableUpdateVersion: undefined,
  lastUpdateCheckDate: undefined
};

// Extend Obsidian App interface (module augmentation)
declare module 'obsidian' {
  interface App {
    commands: {
      listCommands(): Command[];
      executeCommandById(id: string): Promise<void>;
      commands: { [id: string]: Command };
    };
    plugins: {
      getPlugin(id: string): any;
      enablePlugin(id: string): Promise<void>;
      disablePlugin(id: string): Promise<void>;
      plugins: { [id: string]: any };
    };
  }
}
```

## types/llm/index.ts

```typescript
/**
 * LLM-related types export barrel
 * Centralizes all LLM provider type exports
 */

export type {
  ModelConfig,
  LLMProviderConfig,
  DefaultModelSettings,
  LLMProviderSettings
} from './ProviderTypes';

export {
  DEFAULT_LLM_PROVIDER_SETTINGS
} from './ProviderTypes';

// Memory settings now handled by simplified JSON-based memory system
```

## types/llm/ProviderTypes.ts

```typescript
/**
 * LLM Provider Configuration Types
 * Extracted from types.ts for better organization and maintainability
 */

/**
 * Thinking effort levels - unified across all providers
 */
export type ThinkingEffort = 'low' | 'medium' | 'high';

/**
 * Thinking settings for models that support extended thinking
 */
export interface ThinkingSettings {
  enabled: boolean;
  effort: ThinkingEffort;
}

/**
 * Alias for backwards compatibility
 */
export type DefaultThinkingSettings = ThinkingSettings;

/**
 * Model configuration with enabled status and optional description
 */
export interface ModelConfig {
  enabled: boolean; // Primary field for controlling model visibility
  description?: string; // Optional user-defined description (for backwards compatibility)
}

/**
 * LLM provider configuration
 */
export interface LLMProviderConfig {
  apiKey: string;
  userDescription?: string;
  enabled: boolean;
  models?: { [modelId: string]: ModelConfig }; // Model-specific configurations
  ollamaModel?: string; // For Ollama: user-configured model name
  lastValidated?: number; // Unix timestamp (ms) of last successful validation
  validationHash?: string; // First 16 chars of SHA256 hash of validated API key
  // OpenRouter-specific headers (optional, but recommended for production)
  httpReferer?: string;
  xTitle?: string;
  // WebLLM-specific settings
  webllmModel?: string; // Selected WebLLM model (e.g., 'nexus-tools-q4f16')
  webllmQuantization?: 'q4f16' | 'q5f16' | 'q8f16'; // Quantization level
}

/**
 * Default model selection settings
 */
export interface DefaultModelSettings {
  provider: string;
  model: string;
}

/**
 * Default image model selection settings
 */
export interface DefaultImageModelSettings {
  provider: 'google' | 'openrouter';
  model: string;
}

/**
 * LLM provider settings
 */
export interface LLMProviderSettings {
  providers: {
    [providerId: string]: LLMProviderConfig;
  };
  defaultModel: DefaultModelSettings;
  agentModel?: DefaultModelSettings; // Model for executePrompt (API-only, used when chat model is local)
  defaultImageModel?: DefaultImageModelSettings; // Default image generation model
  defaultThinking?: DefaultThinkingSettings; // Default thinking settings for supported models
  defaultTemperature?: number; // Default temperature (0.0-1.0, default 0.5)
  monthlyBudget?: number; // Monthly budget in USD for LLM usage
}

/**
 * Default LLM provider settings
 */
export const DEFAULT_LLM_PROVIDER_SETTINGS: LLMProviderSettings = {
  providers: {
    openai: {
      apiKey: '',
      enabled: false
    },
    anthropic: {
      apiKey: '',
      enabled: false
    },
    google: {
      apiKey: '',
      enabled: false
    },
    mistral: {
      apiKey: '',
      enabled: false
    },
    groq: {
      apiKey: '',
      enabled: false
    },
    openrouter: {
      apiKey: '',
      enabled: false,
      httpReferer: '',
      xTitle: ''
    },
    requesty: {
      apiKey: '',
      enabled: false
    },
    perplexity: {
      apiKey: '',
      enabled: false
    },
    ollama: {
      apiKey: 'http://127.0.0.1:11434',
      enabled: false,
      ollamaModel: '' // User must configure their installed model
    },
    lmstudio: {
      apiKey: 'http://127.0.0.1:1234',
      enabled: false
    },
    webllm: {
      apiKey: '', // Not used - WebLLM is fully local
      enabled: false,
      webllmModel: 'nexus-tools-q4f16', // Default to Q4 quantization
      webllmQuantization: 'q4f16'
    }
  },
  defaultModel: {
    provider: 'openai',
    model: 'gpt-4o'
  },
  defaultImageModel: {
    provider: 'google',
    model: 'gemini-2.5-flash-image'
  },
  defaultThinking: {
    enabled: false,
    effort: 'medium'
  },
  defaultTemperature: 0.5
};

```

## types/mcp/AgentTypes.ts

```typescript
/**
 * MCP Agent and Tool-related Types
 * Extracted from types.ts for better organization
 */

import { WorkspaceContext } from '../../utils/contextUtils';

/**
 * Tool call definition for chaining to another agent/tool
 */
export interface ToolCall {
  /**
   * Agent name to execute tool on
   */
  agent: string;

  /**
   * Tool to execute
   */
  tool: string;

  /**
   * Parameters to pass to the tool
   */
  parameters: any;

  /**
   * Whether to return results to original agent
   */
  returnHere?: boolean;

  /**
   * Whether this tool should be executed regardless of previous tool failures
   * Default is false - execution stops on first failure
   */
  continueOnFailure?: boolean;

  /**
   * Tool execution strategy
   * - serial: wait for previous tools to complete before executing (default)
   * - parallel: execute in parallel with other tools marked as parallel
   */
  strategy?: 'serial' | 'parallel';

  /**
   * Optional name to identify this tool call in the results
   */
  callName?: string;
}

/**
 * @deprecated Use ToolCall instead
 */
export type ModeCall = ToolCall;

/**
 * New context schema for Two-Tool Architecture
 * Uses memory â†’ goal â†’ constraints flow instead of verbose legacy fields
 *
 * This is the CANONICAL context format used by:
 * - toolManager_useTool (required)
 * - All tools via CommonParameters (optional, for backward compatibility)
 */
export interface ToolContext {
  /** Workspace scope identifier */
  workspaceId: string;

  /** Session identifier for tracking */
  sessionId: string;

  /** Compressed essence of conversation so far (1-3 sentences) */
  memory: string;

  /** Current objective informed by memory (1-3 sentences) */
  goal: string;

  /** Optional rules/limits to follow (1-3 sentences) */
  constraints?: string;
}

/**
 * Common parameters structure for standardized agent tools
 * Provides session tracking and workspace context
 *
 * Uses new ToolContext format (memory/goal/constraints)
 * Context is REQUIRED - all tools are called via useTool which provides context
 */
export interface CommonParameters {
  /**
   * Contextual information for this tool call (REQUIRED)
   * Uses ToolContext format with memory, goal, and optional constraints
   */
  context: ToolContext;

  /**
   * Optional workspace context for scoping operations
   * Can be either an object with workspaceId or a JSON string representation
   */
  workspaceContext?: WorkspaceContext | string;

}

/**
 * Common result structure for standardized agent responses
 */
export interface CommonResult {
  /**
   * Whether the operation succeeded
   */
  success: boolean;

  /**
   * Error message if success is false
   */
  error?: string;

  /**
   * Operation-specific result data
   */
  data?: unknown;

  /**
   * Contextual information echoed back
   * Uses ToolContext format (memory/goal/constraints)
   */
  context?: ToolContext | string;

  /**
   * Workspace context that was used (for continuity)
   */
  workspaceContext?: WorkspaceContext;

}

/**
 * Tool call result for tracking execution outcomes
 */
export interface ToolCallResult extends CommonResult {
  /**
   * Agent name that executed the tool
   */
  agent?: string;

  /**
   * Tool that was executed
   */
  tool?: string;

  /**
   * Name of the tool call if specified
   */
  callName?: string;

  /**
   * Sequence number of this tool call
   */
  sequence?: number;

  /**
   * Timestamp when the tool call started
   */
  startTime?: number;

  /**
   * Timestamp when the tool call completed
   */
  endTime?: number;

  /**
   * Duration of the tool call in milliseconds
   */
  duration?: number;
}

/**
 * @deprecated Use ToolCallResult instead
 */
export type ModeCallResult = ToolCallResult;
```

## types/mcp/CustomPromptTypes.ts

```typescript
/**
 * Custom Prompt Types
 * Extracted from types.ts for better organization
 */

/**
 * Custom prompt definition for MCP
 */
export interface CustomPrompt {
  id: string;
  name: string;
  description: string;
  prompt: string;
  isEnabled: boolean;
}

/**
 * Custom prompts settings
 */
export interface CustomPromptsSettings {
  enabled: boolean;
  prompts: CustomPrompt[];
}

/**
 * Default custom prompts settings
 */
export const DEFAULT_CUSTOM_PROMPTS_SETTINGS: CustomPromptsSettings = {
  enabled: true,
  prompts: []
};
```

## types/mcp/index.ts

```typescript
/**
 * MCP-related types export barrel
 * Centralizes all MCP protocol type exports
 */

export {
  type ToolContext,
  type ModeCall,
  type CommonParameters,
  type CommonResult,
  type ModeCallResult
} from './AgentTypes';

export type {
  CustomPrompt,
  CustomPromptsSettings
} from './CustomPromptTypes';

export {
  DEFAULT_CUSTOM_PROMPTS_SETTINGS
} from './CustomPromptTypes';

export type {
  ServerStatus,
  IMCPServer,
  MutualTLSOptions,
  ServerState
} from './ServerTypes';
```

## types/mcp/ServerTypes.ts

```typescript
/**
 * MCP Server-related Types
 * Extracted from types.ts for better organization
 */

import { PluginManifest } from 'obsidian';
import { IAgent } from '../../agents/interfaces/IAgent';

/**
 * Server status enum
 */
export type ServerStatus = 'initializing' | 'starting' | 'running' | 'stopping' | 'stopped' | 'error';

/**
 * MCP Server interface
 */
export interface IMCPServer {
  start(): Promise<void>;
  stop(): Promise<void>;
  isRunning(): boolean;
  getStatus(): ServerStatus;
  registerAgent(agent: IAgent): void;
}

/**
 * Mutual TLS Options
 */
export interface MutualTLSOptions {
  certPath: string;
  keyPath: string;
  caPath?: string;
}

/**
 * Server State
 */
export interface ServerState {
  running: boolean;
  port: number;
  socketPath?: string;
  protocol: 'http' | 'unix';
  startTime?: Date;
  totalRequests: number;
  clientsConnected: number;
  lastError?: string;
  manifest: PluginManifest;
}
```

## types/mcp/ToolTypes.ts

```typescript
/**
 * Location: src/types/mcp/ToolTypes.ts
 * 
 * Type definitions for MCP tool-related interfaces and data structures.
 * Used throughout the MCP system for type safety and consistency.
 */

/**
 * MCP tool call request structure
 */
export interface MCPToolCallRequest {
    params: {
        name: string;
        arguments: Record<string, any>;
    };
    meta?: {
        requestId?: string;
        timestamp?: Date;
        source?: string;
    };
}

/**
 * MCP tool call response structure
 */
export interface MCPToolCallResponse {
    content: Array<{
        type: 'text' | 'resource';
        text?: string;
        resource?: any;
    }>;
    isError?: boolean;
    error?: {
        code: string;
        message: string;
        data?: any;
    };
}

/**
 * Tool descriptor for MCP tool registration
 */
export interface ToolDescriptor {
    /** Tool name in format 'agentName_modeName' */
    name: string;
    
    /** Tool description */
    description: string;
    
    /** Input parameter schema */
    inputSchema?: any;
    
    /** Output result schema */
    outputSchema?: any;
    
    /** Tool metadata */
    metadata?: ToolMetadata;
    
    /** Tool capabilities */
    capabilities?: ToolCapabilities;
}

/**
 * Tool metadata information
 */
export interface ToolMetadata {
    agent: string;
    mode: string;
    version?: string;
    category?: string;
    tags?: string[];
    deprecated?: boolean;
    experimental?: boolean;
}

/**
 * Tool capabilities definition
 */
export interface ToolCapabilities {
    requiresAuth?: boolean;
    requiresVectorStore?: boolean;
    requiresLLM?: boolean;
    supportsBatch?: boolean;
    supportsStreaming?: boolean;
    isIdempotent?: boolean;
}

/**
 * MCP connection status information
 */
export interface MCPConnectionStatus {
    /** Whether manager is initialized */
    isInitialized: boolean;
    
    /** Whether server is running */
    isServerRunning: boolean;
    
    /** Server creation timestamp */
    serverCreatedAt?: Date;
    
    /** Last error encountered */
    lastError?: {
        message: string;
        timestamp: Date;
    };
}

/**
 * Tool routing statistics
 */
export interface ToolRoutingStats {
    totalCalls: number;
    successfulCalls: number;
    failedCalls: number;
    averageExecutionTime: number;
    callsByAgent: Record<string, number>;
    callsByMode: Record<string, number>;
    errorsByType: Record<string, number>;
}

/**
 * Tool execution context
 */
export interface ToolExecutionContext {
    requestId?: string;
    sessionId?: string;
    userId?: string;
    timestamp: Date;
    source: 'mcp-client' | 'internal' | 'api';
    metadata?: Record<string, any>;
}
```

## types/memory/index.ts

```typescript
/**
 * Memory Types Barrel Export
 * 
 * Location: src/types/memory/index.ts
 * Purpose: Centralizes all memory-related type exports
 */

export * from './MemorySearchTypes';
```

## types/memory/MemorySearchTypes.ts

```typescript
/**
 * Memory Search Types
 * 
 * Location: src/types/memory/MemorySearchTypes.ts
 * Purpose: Consolidated type definitions for memory search operations
 * Used by: MemorySearchProcessor, MemorySearchFilters, ResultFormatter, SearchMemoryMode
 */

import { CommonParameters } from '../mcp/AgentTypes';

// Core search parameters interface
export interface MemorySearchParameters extends CommonParameters {
  query: string;
  memoryTypes?: ('traces' | 'toolCalls' | 'sessions' | 'states' | 'workspaces')[];
  workspace?: string;
  workspaceId?: string;
  dateRange?: DateRange;
  limit?: number;
  toolCallFilters?: ToolCallFilter;
  searchMethod?: 'semantic' | 'exact' | 'mixed';
  filterBySession?: boolean;
}

// Date range filter
export interface DateRange {
  start?: string;
  end?: string;
}

// Tool call specific filters
export interface ToolCallFilter {
  agent?: string;
  mode?: string;
  success?: boolean;
  minExecutionTime?: number;
  maxExecutionTime?: number;
}

// Search execution options for processor
export interface MemorySearchExecutionOptions {
  workspaceId?: string;
  sessionId?: string;
  limit?: number;
  toolCallFilters?: ToolCallFilter;
  memoryTypes?: ('traces' | 'toolCalls' | 'sessions' | 'states' | 'workspaces')[];
}

// Memory search context
export interface MemorySearchContext {
  params: MemorySearchParameters;
  timestamp: Date;
}

// Raw memory result from searches
export interface RawMemoryResult {
  trace: any; // MemoryTrace or ToolCallMemoryTrace
  similarity?: number;
}

// Processed memory search result
export interface MemorySearchResult {
  type: 'trace' | 'toolCall' | 'session' | 'state' | 'workspace';
  id: string;
  highlight: string;
  metadata: MemoryResultMetadata;
  context: SearchResultContext;
  score: number;
}

// Enriched memory search result with raw trace attached
export interface EnrichedMemorySearchResult extends MemorySearchResult {
  _rawTrace: any;
}

// Memory result metadata
export interface MemoryResultMetadata {
  created: string;
  updated?: string;
  sessionId?: string;
  workspaceId?: string;
  primaryGoal?: string;
  filesReferenced?: string[];
  toolUsed?: string;
  modeUsed?: string;
  type?: string;
  // Tool call specific metadata
  toolCallId?: string;
  agent?: string;
  mode?: string;
  executionTime?: number;
  success?: boolean;
  errorMessage?: string;
  affectedResources?: string[];
}

// Search result context
export interface SearchResultContext {
  before: string;
  match: string;
  after: string;
}

// Final search result response
export interface SearchMemoryModeResult {
  success: boolean;
  query: string;
  results: MemorySearchResult[];
  totalResults: number;
  error?: string;
}

// Filter options for filtering service
export interface MemoryFilterOptions {
  dateRange?: DateRange;
  toolCallFilters?: ToolCallFilter;
  sessionId?: string;
  workspaceId?: string;
  filterBySession?: boolean;
}

// Content filter options
export interface ContentFilterOptions {
  caseSensitive?: boolean;
  wholeWord?: boolean;
  regex?: boolean;
}

// Format options for formatter service
export interface FormatOptions {
  maxHighlightLength?: number;
  contextLength?: number;
  enhanceToolCallContext?: boolean;
}

// Formatted memory result
export interface FormattedMemoryResult {
  original: MemorySearchResult;
  formattedContent: string;
  preview: string;
  formattedTimestamp: string;
  title: string;
  subtitle?: string;
  formattedMetadata: Record<string, string>;
  highlights: SearchHighlight[];
  formatContext: FormatContext;
}

// Search highlight
export interface SearchHighlight {
  field: string;
  start: number;
  end: number;
  text: string;
  context?: string;
}

// Format context
export interface FormatContext {
  searchQuery: string;
  resultType: string;
  timestamp: Date;
}

// Memory sort options
export interface MemorySortOption {
  field: 'score' | 'timestamp' | 'relevance';
  direction: 'asc' | 'desc';
}

// Memory group options
export interface MemoryGroupOption {
  groupBy: 'type' | 'session' | 'workspace' | 'date';
  subGroupBy?: 'agent' | 'mode' | 'success';
}

// Grouped memory results
export interface GroupedMemoryResults {
  groups: MemoryResultGroup[];
  totalGroups: number;
  totalResults: number;
  groupedBy: MemoryGroupOption;
  groupStats: GroupStatistics;
}

// Memory result group
export interface MemoryResultGroup {
  key: string;
  displayName: string;
  results: MemorySearchResult[];
  count: number;
  totalScore: number;
  averageScore: number;
  metadata: Record<string, any>;
}

// Group statistics
export interface GroupStatistics {
  averageGroupSize: number;
  largestGroupSize: number;
  smallestGroupSize: number;
  scoreDistribution: Record<string, number>;
}

// Paginated memory results
export interface PaginatedMemoryResults {
  items: MemorySearchResult[];
  page: number;
  pageSize: number;
  totalItems: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
}

// Pagination options
export interface PaginationOptions {
  page: number;
  pageSize: number;
  totalItems?: number;
}

// Memory result summary
export interface MemoryResultSummary {
  totalResults: number;
  averageScore: number;
  typeDistribution: Record<string, number>;
  dateRange: { start: Date; end: Date };
  executionTime: number;
}

// Highlight options
export interface HighlightOptions {
  maxHighlights?: number;
  highlightLength?: number;
  caseSensitive?: boolean;
  wholeWord?: boolean;
}

// Validation result
export interface ValidationResult {
  isValid: boolean;
  errors: string[];
}

// Search options for different search types
export interface SearchOptions {
  includeTraces?: boolean;
  includeStates?: boolean;
  includeMessages?: boolean;
  workspaceId?: string;
  sessionId?: string;
  limit?: number;
}

// Memory types enum
export enum MemoryType {
  TRACE = 'trace',
  TOOL_CALL = 'toolCall',
  SESSION = 'session',
  STATE = 'state',
  WORKSPACE = 'workspace'
}

// Search method enum
export enum SearchMethod {
  EXACT = 'exact',
  MIXED = 'mixed'
}


// Memory configuration
export interface MemoryProcessorConfiguration {
  defaultLimit: number;
  maxLimit: number;
  defaultSearchMethod: SearchMethod;
  enableSemanticSearch: boolean;
  enableExactSearch: boolean;
  timeoutMs: number;
}

// Filter configuration
export interface MemoryFilterConfiguration {
  enableDateFiltering: boolean;
  enableSessionFiltering: boolean;
  enableToolCallFiltering: boolean;
  defaultDateRange: DateRange | null;
  strictFiltering: boolean;
}

// Formatter configuration
export interface ResultFormatterConfiguration {
  maxHighlightLength: number;
  contextLength: number;
  enableToolCallEnhancement: boolean;
  dateFormat: string;
  timestampFormat: string;
}

// Processing options
export interface ProcessingOptions {
  enableFiltering: boolean;
  enableFormatting: boolean;
  enableGrouping: boolean;
  enableSorting: boolean;
  batchSize?: number;
}

// Error information
export interface ErrorInfo {
  timestamp: Date;
  message: string;
  operation: string;
}

// Time range
export interface TimeRange {
  start: Date;
  end: Date;
}

// Related memory reference
export interface RelatedMemory {
  id: string;
  type: MemoryType;
  relationshipType: 'parent' | 'child' | 'sibling' | 'reference';
  similarity?: number;
}

// Tool call information
export interface ToolCallInfo {
  id: string;
  name: string;
  agent: string;
  mode: string;
  executionTime?: number;
  success: boolean;
  input?: any;
  output?: any;
  error?: string;
}

// Execution status
export enum ExecutionStatus {
  SUCCESS = 'success',
  ERROR = 'error',
  TIMEOUT = 'timeout',
  CANCELLED = 'cancelled'
}
```

## types/memory/TraceTypes.ts

```typescript
/**
 * src/types/memory/TraceTypes.ts
 * 
 * Memory trace type definitions extracted from MemoryTraceService.ts
 * Contains interface definitions for memory traces, tool call traces, and search operations.
 * Used by MemoryTraceService, ToolCallTraceProcessor, and TraceSearchService.
 */

import { WorkspaceMemoryTrace, TraceMetadata, LegacyWorkspaceTraceMetadata } from '../../database/workspace-types';
// import type { PendingToolCallCapture } from '../../services/toolcall-capture/ToolCallCaptureService';
type PendingToolCallCapture = any;

/**
 * Search options for memory trace queries
 */
export interface MemoryTraceSearchOptions {
  workspaceId?: string;
  workspacePath?: string[];
  limit?: number;
  sessionId?: string;
}

/**
 * Activity trace data structure for tool interactions and user activities
 */
export interface ActivityTraceData {
  type: string;
  content: string;
  metadata: TraceMetadata | LegacyWorkspaceTraceMetadata;
  sessionId?: string;
}

/**
 * Enhanced memory trace for tool call capture with complete JSON preservation.
 * Extends WorkspaceMemoryTrace with tool call specific fields.
 */
export interface ToolCallMemoryTrace extends WorkspaceMemoryTrace {
  // Tool call identification
  toolCallId: string;
  agent: string;
  mode: string;
  toolName: string;
  
  // Enhanced metadata with complete JSON preservation
  metadata: TraceMetadata & {
    // Tool call request data (complete JSON preservation)
    request?: {
      originalParams: Record<string, any>;
      normalizedParams: Record<string, any>;
      workspaceContext?: {
        workspaceId: string;
        sessionId?: string;
        workspacePath?: string[];
      };
      source: 'mcp-client' | 'internal' | 'agent-trigger';
    };
    
    // Tool call response data (complete JSON preservation)
    response?: {
      result: Record<string, any> | null;
      success: boolean;
      error?: {
        type: string;
        message: string;
        code?: string | number;
        stack?: string;
      };
      resultType?: string;
      resultSummary?: string;
      affectedResources?: string[];
    };
    
    // Execution details specific to tool calls
    execution?: {
      agent: string;
      mode: string;
      executionTime: number;
      timestamp: number;
      toolName: string;
    };
  };
  
  // Execution context
  executionContext: {
    timing: {
      startTimestamp: number;
      endTimestamp: number;
      executionTime: number;
    };
    environment: {
      pluginVersion: string;
      platform: string;
    };
    userContext: {
      sessionStart: number;
      sessionDuration: number;
      previousToolCalls: number;
    };
    performance: {
      importance: number;
      complexity: number;
      userEngagement: number;
    };
  };
  
  // Relationships
  relationships: {
    relatedFiles: string[];
    affectedResources: string[];
    sessionToolCalls: string[];
    workspaceContext: string[];
  };
  
  // Search optimization
  searchOptimization: {
    searchContent: {
      primary: string;
      keywords: string[];
      entities: string[];
    };
    categories: {
      functionalCategory: string;
      domainCategory: string;
      complexityCategory: string;
      impactCategory: string;
    };
    searchTags: string[];
    searchScoring: {
      recencyScore: number;
      frequencyScore: number;
      successScore: number;
      impactScore: number;
      userEngagementScore: number;
    };
    indexingHints: {
      shouldIndex: boolean;
      indexPriority: 'high' | 'medium' | 'low';
      cacheStrategy: 'session' | 'workspace' | 'global';
      searchFrequency: 'frequent' | 'occasional' | 'rare';
    };
  };
}

/**
 * Tool call performance metrics
 */
export interface ToolCallPerformanceMetrics {
  importance: number;
  complexity: number;
  userEngagement: number;
}

/**
 * Tool call relationships structure
 */
export interface ToolCallRelationships {
  relatedFiles: string[];
  affectedResources: string[];
  sessionToolCalls: string[];
  workspaceContext: string[];
}

/**
 * Search optimization data structure
 */
export interface ToolCallSearchOptimization {
  searchContent: {
    primary: string;
    keywords: string[];
    entities: string[];
  };
  categories: {
    functionalCategory: string;
    domainCategory: string;
    complexityCategory: string;
    impactCategory: string;
  };
  searchTags: string[];
  searchScoring: {
    recencyScore: number;
    frequencyScore: number;
    successScore: number;
    impactScore: number;
    userEngagementScore: number;
  };
  indexingHints: {
    shouldIndex: boolean;
    indexPriority: 'high' | 'medium' | 'low';
    cacheStrategy: 'session' | 'workspace' | 'global';
    searchFrequency: 'frequent' | 'occasional' | 'rare';
  };
}

/**
 * Search result with similarity score
 */
export interface MemoryTraceSearchResult {
  trace: WorkspaceMemoryTrace;
  similarity: number;
}

/**
 * Tool call processing context
 */
export interface ToolCallProcessingContext {
  request: any;
  response: any;
  sessionContext: any;
  shouldIndex: boolean;
  searchContent: string;
  relationships: ToolCallRelationships;
  performanceMetrics: ToolCallPerformanceMetrics;
  searchOptimization: ToolCallSearchOptimization;
}

```

## types/migration/MigrationTypes.ts

```typescript
// Location: src/types/migration/MigrationTypes.ts
// Core type definitions for the simplified JSON-based data architecture
// Used by: DataMigrationService, WorkspaceService, MemoryService, and ConversationService
// Dependencies: Defines the target structure for migration from ChromaDB collections

import { WorkspaceContext } from '../../database/types/workspace/WorkspaceTypes';
import { WorkspaceStateSnapshot } from '../../database/types/session/SessionTypes';

export interface WorkspaceDataStructure {
  workspaces: {
    [workspaceId: string]: {
      // Core workspace info
      id: string;
      name: string;
      description?: string;
      rootFolder: string;
      created: number;
      lastAccessed: number;
      isActive?: boolean;
      context?: WorkspaceContext;

      // Nested sessions
      sessions: {
        [sessionId: string]: {
          id: string;
          name?: string;
          description?: string;
          startTime: number;
          endTime?: number;
          isActive: boolean;

          // Nested memory traces
          memoryTraces: {
            [traceId: string]: {
              id: string;
              timestamp: number;
              type: string;
              content: string;
              metadata?: {
                tool?: string;
                params?: any;
                result?: any;
                relatedFiles?: string[];
              };
            };
          };

          // Nested states
          states: {
            [stateId: string]: {
              id: string;
              name: string;
              created: number;
              snapshot: WorkspaceStateSnapshot;
            };
          };
        };
      };
    };
  };

  metadata: {
    version: string;
    lastUpdated: number;
    migrationCompleted?: number;
  };
}

export interface ConversationDataStructure {
  conversations: {
    [conversationId: string]: {
      id: string;
      title: string;
      created: number;
      updated: number;
      vault_name: string;
      message_count: number;

      messages: Array<{
        id: string;
        role: 'user' | 'assistant' | 'tool';
        content: string;
        timestamp: number;
        toolName?: string;
        toolParams?: any;
        toolResult?: any;
      }>;
    };
  };

  metadata: {
    version: string;
    lastUpdated: number;
    totalConversations: number;
  };
}

export interface WorkspaceSearchIndex {
  byName: Record<string, string[]>;
  byDescription: Record<string, string[]>;
  byFolder: Record<string, string>;
  sessionsByWorkspace: Record<string, string[]>;
  sessionsByName: Record<string, string[]>;
  tracesByTool: Record<string, string[]>;
  tracesByType: Record<string, string[]>;
  lastUpdated: number;
}

export interface ConversationSearchIndex {
  byTitle: Record<string, string[]>;
  byContent: Record<string, string[]>;
  byVault: Record<string, string[]>;
  byDateRange: Array<{
    start: number;
    end: number;
    conversationIds: string[];
  }>;
  lastUpdated: number;
}
```

## types/pagination/index.ts

```typescript
/**
 * Pagination Types Export Barrel
 *
 * Location: src/types/pagination/index.ts
 * Purpose: Centralized export for pagination types
 */

export type {
  PaginationParams,
  PaginatedResult
} from './PaginationTypes';

export {
  createEmptyPaginatedResult,
  calculatePaginationMetadata
} from './PaginationTypes';

```

## types/pagination/PaginationTypes.ts

```typescript
/**
 * Pagination Types
 *
 * Location: src/types/pagination/PaginationTypes.ts
 * Purpose: Common pagination types used throughout the application
 * Used by: Storage adapters, API services, UI components
 *
 * Provides standardized pagination interfaces for consistent data fetching
 * across different storage backends (SQLite, JSONL, in-memory).
 */

/**
 * Pagination parameters for requesting paginated data
 *
 * @property page - The page number (0-indexed)
 * @property pageSize - Number of items per page
 * @property cursor - Optional cursor for cursor-based pagination
 */
export interface PaginationParams {
  /** Page number (0-indexed) */
  page?: number;

  /** Number of items per page */
  pageSize?: number;

  /** Optional cursor for cursor-based pagination */
  cursor?: string;
}

/**
 * Paginated result containing items and metadata
 *
 * @template T - The type of items in the result
 */
export interface PaginatedResult<T> {
  /** Array of items for the current page */
  items: T[];

  /** Current page number (0-indexed) */
  page: number;

  /** Number of items per page */
  pageSize: number;

  /** Total number of items across all pages */
  totalItems: number;

  /** Total number of pages */
  totalPages: number;

  /** Whether there is a next page available */
  hasNextPage: boolean;

  /** Whether there is a previous page available */
  hasPreviousPage: boolean;

  /** Optional cursor for the next page (cursor-based pagination) */
  nextCursor?: string;

  /** Optional cursor for the previous page (cursor-based pagination) */
  previousCursor?: string;
}

/**
 * Helper to create an empty paginated result
 */
export function createEmptyPaginatedResult<T>(
  page: number = 0,
  pageSize: number = 10
): PaginatedResult<T> {
  return {
    items: [],
    page,
    pageSize,
    totalItems: 0,
    totalPages: 0,
    hasNextPage: false,
    hasPreviousPage: false
  };
}

/**
 * Helper to calculate pagination metadata
 */
export function calculatePaginationMetadata(
  page: number,
  pageSize: number,
  totalItems: number
): Omit<PaginatedResult<any>, 'items'> {
  const totalPages = Math.ceil(totalItems / pageSize);

  return {
    page,
    pageSize,
    totalItems,
    totalPages,
    hasNextPage: page < totalPages - 1,
    hasPreviousPage: page > 0
  };
}

/**
 * Type guard to check if a value is a PaginatedResult
 */
export function isPaginatedResult<T>(
  value: T[] | PaginatedResult<T>
): value is PaginatedResult<T> {
  return value !== null &&
    typeof value === 'object' &&
    'items' in value &&
    'page' in value &&
    Array.isArray((value as PaginatedResult<T>).items);
}

/**
 * Helper to normalize a union type result to an array
 * Extracts .items from PaginatedResult or returns array as-is
 *
 * @param result - Either an array or a PaginatedResult
 * @returns The items as an array
 */
export function normalizeToArray<T>(result: T[] | PaginatedResult<T>): T[] {
  if (isPaginatedResult(result)) {
    return result.items;
  }
  return result;
}

/**
 * Helper to get total count from a union type result
 * Returns totalItems from PaginatedResult or array length
 *
 * @param result - Either an array or a PaginatedResult
 * @returns The total count
 */
export function getTotalCount<T>(result: T[] | PaginatedResult<T>): number {
  if (isPaginatedResult(result)) {
    return result.totalItems;
  }
  return result.length;
}

```

## types/plugin/index.ts

```typescript
/**
 * Plugin-related types export barrel
 * Centralizes all plugin configuration type exports
 */

export type {
  MCPSettings
} from './PluginTypes';
```

## types/plugin/PluginTypes.ts

```typescript
/**
 * Plugin Configuration Types
 * Extracted from types.ts for better organization
 */

import { CustomPromptsSettings } from '../mcp/CustomPromptTypes';
import { LLMProviderSettings } from '../llm/ProviderTypes';

// Memory management settings
interface MemorySettings {
  // Workspace management interface
}

interface ProcessedFileState {
  filePath: string;
  lastModified: number;
  contentHash: string;
  processed: boolean;
}

/**
 * Processed files data structure for file state management
 * Stores file processing state to prevent re-processing on startup
 */
export interface ProcessedFilesData {
  version: string;
  lastUpdated: number;
  files: Record<string, ProcessedFileState>;
}

/**
 * Plugin settings interface
 * Includes vault access toggle and version tracking
 */
export interface MCPSettings {
  enabledVault: boolean;
  configFilePath?: string;
  memory?: MemorySettings;
  customPrompts?: CustomPromptsSettings;
  llmProviders?: LLMProviderSettings;
  // Default selections for chat
  defaultWorkspaceId?: string;
  defaultPromptId?: string;
  defaultContextNotes?: string[];
  // Update tracking
  lastUpdateVersion?: string;
  lastUpdateDate?: string;
  availableUpdateVersion?: string;
  lastUpdateCheckDate?: string;
  processedFiles?: ProcessedFilesData;
}
```

## types/search/FuzzySearchTypes.ts

```typescript
/**
 * FuzzySearchTypes - Type definitions for fuzzy search functionality with typo tolerance and similarity matching
 * Location: src/types/search/FuzzySearchTypes.ts
 * Usage: Provides type safety for fuzzy search operations across the application
 */

export interface FuzzySearchResult {
  id: string;
  title: string;
  snippet: string;
  score: number;
  searchMethod: 'fuzzy';
  metadata: FuzzySearchMetadata;
  content?: string;
}

export interface FuzzySearchMetadata {
  filePath: string;
  fileId: string;
  timestamp: number;
  fuzzyMatches: FuzzyMatch[];
  editDistance: number;
  similarity: number;
  // Enhanced quality metadata
  qualityTier?: FuzzyQualityTier;
  confidenceLevel?: number;
  matchType?: string;
  qualityDescription?: string;
  matchCount?: number;
  searchTermCount?: number;
  matchRatio?: number;
  averageEditDistance?: number;
  exactMatches?: number;
  typoMatches?: number;
  phoneticMatches?: number;
  scoreMethod?: string;
}

export interface FuzzyMatch {
  original: string;
  matched: string;
  distance: number;
  similarity: number;
  matchType: FuzzyMatchType;
}

export interface FuzzyDocument {
  id: string;
  title: string;
  content: string;
  filePath: string;
  metadata: Record<string, any>;
}

export interface FuzzyMatchResult {
  score: number;
  matches: FuzzyMatch[];
  totalDistance: number;
}

export interface FuzzyQualityAssessment {
  tier: FuzzyQualityTier;
  confidence: number;
  matchType: string;
  description: string;
}

export interface FuzzySearchStats {
  totalDocuments: number;
  cachedStems: number;
  synonymMappings: number;
  scoreBasedRanking?: boolean;
}

export interface FuzzySearchOptions {
  limit?: number;
  threshold?: number;
  useScoreBasedRanking?: boolean;
  maxEditDistance?: number;
  minSimilarity?: number;
}

export interface FuzzyQualityDistribution {
  high: number;
  medium: number;
  low: number;
  minimal: number;
}

// Type enums
export type FuzzyMatchType = 'typo' | 'stem' | 'synonym' | 'phonetic';
export type FuzzyQualityTier = 'high' | 'medium' | 'low' | 'minimal';

// Constants for fuzzy search configuration
export const FUZZY_SEARCH_DEFAULTS = {
  LIMIT: 10,
  THRESHOLD: 0.6,
  MIN_WORD_LENGTH: 3,
  MAX_EDIT_DISTANCE_RATIO: 0.3,
  SNIPPET_MAX_LENGTH: 300,
  WINDOW_SIZE: 50,
  TOP_MATCHES_PER_TERM: 3,
  MIN_STEM_LENGTH: 3,
  SOUNDEX_LENGTH: 4,
  SCORE_THRESHOLDS: {
    HIGH_EXACT: 0.95,
    HIGH_TYPO: 0.8,
    MEDIUM: 0.6,
    LOW: 0.4
  },
  SIMILARITY_WEIGHTS: {
    EXACT: 1.0,
    STEM: 0.9,
    SYNONYM: 0.8,
    PHONETIC: 0.7,
    TYPO_MIN: 0.6
  }
} as const;

// Utility type for internal search operations
export interface FuzzySearchContext {
  searchTerms: string[];
  useThresholdFiltering: boolean;
  qualityDistribution?: FuzzyQualityDistribution;
}

// Type for synonym mappings
export type SynonymMappings = Record<string, string[]>;

// Type for stem cache
export type StemCache = Map<string, string>;

// Type for soundex character mappings
export type SoundexMapping = Record<string, string>;

// Type guards
export function isFuzzySearchResult(obj: any): obj is FuzzySearchResult {
  return obj && 
    typeof obj.id === 'string' && 
    typeof obj.title === 'string' && 
    typeof obj.snippet === 'string' && 
    typeof obj.score === 'number' && 
    obj.searchMethod === 'fuzzy' &&
    obj.metadata &&
    Array.isArray(obj.metadata.fuzzyMatches);
}

export function isFuzzyMatch(obj: any): obj is FuzzyMatch {
  return obj &&
    typeof obj.original === 'string' &&
    typeof obj.matched === 'string' &&
    typeof obj.distance === 'number' &&
    typeof obj.similarity === 'number' &&
    ['typo', 'stem', 'synonym', 'phonetic'].includes(obj.matchType);
}

export function isFuzzyDocument(obj: any): obj is FuzzyDocument {
  return obj &&
    typeof obj.id === 'string' &&
    typeof obj.title === 'string' &&
    typeof obj.content === 'string' &&
    typeof obj.filePath === 'string' &&
    obj.metadata &&
    typeof obj.metadata === 'object';
}
```

## types/search/index.ts

```typescript
/**
 * Search Types
 * Provides type definitions for search operations using Obsidian's native search
 */

export type {
  MemoryQueryParams,
  MemoryQueryResult
} from './SearchTypes';

export * from './SearchResults';
```

## types/search/SearchResults.ts

```typescript
/**
 * SearchResults.ts - Type definitions for search result interfaces
 * Location: src/types/search/SearchResults.ts
 * Purpose: Provides standardized interfaces for search results across all search services
 * Used by: HybridSearchService, SearchMetrics, ResultFusion, and QueryCoordinator
 */

export interface SearchResult {
  /** Unique result identifier */
  id: string;
  
  /** Result title */
  title: string;
  
  /** Content snippet or excerpt */
  snippet: string;
  
  /** Relevance score (0-1) */
  score: number;
  
  /** Search method that produced this result */
  searchMethod: 'semantic' | 'keyword' | 'fuzzy' | 'hybrid';
  
  /** Result metadata */
  metadata: SearchResultMetadata;
  
  /** Full content (optional) */
  content?: string;
  
  /** File path if applicable */
  filePath?: string;
}

export interface SearchResultMetadata {
  /** File path */
  filePath: string;
  
  /** File identifier */
  fileId: string;
  
  /** Result timestamp */
  timestamp: number;
  
  /** Content type */
  type?: string;
  
  /** Search method */
  searchMethod?: string;
  
  /** Quality tier classification */
  qualityTier?: 'high' | 'medium' | 'low' | 'minimal';
  
  /** Confidence level (0-1) */
  confidenceLevel?: number;
  
  /** Match type description */
  matchType?: string;
  
  /** Quality description */
  qualityDescription?: string;
  
  /** Score calculation method */
  scoreMethod?: string;
  
  /** Additional metadata */
  [key: string]: any;
}

export interface HybridSearchResult extends SearchResult {
  /** Always 'hybrid' for hybrid search results */
  searchMethod: 'hybrid';
  
  /** Original search methods that contributed to this result */
  originalMethods: string[];
  
  /** Enhanced hybrid-specific metadata */
  metadata: HybridSearchResultMetadata;
}

export interface HybridSearchResultMetadata extends SearchResultMetadata {
  /** Hybrid fusion score */
  hybridScore: number;
  
  /** Scores from individual search methods */
  methodScores: MethodScores;
  
  /** Content type boost applied */
  contentTypeBoost: number;
  
  /** Exact match boost applied */
  exactMatchBoost: number;
  
  /** Final ranking position */
  finalRank: number;
}

export interface MethodScores {
  semantic?: number;
  keyword?: number;
  fuzzy?: number;
}

export interface SearchResultSet {
  /** Search results */
  results: SearchResult[];
  
  /** Weight for fusion (0-1) */
  weight: number;
  
  /** Result set type identifier */
  type: string;
  
  /** Execution time in milliseconds */
  executionTime?: number;
  
  /** Search method */
  method: string;
  
  /** Additional metadata */
  metadata?: Record<string, any>;
}

export interface SearchOptions {
  /** Maximum number of results to return */
  limit?: number;
  
  /** Include full content in results */
  includeContent?: boolean;
  
  /** Force semantic search even if weights suggest otherwise */
  forceSemanticSearch?: boolean;
  
  /** Minimum keyword search threshold */
  keywordThreshold?: number;
  
  /** Minimum fuzzy search threshold */
  fuzzyThreshold?: number;
  
  /** Query type hint */
  queryType?: 'exact' | 'conceptual' | 'exploratory' | 'mixed';
  
  /** Search timeout in milliseconds */
  timeout?: number;
  
  /** Enable result caching */
  enableCaching?: boolean;
  
  /** Minimum score threshold for results */
  scoreThreshold?: number;
}

export interface CachedSearchResult {
  /** Cached search results */
  results: HybridSearchResult[];
  
  /** Cache timestamp */
  timestamp: number;
  
  /** Original query */
  query: string;
  
  /** Cache key */
  key: string;
  
  /** Cache hit count */
  hits?: number;
}

export interface SearchContext {
  /** Search session identifier */
  sessionId?: string;
  
  /** User preferences */
  preferences?: Record<string, any>;
  
  /** Search filters */
  filters?: Record<string, any>;
  
  /** Additional context data */
  metadata?: Record<string, any>;
}

export interface RerankItem {
  /** Item identifier */
  id: string;
  
  /** Item score */
  score: number;
  
  /** Search method */
  method: string;
  
  /** Original ranking position */
  rank?: number;
}

export interface FusionOptions {
  /** Fusion strategy to use */
  strategy?: 'rrf' | 'weighted' | 'simple';
  
  /** RRF k parameter */
  k?: number;
  
  /** Custom weights per result type */
  typeWeights?: Record<string, number>;
  
  /** Maximum results after fusion */
  maxResults?: number;
  
  /** Score threshold after fusion */
  scoreThreshold?: number;
}

export interface RankingStrategy {
  /** Ranking algorithm */
  algorithm: 'rrf' | 'weighted' | 'linear';
  
  /** Algorithm parameters */
  parameters: Record<string, any>;
}
```

## types/search/SearchTypes.ts

```typescript
/**
 * Search and Memory Query Types
 * Extracted from types.ts for better organization
 */

/**
 * Memory storage types (JSON-based storage)
 */

export interface MemoryQueryParams {
  query: string;         
  limit?: number;        
  threshold?: number;    
  filters?: {            
    tags?: string[];     
    paths?: string[];    
    properties?: Record<string, any>;
    dateRange?: {        
      start?: string;
      end?: string;
    }
  },
  graphOptions?: {
    useGraphBoost: boolean;
    boostFactor: number;
    includeNeighbors: boolean;
    maxDistance: number;
    seedNotes?: string[];
  }
}

export interface MemoryQueryResult {
  matches: Array<{
    content: string;
    filePath: string;
    lineStart: number;
    lineEnd: number;
    metadata: {
      frontmatter: Record<string, any>;
      tags: string[];
      links: {
        outgoing: Array<{
          displayText: string;
          targetPath: string;
        }>;
        incoming: Array<{
          sourcePath: string;
          displayText: string;
        }>;
      }
    }
  }>
}


```

## types/storage/HybridStorageTypes.ts

```typescript
/**
 * Hybrid Storage Types
 *
 * Location: src/types/storage/HybridStorageTypes.ts
 * Purpose: Type definitions for the hybrid JSONL + SQLite storage system
 * Used by: Storage adapters, sync services, database backends
 *
 * This file defines all types for the hybrid storage architecture where:
 * - JSONL files are the source of truth (synced via Obsidian Sync)
 * - SQLite is a local cache for fast queries and true pagination
 * - All storage lives in `.nexus/` folder in the vault
 */

// ============================================================================
// Device and Sync Types
// ============================================================================

/**
 * Device identification for multi-device sync tracking
 *
 * Each device running the plugin gets a unique ID for conflict resolution
 * and sync state management.
 */
export interface DeviceInfo {
  /** Unique identifier for this device */
  deviceId: string;

  /** Optional human-readable device name */
  deviceName?: string;

  /** Timestamp of last activity from this device */
  lastSeen: number;
}

/**
 * Sync state tracking for incremental synchronization
 *
 * Tracks which events have been processed to enable efficient sync
 * between JSONL source of truth and SQLite cache.
 */
export interface SyncState {
  /** Device ID that owns this sync state */
  deviceId: string;

  /** Timestamp of the last processed event */
  lastEventTimestamp: number;

  /** Map of filename to last processed timestamp for each JSONL file */
  lastSyncedFiles: Record<string, number>;
}

// ============================================================================
// Workspace Types
// ============================================================================

/**
 * Workflow definition for workspace automation
 */
export interface WorkspaceWorkflow {
  /** Workflow name (e.g., "New Application", "Follow-up") */
  name: string;

  /** When to use this workflow (e.g., "When applying to new position") */
  when: string;

  /** Steps in the workflow (newline-separated) */
  steps: string;
}

/**
 * Workspace context for LLM understanding and workflow automation
 *
 * Contains purpose, goals, workflows, and preferences that help
 * the LLM understand what the user is trying to accomplish.
 */
export interface WorkspaceContext {
  /** What is this workspace for? */
  purpose?: string;

  /** Workflows for different situations */
  workflows?: WorkspaceWorkflow[];

  /** Key files for quick reference (paths) */
  keyFiles?: string[];

  /** User preferences as actionable guidelines */
  preferences?: string;

  /** Single dedicated agent for this workspace */
  dedicatedAgent?: {
    agentId: string;
    agentName: string;
  };
}

/**
 * Workspace metadata for organizational context
 *
 * Workspaces provide organizational boundaries for sessions, states,
 * and memory traces. They typically map to projects or areas of work.
 */
export interface WorkspaceMetadata {
  /** Unique workspace identifier (UUID) */
  id: string;

  /** Human-readable workspace name */
  name: string;

  /** Optional description of workspace purpose */
  description?: string;

  /** Root folder path in the vault */
  rootFolder: string;

  /** Timestamp when workspace was created */
  created: number;

  /** Timestamp of last access */
  lastAccessed: number;

  /** Whether this workspace is currently active */
  isActive: boolean;

  /** Whether this workspace is archived */
  isArchived?: boolean;

  /** Optional dedicated agent ID for this workspace */
  dedicatedAgentId?: string;

  /** Optional workspace context (purpose, workflows, keyFiles, etc.) */
  context?: WorkspaceContext;
}

// ============================================================================
// Session Types
// ============================================================================

/**
 * Session metadata for temporal context tracking
 *
 * Sessions represent periods of focused work within a workspace.
 * They contain states and memory traces.
 */
export interface SessionMetadata {
  /** Unique session identifier (UUID) */
  id: string;

  /** Parent workspace ID */
  workspaceId: string;

  /** Human-readable session name */
  name: string;

  /** Optional description of session purpose or goals */
  description?: string;

  /** Timestamp when session started */
  startTime: number;

  /** Optional timestamp when session ended */
  endTime?: number;

  /** Whether this session is currently active */
  isActive: boolean;
}

// ============================================================================
// State Types
// ============================================================================

/**
 * State metadata for workspace state snapshots
 *
 * States are named snapshots of workspace context that can be
 * resumed later. They contain the full context needed to continue work.
 */
export interface StateMetadata {
  /** Unique state identifier (UUID) */
  id: string;

  /** Parent session ID */
  sessionId: string;

  /** Parent workspace ID (denormalized for faster queries) */
  workspaceId: string;

  /** Human-readable state name */
  name: string;

  /** Optional description of what this state represents */
  description?: string;

  /** Timestamp when state was created */
  created: number;

  /** Whether this state is archived */
  isArchived?: boolean;

  /** Optional tags for categorization */
  tags?: string[];
}

/**
 * Full state data including metadata and content
 *
 * This is the complete state object stored in JSONL files.
 */
export interface StateData extends StateMetadata {
  /** The actual state content (workspace structure, files, etc.) */
  content: any;
}

// ============================================================================
// Conversation Types (OpenAI Fine-tuning Compatible)
// ============================================================================

/**
 * Conversation metadata for chat conversations
 *
 * Tracks metadata about conversations for listing, searching,
 * and organizing chat history. Compatible with OpenAI fine-tuning format.
 */
export interface ConversationMetadata {
  /** Unique conversation identifier (UUID) */
  id: string;

  /** Conversation title (auto-generated or user-provided) */
  title: string;

  /** Timestamp when conversation was created */
  created: number;

  /** Timestamp of last update */
  updated: number;

  /** Name of the vault this conversation belongs to */
  vaultName: string;

  /** Total number of messages in conversation */
  messageCount: number;

  /** Optional workspace association */
  workspaceId?: string;

  /** Optional session association */
  sessionId?: string;

  /** Optional additional metadata (stored as JSON) */
  metadata?: Record<string, any>;
}

/**
 * Alternative message for branching support
 *
 * When a user retries/regenerates a response, the new response is stored
 * as an alternative rather than replacing the original. This enables
 * navigation between different response versions.
 */
export interface AlternativeMessage {
  /** Unique identifier for this alternative */
  id: string;

  /** Alternative content */
  content: string | null;

  /** Timestamp when alternative was created */
  timestamp: number;

  /** Tool calls made in this alternative */
  toolCalls?: ToolCall[];

  /** Reasoning/thinking content for this alternative */
  reasoning?: string;

  /** Message lifecycle state */
  state: 'draft' | 'streaming' | 'complete' | 'aborted' | 'invalid';
}

/**
 * Message data in OpenAI format
 *
 * Compatible with OpenAI's chat completion and fine-tuning APIs.
 * Stored in JSONL files for easy export and training.
 */
export interface MessageData {
  /** Unique message identifier (UUID) */
  id: string;

  /** Parent conversation ID */
  conversationId: string;

  /** Message role */
  role: 'system' | 'user' | 'assistant' | 'tool';

  /** Message content (null for tool calls) */
  content: string | null;

  /** Timestamp when message was created */
  timestamp: number;

  /** Message lifecycle state */
  state: 'draft' | 'streaming' | 'complete' | 'aborted' | 'invalid';

  /** Sequence number for ordering messages */
  sequenceNumber: number;

  /** Optional tool calls made by assistant */
  toolCalls?: ToolCall[];

  /** Optional tool call ID this message responds to */
  toolCallId?: string;

  /** Optional reasoning/thinking content from LLMs */
  reasoning?: string;

  /** Optional metadata */
  metadata?: Record<string, any>;

  /** Alternative responses for branching (retry/regenerate creates alternatives) */
  alternatives?: AlternativeMessage[];

  /** Which alternative is active: 0 = original, 1+ = alternative index + 1 */
  activeAlternativeIndex?: number;
}

/**
 * Tool call structure (OpenAI format with extended properties)
 */
export interface ToolCall {
  /** Unique tool call identifier */
  id: string;

  /** Tool call type (always 'function' for now) */
  type: 'function';

  /** Function call details */
  function: {
    /** Function/tool name */
    name: string;

    /** JSON-encoded arguments */
    arguments: string;
  };

  /** Direct tool name (alternative to function.name) */
  name?: string;

  /** Tool parameters as object (alternative to function.arguments) */
  parameters?: Record<string, unknown>;

  /** Optional result from tool execution */
  result?: unknown;

  /** Whether tool execution succeeded */
  success?: boolean;

  /** Optional error message */
  error?: string;

  /** Execution time in milliseconds */
  executionTime?: number;
}

// ============================================================================
// Memory Trace Types
// ============================================================================

/**
 * Memory trace data for session activity tracking
 *
 * Traces record significant events, decisions, and context during a session.
 * They provide a searchable history of workspace activity.
 */
export interface MemoryTraceData {
  /** Unique trace identifier (UUID) */
  id: string;

  /** Parent session ID */
  sessionId: string;

  /** Parent workspace ID (denormalized for faster queries) */
  workspaceId: string;

  /** Timestamp when trace was created */
  timestamp: number;

  /** Optional trace type for categorization */
  type?: string;

  /** Trace content (text, JSON, etc.) */
  content: string;

  /** Optional metadata for additional context */
  metadata?: Record<string, any>;
}

// ============================================================================
// Export Types
// ============================================================================

/**
 * Filter options for exporting conversations
 *
 * Used to select which conversations to include in exports
 * (for fine-tuning, backup, analysis, etc.)
 */
export interface ExportFilter {
  /** Optional start date filter (timestamp) */
  startDate?: number;

  /** Optional end date filter (timestamp) */
  endDate?: number;

  /** Optional specific conversation IDs to export */
  conversationIds?: string[];

  /** Whether to include system messages */
  includeSystem?: boolean;

  /** Whether to include tool messages */
  includeTools?: boolean;

  /** Optional workspace filter */
  workspaceId?: string;
}

/**
 * Complete data export structure
 *
 * Used for full vault backup and migration between devices.
 */
export interface ExportData {
  /** Export format version for compatibility */
  version: string;

  /** Timestamp when export was created */
  exportedAt: number;

  /** Device that created the export */
  deviceId: string;

  /** Exported workspaces with full data */
  workspaces: WorkspaceExportData[];

  /** Exported conversations with full message history */
  conversations: ConversationExportData[];
}

/**
 * Workspace export data
 */
export interface WorkspaceExportData {
  /** Workspace metadata */
  metadata: WorkspaceMetadata;

  /** All sessions in this workspace */
  sessions: SessionMetadata[];

  /** All states in this workspace */
  states: StateData[];

  /** All memory traces in this workspace */
  traces: MemoryTraceData[];
}

/**
 * Conversation export data
 */
export interface ConversationExportData {
  /** Conversation metadata */
  metadata: ConversationMetadata;

  /** All messages in this conversation */
  messages: MessageData[];
}

// ============================================================================
// Query Result Types
// ============================================================================

/**
 * Search result for full-text search operations
 */
export interface SearchResult<T> {
  /** The matched item */
  item: T;

  /** Relevance score (0-1) */
  score: number;

  /** Highlighted snippets showing matches */
  highlights?: string[];

  /** Which fields matched */
  matchedFields?: string[];
}

/**
 * Sync operation result
 */
export interface SyncResult {
  /** Whether sync completed successfully */
  success: boolean;

  /** Number of events applied during sync */
  eventsApplied: number;

  /** Number of events skipped (already applied) */
  eventsSkipped: number;

  /** Any errors encountered during sync */
  errors: string[];

  /** Timestamp of last successfully synced event */
  lastSyncTimestamp: number;

  /** Files processed during sync */
  filesProcessed: string[];

  /** Duration of sync operation in milliseconds */
  duration: number;
}

// ============================================================================
// Storage Event Types (for JSONL event sourcing)
// ============================================================================

/**
 * Base event structure for event sourcing
 *
 * All changes to data are recorded as events in JSONL files.
 */
export interface StorageEvent {
  /** Unique event identifier (UUID) */
  id: string;

  /** Event type (e.g., 'workspace.created', 'message.added') */
  type: string;

  /** Timestamp when event occurred */
  timestamp: number;

  /** Device that generated this event */
  deviceId: string;

  /** Event payload (varies by event type) */
  payload: any;

  /** Optional metadata */
  metadata?: Record<string, any>;
}

/**
 * Event types for type-safe event handling
 */
export type StorageEventType =
  | 'workspace.created'
  | 'workspace.updated'
  | 'workspace.deleted'
  | 'session.created'
  | 'session.updated'
  | 'session.ended'
  | 'state.created'
  | 'state.updated'
  | 'state.deleted'
  | 'conversation.created'
  | 'conversation.updated'
  | 'conversation.deleted'
  | 'message.added'
  | 'message.updated'
  | 'trace.added';

```

## types/storage/index.ts

```typescript
/**
 * Storage Types Export Barrel
 *
 * Location: src/types/storage/index.ts
 * Purpose: Centralized export for hybrid storage types
 */

export type {
  DeviceInfo,
  SyncState,
  WorkspaceMetadata,
  SessionMetadata,
  StateMetadata,
  StateData,
  ConversationMetadata,
  MessageData,
  ToolCall,
  MemoryTraceData,
  ExportFilter,
  ExportData,
  WorkspaceExportData,
  ConversationExportData,
  SearchResult,
  SyncResult,
  StorageEvent,
  StorageEventType
} from './HybridStorageTypes';

```

## types/storage/StorageTypes.ts

```typescript
// Location: src/types/storage/StorageTypes.ts
// Type definitions for the split storage architecture
// Used by: FileSystemService, IndexManager, ConversationService, WorkspaceService
// Dependencies: Replaces monolithic data structures with individual file formats

import { WorkspaceContext } from '../../database/types/workspace/WorkspaceTypes';
import { WorkspaceState } from '../../database/types/session/SessionTypes';
import { TraceMetadata } from '../../database/types/memory/MemoryTypes';
import { PaginatedResult } from '../pagination/PaginationTypes';
import type { ConversationBranch } from '../branch/BranchTypes';

/**
 * Individual conversation file structure (conversations/{id}.json)
 */
export interface IndividualConversation {
  id: string;
  title: string;
  created: number;
  updated: number;
  vault_name: string;
  message_count: number;
  messages: ConversationMessage[];
  cost?: {
    totalCost: number;
    currency: string;
  };
  metadata?: {
    chatSettings?: {
      providerId?: string;
      modelId?: string;
      agentId?: string;
      workspaceId?: string;
      contextNotes?: string[];
      sessionId?: string;
      temperature?: number; // 0.0-1.0, per-conversation override
    };
    // Conversation-level cost aggregation (legacy)
    cost?: {
      totalCost: number;
      currency: string;
    };
    totalCost?: number;
    totalTokens?: number;
    currency?: string;
    // Branch support (Dec 2025): when set, this conversation is a branch
    parentConversationId?: string;  // The parent conversation this branched from
    parentMessageId?: string;       // The specific message this branched from
    branchType?: 'subagent' | 'alternative';  // Type of branch
    subagentTask?: string;          // For subagent branches: the task description
    inheritContext?: boolean;       // Whether to include parent context (true for human, false for subagent)
    subagent?: {                    // Subagent-specific metadata
      task?: string;
      subagentId?: string;
      state?: string;
      iterations?: number;
      maxIterations?: number;
      startedAt?: number;
      completedAt?: number;
    };
    // Responses API state (OpenAI/LM Studio): persisted for conversation continuity across restarts
    responsesApiId?: string;
  };
  // Optional pagination metadata when messages are loaded with pagination
  messagePagination?: PaginatedResult<ConversationMessage>;
}

/**
 * Conversation message structure
 */
export interface ConversationMessage {
  id: string;
  role: 'user' | 'assistant' | 'tool';
  content: string;
  timestamp: number;
  state?: 'draft' | 'streaming' | 'complete' | 'aborted' | 'invalid'; // Message lifecycle state
  toolCalls?: ToolCall[];
  toolName?: string;
  toolParams?: Record<string, unknown>;
  toolResult?: unknown;

  // Tool response context
  toolCallId?: string;

  // Reasoning/thinking content from LLMs (Claude, GPT-5, Gemini)
  reasoning?: string;

  // Message branching support (legacy - being migrated to branches)
  alternatives?: ConversationMessage[];
  activeAlternativeIndex?: number;

  // Unified branch model (replaces alternatives)
  branches?: ConversationBranch[];

  // Cost tracking (primarily for assistant messages)
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  cost?: {
    totalCost: number;
    currency: string;
  };
  provider?: string;
  model?: string;
}

/**
 * Tool call structure
 */
export interface ToolCall {
  id: string;
  type: string;
  name: string;
  function?: {
    name: string;
    arguments: string;
  };
  parameters?: Record<string, unknown>;
  result?: unknown;
  success?: boolean;
  error?: string;
  executionTime?: number;
}

/**
 * Conversation metadata for index (lightweight - NO messages)
 */
export interface ConversationMetadata {
  id: string;
  title: string;
  created: number;
  updated: number;
  vault_name: string;
  message_count: number;
}

/**
 * Full conversation index structure (conversations/index.json)
 */
export interface ConversationIndex {
  conversations: Record<string, ConversationMetadata>;
  byTitle: Record<string, string[]>;
  byContent: Record<string, string[]>;
  byVault: Record<string, string[]>;
  byDateRange: Array<{
    start: number;
    end: number;
    conversationIds: string[];
  }>;
  lastUpdated: number;
}

/**
 * Individual workspace file structure (workspaces/{id}.json)
 */
export interface IndividualWorkspace {
  id: string;
  name: string;
  description?: string;
  rootFolder: string;
  created: number;
  lastAccessed: number;
  isActive?: boolean;
  isArchived?: boolean;
  context?: WorkspaceContext;
  sessions: Record<string, SessionData>;
}

/**
 * Session data nested within workspace
 */
export interface SessionData {
  id: string;
  name?: string;
  description?: string;
  startTime: number;
  endTime?: number;
  isActive: boolean;
  memoryTraces: Record<string, MemoryTrace>;
  states: Record<string, StateData>;
}

/**
 * Memory trace within session
 */
export interface MemoryTrace {
  id: string;
  timestamp: number;
  type: string;
  content: string;
  metadata?: TraceMetadata;
}

/**
 * State data within session
 */
export interface StateData {
  id: string;
  name: string;
  description?: string;
  created: number;
  state: WorkspaceState;
}

/**
 * Workspace metadata for index (lightweight - NO sessions)
 */
export interface WorkspaceMetadata {
  id: string;
  name: string;
  description?: string;
  rootFolder: string;
  created: number;
  lastAccessed: number;
  isActive?: boolean;
  sessionCount: number;
  traceCount: number;
}

/**
 * Full workspace index structure (workspaces/index.json)
 */
export interface WorkspaceIndex {
  workspaces: Record<string, WorkspaceMetadata>;
  byName: Record<string, string[]>;
  byDescription: Record<string, string[]>;
  byFolder: Record<string, string>;
  sessionsByWorkspace: Record<string, string[]>;
  lastUpdated: number;
}

```

## ui/chat/builders/ChatLayoutBuilder.ts

```typescript
/**
 * ChatLayoutBuilder - Builds the chat interface DOM structure
 * Location: /src/ui/chat/builders/ChatLayoutBuilder.ts
 *
 * This class is responsible for:
 * - Creating the main chat layout structure
 * - Building header with hamburger, title, and settings buttons
 * - Creating message display, input, and context containers
 * - Building sidebar with conversation list
 * - Auto-hiding experimental warning banner
 *
 * Used by ChatView to build the initial DOM structure,
 * following the Builder pattern for complex UI construction.
 */

import { setIcon } from 'obsidian';

export interface ChatLayoutElements {
  messageContainer: HTMLElement;
  inputContainer: HTMLElement;
  contextContainer: HTMLElement;
  conversationListContainer: HTMLElement;
  newChatButton: HTMLElement;
  settingsButton: HTMLElement;
  chatTitle: HTMLElement;
  hamburgerButton: HTMLElement;
  backdrop: HTMLElement;
  sidebarContainer: HTMLElement;
  loadingOverlay: HTMLElement;
  branchHeaderContainer: HTMLElement;
}

export class ChatLayoutBuilder {
  /**
   * Build the complete chat interface layout
   */
  static buildLayout(container: HTMLElement): ChatLayoutElements {
    container.empty();
    container.addClass('chat-view-container');

    // Create main layout structure
    const chatLayout = container.createDiv('chat-layout');
    const mainContainer = chatLayout.createDiv('chat-main');

    // Experimental warning banner
    this.createWarningBanner(mainContainer);

    // Header
    const { chatTitle, hamburgerButton, settingsButton } = this.createHeader(mainContainer);

    // Branch header container (above messages, separate from message container)
    // This ensures BranchHeader isn't clobbered when MessageDisplay.setConversation() empties the message container
    const branchHeaderContainer = mainContainer.createDiv('nexus-branch-header-container');

    // Main content areas
    const messageContainer = mainContainer.createDiv('message-display-container');
    const inputContainer = mainContainer.createDiv('chat-input-container');
    const contextContainer = mainContainer.createDiv('chat-context-container');

    // Nexus model loading overlay (hidden by default)
    const loadingOverlay = this.createLoadingOverlay(mainContainer);

    // Backdrop and sidebar
    const backdrop = chatLayout.createDiv('chat-backdrop');
    const { sidebarContainer, conversationListContainer, newChatButton } = this.createSidebar(chatLayout);

    return {
      messageContainer,
      inputContainer,
      contextContainer,
      conversationListContainer,
      newChatButton,
      settingsButton,
      chatTitle,
      hamburgerButton,
      backdrop,
      sidebarContainer,
      loadingOverlay,
      branchHeaderContainer
    };
  }

  /**
   * Create Nexus model loading overlay (hidden by default)
   */
  private static createLoadingOverlay(container: HTMLElement): HTMLElement {
    const overlay = container.createDiv('nexus-loading-overlay');
    overlay.addClass('chat-loading-overlay-hidden');

    const content = overlay.createDiv('nexus-loading-content');

    // Animated spinner - using createSvg for safe SVG creation
    const spinner = content.createDiv('nexus-loading-spinner');
    const svg = spinner.createSvg('svg', { attr: { viewBox: '0 0 50 50', class: 'nexus-spinner' } });
    const circle = svg.createSvg('circle', {
      attr: { cx: '25', cy: '25', r: '20', fill: 'none', stroke: 'currentColor', 'stroke-width': '4', 'stroke-linecap': 'round' }
    });
    // Add animations via DOM
    const animate1 = circle.createSvg('animate', {
      attr: { attributeName: 'stroke-dasharray', values: '1,150;90,150;90,150', dur: '1.5s', repeatCount: 'indefinite' }
    });
    const animate2 = circle.createSvg('animate', {
      attr: { attributeName: 'stroke-dashoffset', values: '0;-35;-125', dur: '1.5s', repeatCount: 'indefinite' }
    });

    // Status text
    const statusText = content.createDiv('nexus-loading-status');
    statusText.textContent = 'Loading Nexus model...';
    statusText.dataset.statusEl = 'true';

    // Progress bar
    const progressContainer = content.createDiv('nexus-loading-progress-container');
    const progressBar = progressContainer.createDiv('nexus-loading-progress-bar');
    progressBar.addClass('chat-progress-bar-reset');
    progressBar.dataset.progressEl = 'true';

    // Progress text
    const progressText = content.createDiv('nexus-loading-progress-text');
    progressText.textContent = '0%';
    progressText.dataset.progressTextEl = 'true';

    return overlay;
  }

  /**
   * Create experimental warning banner with auto-hide
   */
  private static createWarningBanner(container: HTMLElement): void {
    const warningBanner = container.createDiv('chat-experimental-warning');

    warningBanner.createEl('span', { cls: 'warning-icon', text: 'âš ï¸' });
    warningBanner.createEl('span', { cls: 'warning-text', text: 'Experimental Feature: Nexus Chat is in beta.' });
    const link = warningBanner.createEl('a', { cls: 'warning-link', text: 'Report issues' });
    link.href = 'https://github.com/ProfSynapse/nexus/issues';
    link.target = '_blank';
    link.rel = 'noopener noreferrer';
    warningBanner.createEl('span', { cls: 'warning-text', text: 'â€¢ Use at your own risk' });

    // Auto-hide warning after 5 seconds
    setTimeout(() => {
      warningBanner.addClass('chat-warning-banner-fadeout');
      setTimeout(() => {
        warningBanner.addClass('chat-loading-overlay-hidden');
      }, 500);
    }, 5000);
  }

  /**
   * Create chat header with hamburger, title, and settings
   */
  private static createHeader(container: HTMLElement): {
    chatTitle: HTMLElement;
    hamburgerButton: HTMLElement;
    settingsButton: HTMLElement;
  } {
    const chatHeader = container.createDiv('chat-header');

    const hamburgerButton = chatHeader.createEl('button', { cls: 'chat-hamburger-button' });
    setIcon(hamburgerButton, 'menu');
    hamburgerButton.setAttribute('aria-label', 'Toggle conversations');

    // Center: Title
    const chatTitle = chatHeader.createDiv('chat-title');
    chatTitle.textContent = 'Nexus Chat';

    // Right: Settings gear icon
    const settingsButton = chatHeader.createEl('button', { cls: 'chat-settings-button' });
    setIcon(settingsButton, 'settings');
    settingsButton.setAttribute('aria-label', 'Chat settings');

    return { chatTitle, hamburgerButton, settingsButton };
  }

  /**
   * Create sidebar with conversation list
   */
  private static createSidebar(container: HTMLElement): {
    sidebarContainer: HTMLElement;
    conversationListContainer: HTMLElement;
    newChatButton: HTMLElement;
  } {
    const sidebarContainer = container.createDiv('chat-sidebar');
    sidebarContainer.addClass('chat-sidebar-hidden');

    const sidebarHeader = sidebarContainer.createDiv('chat-sidebar-header');
    sidebarHeader.createEl('h3', { text: 'Conversations' });
    const newChatButton = sidebarHeader.createEl('button', {
      cls: 'chat-new-button',
      text: '+ New Chat'
    });

    const conversationListContainer = sidebarContainer.createDiv('conversation-list-container');

    return { sidebarContainer, conversationListContainer, newChatButton };
  }
}

```

## ui/chat/ChatView.ts

```typescript
/**
 * ChatView - Clean orchestrator for the chat interface
 * Location: /src/ui/chat/ChatView.ts
 *
 * Coordinates between services, controllers, and UI components following SOLID principles.
 * This class is responsible for initialization, delegation, and high-level event coordination only.
 * Delegates UI construction to ChatLayoutBuilder, event binding to ChatEventBinder,
 * and tool event coordination to ToolEventCoordinator.
 */

import { ItemView, WorkspaceLeaf, Notice } from 'obsidian';
import { ConversationList } from './components/ConversationList';
import { MessageDisplay } from './components/MessageDisplay';
import { ChatInput } from './components/ChatInput';
import { ContextProgressBar } from './components/ContextProgressBar';
import { ChatSettingsModal } from './components/ChatSettingsModal';
import { ChatService } from '../../services/chat/ChatService';
import { ConversationData, ConversationMessage } from '../../types/chat/ChatTypes';
import { MessageEnhancement } from './components/suggesters/base/SuggesterInterfaces';
import type NexusPlugin from '../../main';
import type { WorkspaceService } from '../../services/WorkspaceService';

// Services
import { ConversationManager, ConversationManagerEvents } from './services/ConversationManager';
import { MessageManager, MessageManagerEvents } from './services/MessageManager';
import { ModelAgentManager, ModelAgentManagerEvents } from './services/ModelAgentManager';
import { BranchManager, BranchManagerEvents } from './services/BranchManager';
import { ContextCompactionService } from '../../services/chat/ContextCompactionService';
import { ContextPreservationService } from '../../services/chat/ContextPreservationService';
import { ContextTracker } from './services/ContextTracker';

// Controllers
import { UIStateController, UIStateControllerEvents } from './controllers/UIStateController';
import { StreamingController } from './controllers/StreamingController';
import { NexusLoadingController } from './controllers/NexusLoadingController';
import { SubagentController, SubagentContextProvider } from './controllers/SubagentController';

// Coordinators
import { ToolEventCoordinator } from './coordinators/ToolEventCoordinator';

// Builders and Utilities
import { ChatLayoutBuilder, ChatLayoutElements } from './builders/ChatLayoutBuilder';
import { ChatEventBinder } from './utils/ChatEventBinder';

// Utils
import { ReferenceMetadata } from './utils/ReferenceExtractor';
import { CHAT_VIEW_TYPES } from '../../constants/branding';
import { getNexusPlugin } from '../../utils/pluginLocator';

// Nexus Lifecycle
import { getWebLLMLifecycleManager } from '../../services/llm/adapters/webllm/WebLLMLifecycleManager';

// Subagent infrastructure (delegated to SubagentController)
import type { AgentManager } from '../../services/AgentManager';
import type { DirectToolExecutor } from '../../services/chat/DirectToolExecutor';
import type { PromptManagerAgent } from '../../agents/promptManager/promptManager';
import type { HybridStorageAdapter } from '../../database/adapters/HybridStorageAdapter';

// Branch UI components
import { BranchHeader, BranchViewContext } from './components/BranchHeader';
import { isSubagentMetadata } from '../../types/branch/BranchTypes';

export const CHAT_VIEW_TYPE = CHAT_VIEW_TYPES.current;

export class ChatView extends ItemView {
  // Core components
  private conversationList!: ConversationList;
  private messageDisplay!: MessageDisplay;
  private chatInput!: ChatInput;
  private contextProgressBar!: ContextProgressBar;

  // Services
  private conversationManager!: ConversationManager;
  private messageManager!: MessageManager;
  private modelAgentManager!: ModelAgentManager;
  private branchManager!: BranchManager;
  private compactionService: ContextCompactionService;
  private preservationService: ContextPreservationService | null = null;
  private contextTracker!: ContextTracker;

  // Controllers and Coordinators
  private uiStateController!: UIStateController;
  private streamingController!: StreamingController;
  private nexusLoadingController!: NexusLoadingController;
  private toolEventCoordinator!: ToolEventCoordinator;

  // Subagent infrastructure (delegated to SubagentController)
  private subagentController: SubagentController | null = null;

  // Branch UI state
  private branchHeader: BranchHeader | null = null;
  private currentBranchContext: BranchViewContext | null = null;

  // Parent conversation reference when viewing a branch
  // Used for back navigation - the branch becomes currentConversation when viewing
  private parentConversationId: string | null = null;
  // Scroll position to restore when returning from branch
  private parentScrollPosition: number = 0;

  // Layout elements
  private layoutElements!: ChatLayoutElements;

  constructor(leaf: WorkspaceLeaf, private chatService: ChatService) {
    super(leaf);
    this.compactionService = new ContextCompactionService();
  }

  getViewType(): string {
    return CHAT_VIEW_TYPE;
  }

  getDisplayText(): string {
    const conversation = this.conversationManager?.getCurrentConversation();
    return conversation?.title || 'Nexus Chat';
  }

  getIcon(): string {
    return 'message-square';
  }

  async onOpen(): Promise<void> {
    if (!this.chatService) {
      return;
    }

    try {
      await this.chatService.initialize();

      // Set up tool event callback for live UI updates
      this.chatService.setToolEventCallback((messageId, event, data) => {
        this.handleToolEvent(messageId, event, data);
      });

    } catch (error) {
      // ChatService initialization failed
    }

    this.initializeArchitecture();

    // Check if database is still loading and show overlay
    await this.waitForDatabaseReady();

    await this.loadInitialData();

    // Set up Nexus lifecycle callbacks for loading indicator
    const lifecycleManager = getWebLLMLifecycleManager();
    lifecycleManager.setCallbacks({
      onLoadingStart: () => this.nexusLoadingController.showNexusLoadingOverlay(),
      onLoadingProgress: (progress, stage) => this.nexusLoadingController.updateNexusLoadingProgress(progress, stage),
      onLoadingComplete: () => this.nexusLoadingController.hideNexusLoadingOverlay(),
      onError: (error) => {
        this.nexusLoadingController.hideNexusLoadingOverlay();
        console.error('[ChatView] Nexus loading error:', error);
      }
    });

    // Notify Nexus lifecycle manager that ChatView is open
    // Pass current provider so it can pre-load if Nexus is selected
    const currentProvider = (await this.modelAgentManager.getMessageOptions()).provider;
    console.log('[ChatView] Notifying lifecycle manager with provider:', currentProvider);
    lifecycleManager.handleChatViewOpened(currentProvider).catch((error) => {
      console.error('[ChatView] handleChatViewOpened failed:', error);
    });
  }

  /**
   * Wait for database to be ready, showing loading overlay if needed
   */
  private async waitForDatabaseReady(): Promise<void> {
    const plugin = getNexusPlugin<NexusPlugin>(this.app);
    if (!plugin) return;

    const storageAdapter = await plugin.getService<{ isReady?: () => boolean; waitForReady?: () => Promise<boolean> }>('hybridStorageAdapter');
    if (!storageAdapter) return;

    await this.nexusLoadingController.waitForDatabaseReady(storageAdapter);
  }

  async onClose(): Promise<void> {
    // Notify Nexus lifecycle manager that ChatView is closing
    // This starts the idle timer for potential model unloading
    const lifecycleManager = getWebLLMLifecycleManager();
    lifecycleManager.handleChatViewClosed();

    this.cleanup();
  }

  /**
   * Initialize the clean architecture components
   */
  private initializeArchitecture(): void {
    this.createChatInterface();
    this.initializeServices();
    this.initializeControllers();
    this.initializeComponents();
    this.wireEventHandlers();

    // Initialize subagent infrastructure (async, non-blocking)
    this.initializeSubagentInfrastructure().catch((error) => {
      console.error('[ChatView] Failed to initialize subagent infrastructure:', error);
    });
  }

  /**
   * Create the main chat interface layout using builder
   */
  private createChatInterface(): void {
    const container = this.containerEl.children[1] as HTMLElement;
    this.layoutElements = ChatLayoutBuilder.buildLayout(container);
  }

  /**
   * Initialize business logic services
   */
  private initializeServices(): void {
    // Branch management
    const branchEvents: BranchManagerEvents = {
      onBranchCreated: (messageId: string, branchId: string) => this.handleBranchCreated(messageId, branchId),
      onBranchSwitched: (messageId: string, branchId: string) => this.handleBranchSwitched(messageId, branchId),
      onError: (message) => this.uiStateController.showError(message)
    };
    this.branchManager = new BranchManager(this.chatService.getConversationRepository(), branchEvents);

    // Conversation management
    const conversationEvents: ConversationManagerEvents = {
      onConversationSelected: (conversation) => this.handleConversationSelected(conversation),
      onConversationsChanged: () => this.handleConversationsChanged(),
      onError: (message) => this.uiStateController.showError(message)
    };
    this.conversationManager = new ConversationManager(this.app, this.chatService, this.branchManager, conversationEvents);

    // Message handling
    const messageEvents: MessageManagerEvents = {
      onMessageAdded: (message) => this.messageDisplay.addMessage(message),
      onAIMessageStarted: (message) => this.handleAIMessageStarted(message),
      onStreamingUpdate: (messageId, content, isComplete, isIncremental) =>
        this.handleStreamingUpdate(messageId, content, isComplete, isIncremental),
      onConversationUpdated: (conversation) => this.handleConversationUpdated(conversation),
      onLoadingStateChanged: (loading) => this.handleLoadingStateChanged(loading),
      onError: (message) => this.uiStateController.showError(message),
      onToolCallsDetected: (messageId, toolCalls) => this.toolEventCoordinator.handleToolCallsDetected(messageId, toolCalls),
      onToolExecutionStarted: (messageId, toolCall) => this.toolEventCoordinator.handleToolExecutionStarted(messageId, toolCall),
      onToolExecutionCompleted: (messageId, toolId, result, success, error) =>
        this.toolEventCoordinator.handleToolExecutionCompleted(messageId, toolId, result, success, error),
      onMessageIdUpdated: (oldId, newId, updatedMessage) => this.handleMessageIdUpdated(oldId, newId, updatedMessage),
      onGenerationAborted: (messageId, partialContent) => this.handleGenerationAborted(messageId, partialContent),
      // Token usage tracking for local models with limited context
      onUsageAvailable: (usage) => this.modelAgentManager.recordTokenUsage(usage.promptTokens, usage.completionTokens)
    };
    this.messageManager = new MessageManager(this.chatService, this.branchManager, messageEvents);

    // Model and agent management
    const modelAgentEvents: ModelAgentManagerEvents = {
      onModelChanged: (model) => this.handleModelChanged(model),
      onPromptChanged: (prompt) => this.handlePromptChanged(prompt),
      onSystemPromptChanged: () => this.updateContextProgress()
    };
    this.modelAgentManager = new ModelAgentManager(
      this.app,
      modelAgentEvents,
      this.chatService.getConversationService()
    );

    // Context tracking
    this.contextTracker = new ContextTracker(
      this.conversationManager,
      this.modelAgentManager
    );
  }

  /**
   * Initialize UI controllers and coordinators
   */
  private initializeControllers(): void {
    const uiStateEvents: UIStateControllerEvents = {
      onSidebarToggled: (visible) => { /* Sidebar toggled */ }
    };
    this.uiStateController = new UIStateController(this.containerEl, uiStateEvents, this);
    this.uiStateController.setOpenSettingsCallback(() => this.openChatSettingsModal());
    this.streamingController = new StreamingController(this.containerEl, this.app, this);
    this.nexusLoadingController = new NexusLoadingController(this.containerEl);
  }

  /**
   * Initialize UI components
   */
  private initializeComponents(): void {
    this.conversationList = new ConversationList(
      this.layoutElements.conversationListContainer,
      (conversation) => this.conversationManager.selectConversation(conversation),
      (conversationId) => this.conversationManager.deleteConversation(conversationId),
      (conversationId, newTitle) => this.conversationManager.renameConversation(conversationId, newTitle),
      this // Pass Component for registerDomEvent
    );

    this.messageDisplay = new MessageDisplay(
      this.layoutElements.messageContainer,
      this.app,
      this.branchManager,
      (messageId) => this.handleRetryMessage(messageId),
      (messageId, newContent) => this.handleEditMessage(messageId, newContent),
      (messageId, event, data) => this.handleToolEvent(messageId, event, data),
      (messageId: string, alternativeIndex: number) => this.handleBranchSwitchedByIndex(messageId, alternativeIndex),
      (branchId: string) => this.navigateToBranch(branchId)
    );

    // Initialize tool event coordinator after messageDisplay is created
    this.toolEventCoordinator = new ToolEventCoordinator(this.messageDisplay);

    this.chatInput = new ChatInput(
      this.layoutElements.inputContainer,
      (message, enhancement, metadata) => this.handleSendMessage(message, enhancement, metadata),
      () => this.messageManager.getIsLoading(),
      this.app,
      () => this.handleStopGeneration(),
      () => this.conversationManager.getCurrentConversation() !== null,
      this // Pass Component for registerDomEvent
    );

    this.contextProgressBar = new ContextProgressBar(
      this.layoutElements.contextContainer,
      () => this.getContextUsage(),
      () => this.getConversationCost()
    );

    // Update conversation list if conversations were already loaded
    const conversations = this.conversationManager.getConversations();
    if (conversations.length > 0) {
      this.conversationList.setConversations(conversations);
    }
  }

  /**
   * Wire up event handlers using event binder
   */
  private wireEventHandlers(): void {
    ChatEventBinder.bindNewChatButton(
      this.layoutElements.newChatButton,
      () => this.conversationManager.createNewConversation(),
      this
    );

    ChatEventBinder.bindSettingsButton(
      this.layoutElements.settingsButton,
      () => this.openChatSettingsModal(),
      this
    );

    this.uiStateController.initializeEventListeners();
  }

  /**
   * Initialize subagent infrastructure via SubagentController
   * This is async and non-blocking - subagent features will be available once this completes
   */
  private async initializeSubagentInfrastructure(): Promise<void> {
    try {
      const plugin = getNexusPlugin<NexusPlugin>(this.app);
      if (!plugin) return;

      // Get required services
      const directToolExecutor = await plugin.getService<DirectToolExecutor>('directToolExecutor');
      if (!directToolExecutor) return;

      const agentManager = await plugin.getService<AgentManager>('agentManager');
      if (!agentManager) return;

      const promptManagerAgent = agentManager.getAgent('promptManager') as PromptManagerAgent | null;
      if (!promptManagerAgent) return;

      const storageAdapter = await plugin.getService<HybridStorageAdapter>('hybridStorageAdapter');
      if (!storageAdapter) return;

      const llmService = this.chatService.getLLMService();
      if (!llmService) return;

      // Create SubagentController
      this.subagentController = new SubagentController(this.app, this, {
        onStreamingUpdate: () => { /* handled internally */ },
        onToolCallsDetected: () => { /* handled internally */ },
        onStatusChanged: () => { /* status menu auto-updates */ },
        onConversationNeedsRefresh: async (conversationId: string) => {
          // Reload conversation if viewing the one that was updated
          const current = this.conversationManager?.getCurrentConversation();
          if (current?.id === conversationId) {
            console.log('[SUBAGENT-DEBUG] Refreshing conversation display');
            // Re-select current conversation to trigger full reload
            await this.conversationManager?.selectConversation(current);
          }
        },
      });

      // Build context provider from ModelAgentManager
      const contextProvider: SubagentContextProvider = {
        getCurrentConversation: () => this.conversationManager?.getCurrentConversation() ?? null,
        getSelectedModel: () => this.modelAgentManager?.getSelectedModel() ?? null,
        getSelectedPrompt: () => this.modelAgentManager?.getSelectedPrompt() ?? null,
        getLoadedWorkspaceData: () => this.modelAgentManager?.getLoadedWorkspaceData(),
        getContextNotes: () => this.modelAgentManager?.getContextNotes() || [],
        getThinkingSettings: () => this.modelAgentManager?.getThinkingSettings() ?? null,
        getSelectedWorkspaceId: () => this.modelAgentManager?.getSelectedWorkspaceId() ?? null,
      };

      // Initialize with dependencies
      await this.subagentController.initialize(
        {
          app: this.app,
          chatService: this.chatService,
          directToolExecutor,
          promptManagerAgent,
          storageAdapter,
          llmService,
        },
        contextProvider,
        this.streamingController,
        this.toolEventCoordinator,
        this.layoutElements.settingsButton?.parentElement ?? undefined,
        this.layoutElements.settingsButton
      );

      // Wire up navigation callbacks for agent status modal
      this.subagentController.setNavigationCallbacks({
        onNavigateToBranch: (branchId) => this.navigateToBranch(branchId),
        onContinueAgent: (branchId) => this.continueSubagent(branchId),
      });

      // Initialize ContextPreservationService for LLM-driven saveState at 90% context
      this.preservationService = new ContextPreservationService({
        llmService: llmService,
        getAgent: (name: string) => agentManager.getAgent(name),
        executeToolCalls: (toolCalls, context) =>
          directToolExecutor.executeToolCalls(toolCalls, context),
      });


    } catch (error) {
      console.error('[ChatView] Failed to initialize subagent infrastructure:', error);
      throw error;
    }
  }

  /**
   * Open chat settings modal
   */
  private async openChatSettingsModal(): Promise<void> {
    const plugin = getNexusPlugin<NexusPlugin>(this.app);
    if (!plugin) {
      console.error('[ChatView] Plugin not found');
      return;
    }

    const workspaceService = await plugin.getService<WorkspaceService>('workspaceService');
    if (!workspaceService) {
      console.error('[ChatView] WorkspaceService not available');
      return;
    }

    const currentConversation = this.conversationManager.getCurrentConversation();

    if (currentConversation) {
      // Access private property via type assertion - currentConversationId exists but is private
      (this.modelAgentManager as unknown as { currentConversationId: string | null }).currentConversationId = currentConversation.id;
    }

    const modal = new ChatSettingsModal(
      this.app,
      currentConversation?.id || null,
      workspaceService,
      this.modelAgentManager
    );
    modal.open();
  }

  /**
   * Load initial data
   */
  private async loadInitialData(): Promise<void> {
    await this.conversationManager.loadConversations();

    const conversations = this.conversationManager.getConversations();
    if (conversations.length === 0) {
      // Initialize with defaults (model, workspace, agent) for new chats
      await this.modelAgentManager.initializeDefaults();

      const hasProviders = this.chatService.hasConfiguredProviders();
      this.uiStateController.showWelcomeState(hasProviders);
      if (this.chatInput) {
        this.chatInput.setConversationState(false);
      }
      if (hasProviders) {
        this.wireWelcomeButton();
      }
    }
  }

  /**
   * Wire up the welcome screen button
   */
  private wireWelcomeButton(): void {
    ChatEventBinder.bindWelcomeButton(
      this.containerEl,
      () => this.conversationManager.createNewConversation(),
      this
    );
  }

  // Event Handlers

  private async handleConversationSelected(conversation: ConversationData): Promise<void> {
    // Cancel any ongoing generation from the previous conversation
    // This prevents the loading state from blocking the new conversation
    if (this.messageManager.getIsLoading()) {
      this.messageManager.cancelCurrentGeneration();
      this.streamingController.cleanup();
    }

    // Clear agent status when switching conversations (session-scoped)
    this.subagentController?.clearAgentStatus();

    // Access private property via type assertion - currentConversationId exists but is private
    (this.modelAgentManager as unknown as { currentConversationId: string | null }).currentConversationId = conversation.id;
    await this.modelAgentManager.initializeFromConversation(conversation.id);
    this.messageDisplay.setConversation(conversation);
    this.updateChatTitle();
    this.uiStateController.setInputPlaceholder('Type your message...');
    this.updateContextProgress();

    if (this.chatInput) {
      this.chatInput.setConversationState(true);
    }

    if (this.uiStateController.getSidebarVisible()) {
      this.uiStateController.toggleConversationList();
    }
  }

  private async handleConversationsChanged(): Promise<void> {
    if (this.conversationList) {
      this.conversationList.setConversations(this.conversationManager.getConversations());
    }

    const conversations = this.conversationManager.getConversations();
    const currentConversation = this.conversationManager.getCurrentConversation();

    if (conversations.length === 0) {
      // Re-initialize with defaults when returning to welcome state
      await this.modelAgentManager.initializeDefaults();

      const hasProviders = this.chatService.hasConfiguredProviders();
      this.uiStateController.showWelcomeState(hasProviders);
      if (this.chatInput) {
        this.chatInput.setConversationState(false);
      }
      if (hasProviders) {
        this.wireWelcomeButton();
      }
    } else if (!currentConversation && conversations.length > 0) {
      await this.conversationManager.selectConversation(conversations[0]);
    }
  }

  private handleAIMessageStarted(message: ConversationMessage): void {
    this.messageDisplay.addAIMessage(message);
  }

  private handleStreamingUpdate(messageId: string, content: string, isComplete: boolean, isIncremental?: boolean): void {
    const currentConversation = this.conversationManager?.getCurrentConversation();
    const message = currentConversation?.messages.find((m) => m.id === messageId);
    const isRetry = message && message.branches && message.branches.length > 0;

    if (isIncremental) {
      this.streamingController.updateStreamingChunk(messageId, content);
    } else if (isComplete) {
      this.streamingController.finalizeStreaming(messageId, content);
      this.messageDisplay.updateMessageContent(messageId, content);
    } else {
      this.streamingController.startStreaming(messageId);
      this.streamingController.updateStreamingChunk(messageId, content);
    }
  }

  private handleConversationUpdated(conversation: ConversationData): void {
    this.conversationManager.updateCurrentConversation(conversation);
    this.messageDisplay.setConversation(conversation);
    this.updateChatTitle();

    this.updateContextProgress();
  }

  private async handleSendMessage(
    message: string,
    enhancement?: MessageEnhancement,
    metadata?: ReferenceMetadata
  ): Promise<void> {
    const currentConversation = this.conversationManager.getCurrentConversation();

    if (!currentConversation) {
      return;
    }

    try {
      if (enhancement) {
        this.modelAgentManager.setMessageEnhancement(enhancement);
      }

      // Check if context compaction is needed (local models with limited context)
      // Triggered at 90% context usage - uses LLM to save state before compacting
      if (this.modelAgentManager.shouldCompactBeforeSending(message)) {
        await this.performContextCompaction(currentConversation);
      }

      const messageOptions = await this.modelAgentManager.getMessageOptions();

      await this.messageManager.sendMessage(
        currentConversation,
        message,
        messageOptions,
        metadata
      );
    } finally {
      this.modelAgentManager.clearMessageEnhancement();
      this.chatInput?.clearMessageEnhancer();
    }
  }

  /**
   * Perform context compaction when approaching token limit (90%)
   * Shows an auto-save style notice (like a video game) during the process.
   *
   * Flow:
   * 1. Try LLM-driven saveState via preservationService (rich semantic context)
   * 2. Fall back to programmatic compaction if LLM fails
   * 3. Compact conversation messages
   * 4. Update storage and progress bar
   */
  private async performContextCompaction(conversation: ConversationData): Promise<void> {
    let stateContent: string | undefined;
    let usedLLM = false;

    // Try LLM-driven saveState if preservationService is available
    if (this.preservationService) {
      // Show "saving" notice - like a video game auto-save
      const savingNotice = new Notice('Saving context...', 0); // 0 = don't auto-dismiss

      try {
        const messageOptions = await this.modelAgentManager.getMessageOptions();
        const result = await this.preservationService.forceStateSave(
          conversation.messages,
          {
            provider: messageOptions.provider,
            model: messageOptions.model,
          },
          {
            workspaceId: this.modelAgentManager.getSelectedWorkspaceId() || undefined,
            sessionId: conversation.metadata?.chatSettings?.sessionId,
          }
        );

        if (result.success && result.stateContent) {
          stateContent = result.stateContent;
          usedLLM = true;
        }
      } catch (error) {
        // LLM-driven preservation failed, will fall back to programmatic
        console.error('[ChatView] LLM-driven saveState failed, using programmatic fallback:', error);
      } finally {
        // Dismiss the "saving" notice
        savingNotice.hide();
      }
    }

    // Run programmatic compaction (truncates messages)
    const compactedContext = this.compactionService.compact(conversation, {
      exchangesToKeep: 2, // Keep last 2 user/assistant exchanges
      maxSummaryLength: 500,
      includeFileReferences: true
    });

    if (compactedContext.messagesRemoved > 0) {
      // Use LLM-saved state if available, otherwise use programmatic summary
      if (stateContent) {
        compactedContext.summary = stateContent;
      }

      // Set previous context for injection into system prompt
      this.modelAgentManager.setPreviousContext(compactedContext);

      // Reset token tracker for fresh accounting with compacted conversation
      this.modelAgentManager.resetTokenTracker();

      // Update conversation in storage with compacted messages
      await this.chatService.updateConversation(conversation);

      // Update progress bar immediately to reflect new token count
      this.updateContextProgress();

      // Show completion notice - brief auto-save style feedback
      const savedMsg = usedLLM
        ? `Context saved (${compactedContext.messagesRemoved} messages compacted)`
        : `Context compacted (${compactedContext.messagesRemoved} messages)`;
      new Notice(savedMsg, 2500);
    }
  }

  private async handleRetryMessage(messageId: string): Promise<void> {
    const currentConversation = this.conversationManager.getCurrentConversation();
    if (currentConversation) {
      const messageOptions = await this.modelAgentManager.getMessageOptions();
      await this.messageManager.handleRetryMessage(
        currentConversation,
        messageId,
        messageOptions
      );
    }
  }

  private async handleEditMessage(messageId: string, newContent: string): Promise<void> {
    const currentConversation = this.conversationManager.getCurrentConversation();
    if (currentConversation) {
      const messageOptions = await this.modelAgentManager.getMessageOptions();
      await this.messageManager.handleEditMessage(
        currentConversation,
        messageId,
        newContent,
        messageOptions
      );
    }
  }

  private handleStopGeneration(): void {
    this.messageManager.cancelCurrentGeneration();
  }

  private handleGenerationAborted(messageId: string, _partialContent: string): void {
    const messageBubble = this.messageDisplay.findMessageBubble(messageId);
    if (messageBubble) {
      messageBubble.stopLoadingAnimation();
    }

    const messageElement = this.containerEl.querySelector(`[data-message-id="${messageId}"]`);
    if (messageElement) {
      const contentElement = messageElement.querySelector('.message-bubble .message-content');
      if (contentElement) {
        this.streamingController.stopLoadingAnimation(contentElement);
      }
    }

    // Get actual content from conversation (progressively saved during streaming)
    // The passed partialContent is always empty; real content is in conversation object
    const currentConversation = this.conversationManager?.getCurrentConversation();
    const message = currentConversation?.messages.find(m => m.id === messageId);
    const actualContent = message?.content || '';

    // Only finalize if we have content - otherwise just stop the animation
    if (actualContent) {
      this.streamingController.finalizeStreaming(messageId, actualContent);
    }
  }

  private handleLoadingStateChanged(loading: boolean): void {
    if (this.chatInput) {
      this.chatInput.setLoading(loading);
    }
  }

  private handleModelChanged(model: any | null): void {
    this.updateContextProgress();
  }

  private handlePromptChanged(prompt: any | null): void {
    // Prompt changed
  }

  private async getContextUsage() {
    return await this.contextTracker.getContextUsage();
  }

  private getConversationCost(): { totalCost: number; currency: string } | null {
    return this.contextTracker.getConversationCost();
  }

  private async updateContextProgress(): Promise<void> {
    if (this.contextProgressBar) {
      await this.contextProgressBar.update();
      this.contextProgressBar.checkWarningThresholds();
    }
  }

  private updateChatTitle(): void {
    const conversation = this.conversationManager.getCurrentConversation();

    if (this.layoutElements.chatTitle) {
      this.layoutElements.chatTitle.textContent = conversation?.title || 'Nexus Chat';
    }
  }

  // Tool event handlers delegated to coordinator

  private handleToolEvent(messageId: string, event: 'detected' | 'updated' | 'started' | 'completed', data: any): void {
    this.toolEventCoordinator.handleToolEvent(messageId, event, data);
  }

  private handleMessageIdUpdated(oldId: string, newId: string, updatedMessage: ConversationMessage): void {
    this.messageDisplay.updateMessageId(oldId, newId, updatedMessage);
  }

  // Branch event handlers

  private handleBranchCreated(messageId: string, branchId: string): void {
    const currentConversation = this.conversationManager.getCurrentConversation();
    if (currentConversation) {
      this.messageDisplay.setConversation(currentConversation);
    }
  }

  private async handleBranchSwitched(messageId: string, branchId: string): Promise<void> {
    const currentConversation = this.conversationManager.getCurrentConversation();
    if (currentConversation) {
      const success = await this.branchManager.switchToBranch(
        currentConversation,
        messageId,
        branchId
      );

      if (success) {
        const updatedMessage = currentConversation.messages.find(msg => msg.id === messageId);
        if (updatedMessage) {
          this.messageDisplay.updateMessage(messageId, updatedMessage);
        }
      }
    }
  }

  /**
   * Handle branch switch by index (for MessageDisplay callback compatibility)
   */
  private async handleBranchSwitchedByIndex(messageId: string, alternativeIndex: number): Promise<void> {
    const currentConversation = this.conversationManager.getCurrentConversation();
    if (currentConversation) {
      const success = await this.branchManager.switchToBranchByIndex(
        currentConversation,
        messageId,
        alternativeIndex
      );

      if (success) {
        const updatedMessage = currentConversation.messages.find(msg => msg.id === messageId);
        if (updatedMessage) {
          this.messageDisplay.updateMessage(messageId, updatedMessage);
        }
      }
    }
  }


  // Branch navigation methods for subagent viewing

  /**
   * Navigate to a specific branch (subagent or human)
   * Shows the branch messages in the message display with a back header
   *
   * For actively streaming branches, uses in-memory messages for flicker-free updates.
   * StreamingController handles live updates via onStreamingUpdate event.
   *
   * ARCHITECTURE NOTE (Dec 2025):
   * A branch IS a conversation with parent metadata. When viewing a branch,
   * we set the branch as the currentConversation in ConversationManager.
   * This means all message operations (send, edit, retry) naturally save to
   * the branch conversation via ChatService - no special routing needed.
   */
  async navigateToBranch(branchId: string): Promise<void> {
    console.log('[SUBAGENT-DEBUG] navigateToBranch START', { branchId });
    const currentConversation = this.conversationManager.getCurrentConversation();
    if (!currentConversation) {
      console.log('[SUBAGENT-DEBUG] navigateToBranch: no current conversation');
      return;
    }

    try {
      // In the new architecture, branchId IS the conversation ID
      // Load the branch conversation directly from storage
      const branchConversation = await this.chatService.getConversation(branchId);
      console.log('[SUBAGENT-DEBUG] navigateToBranch: loaded branch', {
        found: !!branchConversation,
        messageCount: branchConversation?.messages?.length,
      });
      if (!branchConversation) {
        console.error('[SUBAGENT-DEBUG] Branch conversation not found:', branchId);
        return;
      }

      // Store parent conversation ID and scroll position for back navigation
      // Only set if not already viewing a branch (avoid nested overwrite)
      if (!this.parentConversationId) {
        this.parentConversationId = currentConversation.id;
        this.parentScrollPosition = this.messageDisplay.getScrollPosition();
      }

      // Check if this branch is actively streaming - use in-memory messages
      const inMemoryMessages = this.subagentController?.getStreamingBranchMessages(branchId);
      const isStreaming = inMemoryMessages !== null;

      // Build branch context for header display (uses conversation metadata)
      const branchType = branchConversation.metadata?.branchType || 'human';
      const parentMessageId = branchConversation.metadata?.parentMessageId || '';

      this.currentBranchContext = {
        conversationId: branchConversation.metadata?.parentConversationId || currentConversation.id,
        branchId,
        parentMessageId,
        branchType: branchType as 'human' | 'subagent',
        metadata: branchConversation.metadata?.subagent || { description: branchConversation.title },
      };

      // Sync context to SubagentController for event filtering
      this.subagentController?.setCurrentBranchContext(this.currentBranchContext);

      // Set the branch as the current conversation
      // All message operations will now naturally save to the branch
      this.conversationManager.setCurrentConversation(branchConversation);

      // Use in-memory messages if streaming, otherwise use stored messages
      if (isStreaming && inMemoryMessages) {
        const streamingView: ConversationData = {
          ...branchConversation,
          messages: inMemoryMessages,
        };
        this.messageDisplay.setConversation(streamingView);
      } else {
        this.messageDisplay.setConversation(branchConversation);
      }

      // If streaming, initialize StreamingController for the active message
      if (isStreaming && inMemoryMessages && inMemoryMessages.length > 0) {
        const lastMessage = inMemoryMessages[inMemoryMessages.length - 1];
        if (lastMessage.state === 'streaming') {
          this.streamingController.startStreaming(lastMessage.id);
        }
      }

      // Show branch header
      if (!this.branchHeader) {
        this.branchHeader = new BranchHeader(
          this.layoutElements.branchHeaderContainer,
          {
            onNavigateToParent: () => this.navigateToParent(),
            onCancel: (subagentId) => this.cancelSubagent(subagentId),
            onContinue: (branchId) => this.continueSubagent(branchId),
          },
          this
        );
      }
      this.branchHeader.show(this.currentBranchContext);

    } catch (error) {
      console.error('[ChatView] Failed to navigate to branch:', error);
    }
  }

  /**
   * Navigate back to the parent conversation from a branch view
   *
   * ARCHITECTURE NOTE (Dec 2025):
   * When viewing a branch, the branch IS the currentConversation.
   * To go back, we restore the parent conversation as current.
   */
  async navigateToParent(): Promise<void> {
    // Hide branch header
    this.branchHeader?.hide();
    this.currentBranchContext = null;
    this.subagentController?.setCurrentBranchContext(null);

    // Get parent ID and scroll position before clearing
    const parentId = this.parentConversationId;
    const scrollPosition = this.parentScrollPosition;
    this.parentConversationId = null;
    this.parentScrollPosition = 0;

    if (parentId) {
      // Load parent conversation fresh (may have new messages from subagent results)
      const parentConversation = await this.chatService.getConversation(parentId);
      if (parentConversation) {
        // Set parent as current conversation
        this.conversationManager.setCurrentConversation(parentConversation);
        this.messageDisplay.setConversation(parentConversation);
        // Restore scroll position after render
        requestAnimationFrame(() => {
          this.messageDisplay.setScrollPosition(scrollPosition);
        });
        return;
      }
    }

    // Fallback: reload current conversation (shouldn't happen normally)
    const currentConversation = this.conversationManager.getCurrentConversation();
    if (currentConversation) {
      const updated = await this.chatService.getConversation(currentConversation.id);
      if (updated) {
        this.conversationManager.setCurrentConversation(updated);
        this.messageDisplay.setConversation(updated);
      }
    }
  }

  /**
   * Cancel a running subagent
   */
  private cancelSubagent(subagentId: string): void {
    const cancelled = this.subagentController?.cancelSubagent(subagentId);
    if (cancelled) {
      // Update the branch header if we're viewing this branch
      const contextMetadata = this.currentBranchContext?.metadata;
      if (isSubagentMetadata(contextMetadata) && contextMetadata.subagentId === subagentId) {
        this.branchHeader?.update({
          metadata: { ...contextMetadata, state: 'cancelled' },
        });
      }
    }
  }

  /**
   * Continue a paused subagent (hit max_iterations)
   */
  private async continueSubagent(branchId: string): Promise<void> {
    // Navigate back to parent first
    await this.navigateToParent();

    // TODO: Implement subagent continuation
    // This would call the subagent tool with continueBranchId parameter
  }

  /**
   * Open the agent status modal
   */
  private openAgentStatusModal(): void {
    if (!this.subagentController?.isInitialized()) {
      console.warn('[ChatView] SubagentController not initialized - cannot open modal');
      return;
    }

    const contextProvider: SubagentContextProvider = {
      getCurrentConversation: () => this.conversationManager?.getCurrentConversation() ?? null,
      getSelectedModel: () => this.modelAgentManager?.getSelectedModel() ?? null,
      getSelectedPrompt: () => this.modelAgentManager?.getSelectedPrompt() ?? null,
      getLoadedWorkspaceData: () => this.modelAgentManager?.getLoadedWorkspaceData(),
      getContextNotes: () => this.modelAgentManager?.getContextNotes() || [],
      getThinkingSettings: () => this.modelAgentManager?.getThinkingSettings() ?? null,
      getSelectedWorkspaceId: () => this.modelAgentManager?.getSelectedWorkspaceId() ?? null,
    };

    this.subagentController.openStatusModal(contextProvider, {
      onViewBranch: (branchId) => this.navigateToBranch(branchId),
      onContinueAgent: (branchId) => this.continueSubagent(branchId),
    });
  }

  /**
   * Check if currently viewing a branch
   */
  isViewingBranch(): boolean {
    return this.currentBranchContext !== null;
  }

  /**
   * Get current branch context (for external use)
   */
  getCurrentBranchContext(): BranchViewContext | null {
    return this.currentBranchContext;
  }

  private cleanup(): void {
    this.conversationList?.cleanup();
    this.messageDisplay?.cleanup();
    this.chatInput?.cleanup();
    this.contextProgressBar?.cleanup();
    this.uiStateController?.cleanup();
    this.streamingController?.cleanup();
    this.nexusLoadingController?.unload();
    this.subagentController?.cleanup();
    this.branchHeader?.cleanup();
  }
}

```

## ui/chat/components/AgentStatusMenu.ts

```typescript
/**
 * AgentStatusMenu - Header icon + badge showing running subagent count
 *
 * Displays in the chat header next to settings button.
 * Shows:
 * - Robot icon with badge when agents are running
 * - Clicking opens AgentStatusModal
 *
 * Uses Obsidian's setIcon helper for consistent iconography.
 * Uses event-based updates instead of polling for efficiency.
 */

import { setIcon, Component, Events } from 'obsidian';
import type { SubagentExecutor } from '../../../services/chat/SubagentExecutor';
import type { SubagentExecutorEvents } from '../../../types/branch/BranchTypes';

export interface AgentStatusMenuCallbacks {
  onOpenModal: () => void;
}

/**
 * Event emitter for subagent status updates
 * Allows UI components to subscribe to status changes without polling
 */
export class SubagentEventBus extends Events {
  trigger(name: 'status-changed'): void {
    super.trigger(name);
  }

  on(name: 'status-changed', callback: () => void): ReturnType<Events['on']> {
    return super.on(name, callback);
  }
}

// Singleton event bus for subagent status updates
let globalEventBus: SubagentEventBus | null = null;

export function getSubagentEventBus(): SubagentEventBus {
  if (!globalEventBus) {
    globalEventBus = new SubagentEventBus();
  }
  return globalEventBus;
}

/**
 * Create event handlers that notify the event bus
 * Wire these to SubagentExecutor.setEventHandlers()
 */
export function createSubagentEventHandlers(): Partial<SubagentExecutorEvents> {
  const eventBus = getSubagentEventBus();

  return {
    onSubagentStarted: () => {
      eventBus.trigger('status-changed');
    },
    onSubagentProgress: () => {
      // Trigger on progress updates (tool changes, iteration updates)
      eventBus.trigger('status-changed');
    },
    onSubagentComplete: () => {
      eventBus.trigger('status-changed');
    },
    onSubagentError: () => {
      eventBus.trigger('status-changed');
    },
  };
}

export class AgentStatusMenu {
  private element: HTMLElement | null = null;
  private badgeEl: HTMLElement | null = null;
  private iconEl: HTMLElement | null = null;
  private lastCount: number = 0;
  private eventRef: ReturnType<Events['on']> | null = null;
  private hasShownSuccess: boolean = false; // Track if green state was shown
  private isShowingSpinner: boolean = false; // Track current icon state

  constructor(
    private container: HTMLElement,
    private subagentExecutor: SubagentExecutor | null,
    private callbacks: AgentStatusMenuCallbacks,
    private component?: Component,
    private insertBefore?: HTMLElement // Insert before this element (e.g., settings button)
  ) {}

  /**
   * Create and render the status menu button
   */
  render(): HTMLElement {
    // Create the button element
    const button = document.createElement('button');
    button.addClass('clickable-icon', 'nexus-agent-status-button');
    button.setAttribute('aria-label', 'Running agents');
    button.setAttribute('title', 'Running agents');

    // Icon container
    const iconContainer = button.createDiv('nexus-agent-status-icon');
    setIcon(iconContainer, 'bot');
    this.iconEl = iconContainer;

    // Badge (hidden by default)
    const badge = button.createDiv('nexus-agent-status-badge');
    badge.addClass('nexus-badge-hidden');
    badge.textContent = '0';
    this.badgeEl = badge;

    // Click handler - clears success state when modal opens
    if (this.component) {
      this.component.registerDomEvent(button, 'click', () => {
        this.clearSuccessState();
        this.callbacks.onOpenModal();
      });
    } else {
      button.addEventListener('click', () => {
        this.clearSuccessState();
        this.callbacks.onOpenModal();
      });
    }

    this.element = button;

    // Insert before settings button (left side) or append (right side)
    if (this.insertBefore) {
      this.container.insertBefore(button, this.insertBefore);
    } else {
      this.container.appendChild(button);
    }

    // Subscribe to event bus for status updates (replaces polling)
    this.subscribeToEvents();

    // Initial update
    this.updateDisplay();

    return button;
  }

  /**
   * Update the executor reference (if initialized later)
   */
  setSubagentExecutor(executor: SubagentExecutor): void {
    this.subagentExecutor = executor;
    this.updateDisplay();
  }

  /**
   * Subscribe to subagent status events
   */
  private subscribeToEvents(): void {
    const eventBus = getSubagentEventBus();
    this.eventRef = eventBus.on('status-changed', () => {
      this.updateDisplay();
    });
  }

  /**
   * Update the badge display based on running agent count
   * Handles three states: running (spinner icon), success (green bot), default (bot)
   */
  updateDisplay(): void {
    if (!this.element || !this.badgeEl || !this.iconEl) return;

    const statusList = this.subagentExecutor?.getAgentStatusList() ?? [];
    const runningCount = statusList.filter(a => a.state === 'running').length;
    const completedCount = statusList.filter(a =>
      ['complete', 'cancelled', 'max_iterations', 'abandoned'].includes(a.state)
    ).length;
    console.log('[SUBAGENT-DEBUG] AgentStatusMenu.updateDisplay', {
      hasExecutor: !!this.subagentExecutor,
      statusListLength: statusList.length,
      runningCount,
      completedCount,
      states: statusList.map(a => ({ id: a.subagentId?.slice(-8), state: a.state })),
    });

    // Update badge
    this.badgeEl.textContent = runningCount.toString();
    this.badgeEl.toggleClass('nexus-badge-hidden', runningCount === 0);

    // State logic: running > success > default
    if (runningCount > 0) {
      // Running state - swap to spinner icon
      if (!this.isShowingSpinner) {
        setIcon(this.iconEl, 'loader-2');
        this.isShowingSpinner = true;
      }
      this.element.addClass('nexus-status-running');
      this.element.removeClass('nexus-status-success');
      this.element.addClass('nexus-agents-active');
      this.element.setAttribute('title', `${runningCount} agent${runningCount > 1 ? 's' : ''} running`);
      this.hasShownSuccess = false; // Reset on new activity
    } else if (completedCount > 0 && !this.hasShownSuccess) {
      // Success state - show green bot icon
      if (this.isShowingSpinner) {
        setIcon(this.iconEl, 'bot');
        this.isShowingSpinner = false;
      }
      this.element.removeClass('nexus-status-running');
      this.element.addClass('nexus-status-success');
      this.element.removeClass('nexus-agents-active');
      this.element.setAttribute('title', 'Agents completed');
      this.hasShownSuccess = true;
    } else if (!this.hasShownSuccess) {
      // Default state - show bot icon
      if (this.isShowingSpinner) {
        setIcon(this.iconEl, 'bot');
        this.isShowingSpinner = false;
      }
      this.element.removeClass('nexus-status-running', 'nexus-status-success', 'nexus-agents-active');
      this.element.setAttribute('title', 'Running agents');
    }
    // If hasShownSuccess is true, keep the green state until clearSuccessState() is called

    this.lastCount = runningCount;
  }

  /**
   * Clear the success (green) state - called when modal is opened
   */
  clearSuccessState(): void {
    if (!this.element) return;
    this.element.removeClass('nexus-status-success');
    this.hasShownSuccess = false;
    this.element.setAttribute('title', 'Running agents');
  }

  /**
   * Force refresh the display (call after agent state changes)
   */
  refresh(): void {
    this.lastCount = -1; // Force update
    this.updateDisplay();
  }

  /**
   * Show visual feedback when an agent completes
   */
  showCompletionPulse(): void {
    if (!this.element) return;

    this.element.addClass('nexus-agent-completion-pulse');
    setTimeout(() => {
      this.element?.removeClass('nexus-agent-completion-pulse');
    }, 1000);
  }

  /**
   * Cleanup
   */
  cleanup(): void {
    // Unsubscribe from events
    if (this.eventRef) {
      getSubagentEventBus().offref(this.eventRef);
      this.eventRef = null;
    }

    this.element?.remove();
    this.element = null;
    this.badgeEl = null;
    this.iconEl = null;
    this.isShowingSpinner = false;
  }
}

```

## ui/chat/components/AgentStatusModal.ts

```typescript
/**
 * AgentStatusModal - Compact modal for viewing running and completed subagents
 *
 * Shows for each agent:
 * - Task name (truncated) + iterations count (x/y)
 * - Last tool used (human-readable)
 * - View link to navigate to agent conversation
 * - Stop button (when running) or status icon (when complete)
 *
 * Fixed height (~200px) with scroll for many agents.
 */

import { App, Modal, setIcon, Events } from 'obsidian';
import type { SubagentExecutor } from '../../../services/chat/SubagentExecutor';
import type { BranchService } from '../../../services/chat/BranchService';
import type { AgentStatusItem, SubagentBranchMetadata } from '../../../types/branch/BranchTypes';
import { getStateIconName } from '../../../utils/branchStatusUtils';
import { formatToolDisplayName } from '../../../utils/toolNameUtils';
import { getSubagentEventBus } from './AgentStatusMenu';

export interface AgentStatusModalCallbacks {
  onViewBranch: (branchId: string) => void;
  onContinueAgent: (branchId: string) => void;
}

export class AgentStatusModal extends Modal {
  private subagentExecutor: SubagentExecutor;
  private branchService: BranchService | null;
  private conversationId: string | null;
  private callbacks: AgentStatusModalCallbacks;
  private eventRef: ReturnType<Events['on']> | null = null;
  private cachedCompletedAgents: AgentStatusItem[] = [];

  constructor(
    app: App,
    subagentExecutor: SubagentExecutor,
    callbacks: AgentStatusModalCallbacks,
    branchService?: BranchService | null,
    conversationId?: string | null
  ) {
    super(app);
    this.subagentExecutor = subagentExecutor;
    this.branchService = branchService ?? null;
    this.conversationId = conversationId ?? null;
    this.callbacks = callbacks;
  }

  async onOpen(): Promise<void> {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass('nexus-agent-status-modal');

    this.titleEl.setText('Agents');

    // Load completed agents from branch storage
    await this.loadCompletedAgentsFromStorage();

    // Subscribe to real-time updates
    const eventBus = getSubagentEventBus();
    this.eventRef = eventBus.on('status-changed', () => {
      this.renderContent();
    });

    this.renderContent();
  }

  /**
   * Load completed agents from branch storage
   * These persist across conversation switches and app restarts
   */
  private async loadCompletedAgentsFromStorage(): Promise<void> {
    if (!this.branchService || !this.conversationId) {
      this.cachedCompletedAgents = [];
      return;
    }

    try {
      const subagentBranches = await this.branchService.getSubagentBranches(this.conversationId);

      this.cachedCompletedAgents = subagentBranches
        .filter(info => {
          // Only include branches with subagent metadata
          const metadata = info.branch.metadata;
          return metadata && 'subagentId' in metadata;
        })
        .map(info => {
          const metadata = info.branch.metadata as SubagentBranchMetadata;
          return {
            subagentId: metadata.subagentId,
            branchId: info.branch.id,
            conversationId: this.conversationId!,
            parentMessageId: info.parentMessageId,
            task: metadata.task,
            state: metadata.state,
            iterations: metadata.iterations,
            maxIterations: metadata.maxIterations,
            startedAt: metadata.startedAt,
            completedAt: metadata.completedAt,
            // lastToolUsed not available for completed agents (not persisted)
          } satisfies AgentStatusItem;
        });
    } catch (error) {
      console.error('Failed to load completed agents from storage:', error);
      this.cachedCompletedAgents = [];
    }
  }

  private renderContent(): void {
    const { contentEl } = this;
    contentEl.empty();

    // Get running agents from executor (in-memory, has lastToolUsed)
    const executorAgents = this.subagentExecutor.getAgentStatusList();

    // Merge with completed agents from storage (persisted)
    // Executor agents take priority (they have more real-time data like lastToolUsed)
    const executorBranchIds = new Set(executorAgents.map(a => a.branchId));
    const storedCompletedAgents = this.cachedCompletedAgents.filter(
      a => !executorBranchIds.has(a.branchId)
    );

    // Combine: executor agents + stored agents not in executor
    const allAgents = [...executorAgents, ...storedCompletedAgents];

    const running = allAgents.filter(a => a.state === 'running');
    const completed = allAgents.filter(a => a.state !== 'running');

    // Scrollable list container
    const listEl = contentEl.createDiv({ cls: 'nexus-agent-list' });

    // Running section
    if (running.length === 0 && completed.length === 0) {
      listEl.createDiv({ cls: 'nexus-agent-empty', text: 'No agents spawned' });
    } else {
      if (running.length > 0) {
        listEl.createDiv({ cls: 'nexus-agent-section-header', text: 'Running' });
        for (const agent of running) {
          this.renderCompactRow(listEl, agent, true);
        }
      }

      if (completed.length > 0) {
        listEl.createDiv({ cls: 'nexus-agent-section-header', text: 'Completed' });
        for (const agent of completed) {
          this.renderCompactRow(listEl, agent, false);
        }
      }
    }
  }

  /**
   * Render a compact agent row
   * Layout: [Task description + iterations] | [Tool badge] | [View + Stop/Icon]
   */
  private renderCompactRow(container: HTMLElement, agent: AgentStatusItem, isRunning: boolean): void {
    const row = container.createDiv({ cls: 'nexus-agent-row-compact' });

    // Left: Task description with iterations inline
    const info = row.createDiv({ cls: 'nexus-agent-info' });
    const taskText = `${this.truncateTask(agent.task, 40)} (${agent.iterations}/${agent.maxIterations})`;
    info.createDiv({ cls: 'nexus-agent-task', text: taskText });

    // Middle: Tool badge
    const toolContainer = row.createDiv({ cls: 'nexus-agent-tool-container' });
    if (agent.lastToolUsed) {
      toolContainer.createSpan({
        cls: 'nexus-agent-tool-badge',
        text: formatToolDisplayName(agent.lastToolUsed),
      });
    }

    // Right: View button + Stop/Status icon
    const actions = row.createDiv({ cls: 'nexus-agent-actions' });
    const viewBtn = actions.createEl('button', {
      cls: 'nexus-agent-view-btn clickable-icon',
      attr: { 'aria-label': 'View agent conversation' },
    });
    setIcon(viewBtn, 'eye');
    viewBtn.addEventListener('click', () => {
      this.close();
      this.callbacks.onViewBranch(agent.branchId);
    });

    if (isRunning) {
      const stopBtn = actions.createEl('button', {
        cls: 'nexus-agent-stop-btn clickable-icon',
        attr: { 'aria-label': 'Stop agent' },
      });
      setIcon(stopBtn, 'square');
      stopBtn.addEventListener('click', () => {
        this.subagentExecutor.cancelSubagent(agent.subagentId);
        this.renderContent();
      });
    } else {
      const iconEl = actions.createSpan({ cls: `nexus-state-icon nexus-state-icon-${agent.state}` });
      setIcon(iconEl, getStateIconName(agent.state));
    }
  }

  /**
   * Truncate task to max length with ellipsis
   */
  private truncateTask(task: string, maxLength: number): string {
    if (task.length <= maxLength) return task;
    return task.substring(0, maxLength - 1) + 'â€¦';
  }

  onClose(): void {
    // Unsubscribe from events
    if (this.eventRef) {
      getSubagentEventBus().offref(this.eventRef);
      this.eventRef = null;
    }
    this.contentEl.empty();
  }
}

```

## ui/chat/components/BranchHeader.ts

```typescript
/**
 * BranchHeader - Navigation header when viewing a branch
 *
 * Displays above the message list when user navigates into a subagent or human branch.
 * Shows:
 * - Back button to return to parent conversation
 * - Branch task/description
 * - Status badge (running, complete, paused, etc.)
 *
 * Uses Obsidian's setIcon helper for consistent iconography.
 * Uses shared utilities for status display (DRY).
 */

import { setIcon, Component } from 'obsidian';
import type { SubagentBranchMetadata, HumanBranchMetadata } from '../../../types/branch/BranchTypes';
import { isSubagentMetadata } from '../../../types/branch/BranchTypes';
import { getStatusText, createStateIcon } from '../../../utils/branchStatusUtils';

export interface BranchViewContext {
  conversationId: string;
  branchId: string;
  parentMessageId: string;
  branchType: 'human' | 'subagent';
  metadata?: SubagentBranchMetadata | HumanBranchMetadata;
}

export interface BranchHeaderCallbacks {
  onNavigateToParent: () => void;
  onCancel?: (subagentId: string) => void;
  onContinue?: (branchId: string) => void;
}

export class BranchHeader {
  private element: HTMLElement | null = null;
  private context: BranchViewContext | null = null;

  constructor(
    private container: HTMLElement,
    private callbacks: BranchHeaderCallbacks,
    private component?: Component
  ) {}

  /**
   * Show the branch header with the given context
   */
  show(context: BranchViewContext): void {
    console.log('[SUBAGENT-DEBUG] BranchHeader.show', { branchId: context.branchId, branchType: context.branchType });
    this.context = context;
    this.render();
  }

  /**
   * Hide the branch header
   */
  hide(): void {
    this.context = null;
    if (this.element) {
      this.element.remove();
      this.element = null;
    }
  }

  /**
   * Update the context (e.g., when iteration count changes)
   */
  update(context: Partial<BranchViewContext>): void {
    if (!this.context) return;
    this.context = { ...this.context, ...context };
    this.render();
  }

  /**
   * Check if header is currently visible
   */
  isVisible(): boolean {
    return this.element !== null;
  }

  /**
   * Get current branch context
   */
  getContext(): BranchViewContext | null {
    return this.context;
  }

  /**
   * Render the header
   */
  private render(): void {
    if (!this.context) return;

    // Remove existing element if any
    if (this.element) {
      this.element.remove();
    }

    const header = document.createElement('div');
    header.addClass('nexus-branch-header');

    // Back button
    const backBtn = header.createEl('button', {
      cls: 'nexus-branch-back clickable-icon',
    });
    const backIcon = backBtn.createSpan('nexus-branch-back-icon');
    setIcon(backIcon, 'arrow-left');
    backBtn.createSpan({ text: ' Back' });

    const handleBack = () => {
      this.callbacks.onNavigateToParent();
    };

    if (this.component) {
      this.component.registerDomEvent(backBtn, 'click', handleBack);
    } else {
      backBtn.addEventListener('click', handleBack);
    }

    // Branch info container
    const info = header.createDiv('nexus-branch-info');

    // Branch task/description - use type guard to narrow metadata type
    if (this.context.branchType === 'subagent' && isSubagentMetadata(this.context.metadata)) {
      const metadata = this.context.metadata; // Now properly typed as SubagentBranchMetadata
      const task = metadata.task || 'Subagent';
      const taskEl = info.createSpan({
        text: `Subagent: "${this.truncateTask(task)}"`,
        cls: 'nexus-branch-task',
      });
      taskEl.setAttribute('title', task);

      // Status badge using shared utilities
      const statusContainer = info.createSpan('nexus-branch-status');
      const statusText = getStatusText(metadata);

      statusContainer.createSpan({
        text: statusText,
        cls: `nexus-status-text nexus-status-${metadata.state || 'running'}`,
      });

      // Use setIcon-based status icon
      const iconEl = statusContainer.createSpan('nexus-status-icon');
      createStateIcon(metadata.state, iconEl);

      // Action buttons for running/paused agents
      if (metadata.state === 'running' && this.callbacks.onCancel && metadata.subagentId) {
        const cancelBtn = header.createEl('button', {
          cls: 'nexus-branch-action-btn nexus-branch-cancel-btn clickable-icon',
          text: 'Cancel',
        });
        const subagentId = metadata.subagentId;
        if (this.component) {
          this.component.registerDomEvent(cancelBtn, 'click', () => {
            this.callbacks.onCancel!(subagentId);
          });
        } else {
          cancelBtn.addEventListener('click', () => {
            this.callbacks.onCancel!(subagentId);
          });
        }
      }

      if (metadata.state === 'max_iterations' && this.callbacks.onContinue) {
        const continueBtn = header.createEl('button', {
          cls: 'nexus-branch-action-btn nexus-branch-continue-btn mod-cta',
          text: 'Continue',
        });
        const branchId = this.context.branchId;
        if (this.component) {
          this.component.registerDomEvent(continueBtn, 'click', () => {
            this.callbacks.onContinue!(branchId);
          });
        } else {
          continueBtn.addEventListener('click', () => {
            this.callbacks.onContinue!(branchId);
          });
        }
      }
    } else {
      // Human branch
      info.createSpan({
        text: 'Alternative Branch',
        cls: 'nexus-branch-task',
      });
    }

    this.element = header;
    this.container.prepend(header);
  }

  /**
   * Truncate long task descriptions
   */
  private truncateTask(task: string, maxLength: number = 50): string {
    if (task.length <= maxLength) return task;
    return task.substring(0, maxLength - 3) + '...';
  }

  /**
   * Cleanup
   */
  cleanup(): void {
    this.hide();
  }
}

```

## ui/chat/components/ChatInput.ts

```typescript
/**
 * ChatInput - Message input component with send functionality
 *
 * Provides text input, send button, and model selection
 */

import { setIcon, App, Platform, Component } from 'obsidian';
import { initializeSuggesters, SuggesterInstances } from './suggesters/initializeSuggesters';
import { ContentEditableHelper } from '../utils/ContentEditableHelper';
import { ReferenceExtractor, ReferenceMetadata } from '../utils/ReferenceExtractor';
import { MessageEnhancement } from './suggesters/base/SuggesterInterfaces';
import { isMobile, isIOS } from '../../../utils/platform';

export class ChatInput {
  private element: HTMLElement | null = null;
  private inputElement: HTMLElement | null = null;
  private sendButton: HTMLButtonElement | null = null;
  private isLoading = false;
  private hasConversation = false;
  private suggesters: SuggesterInstances | null = null;

  constructor(
    private container: HTMLElement,
    private onSendMessage: (
      message: string,
      enhancement?: MessageEnhancement,
      metadata?: ReferenceMetadata
    ) => void,
    private getLoadingState: () => boolean,
    private app?: App,
    private onStopGeneration?: () => void,
    private getHasConversation?: () => boolean,
    private component?: Component
  ) {
    this.render();
  }

  /**
   * Set loading state
   */
  setLoading(loading: boolean): void {
    this.isLoading = loading;
    this.updateUI();
  }

  /**
   * Set conversation state (whether a conversation is active)
   */
  setConversationState(hasConversation: boolean): void {
    this.hasConversation = hasConversation;
    this.updateUI();
  }

  /**
   * Set placeholder text
   */
  setPlaceholder(placeholder: string): void {
    if (this.inputElement) {
      this.inputElement.setAttribute('data-placeholder', placeholder);
    }
  }

  /**
   * Render the chat input interface
   */
  private render(): void {
    this.container.empty();
    this.container.addClass('chat-input');

    // Input wrapper - contains both textarea and embedded send button
    const inputWrapper = this.container.createDiv('chat-input-wrapper');

    // Contenteditable input
    this.inputElement = inputWrapper.createDiv('chat-textarea');
    this.inputElement.contentEditable = 'true';
    this.inputElement.setAttribute('data-placeholder', 'Type your message...');
    this.inputElement.setAttribute('role', 'textbox');
    this.inputElement.setAttribute('aria-multiline', 'true');

    // Handle Enter key (send) and Shift+Enter (new line)
    const keydownHandler = (e: KeyboardEvent) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        // Don't send if any suggester is active (let suggester handle it)
        const anySuggesterActive =
          this.suggesters?.noteSuggester?.getIsActive() ||
          this.suggesters?.toolSuggester?.getIsActive() ||
          this.suggesters?.promptSuggester?.getIsActive();

        if (!anySuggesterActive) {
          e.preventDefault();
          this.handleSendMessage();
        }
      }
    };

    // Auto-resize on input
    const inputHandler = () => {
      this.autoResizeInput();
    };

    // iOS: Scroll input into view when keyboard opens
    const focusHandler = () => {
      // Wait for keyboard animation to complete
      setTimeout(() => {
        this.inputElement?.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }, 300);
    };

    // Register events with component for auto-cleanup
    this.component!.registerDomEvent(this.inputElement, 'keydown', keydownHandler);
    this.component!.registerDomEvent(this.inputElement, 'input', inputHandler);
    if (isIOS()) {
      this.component!.registerDomEvent(this.inputElement, 'focus', focusHandler);
    }

    // Mobile: Add mobile-specific class for styling
    if (isMobile()) {
      inputWrapper.addClass('chat-input-mobile');
    }

    // Send button - embedded inside the input wrapper (bottom-right)
    // Uses Obsidian's clickable-icon class for proper icon sizing
    this.sendButton = inputWrapper.createEl('button', {
      cls: 'chat-send-button clickable-icon'
    });

    // Add send icon using Obsidian's setIcon
    setIcon(this.sendButton, 'arrow-up');
    this.sendButton.setAttribute('aria-label', 'Send message');

    const sendClickHandler = () => {
      this.handleSendOrStop();
    };
    this.component!.registerDomEvent(this.sendButton, 'click', sendClickHandler);

    // Initialize suggesters if app is available
    if (this.app && this.inputElement) {
      this.suggesters = initializeSuggesters(this.app, this.inputElement, this.component);
    }

    this.element = this.container;
    this.updateUI();
  }

  /**
   * Handle send or stop based on current state
   */
  private handleSendOrStop(): void {
    const actuallyLoading = this.isLoading || this.getLoadingState();

    if (actuallyLoading) {
      // Stop generation
      if (this.onStopGeneration) {
        this.onStopGeneration();
      }
    } else {
      // Send message
      this.handleSendMessage();
    }
  }

  /**
   * Handle sending a message
   */
  private handleSendMessage(): void {
    if (!this.inputElement) return;

    // Check if a conversation is active
    const hasConversation = this.getHasConversation ? this.getHasConversation() : this.hasConversation;
    if (!hasConversation) {
      return;
    }

    const extracted = ReferenceExtractor.extractContent(this.inputElement);
    const message = extracted.plainText.trim();
    if (!message) return;

    // Build enhancement from MessageEnhancer
    let enhancement: MessageEnhancement | undefined = undefined;
    if (this.suggesters?.messageEnhancer && this.suggesters.messageEnhancer.hasEnhancements()) {
      enhancement = this.suggesters.messageEnhancer.buildEnhancement(message);
    }

    const metadata: ReferenceMetadata | undefined =
      extracted.references.length > 0
        ? {
            references: extracted.references
          }
        : undefined;

    // Clear the input
    ContentEditableHelper.clear(this.inputElement);
    this.autoResizeInput();

    // Send the message with enhancement
    this.onSendMessage(message, enhancement, metadata);
  }

  /**
   * Auto-resize input based on content (limited to ~4 lines)
   */
  private autoResizeInput(): void {
    if (!this.inputElement) return;

    // Reset height to auto to get the correct scrollHeight
    this.inputElement.addClass('chat-input-auto-height');

    // Set height limits - matches CSS min/max heights
    const minHeight = 48;
    const maxHeight = 120;
    const newHeight = Math.min(Math.max(this.inputElement.scrollHeight, minHeight), maxHeight);

    // Remove auto-height class and set specific height
    this.inputElement.removeClass('chat-input-auto-height');
    this.inputElement.style.setProperty('height', newHeight + 'px');

    // Enable scrolling if content exceeds max height
    if (this.inputElement.scrollHeight > maxHeight) {
      this.inputElement.removeClass('chat-input-overflow-hidden');
      this.inputElement.addClass('chat-input-overflow-auto');
    } else {
      this.inputElement.removeClass('chat-input-overflow-auto');
      this.inputElement.addClass('chat-input-overflow-hidden');
    }
  }

  /**
   * Update UI based on current state
   */
  private updateUI(): void {
    if (!this.sendButton || !this.inputElement) return;

    const actuallyLoading = this.isLoading || this.getLoadingState();
    const hasConversation = this.getHasConversation ? this.getHasConversation() : this.hasConversation;

    if (!hasConversation) {
      // No conversation selected - disable everything
      this.sendButton.disabled = true;
      this.sendButton.classList.remove('stop-mode');
      this.sendButton.classList.add('disabled-mode');
      this.sendButton.empty();
      setIcon(this.sendButton, 'arrow-up');
      this.sendButton.setAttribute('aria-label', 'No conversation selected');
      this.inputElement.contentEditable = 'false';
      this.inputElement.setAttribute('data-placeholder', 'Select or create a conversation to begin');
    } else if (actuallyLoading) {
      // Show stop button (keep enabled so user can click to stop)
      this.sendButton.disabled = false;
      this.sendButton.classList.add('stop-mode');
      this.sendButton.classList.remove('disabled-mode');
      this.sendButton.empty();
      setIcon(this.sendButton, 'square');
      this.sendButton.setAttribute('aria-label', 'Stop generation');
      this.inputElement.contentEditable = 'false';
    } else {
      // Show normal send button
      this.sendButton.disabled = false;
      this.sendButton.classList.remove('stop-mode');
      this.sendButton.classList.remove('disabled-mode');
      this.sendButton.empty();
      setIcon(this.sendButton, 'arrow-up');
      this.sendButton.setAttribute('aria-label', 'Send message');
      this.inputElement.contentEditable = 'true';
      this.inputElement.setAttribute('data-placeholder', 'Type your message...');
    }
  }

  /**
   * Focus the input
   */
  focus(): void {
    if (this.inputElement) {
      ContentEditableHelper.focus(this.inputElement);
    }
  }

  /**
   * Clear the input
   */
  clear(): void {
    if (this.inputElement) {
      ContentEditableHelper.clear(this.inputElement);
      this.autoResizeInput();
    }
  }

  /**
   * Get current input value
   */
  getValue(): string {
    return this.inputElement ? ContentEditableHelper.getPlainText(this.inputElement) : '';
  }

  /**
   * Set input value
   */
  setValue(value: string): void {
    if (this.inputElement) {
      ContentEditableHelper.setPlainText(this.inputElement, value);
      this.autoResizeInput();
    }
  }

  /**
   * Get message enhancer (for accessing enhancements before sending)
   */
  getMessageEnhancer() {
    return this.suggesters?.messageEnhancer || null;
  }

  /**
   * Clear message enhancer (call after message is sent)
   */
  clearMessageEnhancer(): void {
    if (this.suggesters?.messageEnhancer) {
      this.suggesters.messageEnhancer.clearEnhancements();
    }
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    if (this.suggesters) {
      this.suggesters.cleanup();
      this.suggesters = null;
    }

    this.element = null;
    this.inputElement = null;
    this.sendButton = null;
  }
}

```

## ui/chat/components/ChatSettingsModal.ts

```typescript
/**
 * ChatSettingsModal - Modal for configuring chat session settings
 *
 * Uses ChatSettingsRenderer for identical UI to DefaultsTab.
 * Saves to conversation metadata (this session only).
 */

import { App, Modal, ButtonComponent, Plugin } from 'obsidian';
import { WorkspaceService } from '../../../services/WorkspaceService';
import { ModelAgentManager } from '../services/ModelAgentManager';
import { ChatSettingsRenderer, ChatSettings } from '../../../components/shared/ChatSettingsRenderer';
import { getNexusPlugin } from '../../../utils/pluginLocator';
import { Settings } from '../../../settings';

/**
 * Type for the NexusPlugin with settings property
 * Used to access plugin settings in a type-safe way
 */
interface NexusPluginWithSettings extends Plugin {
  settings?: Settings;
}

export class ChatSettingsModal extends Modal {
  private workspaceService: WorkspaceService;
  private modelAgentManager: ModelAgentManager;
  private conversationId: string | null;
  private renderer: ChatSettingsRenderer | null = null;
  private pendingSettings: ChatSettings | null = null;

  constructor(
    app: App,
    conversationId: string | null,
    workspaceService: WorkspaceService,
    modelAgentManager: ModelAgentManager
  ) {
    super(app);
    this.conversationId = conversationId;
    this.workspaceService = workspaceService;
    this.modelAgentManager = modelAgentManager;
  }

  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass('chat-settings-modal');

    // Header with buttons
    const header = contentEl.createDiv('chat-settings-header');
    header.createEl('h2', { text: 'Chat Settings' });

    const buttonContainer = header.createDiv('chat-settings-buttons');
    new ButtonComponent(buttonContainer)
      .setButtonText('Cancel')
      .onClick(() => this.close());

    new ButtonComponent(buttonContainer)
      .setButtonText('Save')
      .setCta()
      .onClick(() => this.handleSave());

    // Load data and render
    await this.loadAndRender(contentEl);
  }

  private async loadAndRender(contentEl: HTMLElement): Promise<void> {
    const plugin = getNexusPlugin<NexusPluginWithSettings>(this.app);
    const llmProviderSettings = plugin?.settings?.settings?.llmProviders;

    if (!llmProviderSettings) {
      contentEl.createEl('p', { text: 'Settings not available' });
      return;
    }

    // Load workspaces and prompts
    const workspaces = await this.loadWorkspaces();
    const prompts = await this.loadPrompts();

    // Get current settings from ModelAgentManager
    const initialSettings = this.getCurrentSettings();

    // Create renderer
    const rendererContainer = contentEl.createDiv('chat-settings-renderer');

    this.renderer = new ChatSettingsRenderer(rendererContainer, {
      app: this.app,
      llmProviderSettings,
      initialSettings,
      options: { workspaces, prompts },
      callbacks: {
        onSettingsChange: (settings) => {
          this.pendingSettings = settings;
        }
      }
    });

    this.renderer.render();
  }

  private async loadWorkspaces(): Promise<Array<{ id: string; name: string }>> {
    try {
      const workspaces = await this.workspaceService.listWorkspaces();
      return workspaces.map(w => ({ id: w.id, name: w.name }));
    } catch {
      return [];
    }
  }

  private async loadPrompts(): Promise<Array<{ id: string; name: string }>> {
    try {
      const prompts = await this.modelAgentManager.getAvailablePrompts();
      return prompts.map(p => ({ id: p.id || p.name, name: p.name }));
    } catch {
      return [];
    }
  }

  private getCurrentSettings(): ChatSettings {
    const model = this.modelAgentManager.getSelectedModel();
    const prompt = this.modelAgentManager.getSelectedPrompt();
    const thinking = this.modelAgentManager.getThinkingSettings();
    const contextNotes = this.modelAgentManager.getContextNotes();
    const temperature = this.modelAgentManager.getTemperature();

    // Get plugin defaults for image settings
    const plugin = getNexusPlugin<NexusPluginWithSettings>(this.app);
    const llmSettings = plugin?.settings?.settings?.llmProviders;

    return {
      provider: model?.providerId || llmSettings?.defaultModel?.provider || '',
      model: model?.modelId || llmSettings?.defaultModel?.model || '',
      thinking: {
        enabled: thinking?.enabled ?? false,
        effort: thinking?.effort ?? 'medium'
      },
      temperature: temperature,
      imageProvider: llmSettings?.defaultImageModel?.provider || 'google',
      imageModel: llmSettings?.defaultImageModel?.model || 'gemini-2.5-flash-image',
      workspaceId: this.modelAgentManager.getSelectedWorkspaceId(),
      promptId: prompt?.id || prompt?.name || null,
      contextNotes: [...contextNotes]
    };
  }

  private async handleSave(): Promise<void> {
    if (!this.pendingSettings) {
      this.pendingSettings = this.renderer?.getSettings() || null;
    }

    if (!this.pendingSettings) {
      this.close();
      return;
    }

    try {
      const settings = this.pendingSettings;

      // Update model
      const availableModels = await this.modelAgentManager.getAvailableModels();
      const model = availableModels.find(
        m => m.providerId === settings.provider && m.modelId === settings.model
      );
      if (model) {
        this.modelAgentManager.handleModelChange(model);
      }

      // Update prompt
      if (settings.promptId) {
        const availablePrompts = await this.modelAgentManager.getAvailablePrompts();
        const prompt = availablePrompts.find(p => p.id === settings.promptId || p.name === settings.promptId);
        await this.modelAgentManager.handlePromptChange(prompt || null);
      } else {
        await this.modelAgentManager.handlePromptChange(null);
      }

      // Update workspace
      if (settings.workspaceId) {
        const workspace = await this.workspaceService.getWorkspace(settings.workspaceId);
        if (workspace?.context) {
          await this.modelAgentManager.setWorkspaceContext(settings.workspaceId, workspace.context);
        }
      } else {
        await this.modelAgentManager.clearWorkspaceContext();
      }

      // Update thinking
      this.modelAgentManager.setThinkingSettings(settings.thinking);

      // Update temperature
      this.modelAgentManager.setTemperature(settings.temperature);

      // Update context notes
      await this.modelAgentManager.setContextNotes(settings.contextNotes);

      // Save to conversation metadata
      if (this.conversationId) {
        await this.modelAgentManager.saveToConversation(this.conversationId);
      }

      this.close();
    } catch (error) {
      console.error('[ChatSettingsModal] Error saving settings:', error);
    }
  }

  onClose() {
    this.renderer = null;
    this.pendingSettings = null;
    this.contentEl.empty();
  }
}

```

## ui/chat/components/ContextProgressBar.ts

```typescript
/**
 * ContextProgressBar - Visual indicator of context window usage
 * 
 * Shows how much of the current model's context window is being used
 * by the conversation history, helping users understand when they're
 * approaching the limit.
 */

export interface ContextUsage {
  used: number;
  total: number;
  percentage: number;
}

export class ContextProgressBar {
  private element: HTMLElement | null = null;
  private progressBar: HTMLElement | null = null;
  private usageText: HTMLElement | null = null;
  private costBadge: HTMLElement | null = null;
  private currentUsage: ContextUsage = { used: 0, total: 0, percentage: 0 };
  private currentCost: { totalCost: number; currency: string } | null = null;

  constructor(
    private container: HTMLElement,
    private getContextUsage: () => Promise<ContextUsage>,
    private getConversationCost?: () => { totalCost: number; currency: string } | null
  ) {
    this.render();
  }

  /**
   * Render the context progress bar
   */
  private render(): void {
    this.container.empty();
    this.container.addClass('context-progress-container');

    // Header
    const header = this.container.createDiv('context-progress-header');
    const label = header.createSpan('context-progress-label');
    label.textContent = 'Context Usage';

    this.usageText = header.createSpan('context-progress-usage');
    this.usageText.textContent = '0 / 0 tokens (0%)';

    // Cost badge
    this.costBadge = header.createSpan('chat-cost-badge');
    this.costBadge.textContent = '$0.0000';

    // Progress bar container
    const progressContainer = this.container.createDiv('context-progress-bar-container');
    
    // Background bar
    const backgroundBar = progressContainer.createDiv('context-progress-bar-bg');
    
    // Progress bar (filled portion)
    this.progressBar = backgroundBar.createDiv('context-progress-bar-fill');
    this.progressBar.addClass('context-progress-bar-fill-initial');

    // Segments for visual indication
    this.createSegments(backgroundBar);

    this.element = this.container;
    this.updateDisplay();
  }

  /**
   * Create visual segments on the progress bar
   */
  private createSegments(container: HTMLElement): void {
    // Add segment markers at 25%, 50%, 75% for visual reference
    const segments = [25, 50, 75];

    segments.forEach(percent => {
      const segment = container.createDiv('context-progress-segment');
      segment.addClass('context-progress-segment-positioned');
      segment.style.left = `${percent}%`;
    });
  }

  /**
   * Update the progress bar display
   */
  public async update(): Promise<void> {
    try {
      this.currentUsage = await this.getContextUsage();

      // Update cost if callback provided
      if (this.getConversationCost) {
        this.currentCost = this.getConversationCost();
      }

      this.updateDisplay();
    } catch (error) {
      console.error('[ContextProgressBar] Failed to update context usage:', error);
    }
  }

  /**
   * Update the visual display
   */
  private updateDisplay(): void {
    if (!this.progressBar || !this.usageText) return;

    const { used, total, percentage } = this.currentUsage;

    // Ensure minimum visible width for non-zero usage
    // For large context windows (>100k), small percentages are invisible
    // Use logarithmic scaling for better visualization
    let visualPercentage = percentage;
    if (used > 0 && percentage < 2) {
      // Minimum 2% visual width if there's any usage
      // but scale between 2-5% based on actual percentage (0-2%)
      visualPercentage = 2 + (percentage / 2) * 3; // Maps 0-2% to 2-5%
    }

    // Update progress bar width with visual scaling
    this.progressBar.style.width = `${Math.min(visualPercentage, 100)}%`;

    // The gradient automatically shows the appropriate color based on fill width
    this.progressBar.className = 'context-progress-bar-fill';

    // Update usage text
    const usedFormatted = this.formatTokenCount(used);
    const totalFormatted = this.formatTokenCount(total);

    this.usageText.textContent = `${usedFormatted} / ${totalFormatted} tokens (${Math.round(percentage)}%)`;

    // Add tooltip with more details
    this.usageText.title = this.createTooltipText();

    // Update cost badge
    if (this.costBadge) {
      const cost = this.currentCost?.totalCost || 0;
      this.costBadge.textContent = `$${cost.toFixed(4)}`;
      this.costBadge.title = `Total conversation cost: $${cost.toFixed(6)}`;
    }
  }

  /**
   * Format token count for display
   */
  private formatTokenCount(tokens: number): string {
    if (tokens >= 1000000) {
      return `${(tokens / 1000000).toFixed(1)}M`;
    } else if (tokens >= 1000) {
      return `${(tokens / 1000).toFixed(1)}k`;
    } else {
      return tokens.toString();
    }
  }

  /**
   * Create detailed tooltip text
   */
  private createTooltipText(): string {
    const { used, total, percentage } = this.currentUsage;
    const remaining = total - used;
    
    return [
      `Context Window Usage`,
      `Used: ${used.toLocaleString()} tokens`,
      `Total: ${total.toLocaleString()} tokens`,
      `Remaining: ${remaining.toLocaleString()} tokens`,
      `Usage: ${percentage.toFixed(1)}%`
    ].join('\n');
  }

  /**
   * Set context usage directly (for immediate updates)
   */
  public setUsage(usage: ContextUsage): void {
    this.currentUsage = usage;
    this.updateDisplay();
  }

  /**
   * Get current usage
   */
  public getCurrentUsage(): ContextUsage {
    return { ...this.currentUsage };
  }

  /**
   * Show warning when approaching limit
   */
  public checkWarningThresholds(): void {
    const { percentage } = this.currentUsage;
    
    if (percentage >= 95) {
      this.showWarning('Context window nearly full. Consider starting a new conversation.', 'critical');
    } else if (percentage >= 85) {
      this.showWarning('Context window getting full. Responses may be truncated soon.', 'warning');
    }
  }

  /**
   * Show context usage warning
   */
  private showWarning(message: string, level: 'warning' | 'critical'): void {
    // Create temporary warning element
    const warning = document.createElement('div');
    warning.addClass('context-warning-message');
    warning.addClass(`context-warning-${level}`);
    warning.textContent = message;
    
    // Insert after the progress bar
    if (this.element) {
      this.element.appendChild(warning);
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        if (warning.parentElement) {
          warning.remove();
        }
      }, 5000);
    }
  }

  /**
   * Reset usage (for new conversations)
   */
  public reset(): void {
    this.currentUsage = { used: 0, total: 0, percentage: 0 };
    this.updateDisplay();
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    this.element = null;
    this.progressBar = null;
    this.usageText = null;
  }
}
```

## ui/chat/components/ConversationList.ts

```typescript
/**
 * ConversationList - Sidebar component for managing conversations
 *
 * Displays list of conversations with create/delete/rename functionality
 */

import { setIcon, Component } from 'obsidian';
import { ConversationData } from '../../../types/chat/ChatTypes';

export class ConversationList {
  private conversations: ConversationData[] = [];
  private activeConversationId: string | null = null;

  constructor(
    private container: HTMLElement,
    private onConversationSelect: (conversation: ConversationData) => void,
    private onConversationDelete: (conversationId: string) => void,
    private onConversationRename?: (conversationId: string, newTitle: string) => void,
    private component?: Component
  ) {
    this.render();
  }

  /**
   * Set conversations to display
   */
  setConversations(conversations: ConversationData[]): void {
    this.conversations = conversations.sort((a, b) => b.updated - a.updated);
    this.render();
  }

  /**
   * Set active conversation
   */
  setActiveConversation(conversationId: string): void {
    this.activeConversationId = conversationId;
    this.updateActiveState();
  }

  /**
   * Render the conversation list
   */
  private render(): void {
    this.container.empty();
    this.container.addClass('conversation-list');

    if (this.conversations.length === 0) {
      const emptyState = this.container.createDiv('conversation-list-empty');
      emptyState.textContent = 'No conversations yet';
      return;
    }

    this.conversations.forEach(conversation => {
      const item = this.container.createDiv('conversation-item');

      if (conversation.id === this.activeConversationId) {
        item.addClass('active');
      }

      // Main conversation content
      const content = item.createDiv('conversation-content');
      const selectHandler = () => {
        this.onConversationSelect(conversation);
      };
      this.component!.registerDomEvent(content, 'click', selectHandler);

      // Title
      const title = content.createDiv('conversation-title');
      title.textContent = conversation.title;

      // Last message preview
      const lastMessage = conversation.messages[conversation.messages.length - 1];
      if (lastMessage) {
        const preview = content.createDiv('conversation-preview');
        const previewText = lastMessage.content.length > 60
          ? lastMessage.content.substring(0, 60) + '...'
          : lastMessage.content;
        preview.textContent = previewText;
      }

      // Timestamp
      const timestamp = content.createDiv('conversation-timestamp');
      timestamp.textContent = this.formatTimestamp(conversation.updated);

      // Action buttons container
      const actions = item.createDiv('conversation-actions');

      // Edit/rename button - uses clickable-icon for proper icon sizing
      if (this.onConversationRename) {
        const editBtn = actions.createEl('button', {
          cls: 'conversation-action-btn conversation-edit-btn clickable-icon'
        });
        setIcon(editBtn, 'pencil');
        editBtn.setAttribute('aria-label', 'Rename conversation');
        const editHandler = (e: MouseEvent) => {
          e.stopPropagation();
          this.showRenameInput(item, content, conversation);
        };
        this.component!.registerDomEvent(editBtn, 'click', editHandler);
      }

      // Delete button - uses clickable-icon for proper icon sizing
      const deleteBtn = actions.createEl('button', {
        cls: 'conversation-action-btn conversation-delete-btn clickable-icon'
      });
      setIcon(deleteBtn, 'trash-2');
      deleteBtn.setAttribute('aria-label', 'Delete conversation');
      const deleteHandler = (e: MouseEvent) => {
        e.stopPropagation();
        if (confirm('Delete this conversation?')) {
          this.onConversationDelete(conversation.id);
        }
      };
      this.component!.registerDomEvent(deleteBtn, 'click', deleteHandler);
    });
  }

  /**
   * Show inline rename input for a conversation
   */
  private showRenameInput(
    item: HTMLElement,
    content: HTMLElement,
    conversation: ConversationData
  ): void {
    const titleEl = content.querySelector('.conversation-title') as HTMLElement;
    if (!titleEl) return;

    const currentTitle = conversation.title;

    // Create input element
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentTitle;
    input.className = 'conversation-rename-input';

    // Replace title with input
    titleEl.replaceWith(input);
    input.focus();
    input.select();

    // Hide action buttons while editing
    const actions = item.querySelector('.conversation-actions') as HTMLElement;
    if (actions) {
      actions.addClass('conversation-actions-hidden');
    }

    const finishRename = (save: boolean) => {
      const newTitle = input.value.trim();

      // Restore title element
      const newTitleEl = document.createElement('div');
      newTitleEl.className = 'conversation-title';
      newTitleEl.textContent = save && newTitle ? newTitle : currentTitle;
      input.replaceWith(newTitleEl);

      // Restore action buttons
      if (actions) {
        actions.removeClass('conversation-actions-hidden');
      }

      // Call rename callback if title changed
      if (save && newTitle && newTitle !== currentTitle && this.onConversationRename) {
        this.onConversationRename(conversation.id, newTitle);
      }
    };

    // Handle blur (save on focus loss)
    const blurHandler = () => finishRename(true);

    // Handle keyboard events
    const keydownHandler = (e: KeyboardEvent) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        input.blur(); // Trigger blur handler to save
      } else if (e.key === 'Escape') {
        e.preventDefault();
        // Remove blur handler before restoring to avoid double-save
        input.removeEventListener('blur', blurHandler);
        finishRename(false);
      }
    };

    this.component!.registerDomEvent(input, 'blur', blurHandler);
    this.component!.registerDomEvent(input, 'keydown', keydownHandler);
  }

  /**
   * Update active state styling
   */
  private updateActiveState(): void {
    const items = this.container.querySelectorAll('.conversation-item');
    items.forEach((item, index) => {
      const conversation = this.conversations[index];
      if (conversation && conversation.id === this.activeConversationId) {
        item.addClass('active');
      } else {
        item.removeClass('active');
      }
    });
  }

  /**
   * Format timestamp for display
   */
  private formatTimestamp(timestamp: number): string {
    const date = new Date(timestamp);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);

    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;

    return date.toLocaleDateString();
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    // Clean up any event listeners if needed
  }
}

```

## ui/chat/components/ConversationTitleModal.ts

```typescript
/**
 * ConversationTitleModal - Modal for creating new conversation with title
 *
 * Properly extends Obsidian's Modal class for proper focus management
 */

import { App, Modal, Setting } from 'obsidian';

export class ConversationTitleModal extends Modal {
  private result: string | null = null;
  private submitted = false;
  private inputEl: HTMLInputElement | null = null;

  constructor(app: App, private onSubmit: (title: string | null) => void) {
    super(app);
  }

  onOpen() {
    const { contentEl } = this;
    contentEl.addClass('chat-conversation-title-modal');

    contentEl.createEl('h2', { text: 'New Conversation' });
    contentEl.createEl('p', { text: 'Enter a title for your new conversation:' });

    // Create input using Obsidian's Setting component for consistency
    new Setting(contentEl)
      .setName('Conversation Title')
      .addText((text) => {
        this.inputEl = text.inputEl;
        text
          .setPlaceholder('e.g., "Help with React project"')
          .onChange((value) => {
            this.result = value;
          });
        // Modal cleanup handles this automatically
        text.inputEl.addEventListener('keydown', (e: KeyboardEvent) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            this.submit();
          }
        });

        // Focus the input after a small delay to ensure modal is fully rendered
        setTimeout(() => {
          text.inputEl.focus();
          text.inputEl.select();
        }, 10);
      });

    // Action buttons
    const buttonContainer = contentEl.createDiv('modal-button-container');
    buttonContainer.addClass('modal-button-container-flex');

    const cancelBtn = buttonContainer.createEl('button', {
      text: 'Cancel',
      cls: 'mod-cancel'
    });
    cancelBtn.addEventListener('click', () => this.close());

    const createBtn = buttonContainer.createEl('button', {
      text: 'Create Chat',
      cls: 'mod-cta'
    });
    createBtn.addEventListener('click', () => this.submit());
  }

  private submit() {
    const title = this.result?.trim();
    if (!title) {
      // Show error state on input
      if (this.inputEl) {
        this.inputEl.addClass('is-invalid');
        this.inputEl.focus();
        setTimeout(() => {
          this.inputEl?.removeClass('is-invalid');
        }, 2000);
      }
      return;
    }

    this.submitted = true;
    this.close();
  }

  onClose() {
    const { contentEl } = this;
    contentEl.empty();

    // Call the callback with result (or null if cancelled)
    if (this.submitted && this.result?.trim()) {
      this.onSubmit(this.result.trim());
    } else {
      this.onSubmit(null);
    }
  }
}

```

## ui/chat/components/factories/ToolBubbleFactory.ts

```typescript
/**
 * ToolBubbleFactory - Factory for creating tool and text bubble elements
 * Location: /src/ui/chat/components/factories/ToolBubbleFactory.ts
 *
 * This class is responsible for:
 * - Creating tool bubbles containing progressive tool accordions
 * - Creating text bubbles for assistant responses
 * - Creating tool bubbles on-demand during streaming
 *
 * Used by MessageBubble to separate tool execution UI from text responses,
 * following the Factory pattern for consistent bubble creation.
 */

import { setIcon, Component } from 'obsidian';
import { ConversationMessage } from '../../../../types/chat/ChatTypes';
import { ProgressiveToolAccordion } from '../ProgressiveToolAccordion';
import { formatToolDisplayName, normalizeToolName } from '../../../../utils/toolNameUtils';

export interface ToolBubbleFactoryOptions {
  message: ConversationMessage;
  parseParameterValue: (value: any) => any;
  getToolCallArguments: (toolCall: any) => any;
  progressiveToolAccordions: Map<string, ProgressiveToolAccordion>;
  component?: Component;
}

export class ToolBubbleFactory {
  /**
   * Create tool bubble containing multiple tool accordions
   */
  static createToolBubble(options: ToolBubbleFactoryOptions): HTMLElement {
    const { message, parseParameterValue, getToolCallArguments, progressiveToolAccordions, component } = options;

    const toolContainer = document.createElement('div');
    toolContainer.addClass('message-container');
    toolContainer.addClass('message-tool');
    toolContainer.setAttribute('data-message-id', `${message.id}_tools`);

    const bubble = toolContainer.createDiv('message-bubble tool-bubble');

    // Header with wrench icon
    const header = bubble.createDiv('message-header');
    const roleIcon = header.createDiv('message-role-icon');
    setIcon(roleIcon, 'wrench');

    // Content area for tool accordions
    const content = bubble.createDiv('tool-bubble-content');

    // Create reasoning accordion if message has persisted reasoning
    if (message.reasoning) {
      const reasoningAccordion = new ProgressiveToolAccordion(component);
      const reasoningEl = reasoningAccordion.createElement();

      // Create synthetic reasoning tool call for display
      const reasoningId = `reasoning_${message.id}`;
      reasoningAccordion.detectTool({
        id: reasoningId,
        name: 'Reasoning',
        technicalName: 'extended_thinking',
        type: 'reasoning',
        result: message.reasoning,
        status: 'completed',
        isVirtual: true,
        isComplete: true
      });

      content.appendChild(reasoningEl);
      progressiveToolAccordions.set(reasoningId, reasoningAccordion);
    }

    // Create one ProgressiveToolAccordion per tool (unwrapping useTool calls)
    if (message.toolCalls) {
      message.toolCalls.forEach(toolCall => {
        // Unwrap useTool calls to show inner tools
        const unwrappedTools = ToolBubbleFactory.unwrapUseTool(toolCall, parseParameterValue, getToolCallArguments);

        unwrappedTools.forEach(unwrapped => {
          const accordion = new ProgressiveToolAccordion(component);
          const accordionEl = accordion.createElement();

          accordion.detectTool({
            id: unwrapped.id,
            name: unwrapped.displayName,
            technicalName: unwrapped.technicalName,
            parameters: unwrapped.parameters,
            isComplete: true
          });

          // If tool has results, mark as completed
          if (unwrapped.result !== undefined || unwrapped.success !== undefined) {
            accordion.completeTool(
              unwrapped.id,
              unwrapped.result,
              unwrapped.success !== false,
              unwrapped.error
            );
          }

          content.appendChild(accordionEl);
          progressiveToolAccordions.set(unwrapped.id, accordion);
        });
      });
    }

    return toolContainer;
  }

  /**
   * Create text bubble containing only the assistant response text
   */
  static createTextBubble(
    message: ConversationMessage,
    renderContentCallback: (content: HTMLElement, text: string) => Promise<void>,
    onCopy: (messageId: string) => void,
    showCopyFeedback: (button: HTMLElement) => void,
    messageBranchNavigator: any | null,
    onMessageAlternativeChanged?: (messageId: string, alternativeIndex: number) => void,
    component?: Component
  ): HTMLElement {
    const messageContainer = document.createElement('div');
    messageContainer.addClass('message-container');
    messageContainer.addClass('message-assistant');
    messageContainer.setAttribute('data-message-id', `${message.id}_text`);

    const bubble = messageContainer.createDiv('message-bubble');

    // Actions inside the bubble (for sticky positioning)
    const actions = bubble.createDiv('message-actions-external');

    // Header with bot icon
    const header = bubble.createDiv('message-header');
    const roleIcon = header.createDiv('message-role-icon');
    setIcon(roleIcon, 'bot');

    // Message content
    const content = bubble.createDiv('message-content');

    // Render content with enhanced markdown support
    const activeContent = ToolBubbleFactory.getActiveMessageContent(message);
    renderContentCallback(content, activeContent).catch(error => {
      console.error('[ToolBubbleFactory] Error rendering text bubble content:', error);
    });

    // Copy button
    const copyBtn = actions.createEl('button', {
      cls: 'message-action-btn clickable-icon',
      attr: { title: 'Copy message' }
    });
    setIcon(copyBtn, 'copy');
    const copyHandler = () => {
      showCopyFeedback(copyBtn);
      onCopy(message.id);
    };
    component!.registerDomEvent(copyBtn, 'click', copyHandler);

    // Message branch navigator for messages with branches
    if (message.branches && message.branches.length > 0 && messageBranchNavigator) {
      const navigatorEvents = {
        onAlternativeChanged: (messageId: string, alternativeIndex: number) => {
          if (onMessageAlternativeChanged) {
            onMessageAlternativeChanged(messageId, alternativeIndex);
          }
        },
        onError: (errorMessage: string) => console.error('[ToolBubbleFactory] Branch navigation error:', errorMessage)
      };

      messageBranchNavigator.updateMessage(message);
    }

    return messageContainer;
  }

  /**
   * Create tool bubble on-demand during streaming (when first tool is detected)
   */
  static createToolBubbleOnDemand(message: ConversationMessage, parentElement: HTMLElement | null): HTMLElement {
    const toolContainer = document.createElement('div');
    toolContainer.addClass('message-container');
    toolContainer.addClass('message-tool');
    toolContainer.setAttribute('data-message-id', `${message.id}_tools`);

    const bubble = toolContainer.createDiv('message-bubble tool-bubble');

    // Header with wrench icon
    const header = bubble.createDiv('message-header');
    const roleIcon = header.createDiv('message-role-icon');
    setIcon(roleIcon, 'wrench');

    // Content area for tool accordions
    bubble.createDiv('tool-bubble-content');

    // Insert before the main message bubble (or at the beginning if no main bubble yet)
    if (parentElement) {
      parentElement.insertBefore(toolContainer, parentElement.firstChild);
    }

    return toolContainer;
  }

  /**
   * Get the active content for the message (original or from branch)
   */
  private static getActiveMessageContent(message: ConversationMessage): string {
    const activeIndex = message.activeAlternativeIndex || 0;

    // Index 0 is the original message
    if (activeIndex === 0) {
      return message.content;
    }

    // Branch messages start at index 1
    if (message.branches && message.branches.length > 0) {
      const branchIndex = activeIndex - 1;
      if (branchIndex >= 0 && branchIndex < message.branches.length) {
        const branch = message.branches[branchIndex];
        if (branch.messages.length > 0) {
          return branch.messages[branch.messages.length - 1].content;
        }
      }
    }

    // Fallback to original content
    return message.content;
  }

  /**
   * Unwrap toolManager_useTool calls to show inner tools
   * Returns an array of unwrapped tool info for display
   */
  private static unwrapUseTool(
    toolCall: any,
    parseParameterValue: (value: any) => any,
    getToolCallArguments: (toolCall: any) => any
  ): Array<{
    id: string;
    displayName: string;
    technicalName: string;
    parameters: any;
    result?: any;
    success?: boolean;
    error?: string;
  }> {
    const rawName = toolCall.technicalName || toolCall.name || toolCall.function?.name || 'Unknown Tool';

    // Check if this is a useTool wrapper call
    const isUseTool = rawName === 'toolManager_useTool' ||
                      rawName === 'toolManager.useTool' ||
                      rawName.endsWith('_useTool') ||
                      rawName.endsWith('.useTool');

    if (!isUseTool) {
      // Not a useTool call - return as-is
      const displayName = toolCall.displayName || formatToolDisplayName(rawName);
      const technicalName = toolCall.technicalName || normalizeToolName(rawName) || rawName;
      const fallbackArguments = getToolCallArguments(toolCall);
      const parameters = parseParameterValue(
        toolCall.parameters !== undefined ? toolCall.parameters : fallbackArguments
      );

      return [{
        id: toolCall.id,
        displayName,
        technicalName,
        parameters,
        result: toolCall.result,
        success: toolCall.success,
        error: toolCall.error
      }];
    }

    // Unwrap useTool - extract inner calls
    const fallbackArguments = getToolCallArguments(toolCall);
    const useToolParams = parseParameterValue(
      toolCall.parameters !== undefined ? toolCall.parameters : fallbackArguments
    );

    // useTool format: { context: {...}, calls: [{ agent, tool, params }] }
    const calls = useToolParams?.calls || [];

    // useTool result format: { success, data: { results: [...] } }
    const useToolResult = toolCall.result as {
      success?: boolean;
      data?: { results?: Array<{ success?: boolean; data?: any; error?: string; agent?: string; tool?: string }> };
    } | undefined;
    const results = useToolResult?.data?.results || [];

    if (calls.length === 0) {
      // No calls in parameters - reconstruct from results
      if (results.length > 0) {
        return results.map((result: { agent?: string; tool?: string; success?: boolean; data?: any; error?: string }, index: number) => {
          const innerAgentName = result.agent || 'unknown';
          const innerToolName = result.tool || 'unknown';
          const fullName = `${innerAgentName}.${innerToolName}`;

          return {
            id: `${toolCall.id}_${index}`,
            displayName: formatToolDisplayName(fullName),
            technicalName: fullName,
            parameters: {}, // Parameters not available in results
            result: result.data,
            success: result.success,
            error: result.error
          };
        });
      }

      // No inner calls and no results - show the wrapper itself
      return [{
        id: toolCall.id,
        displayName: 'useTool (empty)',
        technicalName: rawName,
        parameters: useToolParams,
        result: toolCall.result,
        success: toolCall.success,
        error: toolCall.error
      }];
    }

    // Create an unwrapped entry for each inner call
    return calls.map((call: { agent?: string; tool?: string; params?: any }, index: number) => {
      const innerToolName = call.tool || 'unknown';
      const innerAgentName = call.agent || 'unknown';
      const fullName = `${innerAgentName}.${innerToolName}`;
      const innerResult = results[index];

      return {
        id: `${toolCall.id}_${index}`,
        displayName: formatToolDisplayName(fullName),
        technicalName: fullName,
        parameters: call.params || {},
        result: innerResult?.data,
        success: innerResult?.success,
        error: innerResult?.error
      };
    });
  }
}

```

## ui/chat/components/MessageBranchNavigator.ts

```typescript
/**
 * MessageBranchNavigator - UI component for navigating between message branches
 *
 * Shows mini "< X/Y >" navigation for individual messages that have multiple branches
 * Only displays when message has branches (human or subagent)
 */

import { ConversationMessage } from '../../../types/chat/ChatTypes';
import { setIcon, Component } from 'obsidian';

export interface MessageBranchNavigatorEvents {
  onAlternativeChanged: (messageId: string, alternativeIndex: number) => void;
  onError: (message: string) => void;
}

export class MessageBranchNavigator {
  private container: HTMLElement;
  private branchIndicator!: HTMLElement;
  private prevButton!: HTMLButtonElement;
  private nextButton!: HTMLButtonElement;
  private currentMessage: ConversationMessage | null = null;

  constructor(
    container: HTMLElement,
    private events: MessageBranchNavigatorEvents,
    private component?: Component
  ) {
    this.container = container;
    this.createBranchNavigator();
    this.hide(); // Hidden by default
  }

  /**
   * Create the mini branch navigation UI
   */
  private createBranchNavigator(): void {
    this.container.addClass('message-branch-navigator');

    this.prevButton = this.container.createEl('button', {
      cls: 'message-action-btn message-branch-prev clickable-icon',
      attr: {
        'aria-label': 'Previous alternative',
        'title': 'Go to previous alternative response'
      }
    });
    setIcon(this.prevButton, 'chevron-left');

    // Branch indicator (shows current/total like "2/4")
    this.branchIndicator = this.container.createDiv('message-branch-indicator');
    this.branchIndicator.textContent = '1/1';

    this.nextButton = this.container.createEl('button', {
      cls: 'message-action-btn message-branch-next clickable-icon',
      attr: {
        'aria-label': 'Next alternative',
        'title': 'Go to next alternative response'
      }
    });
    setIcon(this.nextButton, 'chevron-right');

    // Event listeners
    const prevHandler = () => this.handlePreviousAlternative();
    const nextHandler = () => this.handleNextAlternative();
    this.component!.registerDomEvent(this.prevButton, 'click', prevHandler);
    this.component!.registerDomEvent(this.nextButton, 'click', nextHandler);
  }

  /**
   * Update the navigator for a message
   */
  updateMessage(message: ConversationMessage): void {
    this.currentMessage = message;
    this.updateDisplay();
  }

  /**
   * Update the display based on current message
   */
  private updateDisplay(): void {
    if (!this.currentMessage || !this.hasAlternatives()) {
      this.hide();
      return;
    }

    const alternativeCount = this.getAlternativeCount();
    const currentIndex = this.currentMessage.activeAlternativeIndex || 0;
    
    // Show and update the indicator (1-based display)
    this.show();
    this.branchIndicator.textContent = `${currentIndex + 1}/${alternativeCount}`;
    
    // Update button states
    this.updateButtonStates(currentIndex, alternativeCount);
  }

  /**
   * Update navigation button states
   */
  private updateButtonStates(currentIndex: number, totalCount: number): void {
    const isFirst = currentIndex === 0;
    const isLast = currentIndex === totalCount - 1;
    
    this.prevButton.disabled = isFirst;
    this.nextButton.disabled = isLast;
    
    // Update visual states
    this.prevButton.toggleClass('disabled', isFirst);
    this.nextButton.toggleClass('disabled', isLast);
  }

  /**
   * Handle previous alternative navigation
   */
  private async handlePreviousAlternative(): Promise<void> {
    if (!this.currentMessage) return;
    
    const currentIndex = this.currentMessage.activeAlternativeIndex || 0;
    if (currentIndex <= 0) return;

    const newIndex = currentIndex - 1;
    this.events.onAlternativeChanged(this.currentMessage.id, newIndex);
    this.updateDisplay();
  }

  /**
   * Handle next alternative navigation
   */
  private async handleNextAlternative(): Promise<void> {
    if (!this.currentMessage) return;
    
    const currentIndex = this.currentMessage.activeAlternativeIndex || 0;
    const totalCount = this.getAlternativeCount();
    if (currentIndex >= totalCount - 1) return;

    const newIndex = currentIndex + 1;
    this.events.onAlternativeChanged(this.currentMessage.id, newIndex);
    this.updateDisplay();
  }

  /**
   * Check if current message has branches
   */
  private hasAlternatives(): boolean {
    return !!(this.currentMessage?.branches && this.currentMessage.branches.length > 0);
  }

  /**
   * Get total branch count (including the original message)
   */
  private getAlternativeCount(): number {
    if (!this.hasAlternatives()) return 1;
    return (this.currentMessage!.branches!.length) + 1; // +1 for original message
  }

  /**
   * Show the navigator
   */
  private show(): void {
    this.container.removeClass('message-branch-navigator-hidden');
    this.container.addClass('message-branch-navigator-visible');
  }

  /**
   * Hide the navigator
   */
  private hide(): void {
    this.container.removeClass('message-branch-navigator-visible');
    this.container.addClass('message-branch-navigator-hidden');
  }

  /**
   * Get current alternative information for external use
   */
  getCurrentAlternativeInfo(): { current: number; total: number; hasAlternatives: boolean } | null {
    if (!this.currentMessage) return null;
    
    const currentIndex = this.currentMessage.activeAlternativeIndex || 0;
    const totalCount = this.getAlternativeCount();
    
    return {
      current: currentIndex + 1, // 1-based for display
      total: totalCount,
      hasAlternatives: this.hasAlternatives()
    };
  }

  /**
   * Check if navigator is currently visible
   */
  isVisible(): boolean {
    return this.container.hasClass('message-branch-navigator-visible');
  }

  /**
   * Clean up resources
   */
  destroy(): void {
    this.prevButton.removeEventListener('click', () => this.handlePreviousAlternative());
    this.nextButton.removeEventListener('click', () => this.handleNextAlternative());
    this.container.empty();
  }
}
```

## ui/chat/components/MessageBubble.ts

```typescript
/**
 * MessageBubble - Individual message bubble component
 * Location: /src/ui/chat/components/MessageBubble.ts
 *
 * Renders user/AI messages with copy, retry, and edit actions.
 * Delegates rendering responsibilities to specialized classes following SOLID principles.
 *
 * Used by MessageDisplay to render individual messages in the chat interface.
 * Coordinates with ReferenceBadgeRenderer, ToolBubbleFactory, ToolEventParser,
 * MessageContentRenderer, and MessageEditController for specific concerns.
 */

import { ConversationMessage } from '../../../types/chat/ChatTypes';
import { ProgressiveToolAccordion } from './ProgressiveToolAccordion';
import { MessageBranchNavigator, MessageBranchNavigatorEvents } from './MessageBranchNavigator';
import { setIcon, Component, App } from 'obsidian';

// Extracted classes
import { ReferenceBadgeRenderer } from './renderers/ReferenceBadgeRenderer';
import { ToolBubbleFactory } from './factories/ToolBubbleFactory';
import { ToolEventParser } from '../utils/ToolEventParser';
import { MessageContentRenderer } from './renderers/MessageContentRenderer';
import { MessageEditController } from '../controllers/MessageEditController';

export class MessageBubble extends Component {
  private element: HTMLElement | null = null;
  private loadingInterval: any = null;
  private progressiveToolAccordions: Map<string, ProgressiveToolAccordion> = new Map();
  private messageBranchNavigator: MessageBranchNavigator | null = null;
  private toolBubbleElement: HTMLElement | null = null;
  private textBubbleElement: HTMLElement | null = null;
  private imageBubbleElement: HTMLElement | null = null;

  constructor(
    private message: ConversationMessage,
    private app: App,
    private onCopy: (messageId: string) => void,
    private onRetry: (messageId: string) => void,
    private onEdit?: (messageId: string, newContent: string) => void,
    private onToolEvent?: (messageId: string, event: 'detected' | 'started' | 'completed', data: any) => void,
    private onMessageAlternativeChanged?: (messageId: string, alternativeIndex: number) => void,
    private onViewBranch?: (branchId: string) => void
  ) {
    super();
  }

  /**
   * Create the message bubble element
   * For assistant messages with toolCalls or reasoning, returns a fragment containing tool bubble + text bubble
   */
  createElement(): HTMLElement {
    const activeToolCalls = this.getActiveToolCalls(this.message);
    const hasToolCalls = this.message.role === 'assistant' && activeToolCalls && activeToolCalls.length > 0;
    const activeReasoning = this.getActiveReasoning(this.message);
    const hasReasoning = this.message.role === 'assistant' && activeReasoning;
    const showToolBubble = hasToolCalls || hasReasoning;
    const activeContent = this.getActiveMessageContent(this.message);

    if (showToolBubble) {
      const wrapper = document.createElement('div');
      wrapper.addClass('message-group');
      wrapper.setAttribute('data-message-id', this.message.id);

      // Render using the active alternative's tool calls and reasoning so retries/branches preserve them
      const renderMessage: ConversationMessage = { ...this.message, toolCalls: activeToolCalls, reasoning: activeReasoning };

      // Create tool bubble using factory
      this.toolBubbleElement = ToolBubbleFactory.createToolBubble({
        message: renderMessage,
        parseParameterValue: ToolEventParser.parseParameterValue,
        getToolCallArguments: ToolEventParser.getToolCallArguments,
        progressiveToolAccordions: this.progressiveToolAccordions,
        component: this
      });
      wrapper.appendChild(this.toolBubbleElement);

      // Wire up onViewBranch callback to all accordions
      if (this.onViewBranch) {
        this.progressiveToolAccordions.forEach(accordion => {
          accordion.setCallbacks({ onViewBranch: this.onViewBranch });
        });
      }

      // Check for image results in completed tool calls (for loaded messages)
      if (activeToolCalls) {
        for (const toolCall of activeToolCalls) {
          if (toolCall.result && toolCall.success !== false) {
            const imageData = this.extractImageFromResult(toolCall.result);
            if (imageData) {
              this.createImageBubbleStatic(wrapper, imageData);
            }
          }
        }
      }

      // Create text bubble if there's content OR if streaming (need element for StreamingController)
      const isStreaming = this.message.state === 'streaming';
      if ((activeContent && activeContent.trim()) || isStreaming) {
        this.textBubbleElement = ToolBubbleFactory.createTextBubble(
          renderMessage,
          (container, content) => this.renderContent(container, content),
          this.onCopy,
          (button) => this.showCopyFeedback(button),
          this.messageBranchNavigator,
          this.onMessageAlternativeChanged,
          this
        );
        wrapper.appendChild(this.textBubbleElement);

        // Add branch navigator for assistant messages with branches
        if (renderMessage.branches && renderMessage.branches.length > 0) {
          const actions = this.textBubbleElement.querySelector('.message-actions-external');
          if (actions instanceof HTMLElement) {
            const navigatorEvents: MessageBranchNavigatorEvents = {
              onAlternativeChanged: (messageId, alternativeIndex) => {
                if (this.onMessageAlternativeChanged) {
                  this.onMessageAlternativeChanged(messageId, alternativeIndex);
                }
              },
              onError: (message) => console.error('[MessageBubble] Branch navigation error:', message)
            };

            this.messageBranchNavigator = new MessageBranchNavigator(actions, navigatorEvents, this);
            this.messageBranchNavigator.updateMessage(renderMessage);
          }
        }
      }

      this.element = wrapper;
      return wrapper;
    }

    // Normal single bubble for user messages or assistant without tools
    const messageContainer = document.createElement('div');
    messageContainer.addClass('message-container');
    messageContainer.addClass(`message-${this.message.role}`);
    messageContainer.setAttribute('data-message-id', this.message.id);

    const bubble = messageContainer.createDiv('message-bubble');

    // Message header with role icon only
    const header = bubble.createDiv('message-header');
    const roleIcon = header.createDiv('message-role-icon');
    if (this.message.role === 'user') {
      setIcon(roleIcon, 'user');
    } else if (this.message.role === 'tool') {
      setIcon(roleIcon, 'wrench');
    } else {
      setIcon(roleIcon, 'bot');
    }

    // Add loading state in header if AI message is loading with empty content
    if (this.message.role === 'assistant' && this.message.isLoading && !this.message.content.trim()) {
      const loadingSpan = header.createEl('span', { cls: 'ai-loading-header' });
      loadingSpan.appendText('Thinking');
      loadingSpan.createEl('span', { cls: 'dots', text: '...' });
      this.startLoadingAnimation(loadingSpan);
    }

    // Create actions in header for user messages (next to icon), elsewhere for others
    // This prevents action buttons from overlapping message content on mobile
    let actions: HTMLElement;
    if (this.message.role === 'user') {
      actions = header.createDiv('message-actions-external');
    } else if (this.message.role === 'assistant') {
      actions = bubble.createDiv('message-actions-external');
    } else {
      actions = messageContainer.createDiv('message-actions-external');
    }

    this.createActionButtons(actions, bubble);

    // Message content
    const content = bubble.createDiv('message-content');
    this.renderContent(content, activeContent).catch(error => {
      console.error('[MessageBubble] Error rendering initial content:', error);
    });

    this.element = messageContainer;
    return messageContainer;
  }

  /**
   * Create action buttons (edit, retry, copy, branch navigator)
   */
  private createActionButtons(actions: HTMLElement, bubble: HTMLElement): void {
    if (this.message.role === 'user') {
      // Edit button for user messages
      if (this.onEdit) {
        const editBtn = actions.createEl('button', {
          cls: 'message-action-btn clickable-icon',
          attr: { title: 'Edit message' }
        });
        setIcon(editBtn, 'edit');
        this.registerDomEvent(editBtn, 'click', () => MessageEditController.handleEdit(this.message, this.element, this.onEdit!, this));
      }

      // Retry button for user messages
      const retryBtn = actions.createEl('button', {
        cls: 'message-action-btn clickable-icon',
        attr: { title: 'Retry message' }
      });
      setIcon(retryBtn, 'rotate-ccw');
      this.registerDomEvent(retryBtn, 'click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        if (this.onRetry) {
          this.onRetry(this.message.id);
        }
      });
    } else if (this.message.role === 'tool') {
      // Tool messages get minimal actions - just copy for debugging
      const copyBtn = actions.createEl('button', {
        cls: 'message-action-btn clickable-icon',
        attr: { title: 'Copy tool execution details' }
      });
      setIcon(copyBtn, 'copy');
      this.registerDomEvent(copyBtn, 'click', () => {
        this.showCopyFeedback(copyBtn);
        this.onCopy(this.message.id);
      });
    } else {
      // Copy button for AI messages
      const copyBtn = actions.createEl('button', {
        cls: 'message-action-btn clickable-icon',
        attr: { title: 'Copy message' }
      });
      setIcon(copyBtn, 'copy');
      this.registerDomEvent(copyBtn, 'click', () => {
        this.showCopyFeedback(copyBtn);
        this.onCopy(this.message.id);
      });

      // Message branch navigator for AI messages with branches
      if (this.message.branches && this.message.branches.length > 0) {
        const navigatorEvents: MessageBranchNavigatorEvents = {
          onAlternativeChanged: (messageId, alternativeIndex) => {
            if (this.onMessageAlternativeChanged) {
              this.onMessageAlternativeChanged(messageId, alternativeIndex);
            }
          },
          onError: (message) => console.error('[MessageBubble] Branch navigation error:', message)
        };

        this.messageBranchNavigator = new MessageBranchNavigator(actions, navigatorEvents, this);
        this.messageBranchNavigator.updateMessage(this.message);
      }
    }
  }

  /**
   * Render message content using enhanced markdown renderer
   */
  private async renderContent(container: HTMLElement, content: string): Promise<void> {
    // Skip rendering if loading with empty content
    if (this.message.isLoading && this.message.role === 'assistant' && !content.trim()) {
      return;
    }

    const referenceMetadata = ReferenceBadgeRenderer.getReferenceMetadata(this.message.metadata);
    await MessageContentRenderer.renderContent(container, content, this.app, this, referenceMetadata);
  }

  /**
   * Get the DOM element
   */
  getElement(): HTMLElement | null {
    return this.element;
  }

  /**
   * Start loading animation (animated dots)
   */
  private startLoadingAnimation(container: HTMLElement): void {
    const dotsElement = container.querySelector('.dots');
    if (dotsElement) {
      let dotCount = 0;
      this.loadingInterval = setInterval(() => {
        dotCount = (dotCount + 1) % 4;
        dotsElement.textContent = '.'.repeat(dotCount);
      }, 500);
    }
  }

  /**
   * Stop loading animation and remove loading UI
   */
  stopLoadingAnimation(): void {
    if (this.loadingInterval) {
      clearInterval(this.loadingInterval);
      this.loadingInterval = null;
    }

    if (this.element) {
      const loadingElement = this.element.querySelector('.ai-loading-header');
      if (loadingElement) {
        loadingElement.remove();
      }
    }
  }

  /**
   * Update static message content
   */
  updateContent(content: string): void {
    if (!this.element) return;

    const contentElement = this.element.querySelector('.message-content');
    if (!contentElement) return;

    this.stopLoadingAnimation();

    // Preserve progressive accordions during content update
    const progressiveAccordions: HTMLElement[] = [];
    if (this.progressiveToolAccordions.size > 0) {
      const accordionElements = contentElement.querySelectorAll('.progressive-tool-accordion');
      accordionElements.forEach(el => {
        if (el instanceof HTMLElement) {
          progressiveAccordions.push(el);
          el.remove();
        }
      });
    }

    contentElement.empty();

    this.renderContent(contentElement as HTMLElement, content).catch(error => {
      console.error('[MessageBubble] Error rendering content:', error);
      const fallbackDiv = document.createElement('div');
      fallbackDiv.textContent = content;
      contentElement.appendChild(fallbackDiv);
    });

    // Re-append progressive accordions if they were preserved
    if (this.progressiveToolAccordions.size > 0 && progressiveAccordions.length > 0) {
      progressiveAccordions.forEach(accordion => {
        contentElement.appendChild(accordion);
      });
    }
  }

  /**
   * Update MessageBubble with new message data
   */
  updateWithNewMessage(newMessage: ConversationMessage): void {
    // Handle progressive accordion transition to static
    const activeToolCalls = this.getActiveToolCalls(newMessage);
    if (this.progressiveToolAccordions.size > 0 && activeToolCalls) {
      const hasCompletedTools = activeToolCalls.some(tc =>
        tc.result !== undefined || tc.success !== undefined
      );

      if (!hasCompletedTools) {
        this.message = newMessage;
        if (this.messageBranchNavigator) {
          this.messageBranchNavigator.updateMessage(newMessage);
        }
        return;
      }
    }

    this.message = newMessage;

    if (this.messageBranchNavigator) {
      this.messageBranchNavigator.updateMessage(newMessage);
    }

    if (!this.element) return;
    const contentElement = this.element.querySelector('.message-content');
    if (!contentElement) return;

    contentElement.empty();

    const activeContent = this.getActiveMessageContent(newMessage);
    this.renderContent(contentElement as HTMLElement, activeContent).catch(error => {
      console.error('[MessageBubble] Error re-rendering content:', error);
    });

    if (newMessage.isLoading && newMessage.role === 'assistant') {
      const loadingDiv = contentElement.createDiv('ai-loading-continuation');
      const loadingSpan = loadingDiv.createEl('span', { cls: 'ai-loading' });
      loadingSpan.appendText('Thinking');
      loadingSpan.createEl('span', { cls: 'dots', text: '...' });
      this.startLoadingAnimation(loadingDiv);
    }
  }

  /**
   * Handle tool events from MessageManager
   */
  handleToolEvent(event: 'detected' | 'updated' | 'started' | 'completed', data: any): void {
    const info = ToolEventParser.getToolEventInfo(data);
    const toolId = info.toolId;
    if (!toolId) {
      return;
    }

    let accordion = this.progressiveToolAccordions.get(toolId);

    if (!accordion && (event === 'detected' || event === 'started')) {
      accordion = new ProgressiveToolAccordion(this);
      const accordionElement = accordion.createElement();

      // Wire up onViewBranch callback for subagent navigation
      if (this.onViewBranch) {
        accordion.setCallbacks({ onViewBranch: this.onViewBranch });
      }

      if (!this.toolBubbleElement) {
        this.createToolBubbleOnDemand();
      }

      const toolContent = this.toolBubbleElement?.querySelector('.tool-bubble-content');
      if (toolContent) {
        toolContent.appendChild(accordionElement);
      }

      this.progressiveToolAccordions.set(toolId, accordion);
    }

    if (!accordion) {
      return;
    }

    switch (event) {
      case 'detected':
        accordion.detectTool({
          id: toolId,
          name: info.displayName,
          technicalName: info.technicalName,
          parameters: info.parameters,
          isComplete: info.isComplete,
          // Pass reasoning-specific properties
          type: info.type,
          result: info.result,
          status: info.status,
          isVirtual: info.isVirtual
        });
        break;

      case 'updated':
        accordion.updateToolParameters(toolId, info.parameters, info.isComplete);
        break;

      case 'started':
        accordion.startTool({
          id: toolId,
          name: info.displayName,
          technicalName: info.technicalName,
          parameters: info.parameters
        });
        break;

      case 'completed':
        accordion.completeTool(
          toolId,
          data.result,
          data.success,
          data.error
        );

        // Check if this is an image generation result
        if (data.success && data.result) {
          this.checkAndRenderImageResult(data.result);
        }
        break;
    }
  }

  /**
   * Create tool bubble on-demand during streaming
   */
  private createToolBubbleOnDemand(): void {
    if (this.toolBubbleElement) return;

    this.toolBubbleElement = ToolBubbleFactory.createToolBubbleOnDemand(this.message, this.element);
  }

  /**
   * Check if a tool result contains an image path and render it
   */
  private checkAndRenderImageResult(result: any): void {
    const imageData = this.extractImageFromResult(result);
    if (!imageData) return;

    this.createImageBubble(imageData);
  }

  /**
   * Extract image data from a tool result (supports generateImage tool format)
   */
  private extractImageFromResult(result: any): { imagePath: string; prompt?: string; dimensions?: { width: number; height: number }; model?: string } | null {
    if (!result) return null;

    // Handle both direct result and nested data structure
    const data = result.data || result;

    // Check for imagePath which indicates an image generation result
    if (data && typeof data.imagePath === 'string') {
      return {
        imagePath: data.imagePath,
        prompt: data.prompt || data.revisedPrompt,
        dimensions: data.dimensions,
        model: data.model
      };
    }

    return null;
  }

  /**
   * Create an image bubble to display generated images prominently in the chat
   */
  private createImageBubble(imageData: { imagePath: string; prompt?: string; dimensions?: { width: number; height: number }; model?: string }): void {
    if (!this.element) return;

    const imageBubble = this.buildImageBubbleElement(imageData);

    // Insert image bubble after tool bubble, before text bubble
    if (this.toolBubbleElement && this.textBubbleElement) {
      this.element.insertBefore(imageBubble, this.textBubbleElement);
    } else if (this.toolBubbleElement) {
      this.element.appendChild(imageBubble);
    } else {
      // No tool bubble, append to wrapper
      this.element.appendChild(imageBubble);
    }

    this.imageBubbleElement = imageBubble;
  }

  /**
   * Create an image bubble for static content (during createElement)
   */
  private createImageBubbleStatic(parent: HTMLElement, imageData: { imagePath: string; prompt?: string; dimensions?: { width: number; height: number }; model?: string }): void {
    const imageBubble = this.buildImageBubbleElement(imageData);
    parent.appendChild(imageBubble);
    this.imageBubbleElement = imageBubble;
  }

  /**
   * Build the image bubble element
   */
  private buildImageBubbleElement(imageData: { imagePath: string; prompt?: string; dimensions?: { width: number; height: number }; model?: string }): HTMLElement {
    // Create image bubble container
    const imageBubble = document.createElement('div');
    imageBubble.addClass('message-container');
    imageBubble.addClass('message-image');
    imageBubble.setAttribute('data-message-id', `${this.message.id}_image`);

    const bubble = imageBubble.createDiv('message-bubble image-bubble');

    // Image container
    const imageContainer = bubble.createDiv('generated-image-container');

    // Create image element
    const img = imageContainer.createEl('img', { cls: 'generated-image' });

    // Get the resource path using Obsidian's vault adapter
    const resourcePath = this.app.vault.adapter.getResourcePath(imageData.imagePath);
    img.src = resourcePath;
    img.alt = imageData.prompt || 'Generated image';
    img.setAttribute('loading', 'lazy');

    // Open in Obsidian button
    const openButton = bubble.createEl('button', { cls: 'generated-image-open-btn' });
    setIcon(openButton, 'external-link');
    openButton.createSpan({ text: 'Open in Obsidian' });
    this.registerDomEvent(openButton, 'click', () => {
      this.app.workspace.openLinkText(imageData.imagePath, '', false);
    });

    return imageBubble;
  }

  /**
   * Get progressive tool accordions for external updates
   */
  getProgressiveToolAccordions(): Map<string, ProgressiveToolAccordion> {
    return this.progressiveToolAccordions;
  }

  /**
   * Get the active content for the message (original or from branch)
   */
  private getActiveMessageContent(message: ConversationMessage): string {
    const activeIndex = message.activeAlternativeIndex || 0;

    if (activeIndex === 0) {
      return message.content;
    }

    // Use branches (new unified model)
    if (message.branches && message.branches.length > 0) {
      const branchIndex = activeIndex - 1;
      if (branchIndex >= 0 && branchIndex < message.branches.length) {
        const branch = message.branches[branchIndex];
        if (branch.messages.length > 0) {
          return branch.messages[branch.messages.length - 1].content;
        }
      }
    }

    return message.content;
  }

  /**
   * Get the active tool calls for the message (original or from branch)
   */
  private getActiveToolCalls(message: ConversationMessage): any[] | undefined {
    const activeIndex = message.activeAlternativeIndex || 0;

    if (activeIndex === 0) {
      return message.toolCalls;
    }

    // Use branches (new unified model)
    if (message.branches && message.branches.length > 0) {
      const branchIndex = activeIndex - 1;
      if (branchIndex >= 0 && branchIndex < message.branches.length) {
        const branch = message.branches[branchIndex];
        if (branch.messages.length > 0) {
          return branch.messages[branch.messages.length - 1].toolCalls;
        }
      }
    }

    return message.toolCalls;
  }

  /**
   * Get the active reasoning for the message (original or from branch)
   */
  private getActiveReasoning(message: ConversationMessage): string | undefined {
    const activeIndex = message.activeAlternativeIndex || 0;

    if (activeIndex === 0) {
      return message.reasoning;
    }

    // Use branches (new unified model)
    if (message.branches && message.branches.length > 0) {
      const branchIndex = activeIndex - 1;
      if (branchIndex >= 0 && branchIndex < message.branches.length) {
        const branch = message.branches[branchIndex];
        if (branch.messages.length > 0) {
          return branch.messages[branch.messages.length - 1].reasoning;
        }
      }
    }

    return message.reasoning;
  }

  /**
   * Show visual feedback when copy button is clicked
   */
  private showCopyFeedback(button: HTMLElement): void {
    const originalTitle = button.getAttribute('title') || '';
    setIcon(button, 'check');
    button.setAttribute('title', 'Copied!');
    button.classList.add('copy-success');

    setTimeout(() => {
      setIcon(button, 'copy');
      button.setAttribute('title', originalTitle);
      button.classList.remove('copy-success');
    }, 1500);
  }

  /**
   * Clean up progressive tool accordions
   */
  private cleanupProgressiveAccordions(): void {
    this.progressiveToolAccordions.forEach(accordion => {
      const element = accordion.getElement();
      if (element) {
        element.remove();
      }
      accordion.cleanup();
    });

    this.progressiveToolAccordions.clear();
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    this.stopLoadingAnimation();
    this.cleanupProgressiveAccordions();

    if (this.messageBranchNavigator) {
      this.messageBranchNavigator.destroy();
      this.messageBranchNavigator = null;
    }

    this.element = null;
  }
}

```

## ui/chat/components/MessageDisplay.ts

```typescript
/**
 * MessageDisplay - Main chat message display area
 *
 * Shows conversation messages with user/AI bubbles and tool execution displays
 */

import { ConversationData, ConversationMessage } from '../../../types/chat/ChatTypes';
import { MessageBubble } from './MessageBubble';
import { BranchManager } from '../services/BranchManager';
import { App, setIcon, ButtonComponent } from 'obsidian';

export class MessageDisplay {
  private conversation: ConversationData | null = null;
  private messageBubbles: MessageBubble[] = [];

  constructor(
    private container: HTMLElement,
    private app: App,
    private branchManager: BranchManager,
    private onRetryMessage?: (messageId: string) => void,
    private onEditMessage?: (messageId: string, newContent: string) => void,
    private onToolEvent?: (messageId: string, event: 'detected' | 'updated' | 'started' | 'completed', data: any) => void,
    private onMessageAlternativeChanged?: (messageId: string, alternativeIndex: number) => void,
    private onViewBranch?: (branchId: string) => void
  ) {
    this.render();
  }

  /**
   * Set conversation to display
   */
  setConversation(conversation: ConversationData): void {
    // Always re-render from the stored conversation data (single source of truth)
    // ProgressiveToolAccordions show both streaming AND final state
    // Tool bubbles are created from toolCalls in the conversation JSON
    this.conversation = conversation;
    this.render();
    this.scrollToBottom();
  }

  /**
   * Add a user message immediately (for optimistic updates)
   */
  addUserMessage(content: string): void {
    const message: ConversationMessage = {
      id: `temp_${Date.now()}`,
      role: 'user',
      content,
      timestamp: Date.now(),
      conversationId: this.conversation?.id || 'unknown'
    };

    const bubble = this.createMessageBubble(message);
    const messagesContainer = this.container.querySelector('.messages-container');
    if (messagesContainer) {
      messagesContainer.appendChild(bubble);
    }
    this.scrollToBottom();
  }

  /**
   * Add a message immediately using the actual message object (prevents duplicate message creation)
   */
  addMessage(message: ConversationMessage): void {
    const bubble = this.createMessageBubble(message);
    this.container.querySelector('.messages-container')?.appendChild(bubble);
    this.scrollToBottom();
  }

  /**
   * Add an AI message immediately (for streaming setup)
   */
  addAIMessage(message: ConversationMessage): void {
    const bubble = this.createMessageBubble(message);
    this.container.querySelector('.messages-container')?.appendChild(bubble);
    this.scrollToBottom();
  }

  /**
   * Update a specific message content for final display (streaming handled by StreamingController)
   */
  updateMessageContent(messageId: string, content: string): void {
    // Find the MessageBubble instance for this message ID
    const messageBubble = this.messageBubbles.find(bubble => {
      const element = bubble.getElement();
      return element?.getAttribute('data-message-id') === messageId;
    });

    if (messageBubble) {
      // Use the MessageBubble's updateContent method for final content only
      messageBubble.updateContent(content);
    }
  }

  /**
   * Update a specific message with new data (including tool calls) without full re-render
   */
  updateMessage(messageId: string, updatedMessage: ConversationMessage): void {
    // Update message with new data

    if (!this.conversation) {
      return;
    }

    // Find and update the message in conversation data
    const messageIndex = this.conversation.messages.findIndex(msg => msg.id === messageId);
    // Update conversation data
    
    if (messageIndex !== -1) {
      this.conversation.messages[messageIndex] = updatedMessage;
      // Message updated in conversation
    }

    // Find the MessageBubble instance
    const messageBubble = this.messageBubbles.find(bubble => {
      const element = bubble.getElement();
      return element?.getAttribute('data-message-id') === messageId;
    });

    // Find message bubble for update

    if (messageBubble) {
      // Tell the MessageBubble to re-render with updated message data
      // Update message bubble
      messageBubble.updateWithNewMessage(updatedMessage);
      // Message bubble updated
    }
  }

  /**
   * Escape HTML for safe display
   */
  private escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }


  /**
   * Show welcome state
   */
  showWelcome(): void {
    this.container.empty();
    this.container.addClass('message-display');

    const welcome = this.container.createDiv('chat-welcome');
    const welcomeContent = welcome.createDiv('chat-welcome-content');

    const welcomeIcon = welcomeContent.createDiv('chat-welcome-icon');
    setIcon(welcomeIcon, 'message-circle');

    // Use Obsidian's ButtonComponent
    new ButtonComponent(welcomeContent)
      .setButtonText('New conversation')
      .setIcon('plus')
      .setClass('chat-welcome-button');
  }

  /**
   * Render the message display
   */
  private render(): void {
    // Full render - clears existing progressive accordions
    this.container.empty();
    this.container.addClass('message-display');

    if (!this.conversation) {
      this.showWelcome();
      return;
    }

    // Create scrollable messages container
    const messagesContainer = this.container.createDiv('messages-container');

    // Clear previous message bubbles
    this.messageBubbles = [];

    // Render all messages (no branch filtering needed for message-level alternatives)
    this.conversation.messages.forEach((message, index) => {
      const messageEl = this.createMessageBubble(message);
      messagesContainer.appendChild(messageEl);
    });

    this.scrollToBottom();
  }

  /**
   * Create a message bubble element
   */
  private createMessageBubble(message: ConversationMessage): HTMLElement {
    // Render using the currently active alternative content/tool calls so branch selection persists across re-renders
    const displayMessage = this.branchManager
      ? {
          ...message,
          content: this.branchManager.getActiveMessageContent(message),
          toolCalls: this.branchManager.getActiveMessageToolCalls(message)
        }
      : message;

    const bubble = new MessageBubble(
      displayMessage,
      this.app,
      (messageId: string) => this.onCopyMessage(messageId),
      (messageId: string) => this.handleRetryMessage(messageId),
      (messageId: string, newContent: string) => this.handleEditMessage(messageId, newContent),
      this.onToolEvent,
      this.onMessageAlternativeChanged ? (messageId: string, alternativeIndex: number) => this.handleMessageAlternativeChanged(messageId, alternativeIndex) : undefined,
      this.onViewBranch
    );

    this.messageBubbles.push(bubble);
    
    const bubbleEl = bubble.createElement();

    // Tool accordion is now rendered inside MessageBubble's content area

    return bubbleEl;
  }

  /**
   * Handle copy message action
   */
  private onCopyMessage(messageId: string): void {
    const message = this.findMessage(messageId);
    if (message) {
      navigator.clipboard.writeText(message.content).then(() => {
        // Message copied to clipboard
      }).catch(err => {
        // Failed to copy message
      });
    }
  }

  /**
   * Handle retry message action
   */
  private handleRetryMessage(messageId: string): void {
    if (this.onRetryMessage) {
      this.onRetryMessage(messageId);
    }
  }

  /**
   * Handle edit message action
   */
  private handleEditMessage(messageId: string, newContent: string): void {
    if (this.onEditMessage) {
      this.onEditMessage(messageId, newContent);
    }
  }

  /**
   * Handle message alternative changed action
   */
  private handleMessageAlternativeChanged(messageId: string, alternativeIndex: number): void {
    if (this.onMessageAlternativeChanged) {
      this.onMessageAlternativeChanged(messageId, alternativeIndex);
    }
  }

  /**
   * Find message by ID
   */
  private findMessage(messageId: string): ConversationMessage | undefined {
    return this.conversation?.messages.find(msg => msg.id === messageId);
  }

  /**
   * Find MessageBubble by messageId for tool events
   */
  findMessageBubble(messageId: string): MessageBubble | undefined {
    if (!this.conversation) return undefined;
    
    const messageIndex = this.conversation.messages.findIndex(msg => msg.id === messageId);
    if (messageIndex === -1) return undefined;
    
    // MessageBubbles are created in same order as messages
    return this.messageBubbles[messageIndex];
  }

  /**
   * Update MessageBubble with new message ID (for handling temporary -> real ID updates)
   */
  updateMessageId(oldId: string, newId: string, updatedMessage: ConversationMessage): void {
    // Find the MessageBubble that was created with the old (temporary) ID
    const messageBubble = this.messageBubbles.find(bubble => {
      const element = bubble.getElement();
      return element?.getAttribute('data-message-id') === oldId;
    });

    if (messageBubble) {
      // Update the MessageBubble's message reference and DOM attribute
      messageBubble.updateWithNewMessage(updatedMessage);

      // Update the DOM attribute to reflect the new ID
      const element = messageBubble.getElement();
      if (element) {
        element.setAttribute('data-message-id', newId);
      }
    }
  }

  /**
   * Check if any message bubbles have progressive tool accordions
   */
  hasProgressiveToolAccordions(): boolean {
    return this.messageBubbles.some(bubble => 
      bubble.getProgressiveToolAccordions().size > 0
    );
  }

  /**
   * Scroll to bottom of messages
   */
  private scrollToBottom(): void {
    const messagesContainer = this.container.querySelector('.messages-container');
    if (messagesContainer) {
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
  }

  /**
   * Get current scroll position
   */
  getScrollPosition(): number {
    const messagesContainer = this.container.querySelector('.messages-container');
    return messagesContainer?.scrollTop ?? 0;
  }

  /**
   * Set scroll position
   */
  setScrollPosition(position: number): void {
    const messagesContainer = this.container.querySelector('.messages-container');
    if (messagesContainer) {
      messagesContainer.scrollTop = position;
    }
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    this.messageBubbles.forEach(bubble => bubble.cleanup());
    this.messageBubbles = [];
  }
}

```

## ui/chat/components/ProgressiveToolAccordion.ts

```typescript
ï»¿/**
 * ProgressiveToolAccordion - Real-time tool execution display
 *
 * Shows tool execution progress in real-time with visual feedback:
 * - Shows tools as they start executing (glow effect)
 * - Updates with results as they complete
 * - Provides rich visual feedback during execution
 */

import { setIcon, Component } from 'obsidian';

export interface ProgressiveToolCall {
  id: string;
  name: string;
  technicalName?: string;
  type?: string;  // Tool type: 'function', 'reasoning', etc.
  parameters?: any;
  status: 'pending' | 'streaming' | 'executing' | 'completed' | 'failed';
  result?: any;
  error?: string;
  executionTime?: number;
  startTime?: number;
  parametersComplete?: boolean; // True when parameters are fully streamed
  isVirtual?: boolean; // True for synthetic tools like reasoning (not executable)
}

export interface ProgressiveToolAccordionCallbacks {
  onViewBranch?: (branchId: string) => void;
}

export class ProgressiveToolAccordion {
  private element: HTMLElement | null = null;
  private isExpanded = false;
  private tools: ProgressiveToolCall[] = [];
  private callbacks: ProgressiveToolAccordionCallbacks = {};

  constructor(private component?: Component, callbacks?: ProgressiveToolAccordionCallbacks) {
    this.callbacks = callbacks || {};
  }

  /**
   * Set callbacks (can be called after construction if needed)
   */
  setCallbacks(callbacks: ProgressiveToolAccordionCallbacks): void {
    this.callbacks = { ...this.callbacks, ...callbacks };
  }

  /**
   * Create the progressive tool accordion element
   */
  createElement(): HTMLElement {
    const accordion = document.createElement('div');
    accordion.addClass('progressive-tool-accordion');

    // Header with summary (initially hidden until first tool)
    const header = accordion.createDiv('progressive-tool-header');
    const toggleHandler = () => this.toggle();
    this.component!.registerDomEvent(header, 'click', toggleHandler);
    header.addClass('progressive-accordion-hidden'); // Hidden until first tool starts

    // Status summary
    const summary = header.createDiv('tool-summary');
    
    // Icon (will update based on status)
    const icon = summary.createSpan('tool-icon');
    
    // Text (will update as tools execute)
    const text = summary.createSpan('tool-text');
    
    // Expand indicator
    const expandIcon = header.createDiv('tool-expand-icon');
    setIcon(expandIcon, 'chevron-right');

    // Content (initially hidden)
    const content = accordion.createDiv('progressive-tool-content');
    content.addClass('progressive-accordion-hidden');

    this.element = accordion;
    return accordion;
  }

  /**
   * Detect a tool (parameters streaming) - shows it immediately with streaming state
   * Handles special tool types like 'reasoning' differently
   */
  detectTool(toolCall: { id: string; name: string; technicalName?: string; type?: string; parameters?: any; result?: any; isComplete?: boolean; isVirtual?: boolean; status?: string }): void {
    // Special handling for reasoning tools - update result instead of parameters
    const isReasoningTool = toolCall.type === 'reasoning';

    // Check if tool already exists
    const existingTool = this.tools.find(t => t.id === toolCall.id);
    if (existingTool) {
      // Tool already detected, just update
      existingTool.name = toolCall.name;
      existingTool.technicalName = toolCall.technicalName;

      if (isReasoningTool) {
        // For reasoning tools, update the result (reasoning text) and status
        existingTool.result = toolCall.result;
        existingTool.status = toolCall.status === 'completed' ? 'completed' : 'streaming';
        this.updateReasoningItem(existingTool);
      } else {
        // For regular tools, update parameters
        this.updateToolParameters(toolCall.id, toolCall.parameters, toolCall.isComplete || false);
        this.updateToolItem(existingTool);
      }
      return;
    }

    // Create new tool entry
    const progressiveTool: ProgressiveToolCall = {
      id: toolCall.id,
      name: toolCall.name,
      technicalName: toolCall.technicalName,
      type: toolCall.type,
      parameters: toolCall.parameters,
      result: isReasoningTool ? toolCall.result : undefined,  // Reasoning stores content in result
      status: isReasoningTool ? 'streaming' : (toolCall.isComplete ? 'pending' : 'streaming'),
      parametersComplete: toolCall.isComplete || false,
      isVirtual: toolCall.isVirtual,
      startTime: Date.now()
    };

    this.tools.push(progressiveTool);
    this.updateDisplay();

    if (isReasoningTool) {
      this.renderReasoningItem(progressiveTool);
    } else {
      this.renderToolItem(progressiveTool);
    }
  }

  /**
   * Update tool parameters during streaming
   */
  updateToolParameters(toolId: string, parameters: any, isComplete: boolean): void {
    const tool = this.tools.find(t => t.id === toolId);
    if (!tool) return;

    tool.parameters = parameters;
    tool.parametersComplete = isComplete;

    if (isComplete && tool.status === 'streaming') {
      tool.status = 'pending'; // Ready to execute
    }

    this.updateDisplay();
    this.updateToolItemParameters(tool);
  }

  /**
   * Start executing a tool - shows it immediately with glow effect
   */
  startTool(toolCall: { id: string; name: string; technicalName?: string; parameters?: any }): void {
    const tool = this.tools.find(t => t.id === toolCall.id);
    if (tool) {
      // Tool already exists from detection, just update status
      tool.status = 'executing';
      tool.startTime = Date.now();
      tool.name = toolCall.name;
      tool.technicalName = toolCall.technicalName;
      this.updateDisplay();
      this.updateToolItem(tool);
    } else {
      // New tool execution (legacy path)
      const progressiveTool: ProgressiveToolCall = {
        id: toolCall.id,
        name: toolCall.name,
        technicalName: toolCall.technicalName,
        parameters: toolCall.parameters,
        status: 'executing',
        parametersComplete: true,
        startTime: Date.now()
      };

      this.tools.push(progressiveTool);
      this.updateDisplay();
      this.renderToolItem(progressiveTool);
    }
  }

  /**
   * Complete a tool execution with results
   */
  completeTool(toolId: string, result: any, success: boolean, error?: string): void {
    const tool = this.tools.find(t => t.id === toolId);
    if (!tool) return;

    tool.status = success ? 'completed' : 'failed';
    tool.result = result;
    tool.error = error;
    if (tool.startTime) {
      tool.executionTime = Date.now() - tool.startTime;
    }

    this.updateDisplay();
    this.updateToolItem(tool);
  }

  /**
   * Update the header display based on current tools
   */
  private updateDisplay(): void {
    if (!this.element) return;

    const header = this.element.querySelector('.progressive-tool-header') as HTMLElement;
    const icon = this.element.querySelector('.tool-icon') as HTMLElement;
    const text = this.element.querySelector('.tool-text') as HTMLElement;

    if (this.tools.length === 0) {
      header.addClass('progressive-accordion-hidden');
      header.removeClass('progressive-accordion-header-visible');
      return;
    }

    header.removeClass('progressive-accordion-hidden');
    header.addClass('progressive-accordion-header-visible');

    const executing = this.tools.filter(t => t.status === 'executing');
    const completed = this.tools.filter(t => t.status === 'completed');
    const failed = this.tools.filter(t => t.status === 'failed');
    const total = this.tools.length;

    // Update icon based on status with color states
    if (executing.length > 0) {
      icon.empty();
      setIcon(icon, 'loader'); // Executing - spinning
      icon.addClass('tool-executing');
      icon.removeClass('tool-success', 'tool-failed');
      header.addClass('tool-executing');
    } else if (failed.length > 0) {
      icon.empty();
      setIcon(icon, 'alert-triangle'); // Some failed - orange
      icon.addClass('tool-failed');
      icon.removeClass('tool-executing', 'tool-success');
      header.removeClass('tool-executing');
    } else {
      icon.empty();
      setIcon(icon, 'check-circle'); // All completed - green
      icon.addClass('tool-success');
      icon.removeClass('tool-executing', 'tool-failed');
      header.removeClass('tool-executing');
    }

    // Update text based on tool names and status
    if (total === 1) {
      const tool = this.tools[0];
      if (tool.status === 'executing') {
        text.textContent = `${tool.name} (running...)`;
      } else {
        text.textContent = tool.name;
      }
    } else {
      const runningTools = executing.map(t => t.name).slice(0, 2);
      if (executing.length > 0) {
        if (executing.length === 1) {
          text.textContent = `${runningTools[0]} (running...) +${total - 1} more`;
        } else {
          text.textContent = `${runningTools.join(', ')} +${total - 2} more (running...)`;
        }
      } else {
        const toolNames = this.tools.map(t => t.name).slice(0, 2);
        const remaining = total - 2;
        if (remaining > 0) {
          text.textContent = `${toolNames.join(', ')} +${remaining} more`;
        } else {
          text.textContent = toolNames.join(', ');
        }
      }
    }
  }

  /**
   * Render individual tool execution item
   */
  private renderToolItem(tool: ProgressiveToolCall): void {
    if (!this.element) return;

    const content = this.element.querySelector('.progressive-tool-content') as HTMLElement;
    
    const item = document.createElement('div');
    item.addClass('progressive-tool-item');
    item.addClass(`tool-${tool.status}`);
    item.setAttribute('data-tool-id', tool.id);

    // Tool header
      const header = item.createDiv('progressive-tool-header-item');

      // Tool name (no status icon - it's in the accordion header now)
      const name = header.createSpan('tool-name');
      name.textContent = tool.name;
      if (tool.technicalName) {
        name.setAttribute('title', tool.technicalName);
      }
      
      // Execution info
      const meta = header.createSpan('tool-meta');
      this.updateExecutionMeta(meta, tool);

    // Parameters section (collapsible)
    if (tool.parameters && Object.keys(tool.parameters).length > 0) {
      const paramsSection = item.createDiv('tool-section');
      const paramsHeader = paramsSection.createDiv('tool-section-header');
      paramsHeader.textContent = 'Parameters:';
      
      const paramsContent = paramsSection.createEl('pre', { cls: 'tool-code' });
      paramsContent.textContent = JSON.stringify(tool.parameters, null, 2);
    }

    // Result section (will be filled when completed)
    const resultSection = item.createDiv('tool-section tool-result-section');
    resultSection.setAttribute('data-result-section', tool.id);
    resultSection.addClass('progressive-accordion-hidden'); // Hidden until completed

    // Error section (will be shown if failed)
    const errorSection = item.createDiv('tool-section tool-error-section');
    errorSection.setAttribute('data-error-section', tool.id);
    errorSection.addClass('progressive-accordion-hidden'); // Hidden unless failed

    content.appendChild(item);
  }

  /**
   * Render a reasoning item (special display for LLM thinking/reasoning)
   * Displays as collapsible accordion showing streamed reasoning text
   */
  private renderReasoningItem(tool: ProgressiveToolCall): void {
    if (!this.element) return;

    const content = this.element.querySelector('.progressive-tool-content') as HTMLElement;

    const item = document.createElement('div');
    item.addClass('progressive-tool-item');
    item.addClass('reasoning-item');  // Special class for styling
    item.addClass(`tool-${tool.status}`);
    item.setAttribute('data-tool-id', tool.id);
    item.setAttribute('data-type', 'reasoning');

    // Reasoning header with brain icon
    const header = item.createDiv('progressive-tool-header-item reasoning-header');

    // Brain icon for reasoning
    const iconSpan = header.createSpan('reasoning-icon');
    setIcon(iconSpan, 'brain');

    // Title
    const name = header.createSpan('tool-name');
    name.textContent = tool.name || 'Reasoning';

    // Status indicator
    const meta = header.createSpan('tool-meta');
    if (tool.status === 'streaming') {
      meta.textContent = 'thinking...';
      meta.addClass('reasoning-streaming');
    } else {
      meta.textContent = '';
    }

    // Reasoning content section (shows the actual reasoning text)
    const reasoningSection = item.createDiv('reasoning-content-section');
    const reasoningContent = reasoningSection.createDiv('reasoning-text');
    reasoningContent.setAttribute('data-reasoning-content', tool.id);

    // Display reasoning text with proper formatting
    if (tool.result) {
      reasoningContent.textContent = tool.result;
    } else {
      reasoningContent.textContent = '';
    }

    // Add streaming indicator if still streaming
    if (tool.status === 'streaming') {
      const streamingIndicator = reasoningSection.createDiv('reasoning-streaming-indicator');
      streamingIndicator.textContent = 'â‹¯';
    }

    content.appendChild(item);
  }

  /**
   * Update reasoning item with new content
   */
  private updateReasoningItem(tool: ProgressiveToolCall): void {
    if (!this.element) return;

    const item = this.element.querySelector(`[data-tool-id="${tool.id}"]`) as HTMLElement;
    if (!item) {
      // Item doesn't exist yet, render it
      this.renderReasoningItem(tool);
      return;
    }

    // Update status classes
    item.className = item.className.replace(/tool-(pending|streaming|executing|completed|failed)/g, '');
    item.addClass(`tool-${tool.status}`);

    // Update the reasoning text content
    const reasoningContent = item.querySelector(`[data-reasoning-content="${tool.id}"]`) as HTMLElement;
    if (reasoningContent && tool.result) {
      reasoningContent.textContent = tool.result;
    }

    // Update meta status
    const meta = item.querySelector('.tool-meta') as HTMLElement;
    if (meta) {
      if (tool.status === 'streaming') {
        meta.textContent = 'thinking...';
        meta.addClass('reasoning-streaming');
      } else if (tool.status === 'completed') {
        meta.textContent = '';
        meta.removeClass('reasoning-streaming');
      }
    }

    // Remove streaming indicator if complete
    if (tool.status === 'completed') {
      const streamingIndicator = item.querySelector('.reasoning-streaming-indicator');
      if (streamingIndicator) {
        streamingIndicator.remove();
      }
    }
  }

  /**
   * Update existing tool item when execution completes
   */
  private updateToolItem(tool: ProgressiveToolCall): void {
    if (!this.element) return;

    const item = this.element.querySelector(`[data-tool-id="${tool.id}"]`) as HTMLElement;
    if (!item) return;

    // Update status classes
    item.className = item.className.replace(/tool-(pending|streaming|executing|completed|failed)/g, '');
    item.addClass(`tool-${tool.status}`);

    // Update execution meta (status icon removed - now only in accordion header)
    const meta = item.querySelector('.tool-meta') as HTMLElement;
    this.updateExecutionMeta(meta, tool);

    // Show result section if completed successfully
    if (tool.status === 'completed' && tool.result) {
      const resultSection = item.querySelector(`[data-result-section="${tool.id}"]`) as HTMLElement;
      resultSection.removeClass('progressive-accordion-hidden');
      resultSection.addClass('progressive-accordion-section-visible');

      const resultHeader = resultSection.createDiv('tool-section-header');
      resultHeader.textContent = 'Result:';

      const resultContent = resultSection.createEl('pre', { cls: 'tool-code' });
      if (typeof tool.result === 'string') {
        resultContent.textContent = tool.result;
      } else {
        resultContent.textContent = JSON.stringify(tool.result, null, 2);
      }

      // Add [View Branch] link for subagent tool results
      this.addViewBranchLink(resultSection, tool);
    }

    // Show error section if failed
    if (tool.status === 'failed' && tool.error) {
      const errorSection = item.querySelector(`[data-error-section="${tool.id}"]`) as HTMLElement;
      errorSection.removeClass('progressive-accordion-hidden');
      errorSection.addClass('progressive-accordion-section-visible');
      
      const errorHeader = errorSection.createDiv('tool-section-header');
      errorHeader.textContent = 'Error:';
      
      const errorContent = errorSection.createDiv('tool-error-content');
      errorContent.textContent = tool.error;
    }
  }

  /**
   * Update tool item parameters display during streaming
   */
  private updateToolItemParameters(tool: ProgressiveToolCall): void {
    if (!this.element) return;

    const item = this.element.querySelector(`[data-tool-id="${tool.id}"]`) as HTMLElement;
    if (!item) return;

    // Find the parameters section
    const paramsContent = item.querySelector('.tool-code') as HTMLElement;
    if (!paramsContent) return;

    // Parse parameters for display
    let displayText = '';
    try {
      const params = typeof tool.parameters === 'string'
        ? JSON.parse(tool.parameters)
        : tool.parameters;
      displayText = JSON.stringify(params, null, 2);
    } catch {
      // If parsing fails, show raw parameters
      displayText = typeof tool.parameters === 'string'
        ? tool.parameters
        : JSON.stringify(tool.parameters);
    }

    paramsContent.textContent = displayText;

    // Update streaming indicator
    let streamingIndicator = paramsContent.nextElementSibling as HTMLElement;

    if (!tool.parametersComplete) {
      // Add or update streaming indicator
      if (!streamingIndicator || !streamingIndicator.hasClass('tool-streaming-indicator')) {
        streamingIndicator = paramsContent.parentElement!.createDiv('tool-streaming-indicator');
        streamingIndicator.textContent = 'â‹¯ streaming parameters';
      }
      paramsContent.addClass('tool-parameters-streaming');
    } else {
      // Remove streaming indicator
      if (streamingIndicator && streamingIndicator.hasClass('tool-streaming-indicator')) {
        streamingIndicator.remove();
      }
      paramsContent.removeClass('tool-parameters-streaming');
    }

    // Update status classes (status icon removed - now only in accordion header)
    item.className = item.className.replace(/tool-(pending|streaming|executing|completed|failed)/g, '');
    item.addClass(`tool-${tool.status}`);
  }

  /**
   * Update execution metadata display
   */
  private updateExecutionMeta(metaElement: HTMLElement, tool: ProgressiveToolCall): void {
    switch (tool.status) {
      case 'executing':
        if (tool.startTime) {
          const elapsed = Date.now() - tool.startTime;
          metaElement.textContent = `${Math.round(elapsed / 100) / 10}s`;
        }
        break;
      case 'completed':
      case 'failed':
        if (tool.executionTime) {
          metaElement.textContent = `${tool.executionTime}ms`;
        }
        break;
    }
  }

  /**
   * Toggle accordion expansion
   */
  private toggle(): void {
    if (!this.element) return;

    this.isExpanded = !this.isExpanded;
    
    const content = this.element.querySelector('.progressive-tool-content') as HTMLElement;
    const expandIcon = this.element.querySelector('.tool-expand-icon') as HTMLElement;

    if (this.isExpanded) {
      content.removeClass('progressive-accordion-hidden');
      content.addClass('progressive-accordion-content-visible');
      expandIcon.empty();
      setIcon(expandIcon, 'chevron-down');
      this.element.addClass('expanded');
    } else {
      content.removeClass('progressive-accordion-content-visible');
      content.addClass('progressive-accordion-hidden');
      expandIcon.empty();
      setIcon(expandIcon, 'chevron-right');
      this.element.removeClass('expanded');
    }
  }

  /**
   * Get the DOM element
   */
  getElement(): HTMLElement | null {
    return this.element;
  }

  /**
   * Get current tool status summary
   */
  getToolSummary(): { total: number; executing: number; completed: number; failed: number } {
    return {
      total: this.tools.length,
      executing: this.tools.filter(t => t.status === 'executing').length,
      completed: this.tools.filter(t => t.status === 'completed').length,
      failed: this.tools.filter(t => t.status === 'failed').length
    };
  }

  /**
   * Add [View Branch] link for subagent tool results
   * Shows only for agentManager.subagent tool results that have a branchId
   */
  private addViewBranchLink(resultSection: HTMLElement, tool: ProgressiveToolCall): void {
    // Check if this is a subagent tool result with a branchId
    const isSubagentTool = tool.name?.toLowerCase().includes('subagent') ||
                           tool.technicalName?.includes('subagent') ||
                           tool.name === 'Spawn Subagent';

    if (!isSubagentTool || !this.callbacks.onViewBranch) {
      return;
    }

    // Extract branchId from result
    let branchId: string | null = null;
    try {
      const result = typeof tool.result === 'string' ? JSON.parse(tool.result) : tool.result;
      branchId = result?.data?.branchId || result?.branchId || null;
    } catch {
      // Not JSON or no branchId - ignore
    }

    if (!branchId) {
      return;
    }

    // Create the view branch link
    const linkContainer = resultSection.createDiv('nexus-view-branch-link-container');
    const viewLink = linkContainer.createEl('a', {
      text: 'View Branch â†’',
      cls: 'nexus-view-branch-link clickable-icon',
      href: '#',
    });

    viewLink.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.callbacks.onViewBranch?.(branchId!);
    });
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    this.tools = [];
    this.element = null;
    this.callbacks = {};
  }
}

```

## ui/chat/components/renderers/MessageContentRenderer.ts

```typescript
/**
 * MessageContentRenderer - Renders message content with markdown and references
 * Location: /src/ui/chat/components/renderers/MessageContentRenderer.ts
 *
 * This class is responsible for:
 * - Rendering message content using Obsidian's markdown renderer
 * - Processing and injecting reference badges
 * - Handling rendering errors with fallback to plain text
 *
 * Used by MessageBubble to render enhanced markdown content with
 * interactive reference badges for tools, agents, and notes.
 */

import { App, Component } from 'obsidian';
import { MarkdownRenderer } from '../../utils/MarkdownRenderer';
import { ReferenceMetadata } from '../../utils/ReferenceExtractor';
import { ReferenceBadgeRenderer } from './ReferenceBadgeRenderer';

export class MessageContentRenderer {
  /**
   * Render message content with enhanced markdown and reference badges
   */
  static async renderContent(
    container: HTMLElement,
    content: string,
    app: App,
    component: Component,
    referenceMetadata?: ReferenceMetadata
  ): Promise<void> {
    // Skip rendering if content is empty
    if (!content.trim()) {
      return;
    }

    let contentToRender = content;
    let placeholders: any[] | null = null;

    // Inject reference placeholders if metadata exists
    if (referenceMetadata && referenceMetadata.references.length > 0) {
      const transformation = ReferenceBadgeRenderer.injectReferencePlaceholders(
        content,
        referenceMetadata.references
      );
      contentToRender = transformation.content;
      placeholders = transformation.placeholders;
    }

    // Use enhanced markdown renderer with Obsidian's native rendering
    try {
      await MarkdownRenderer.renderMarkdown(contentToRender, container, app, component);
    } catch (error) {
      console.error('[MessageContentRenderer] Error rendering markdown:', error);
      // Fallback to plain text
      const pre = container.createEl('pre', {
        cls: 'markdown-renderer-plaintext'
      });
      pre.textContent = contentToRender;
    }

    // Replace placeholders with badge elements
    if (placeholders && placeholders.length > 0) {
      ReferenceBadgeRenderer.replacePlaceholdersWithBadges(container, placeholders);
    }
  }
}

```

## ui/chat/components/renderers/ReferenceBadgeRenderer.ts

```typescript
/**
 * ReferenceBadgeRenderer - Renders reference badges in message content
 * Location: /src/ui/chat/components/renderers/ReferenceBadgeRenderer.ts
 *
 * This class is responsible for:
 * - Injecting placeholders into content at reference positions
 * - Replacing placeholders with styled badge elements
 * - Safely reading and normalizing reference metadata
 *
 * Used by MessageBubble to render @tool, @agent, and @note references
 * as interactive badges within message content.
 */

import { ExtractedReference, ReferenceMetadata } from '../../utils/ReferenceExtractor';

interface ReferencePlaceholder {
  token: string;
  index: number;
  reference: ExtractedReference;
}

export class ReferenceBadgeRenderer {
  private static readonly PLACEHOLDER_PREFIX = '\uFFF0REF';
  private static readonly PLACEHOLDER_SUFFIX = '\uFFF1';

  /**
   * Safely read and normalize reference metadata from message
   */
  static getReferenceMetadata(metadata: any): ReferenceMetadata | undefined {
    const typedMetadata = metadata as ReferenceMetadata | undefined;
    if (!typedMetadata || !Array.isArray(typedMetadata.references)) {
      return undefined;
    }

    const normalizedReferences = typedMetadata.references
      .map(ref => {
        if (!ref) return null;
        const type = ref.type;
        if (type !== 'tool' && type !== 'prompt' && type !== 'note' && type !== 'workspace') {
          return null;
        }
        const position = typeof ref.position === 'number' ? ref.position : Number(ref.position);
        if (!Number.isFinite(position)) {
          return null;
        }
        if (typeof ref.displayText !== 'string' || typeof ref.technicalName !== 'string') {
          return null;
        }
        return {
          type,
          displayText: ref.displayText,
          technicalName: ref.technicalName,
          position: Math.max(0, position)
        } as ExtractedReference;
      })
      .filter((ref): ref is ExtractedReference => ref !== null);

    if (normalizedReferences.length === 0) {
      return undefined;
    }

    return {
      references: normalizedReferences
    };
  }

  /**
   * Inject placeholders into content for reference positions
   */
  static injectReferencePlaceholders(
    content: string,
    references: ExtractedReference[]
  ): { content: string; placeholders: ReferencePlaceholder[] } {
    if (references.length === 0) {
      return { content, placeholders: [] };
    }

    const sorted = [...references].sort((a, b) => a.position - b.position);
    let cursor = 0;
    let result = '';
    const placeholders: ReferencePlaceholder[] = [];

    sorted.forEach((reference, index) => {
      const boundedPosition = Math.min(Math.max(reference.position, 0), content.length);
      if (boundedPosition > cursor) {
        result += content.slice(cursor, boundedPosition);
        cursor = boundedPosition;
      } else if (boundedPosition < cursor) {
        cursor = boundedPosition;
      }

      const token = `${ReferenceBadgeRenderer.PLACEHOLDER_PREFIX}${index}${ReferenceBadgeRenderer.PLACEHOLDER_SUFFIX}`;
      result += token;
      placeholders.push({
        token,
        index,
        reference
      });

      // Skip the original reference text in the rendered content to avoid duplicates
      const displayTextLength = reference.displayText?.length ?? 0;
      if (displayTextLength > 0) {
        const skipTo = Math.min(content.length, boundedPosition + displayTextLength);
        // Only skip forward (never backward)
        if (skipTo > cursor) {
          cursor = skipTo;
        }
      }
    });

    result += content.slice(cursor);

    return {
      content: result,
      placeholders
    };
  }

  /**
   * Replace placeholder tokens with styled badge elements
   */
  static replacePlaceholdersWithBadges(container: HTMLElement, placeholders: ReferencePlaceholder[]): void {
    if (placeholders.length === 0) {
      return;
    }

    const placeholderMap = new Map<number, ExtractedReference>();
    placeholders.forEach(placeholder => {
      placeholderMap.set(placeholder.index, placeholder.reference);
    });

    const pattern = new RegExp(
      `${ReferenceBadgeRenderer.escapeForRegex(ReferenceBadgeRenderer.PLACEHOLDER_PREFIX)}(\\d+)${ReferenceBadgeRenderer.escapeForRegex(ReferenceBadgeRenderer.PLACEHOLDER_SUFFIX)}`,
      'g'
    );

    const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);
    const nodesToProcess: Text[] = [];
    let currentNode = walker.nextNode();
    while (currentNode) {
      const textNode = currentNode as Text;
      const text = textNode.nodeValue ?? '';
      pattern.lastIndex = 0;
      if (pattern.test(text)) {
        nodesToProcess.push(textNode);
      }
      currentNode = walker.nextNode();
    }

    nodesToProcess.forEach(node => {
      const originalText = node.nodeValue ?? '';
      const fragment = document.createDocumentFragment();
      let lastIndex = 0;
      const tokenPattern = new RegExp(pattern, 'g');
      let match: RegExpExecArray | null;

      while ((match = tokenPattern.exec(originalText)) !== null) {
        const matchIndex = match.index;
        if (matchIndex > lastIndex) {
          fragment.appendChild(document.createTextNode(originalText.slice(lastIndex, matchIndex)));
        }

        const placeholderIndex = Number(match[1]);
        const reference = placeholderMap.get(placeholderIndex);

        if (reference) {
          fragment.appendChild(ReferenceBadgeRenderer.createReferenceBadge(reference));
        } else {
          fragment.appendChild(document.createTextNode(match[0]));
        }

        lastIndex = matchIndex + match[0].length;
      }

      if (lastIndex < originalText.length) {
        fragment.appendChild(document.createTextNode(originalText.slice(lastIndex)));
      }

      node.replaceWith(fragment);
    });
  }

  /**
   * Create badge element for a reference
   */
  private static createReferenceBadge(reference: ExtractedReference): HTMLElement {
    const badge = document.createElement('span');
    badge.className = `chat-reference chat-reference-${reference.type}`;
    badge.setAttribute('data-type', reference.type);
    badge.setAttribute('data-name', reference.technicalName);
    badge.textContent = reference.displayText;
    badge.setAttribute('contenteditable', 'false');
    return badge;
  }

  /**
   * Escape special characters for regex
   */
  private static escapeForRegex(value: string): string {
    return value.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
  }
}

```

## ui/chat/components/suggesters/base/BaseSuggester.ts

```typescript
/**
 * BaseSuggester - Abstract base class for all suggester implementations
 * Extends Obsidian's EditorSuggest to provide inline autocomplete functionality
 */

import { App, Editor, EditorPosition, EditorSuggest, TFile } from 'obsidian';
import { TokenCalculator } from '../../../utils/TokenCalculator';
import {
  SuggesterConfig,
  SuggestionItem,
  EditorSuggestContext,
  CacheEntry,
  TokenWarning,
  TokenWarningLevel
} from './SuggesterInterfaces';

/**
 * Abstract base class for suggester implementations
 * Provides common functionality: trigger detection, caching, token estimation
 */
export abstract class BaseSuggester<T> extends EditorSuggest<SuggestionItem<T>> {

  protected config: SuggesterConfig;
  protected cache = new Map<string, CacheEntry<T>>();

  constructor(app: App, config: SuggesterConfig) {
    super(app);
    this.config = config;
  }

  // ==========================================================================
  // Abstract Methods - Must be implemented by subclasses
  // ==========================================================================

  /**
   * Get filtered and ranked suggestions based on context
   * @param context - Editor context with query text
   * @returns Array of suggestion items
   */
  abstract getSuggestions(
    context: EditorSuggestContext
  ): Promise<SuggestionItem<T>[]> | SuggestionItem<T>[];

  /**
   * Render a suggestion item in the dropdown
   * @param item - Suggestion item to render
   * @param el - HTML element to populate
   */
  abstract renderSuggestion(
    item: SuggestionItem<T>,
    el: HTMLElement
  ): void;

  /**
   * Handle selection of a suggestion
   * @param item - Selected suggestion item
   * @param evt - Mouse/keyboard event
   */
  abstract selectSuggestion(
    item: SuggestionItem<T>,
    evt: MouseEvent | KeyboardEvent
  ): void;

  /**
   * Estimate tokens for a specific suggestion item
   * @param item - Suggestion item
   * @returns Estimated token count
   */
  protected abstract estimateItemTokens(item: T): number;

  // ==========================================================================
  // Concrete Methods - Provided by base class
  // ==========================================================================

  /**
   * Trigger detection - called by EditorSuggest on every keystroke
   * Checks if cursor position matches the trigger pattern
   * @param cursor - Current cursor position
   * @param editor - Obsidian editor instance
   * @param file - Current file (may be null)
   * @returns Context if trigger detected, null otherwise
   */
  onTrigger(
    cursor: EditorPosition,
    editor: Editor,
    file: TFile | null
  ): EditorSuggestContext | null {

    const line = editor.getLine(cursor.line);
    const textBeforeCursor = line.substring(0, cursor.ch);

    // Check trigger pattern
    const match = this.config.trigger.exec(textBeforeCursor);

    if (!match) {
      return null;
    }

    // Extract query (everything after trigger character)
    const query = match[1] || '';

    // Calculate trigger start position
    const triggerLength = match[0].length;
    const start: EditorPosition = {
      line: cursor.line,
      ch: cursor.ch - triggerLength
    };

    return {
      query,
      start,
      end: cursor,
      editor
    };
  }

  // ==========================================================================
  // Cache Management
  // ==========================================================================

  /**
   * Get cached data if still valid
   * @param key - Cache key
   * @returns Cached data or null if expired/missing
   */
  protected getCached(key: string): T[] | null {
    const entry = this.cache.get(key);

    if (!entry) {
      return null;
    }

    // Check if cache has expired
    const age = Date.now() - entry.timestamp;
    if (age > this.config.cacheTTL) {
      this.cache.delete(key);
      return null;
    }

    return entry.data;
  }

  /**
   * Store data in cache
   * @param key - Cache key
   * @param data - Data to cache
   */
  protected setCached(key: string, data: T[]): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }

  /**
   * Clear all cached data
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * Clear specific cache entry
   * @param key - Cache key to clear
   */
  protected clearCacheEntry(key: string): void {
    this.cache.delete(key);
  }

  // ==========================================================================
  // Token Management
  // ==========================================================================

  /**
   * Estimate tokens for a suggestion item
   * @param item - Suggestion item
   * @returns Estimated token count
   */
  protected estimateTokens(item: SuggestionItem<T>): number {
    if (item.tokens !== undefined) {
      return item.tokens;
    }
    return this.estimateItemTokens(item.data);
  }

  /**
   * Calculate token warning level
   * @param tokens - Current token count
   * @param maxTokens - Maximum allowed tokens
   * @returns Token warning data
   */
  protected getTokenWarning(tokens: number, maxTokens: number): TokenWarning {
    const percentage = (tokens / maxTokens) * 100;

    let level: TokenWarningLevel;
    let message: string;

    if (percentage >= 100) {
      level = TokenWarningLevel.ERROR;
      message = `Exceeds context limit by ${tokens - maxTokens} tokens!`;
    } else if (percentage >= 90) {
      level = TokenWarningLevel.ERROR;
      message = `Context nearly full (${percentage.toFixed(0)}%)`;
    } else if (percentage >= 75) {
      level = TokenWarningLevel.WARNING;
      message = `High context usage (${percentage.toFixed(0)}%)`;
    } else if (percentage >= 50) {
      level = TokenWarningLevel.INFO;
      message = `Moderate context usage (${percentage.toFixed(0)}%)`;
    } else {
      level = TokenWarningLevel.NONE;
      message = '';
    }

    return {
      level,
      message,
      currentTokens: tokens,
      maxTokens,
      percentage
    };
  }

  /**
   * Add token warning badge to suggestion element
   * @param el - HTML element to add badge to
   * @param tokens - Token count
   * @param maxTokens - Maximum allowed tokens
   */
  protected addTokenBadge(el: HTMLElement, tokens: number, maxTokens: number): void {
    const warning = this.getTokenWarning(tokens, maxTokens);

    if (warning.level === TokenWarningLevel.NONE) {
      return;
    }

    const badge = el.createDiv({ cls: `token-badge token-badge-${warning.level}` });
    badge.textContent = `${tokens.toLocaleString()} tokens`;

    if (warning.message) {
      badge.setAttribute('aria-label', warning.message);
      badge.setAttribute('title', warning.message);
    }
  }

  // ==========================================================================
  // Utility Methods
  // ==========================================================================

  /**
   * Clean up resources when suggester is destroyed
   */
  onDestroy(): void {
    this.clearCache();
  }

  /**
   * Limit array to max suggestions
   * @param items - Array of items
   * @returns Sliced array
   */
  protected limitSuggestions(items: SuggestionItem<T>[]): SuggestionItem<T>[] {
    return items.slice(0, this.config.maxSuggestions);
  }

  /**
   * Sort suggestions by score (descending)
   * @param items - Array of items
   * @returns Sorted array
   */
  protected sortByScore(items: SuggestionItem<T>[]): SuggestionItem<T>[] {
    return items.sort((a, b) => b.score - a.score);
  }
}

```

## ui/chat/components/suggesters/base/SuggesterInterfaces.ts

```typescript
/**
 * Type definitions and interfaces for the suggester system
 * Supports three suggester types: Tools (/), Agents (@), and Notes ([[)
 */

import { Editor, EditorPosition, TFile } from 'obsidian';

// ============================================================================
// Core Suggester Types
// ============================================================================

/**
 * Base suggester context passed to all suggesters
 */
export interface EditorSuggestContext {
  /** Text after trigger character */
  query: string;
  /** Trigger start position */
  start: EditorPosition;
  /** Current cursor position */
  end: EditorPosition;
  /** Obsidian editor instance */
  editor: Editor;
}

/**
 * Configuration for suggester behavior
 */
export interface SuggesterConfig {
  /** Trigger pattern (e.g., /^\/(\w*)$/ for slash commands) */
  trigger: RegExp;
  /** Maximum suggestions to show */
  maxSuggestions: number;
  /** Cache TTL in milliseconds */
  cacheTTL: number;
  /** Debounce delay in ms */
  debounceDelay?: number;
}

/**
 * Wrapper for suggestion items with metadata
 */
export interface SuggestionItem<T> {
  /** The actual suggestion data */
  data: T;
  /** Match score for ranking (higher = better) */
  score: number;
  /** Display text */
  displayText: string;
  /** Optional description */
  description?: string;
  /** Estimated token count */
  tokens?: number;
}

/**
 * Cache entry with TTL
 */
export interface CacheEntry<T> {
  /** Cached data */
  data: T[];
  /** Timestamp when cached */
  timestamp: number;
}

// ============================================================================
// Tool Suggester Types
// ============================================================================

/**
 * Tool suggestion data
 */
export interface ToolSuggestionItem {
  /** Tool name (e.g., "storageManager.list") */
  name: string;
  /** Human-friendly display name (e.g., "Read File") */
  displayName?: string;
  /** Tool description */
  description: string;
  /** Tool category/manager */
  category: string;
  /** Full tool schema */
  schema: ToolSchema;
}

/**
 * MCP Tool schema structure
 */
export interface ToolSchema {
  name: string;
  description: string;
  inputSchema: {
    type: string;
    properties: Record<string, any>;
    required?: string[];
  };
}

/**
 * Tool hint for injection
 */
export interface ToolHint {
  /** Tool name */
  name: string;
  /** Tool schema */
  schema: ToolSchema;
}

// ============================================================================
// Prompt Suggester Types
// ============================================================================

/**
 * Prompt suggestion data
 */
export interface PromptSuggestionItem {
  /** Prompt unique ID */
  id: string;
  /** Prompt display name */
  name: string;
  /** Prompt description */
  description: string;
  /** Prompt instructions */
  prompt: string;
  /** Estimated prompt token count */
  promptTokens: number;
}

/**
 * Prompt reference for injection
 */
export interface PromptReference {
  /** Prompt ID */
  id: string;
  /** Prompt name */
  name: string;
  /** Prompt content */
  prompt: string;
  /** Token count */
  tokens: number;
}

// ============================================================================
// Note Suggester Types
// ============================================================================

/**
 * Note suggestion data
 */
export interface NoteSuggestionItem {
  /** TFile reference */
  file: TFile;
  /** Display name (basename) */
  name: string;
  /** Full path */
  path: string;
  /** File size in bytes */
  size: number;
  /** Estimated token count */
  estimatedTokens: number;
}

/**
 * Note reference for injection
 */
export interface NoteReference {
  /** File path */
  path: string;
  /** File name */
  name: string;
  /** File content */
  content: string;
  /** Token count */
  tokens: number;
}

// ============================================================================
// Workspace Suggester Types
// ============================================================================

/**
 * Workspace suggestion data
 */
export interface WorkspaceSuggestionItem {
  /** Workspace ID */
  id: string;
  /** Workspace name */
  name: string;
  /** Workspace description */
  description?: string;
  /** Root folder */
  rootFolder: string;
  /** Last accessed timestamp */
  lastAccessed: number;
}

/**
 * Workspace reference for injection
 */
export interface WorkspaceReference {
  /** Workspace ID */
  id: string;
  /** Workspace name */
  name: string;
  /** Workspace description */
  description?: string;
  /** Root folder */
  rootFolder: string;
}

// ============================================================================
// Message Enhancement Types
// ============================================================================

/**
 * Enhancement type discriminator
 */
export enum EnhancementType {
  TOOL = 'tool',
  PROMPT = 'prompt',
  NOTE = 'note',
  WORKSPACE = 'workspace'
}

/**
 * Message enhancement metadata
 */
export interface MessageEnhancement {
  /** Original user message */
  originalMessage: string;
  /** Cleaned message (triggers removed) */
  cleanedMessage: string;
  /** Tool hints */
  tools: ToolHint[];
  /** Prompt references */
  prompts: PromptReference[];
  /** Note references */
  notes: NoteReference[];
  /** Workspace references */
  workspaces: WorkspaceReference[];
  /** Total estimated tokens */
  totalTokens: number;
}

/**
 * Enhancement data for a single selection
 */
export interface EnhancementData {
  type: EnhancementType;
  data: ToolHint | PromptReference | NoteReference | WorkspaceReference;
}

// ============================================================================
// Registry Types
// ============================================================================

/**
 * Suggester type discriminator
 */
export enum SuggesterType {
  TOOL = 'tool',
  PROMPT = 'prompt',
  NOTE = 'note',
  WORKSPACE = 'workspace'
}

/**
 * Suggester status
 */
export interface SuggesterStatus {
  /** Is suggester currently active */
  active: boolean;
  /** Current query text */
  query?: string;
  /** Number of current suggestions */
  suggestionCount?: number;
}

// ============================================================================
// Token Warning Types
// ============================================================================

/**
 * Token warning levels
 */
export enum TokenWarningLevel {
  NONE = 'none',
  INFO = 'info',
  WARNING = 'warning',
  ERROR = 'error'
}

/**
 * Token warning data
 */
export interface TokenWarning {
  level: TokenWarningLevel;
  message: string;
  currentTokens: number;
  maxTokens: number;
  percentage: number;
}

```

## ui/chat/components/suggesters/ContentEditableSuggester.ts

```typescript
/**
 * ContentEditableSuggester - Base class for contenteditable suggestions
 *
 * Adapted from TextAreaSuggester to work with contenteditable elements
 * using the Selection/Range API instead of textarea's selectionStart/selectionEnd
 */

import { App, Component } from 'obsidian';
import { SuggesterConfig, SuggestionItem } from './base/SuggesterInterfaces';
import { ContentEditableHelper } from '../../utils/ContentEditableHelper';

export abstract class ContentEditableSuggester<T> {
  protected app: App;
  protected element: HTMLElement;
  protected config: SuggesterConfig;
  protected suggestionContainer: HTMLDivElement | null = null;
  protected selectedIndex = 0;
  protected currentSuggestions: SuggestionItem<T>[] = [];
  protected debounceTimer: NodeJS.Timeout | null = null;
  protected isActive = false;
  protected component?: Component;
  private clickOutsideHandler?: (e: MouseEvent) => void;

  constructor(app: App, element: HTMLElement, config: SuggesterConfig, component?: Component) {
    this.app = app;
    this.element = element;
    this.config = config;
    this.component = component;

    this.setupEventListeners();
  }

  /**
   * Get suggestions based on query
   */
  abstract getSuggestions(query: string): Promise<SuggestionItem<T>[]>;

  /**
   * Render a single suggestion item
   */
  abstract renderSuggestion(item: SuggestionItem<T>, el: HTMLElement): void;

  /**
   * Handle suggestion selection
   */
  abstract selectSuggestion(item: SuggestionItem<T>): Promise<void> | void;

  /**
   * Setup event listeners
   */
  private setupEventListeners(): void {
    const inputHandler = () => this.onInput();
    const keydownHandler = (e: KeyboardEvent) => this.onKeyDown(e);

    this.component!.registerDomEvent(this.element, 'input', inputHandler);
    this.component!.registerDomEvent(this.element, 'keydown', keydownHandler);

    // Click outside to close - stored as instance property for cleanup
    this.clickOutsideHandler = (e: MouseEvent) => {
      if (!this.suggestionContainer?.contains(e.target as Node) &&
          e.target !== this.element) {
        setTimeout(() => this.closeSuggestions(), 100);
      }
    };
    document.addEventListener('click', this.clickOutsideHandler);
  }

  /**
   * Handle input event
   */
  private async onInput(): Promise<void> {
    const text = ContentEditableHelper.getPlainText(this.element);
    const cursorPos = ContentEditableHelper.getCursorPosition(this.element);

    // Clear existing debounce timer
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }

    // Get text before cursor
    const beforeCursor = text.substring(0, cursorPos);
    const match = this.config.trigger.exec(beforeCursor);

    if (!match) {
      this.closeSuggestions();
      return;
    }

    // Extract query from match
    const query = match[1] || '';

    // Debounce the suggestion fetch
    this.debounceTimer = setTimeout(async () => {
      const suggestions = await this.getSuggestions(query);

      if (suggestions.length === 0) {
        this.closeSuggestions();
        return;
      }

      this.currentSuggestions = suggestions;
      this.selectedIndex = 0;
      this.showSuggestions();
    }, this.config.debounceDelay || 100);
  }

  /**
   * Handle keydown events
   */
  private onKeyDown(e: KeyboardEvent): void {
    if (!this.isActive) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        this.selectedIndex = Math.min(
          this.selectedIndex + 1,
          this.currentSuggestions.length - 1
        );
        this.updateSelection();
        break;

      case 'ArrowUp':
        e.preventDefault();
        this.selectedIndex = Math.max(this.selectedIndex - 1, 0);
        this.updateSelection();
        break;

      case 'Enter':
        if (this.currentSuggestions.length > 0) {
          e.preventDefault();
          e.stopPropagation();
          this.selectCurrentSuggestion();
        }
        break;

      case 'Escape':
        e.preventDefault();
        this.closeSuggestions();
        break;
    }
  }

  /**
   * Show suggestions dropdown
   */
  private showSuggestions(): void {
    if (!this.suggestionContainer) {
      this.createSuggestionContainer();
    }

    if (!this.suggestionContainer) return;

    // Clear existing suggestions
    this.suggestionContainer.empty();

    // Render each suggestion
    this.currentSuggestions.forEach((suggestion, index) => {
      const item = this.suggestionContainer!.createDiv('suggester-item');
      if (index === this.selectedIndex) {
        item.addClass('is-selected');
      }

      this.renderSuggestion(suggestion, item);

      // Click to select
      const clickHandler = (e: MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();
        this.selectedIndex = index;
        this.selectCurrentSuggestion();
      };

      this.component!.registerDomEvent(item, 'click', clickHandler);
    });

    // Position above the input
    this.positionSuggestions();

    this.suggestionContainer.classList.remove('suggester-container-hidden');
    this.suggestionContainer.classList.add('suggester-container-visible');
    this.isActive = true;
  }

  /**
   * Create suggestion container
   */
  private createSuggestionContainer(): void {
    this.suggestionContainer = document.body.createDiv('suggester-container');
    this.suggestionContainer.classList.add('suggester-container-positioned', 'suggester-container-hidden');
  }

  /**
   * Position suggestions above input
   */
  private positionSuggestions(): void {
    if (!this.suggestionContainer) return;

    const rect = this.element.getBoundingClientRect();
    this.suggestionContainer.style.left = rect.left + 'px';
    this.suggestionContainer.style.bottom = (window.innerHeight - rect.top + 4) + 'px';
    this.suggestionContainer.style.width = rect.width + 'px';
  }

  /**
   * Update selection highlight
   */
  private updateSelection(): void {
    if (!this.suggestionContainer) return;

    const items = this.suggestionContainer.querySelectorAll('.suggester-item');
    items.forEach((item, index) => {
      if (index === this.selectedIndex) {
        item.addClass('is-selected');
      } else {
        item.removeClass('is-selected');
      }
    });
  }

  /**
   * Select current suggestion
   */
  private async selectCurrentSuggestion(): Promise<void> {
    const suggestion = this.currentSuggestions[this.selectedIndex];
    if (!suggestion) return;

    await this.selectSuggestion(suggestion);
    this.closeSuggestions();

    // Refocus element
    this.element.focus();
  }

  /**
   * Close suggestions dropdown
   */
  protected closeSuggestions(): void {
    if (this.suggestionContainer) {
      this.suggestionContainer.classList.remove('suggester-container-visible');
      this.suggestionContainer.classList.add('suggester-container-hidden');
    }
    this.isActive = false;
    this.currentSuggestions = [];
    this.selectedIndex = 0;
  }

  /**
   * Check if suggester is currently active
   */
  getIsActive(): boolean {
    return this.isActive;
  }

  /**
   * Destroy suggester and cleanup
   */
  destroy(): void {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }

    // Remove document click listener
    if (this.clickOutsideHandler) {
      document.removeEventListener('click', this.clickOutsideHandler);
    }

    if (this.suggestionContainer) {
      this.suggestionContainer.remove();
      this.suggestionContainer = null;
    }

    this.isActive = false;
  }
}

```

## ui/chat/components/suggesters/initializeSuggesters.ts

```typescript
/**
 * Initialize suggesters for a contenteditable element
 */

import { App, Plugin, Component } from 'obsidian';
import { TextAreaNoteSuggester } from './TextAreaNoteSuggester';
import { TextAreaToolSuggester } from './TextAreaToolSuggester';
import { TextAreaPromptSuggester } from './TextAreaPromptSuggester';
import { TextAreaWorkspaceSuggester } from './TextAreaWorkspaceSuggester';
import { MessageEnhancer } from '../../services/MessageEnhancer';
import { CustomPromptStorageService } from '../../../../agents/promptManager/services/CustomPromptStorageService';
import { WorkspaceService } from '../../../../services/WorkspaceService';
import { getNexusPlugin } from '../../../../utils/pluginLocator';
import type { Settings } from '../../../../settings';

/**
 * Interface for NexusPlugin with settings and services
 */
interface NexusPluginWithServices extends Plugin {
  settings?: Settings;
  services?: Record<string, unknown>;
  workspaceService?: WorkspaceService;
}

export interface SuggesterInstances {
  noteSuggester: TextAreaNoteSuggester;
  toolSuggester: TextAreaToolSuggester;
  promptSuggester?: TextAreaPromptSuggester;
  workspaceSuggester?: TextAreaWorkspaceSuggester;
  messageEnhancer: MessageEnhancer;
  cleanup: () => void;
}

export function initializeSuggesters(
  app: App,
  element: HTMLElement,
  component?: Component
): SuggesterInstances {
  const messageEnhancer = new MessageEnhancer();

  // Create suggesters
  const noteSuggester = new TextAreaNoteSuggester(app, element, messageEnhancer, component);
  const toolSuggester = new TextAreaToolSuggester(app, element, messageEnhancer, component);

  // Try to get CustomPromptStorageService for prompt suggester
  let promptSuggester: TextAreaPromptSuggester | undefined;
  let workspaceSuggester: TextAreaWorkspaceSuggester | undefined;
  try {
    const plugin = getNexusPlugin<NexusPluginWithServices>(app);
    if (plugin?.settings) {
      const promptStorage = new CustomPromptStorageService(plugin.settings);
      promptSuggester = new TextAreaPromptSuggester(app, element, messageEnhancer, promptStorage, component);
    }

    // Initialize workspace suggester
    if (plugin) {
      const workspaceService = plugin.workspaceService ||
        (plugin.services?.workspaceService as WorkspaceService | undefined);
      if (workspaceService) {
        workspaceSuggester = new TextAreaWorkspaceSuggester(app, element, messageEnhancer, workspaceService, component);
      }
    }
  } catch (error) {
    // Prompt/workspace suggester initialization failed - will be undefined
  }

  return {
    noteSuggester,
    toolSuggester,
    promptSuggester,
    workspaceSuggester,
    messageEnhancer,
    cleanup: () => {
      noteSuggester.destroy();
      toolSuggester.destroy();
      promptSuggester?.destroy();
      workspaceSuggester?.destroy();
      messageEnhancer.clearEnhancements();
    }
  };
}

```

## ui/chat/components/suggesters/NoteSuggester.ts

```typescript
/**
 * NoteSuggester - Provides autocomplete for [[note]] references
 * Triggers on [[ and suggests vault notes with fuzzy search
 */

import { App, TFile, prepareFuzzySearch, setIcon } from 'obsidian';
import { BaseSuggester } from './base/BaseSuggester';
import {
  SuggestionItem,
  EditorSuggestContext,
  NoteSuggestionItem,
  NoteReference,
  EnhancementType
} from './base/SuggesterInterfaces';
import { MessageEnhancer } from '../../services/MessageEnhancer';
import { TokenCalculator } from '../../utils/TokenCalculator';

/**
 * Note suggester for [[ wikilink autocomplete
 */
export class NoteSuggester extends BaseSuggester<NoteSuggestionItem> {

  private messageEnhancer: MessageEnhancer;
  private maxTokensPerNote = 10000; // Warn if note exceeds this

  constructor(app: App, messageEnhancer: MessageEnhancer) {
    super(app, {
      // Matches [[ followed by any text
      trigger: /\[\[([^\]]*?)$/,
      maxSuggestions: 50,
      cacheTTL: 60000, // 1 minute - notes don't change that often during a chat session
      debounceDelay: 150
    });

    this.messageEnhancer = messageEnhancer;
  }

  // ==========================================================================
  // Abstract Method Implementations
  // ==========================================================================

  /**
   * Get note suggestions with fuzzy search
   * @param context - Editor context with query
   * @returns Filtered and ranked note suggestions
   */
  async getSuggestions(
    context: EditorSuggestContext
  ): Promise<SuggestionItem<NoteSuggestionItem>[]> {

    // Get all markdown files
    const files = this.app.vault.getMarkdownFiles();

    // If no query, return all files (sorted by recent modification)
    if (!context.query || context.query.trim().length === 0) {
      const allSuggestions = files
        .sort((a, b) => b.stat.mtime - a.stat.mtime) // Most recently modified first
        .slice(0, this.config.maxSuggestions)
        .map(file => this.createSuggestion(file, 1.0));

      return allSuggestions;
    }

    // Fuzzy search on file paths and names
    const query = context.query.toLowerCase();
    const fuzzySearch = prepareFuzzySearch(query);

    const suggestions: SuggestionItem<NoteSuggestionItem>[] = [];

    for (const file of files) {
      // Search against basename and path
      const basename = file.basename;
      const path = file.path;

      // Try fuzzy match on basename first (higher priority)
      const basenameMatch = fuzzySearch(basename);
      if (basenameMatch) {
        suggestions.push(this.createSuggestion(file, basenameMatch.score));
        continue;
      }

      // Try fuzzy match on full path (lower priority)
      const pathMatch = fuzzySearch(path);
      if (pathMatch) {
        suggestions.push(this.createSuggestion(file, pathMatch.score * 0.8));
      }
    }

    // Sort by score and limit
    return this.limitSuggestions(this.sortByScore(suggestions));
  }

  /**
   * Render note suggestion in dropdown
   * @param item - Note suggestion item
   * @param el - HTML element to populate
   */
  renderSuggestion(
    item: SuggestionItem<NoteSuggestionItem>,
    el: HTMLElement
  ): void {
    el.addClass('suggester-item', 'note-suggester-item');

    // Icon
    const icon = el.createDiv({ cls: 'suggester-icon' });
    setIcon(icon, 'file-text');

    // Content container
    const content = el.createDiv({ cls: 'suggester-content' });

    // Note name (primary text)
    const name = content.createDiv({ cls: 'suggester-title' });
    name.textContent = item.data.name;

    // Path (secondary text)
    const path = content.createDiv({ cls: 'suggester-description' });
    path.textContent = item.data.path;

    // Token badge
    const badgeContainer = el.createDiv({ cls: 'suggester-badge-container' });

    // Token warning badge if needed
    if (item.data.estimatedTokens > this.maxTokensPerNote * 0.75) {
      this.addTokenBadge(badgeContainer, item.data.estimatedTokens, this.maxTokensPerNote);
    } else {
      // Just show token count
      const tokenBadge = badgeContainer.createSpan({ cls: 'suggester-badge token-info' });
      tokenBadge.textContent = `~${item.data.estimatedTokens.toLocaleString()} tokens`;
    }
  }

  /**
   * Handle note selection
   * @param item - Selected note
   * @param evt - Selection event
   */
  async selectSuggestion(
    item: SuggestionItem<NoteSuggestionItem>,
    evt: MouseEvent | KeyboardEvent
  ): Promise<void> {

    const context = this.context;
    if (!context) return;

    const { editor, start, end } = context;

    // Read note content
    const content = await this.app.vault.read(item.data.file);

    // Calculate actual tokens
    const tokens = TokenCalculator.estimateTextTokens(content);

    // Create note reference
    const noteRef: NoteReference = {
      path: item.data.path,
      name: item.data.name,
      content: content,
      tokens: tokens
    };

    // Add to message enhancer
    this.messageEnhancer.addNote(noteRef);

    // Replace trigger + query with wikilink
    const replacement = `[[${item.data.name}]]`;

    // Replace text in editor
    editor.replaceRange(
      replacement,
      start,
      end
    );

    // Move cursor after the wikilink
    const newCursor = {
      line: start.line,
      ch: start.ch + replacement.length
    };
    editor.setCursor(newCursor);
  }

  /**
   * Estimate tokens for a note
   * @param item - Note data
   * @returns Estimated token count
   */
  protected estimateItemTokens(item: NoteSuggestionItem): number {
    // Use character count for estimation: ~4 chars per token
    // This is a rough estimate without reading the file
    return Math.ceil(item.size / 4);
  }

  // ==========================================================================
  // Helper Methods
  // ==========================================================================

  /**
   * Create suggestion item from TFile
   * @param file - Obsidian TFile
   * @param score - Match score
   * @returns Suggestion item
   */
  private createSuggestion(file: TFile, score: number): SuggestionItem<NoteSuggestionItem> {
    const estimatedTokens = Math.ceil(file.stat.size / 4); // ~4 chars per token

    return {
      data: {
        file: file,
        name: file.basename,
        path: file.path,
        size: file.stat.size,
        estimatedTokens: estimatedTokens
      },
      score: score,
      displayText: file.basename,
      description: file.path,
      tokens: estimatedTokens
    };
  }
}

```

## ui/chat/components/suggesters/PromptSuggester.ts

```typescript
/**
 * PromptSuggester - Provides autocomplete for @prompt mentions
 * Triggers on @ and suggests custom prompts with fuzzy search
 */

import { App, prepareFuzzySearch, setIcon } from 'obsidian';
import { BaseSuggester } from './base/BaseSuggester';
import {
  SuggestionItem,
  EditorSuggestContext,
  PromptSuggestionItem,
  PromptReference,
  EnhancementType
} from './base/SuggesterInterfaces';
import { MessageEnhancer } from '../../services/MessageEnhancer';
import { CustomPromptStorageService } from '../../../../agents/promptManager/services/CustomPromptStorageService';
import { TokenCalculator } from '../../utils/TokenCalculator';

/**
 * Prompt suggester for @ mention autocomplete
 */
export class PromptSuggester extends BaseSuggester<PromptSuggestionItem> {

  private messageEnhancer: MessageEnhancer;
  private promptStorage: CustomPromptStorageService;
  private maxTokensPerPrompt = 5000; // Warn if prompt exceeds this

  constructor(
    app: App,
    messageEnhancer: MessageEnhancer,
    promptStorage: CustomPromptStorageService
  ) {
    super(app, {
      // Matches @ followed by word characters
      trigger: /@(\w*)$/,
      maxSuggestions: 20,
      cacheTTL: 30000, // 30 seconds - prompts may be added/edited during chat
      debounceDelay: 100
    });

    this.messageEnhancer = messageEnhancer;
    this.promptStorage = promptStorage;
  }

  // ==========================================================================
  // Abstract Method Implementations
  // ==========================================================================

  /**
   * Get prompt suggestions with fuzzy search
   * @param context - Editor context with query
   * @returns Filtered and ranked prompt suggestions
   */
  async getSuggestions(
    context: EditorSuggestContext
  ): Promise<SuggestionItem<PromptSuggestionItem>[]> {

    // Get enabled prompts only
    const prompts = this.promptStorage.getEnabledPrompts();

    if (prompts.length === 0) {
      return [];
    }

    // If no query, return all prompts (sorted by name)
    if (!context.query || context.query.trim().length === 0) {
      const allSuggestions = prompts
        .sort((a, b) => a.name.localeCompare(b.name))
        .slice(0, this.config.maxSuggestions)
        .map(prompt => this.createSuggestion(prompt, 1.0));

      return allSuggestions;
    }

    // Fuzzy search on prompt names and descriptions
    const query = context.query.toLowerCase();
    const fuzzySearch = prepareFuzzySearch(query);

    const suggestions: SuggestionItem<PromptSuggestionItem>[] = [];

    for (const prompt of prompts) {
      // Try fuzzy match on name first (higher priority)
      const nameMatch = fuzzySearch(prompt.name);
      if (nameMatch) {
        suggestions.push(this.createSuggestion(prompt, nameMatch.score));
        continue;
      }

      // Try fuzzy match on description (lower priority)
      const descMatch = fuzzySearch(prompt.description);
      if (descMatch) {
        suggestions.push(this.createSuggestion(prompt, descMatch.score * 0.7));
      }
    }

    // Sort by score and limit
    return this.limitSuggestions(this.sortByScore(suggestions));
  }

  /**
   * Render prompt suggestion in dropdown
   * @param item - Prompt suggestion item
   * @param el - HTML element to populate
   */
  renderSuggestion(
    item: SuggestionItem<PromptSuggestionItem>,
    el: HTMLElement
  ): void {
    el.addClass('suggester-item', 'prompt-suggester-item');

    // Icon
    const icon = el.createDiv({ cls: 'suggester-icon' });
    setIcon(icon, 'bot');

    // Content container
    const content = el.createDiv({ cls: 'suggester-content' });

    // Prompt name (primary text)
    const name = content.createDiv({ cls: 'suggester-title' });
    name.textContent = item.data.name;

    // Description (secondary text)
    const desc = content.createDiv({ cls: 'suggester-description' });
    desc.textContent = item.data.description;

    // Token badge
    const badgeContainer = el.createDiv({ cls: 'suggester-badge-container' });

    // Token warning badge if needed
    if (item.data.promptTokens > this.maxTokensPerPrompt * 0.75) {
      this.addTokenBadge(badgeContainer, item.data.promptTokens, this.maxTokensPerPrompt);
    } else {
      // Just show token count
      const tokenBadge = badgeContainer.createSpan({ cls: 'suggester-badge token-info' });
      tokenBadge.textContent = `~${item.data.promptTokens.toLocaleString()} tokens`;
    }
  }

  /**
   * Handle prompt selection
   * @param item - Selected prompt
   * @param evt - Selection event
   */
  selectSuggestion(
    item: SuggestionItem<PromptSuggestionItem>,
    evt: MouseEvent | KeyboardEvent
  ): void {

    // Access the context property from EditorSuggest base class
    // This is typed as EditorSuggestContext | null in Obsidian's API
    if (!this.context) return;

    const { editor, start, end } = this.context;

    // Create prompt reference
    const promptRef: PromptReference = {
      id: item.data.id,
      name: item.data.name,
      prompt: item.data.prompt,
      tokens: item.data.promptTokens
    };

    // Add to message enhancer
    this.messageEnhancer.addPrompt(promptRef);

    // Replace @ mention with prompt name (in format that's clear to user)
    const replacement = `@${item.data.name.replace(/\s+/g, '_')}`;

    // Replace text in editor
    editor.replaceRange(
      replacement + ' ', // Add space after for better UX
      start,
      end
    );

    // Move cursor after the mention
    const newCursor = {
      line: start.line,
      ch: start.ch + replacement.length + 1
    };
    editor.setCursor(newCursor);
  }

  /**
   * Estimate tokens for a prompt
   * @param item - Prompt data
   * @returns Estimated token count
   */
  protected estimateItemTokens(item: PromptSuggestionItem): number {
    return item.promptTokens;
  }

  // ==========================================================================
  // Helper Methods
  // ==========================================================================

  /**
   * Create suggestion item from CustomPrompt
   * @param promptData - Custom prompt data
   * @param score - Match score
   * @returns Suggestion item
   */
  private createSuggestion(
    promptData: { id: string; name: string; description: string; prompt: string },
    score: number
  ): SuggestionItem<PromptSuggestionItem> {

    const promptTokens = TokenCalculator.estimateTextTokens(promptData.prompt);

    return {
      data: {
        id: promptData.id,
        name: promptData.name,
        description: promptData.description,
        prompt: promptData.prompt,
        promptTokens: promptTokens
      },
      score: score,
      displayText: promptData.name,
      description: promptData.description,
      tokens: promptTokens
    };
  }

  /**
   * Refresh cache when prompts are modified
   */
  refreshCache(): void {
    this.clearCache();
  }
}

```

## ui/chat/components/suggesters/TextAreaNoteSuggester.ts

```typescript
/**
 * TextAreaNoteSuggester - Note suggester for textarea
 */

import { App, TFile, prepareFuzzySearch, setIcon, Component } from 'obsidian';
import { ContentEditableSuggester } from './ContentEditableSuggester';
import { ContentEditableHelper } from '../../utils/ContentEditableHelper';
import {
  SuggestionItem,
  NoteSuggestionItem,
  NoteReference
} from './base/SuggesterInterfaces';
import { MessageEnhancer } from '../../services/MessageEnhancer';
import { TokenCalculator } from '../../utils/TokenCalculator';

export class TextAreaNoteSuggester extends ContentEditableSuggester<NoteSuggestionItem> {
  private messageEnhancer: MessageEnhancer;
  private maxTokensPerNote = 10000;

  constructor(app: App, element: HTMLElement, messageEnhancer: MessageEnhancer, component?: Component) {
    super(app, element, {
      trigger: /\[\[([^\]]*?)$/,
      maxSuggestions: 50,
      cacheTTL: 60000,
      debounceDelay: 150
    }, component);

    this.messageEnhancer = messageEnhancer;
  }

  async getSuggestions(query: string): Promise<SuggestionItem<NoteSuggestionItem>[]> {
    const files = this.app.vault.getMarkdownFiles();

    if (!query || query.trim().length === 0) {
      return files
        .sort((a, b) => b.stat.mtime - a.stat.mtime)
        .slice(0, this.config.maxSuggestions)
        .map(file => this.createSuggestion(file, 1.0));
    }

    const fuzzySearch = prepareFuzzySearch(query.toLowerCase());
    const suggestions: SuggestionItem<NoteSuggestionItem>[] = [];

    for (const file of files) {
      const basenameMatch = fuzzySearch(file.basename);
      if (basenameMatch) {
        suggestions.push(this.createSuggestion(file, basenameMatch.score));
        continue;
      }

      const pathMatch = fuzzySearch(file.path);
      if (pathMatch) {
        suggestions.push(this.createSuggestion(file, pathMatch.score * 0.8));
      }
    }

    return suggestions
      .sort((a, b) => b.score - a.score)
      .slice(0, this.config.maxSuggestions);
  }

  renderSuggestion(item: SuggestionItem<NoteSuggestionItem>, el: HTMLElement): void {
    el.addClass('note-suggester-item');

    const icon = el.createDiv({ cls: 'suggester-icon' });
    setIcon(icon, 'file-text');

    const content = el.createDiv({ cls: 'suggester-content' });
    content.createDiv({ cls: 'suggester-title', text: item.data.name });
    content.createDiv({ cls: 'suggester-description', text: item.data.path });

    const badgeContainer = el.createDiv({ cls: 'suggester-badge-container' });
    
    if (item.data.estimatedTokens > this.maxTokensPerNote * 0.75) {
      const tokenBadge = badgeContainer.createSpan({ cls: 'suggester-badge token-badge-warning' });
      tokenBadge.textContent = `~${item.data.estimatedTokens.toLocaleString()} tokens`;
    } else {
      // Just show token count
      const tokenBadge = badgeContainer.createSpan({ cls: 'suggester-badge token-info' });
      tokenBadge.textContent = `~${item.data.estimatedTokens.toLocaleString()} tokens`;
    }
  }

  async selectSuggestion(item: SuggestionItem<NoteSuggestionItem>): Promise<void> {
    // Read note content
    const content = await this.app.vault.read(item.data.file);
    const tokens = TokenCalculator.estimateTextTokens(content);

    // Add to message enhancer
    const noteRef: NoteReference = {
      path: item.data.path,
      name: item.data.name,
      content: content,
      tokens: tokens
    };
    this.messageEnhancer.addNote(noteRef);

    // Replace [[ with styled reference badge
    const cursorPos = ContentEditableHelper.getCursorPosition(this.element);
    const text = ContentEditableHelper.getPlainText(this.element);
    const beforeCursor = text.substring(0, cursorPos);
    const match = /\[\[([^\]]*)$/.exec(beforeCursor);

    if (match) {
      const start = cursorPos - match[0].length;

      // Delete the trigger text
      ContentEditableHelper.deleteTextAtCursor(this.element, start, cursorPos);

      // Insert styled reference
      ContentEditableHelper.insertReferenceNode(
        this.element,
        'note',
        `[[${item.data.name}]]`,
        item.data.path
      );
    }
  }

  private createSuggestion(file: TFile, score: number): SuggestionItem<NoteSuggestionItem> {
    const estimatedTokens = Math.ceil(file.stat.size / 4);

    return {
      data: {
        file: file,
        name: file.basename,
        path: file.path,
        size: file.stat.size,
        estimatedTokens: estimatedTokens
      },
      score: score,
      displayText: file.basename,
      description: file.path,
      tokens: estimatedTokens
    };
  }
}

```

## ui/chat/components/suggesters/TextAreaPromptSuggester.ts

```typescript
/**
 * TextAreaPromptSuggester - Prompt suggester for textarea
 */

import { App, prepareFuzzySearch, setIcon, Component } from 'obsidian';
import { ContentEditableSuggester } from './ContentEditableSuggester';
import { ContentEditableHelper } from '../../utils/ContentEditableHelper';
import {
  SuggestionItem,
  PromptSuggestionItem,
  PromptReference
} from './base/SuggesterInterfaces';
import { MessageEnhancer } from '../../services/MessageEnhancer';
import { CustomPromptStorageService } from '../../../../agents/promptManager/services/CustomPromptStorageService';
import { TokenCalculator } from '../../utils/TokenCalculator';

export class TextAreaPromptSuggester extends ContentEditableSuggester<PromptSuggestionItem> {
  private messageEnhancer: MessageEnhancer;
  private promptStorage: CustomPromptStorageService;
  private maxTokensPerPrompt = 5000;

  constructor(
    app: App,
    element: HTMLElement,
    messageEnhancer: MessageEnhancer,
    promptStorage: CustomPromptStorageService,
    component?: Component
  ) {
    super(app, element, {
      trigger: /@(\w*)$/,
      maxSuggestions: 20,
      cacheTTL: 30000,
      debounceDelay: 100
    }, component);

    this.messageEnhancer = messageEnhancer;
    this.promptStorage = promptStorage;
  }

  async getSuggestions(query: string): Promise<SuggestionItem<PromptSuggestionItem>[]> {
    const prompts = this.promptStorage.getEnabledPrompts();

    if (prompts.length === 0) {
      return [];
    }

    if (!query || query.trim().length === 0) {
      return prompts
        .sort((a, b) => a.name.localeCompare(b.name))
        .slice(0, this.config.maxSuggestions)
        .map(prompt => this.createSuggestion(prompt, 1.0));
    }

    const fuzzySearch = prepareFuzzySearch(query.toLowerCase());
    const suggestions: SuggestionItem<PromptSuggestionItem>[] = [];

    for (const prompt of prompts) {
      const nameMatch = fuzzySearch(prompt.name);
      if (nameMatch) {
        suggestions.push(this.createSuggestion(prompt, nameMatch.score));
        continue;
      }

      const descMatch = fuzzySearch(prompt.description);
      if (descMatch) {
        suggestions.push(this.createSuggestion(prompt, descMatch.score * 0.7));
      }
    }

    return suggestions
      .sort((a, b) => b.score - a.score)
      .slice(0, this.config.maxSuggestions);
  }

  renderSuggestion(item: SuggestionItem<PromptSuggestionItem>, el: HTMLElement): void {
    el.addClass('prompt-suggester-item');

    const icon = el.createDiv({ cls: 'suggester-icon' });
    setIcon(icon, 'bot');

    const content = el.createDiv({ cls: 'suggester-content' });
    content.createDiv({ cls: 'suggester-title', text: item.data.name });
    content.createDiv({ cls: 'suggester-description', text: item.data.description });

    const badgeContainer = el.createDiv({ cls: 'suggester-badge-container' });
    const tokenBadge = badgeContainer.createSpan({ cls: 'suggester-badge token-info' });
    tokenBadge.textContent = `~${item.data.promptTokens.toLocaleString()} tokens`;
  }

  selectSuggestion(item: SuggestionItem<PromptSuggestionItem>): void {
    // Add to message enhancer
    const promptRef: PromptReference = {
      id: item.data.id,
      name: item.data.name,
      prompt: item.data.prompt,
      tokens: item.data.promptTokens
    };
    this.messageEnhancer.addPrompt(promptRef);

    // Replace @ with styled reference badge
    const cursorPos = ContentEditableHelper.getCursorPosition(this.element);
    const text = ContentEditableHelper.getPlainText(this.element);
    const beforeCursor = text.substring(0, cursorPos);
    const match = /@(\w*)$/.exec(beforeCursor);

    if (match) {
      const start = cursorPos - match[0].length;

      // Delete the trigger text
      ContentEditableHelper.deleteTextAtCursor(this.element, start, cursorPos);

      // Insert styled reference
      ContentEditableHelper.insertReferenceNode(
        this.element,
        'prompt',
        `@${item.data.name.replace(/\s+/g, '_')}`,
        item.data.id
      );
    }
  }

  private createSuggestion(
    promptData: { id: string; name: string; description: string; prompt: string },
    score: number
  ): SuggestionItem<PromptSuggestionItem> {
    const promptTokens = TokenCalculator.estimateTextTokens(promptData.prompt);

    return {
      data: {
        id: promptData.id,
        name: promptData.name,
        description: promptData.description,
        prompt: promptData.prompt,
        promptTokens: promptTokens
      },
      score: score,
      displayText: promptData.name,
      description: promptData.description,
      tokens: promptTokens
    };
  }
}

```

## ui/chat/components/suggesters/TextAreaToolSuggester.ts

```typescript
/**
 * TextAreaToolSuggester - Tool suggester for textarea
 */

import { App, Plugin, prepareFuzzySearch, setIcon, Component } from 'obsidian';
import { ContentEditableSuggester } from './ContentEditableSuggester';
import { ContentEditableHelper } from '../../utils/ContentEditableHelper';
import {
  SuggestionItem,
  ToolSuggestionItem,
  ToolHint
} from './base/SuggesterInterfaces';
import { MessageEnhancer } from '../../services/MessageEnhancer';
import { formatToolDisplayName } from '../../../../utils/toolNameUtils';
import { getNexusPlugin } from '../../../../utils/pluginLocator';
import { IAgent } from '../../../../agents/interfaces/IAgent';

/**
 * Extended plugin interface with MCP connector structure
 */
interface PluginWithConnector extends Plugin {
  connector?: {
    agentRegistry?: {
      getAllAgents(): Map<string, IAgent>;
    };
  };
}

export class TextAreaToolSuggester extends ContentEditableSuggester<ToolSuggestionItem> {
  private messageEnhancer: MessageEnhancer;
  private cachedTools: ToolSuggestionItem[] | null = null;

  constructor(
    app: App,
    element: HTMLElement,
    messageEnhancer: MessageEnhancer,
    component?: Component
  ) {
    super(app, element, {
      trigger: /\/(\w*)$/,
      maxSuggestions: 30,
      cacheTTL: 120000,
      debounceDelay: 100
    }, component);

    this.messageEnhancer = messageEnhancer;
  }

  /**
   * Load tools from plugin
   */
  private async loadTools(): Promise<void> {
    try {
      const plugin = getNexusPlugin<PluginWithConnector>(this.app);
      if (!plugin) {
        return;
      }

      // Get agents from connector's agent registry
      if (!plugin.connector?.agentRegistry) {
        return;
      }

      const agents = plugin.connector.agentRegistry.getAllAgents();
      if (!agents || agents.size === 0) {
        return;
      }

      // Extract individual tools from each agent
      this.cachedTools = [];

      for (const agent of Array.from(agents.values())) {
        const tools = agent.getTools();

        for (const tool of tools) {
          const toolName = `${agent.name}.${tool.slug}`;

          this.cachedTools.push({
            name: toolName, // Technical name: "storageManager.list"
            displayName: formatToolDisplayName(toolName), // "Read File"
            description: tool.description || `Execute ${tool.slug} on ${agent.name}`,
            category: agent.name,
            schema: {
              name: toolName,
              description: tool.description || `Execute ${tool.slug}`,
              inputSchema: tool.getParameterSchema?.() || {}
            }
          });
        }
      }
    } catch (error) {
      // Failed to load tools
    }
  }

  async getSuggestions(query: string): Promise<SuggestionItem<ToolSuggestionItem>[]> {

    // Wait for tools to load if not yet loaded
    if (!this.cachedTools) {
      await this.loadTools();
    }

    if (!this.cachedTools || this.cachedTools.length === 0) {
      return [];
    }

    // If no query, return all tools sorted by display name
    if (!query || query.trim().length === 0) {
      return this.cachedTools
        .slice(0, this.config.maxSuggestions)
        .map(tool => this.createSuggestion(tool, 1.0));
    }

    const fuzzySearch = prepareFuzzySearch(query.toLowerCase());
    const suggestions: SuggestionItem<ToolSuggestionItem>[] = [];

    for (const tool of this.cachedTools) {
      // Try fuzzy match on display name first (highest priority)
      const displayName = tool.displayName || tool.name;
      const displayMatch = fuzzySearch(displayName);
      if (displayMatch) {
        suggestions.push(this.createSuggestion(tool, displayMatch.score));
        continue;
      }

      // Try fuzzy match on category (medium priority)
      const categoryMatch = fuzzySearch(tool.category);
      if (categoryMatch) {
        suggestions.push(this.createSuggestion(tool, categoryMatch.score * 0.8));
        continue;
      }

      // Try fuzzy match on description (lower priority)
      const descMatch = fuzzySearch(tool.description);
      if (descMatch) {
        suggestions.push(this.createSuggestion(tool, descMatch.score * 0.6));
      }
    }

    return suggestions
      .sort((a, b) => b.score - a.score)
      .slice(0, this.config.maxSuggestions);
  }

  renderSuggestion(item: SuggestionItem<ToolSuggestionItem>, el: HTMLElement): void {
    el.addClass('tool-suggester-item');

    const icon = el.createDiv({ cls: 'suggester-icon' });
    setIcon(icon, 'wrench');

    const content = el.createDiv({ cls: 'suggester-content' });

    // Show display name (e.g., "Read File") instead of technical name
    const displayName = item.data.displayName || item.data.name;
    content.createDiv({ cls: 'suggester-title', text: displayName });
    content.createDiv({ cls: 'suggester-description', text: item.data.description });
  }

  selectSuggestion(item: SuggestionItem<ToolSuggestionItem>): void {
    // Add to message enhancer
    const toolHint: ToolHint = {
      name: item.data.name,
      schema: item.data.schema
    };
    this.messageEnhancer.addTool(toolHint);

    // Replace /command with styled reference badge
    const cursorPos = ContentEditableHelper.getCursorPosition(this.element);
    const text = ContentEditableHelper.getPlainText(this.element);
    const beforeCursor = text.substring(0, cursorPos);
    const match = /\/(\w*)$/.exec(beforeCursor);

    if (match) {
      const start = cursorPos - match[0].length;
      const displayName = item.data.displayName || item.data.name;

      // Delete the trigger text
      ContentEditableHelper.deleteTextAtCursor(this.element, start, cursorPos);

      // Insert styled reference
      ContentEditableHelper.insertReferenceNode(
        this.element,
        'tool',
        `/${displayName.replace(/\s+/g, '')}`,
        item.data.name
      );
    }
  }

  private createSuggestion(
    tool: ToolSuggestionItem,
    score: number
  ): SuggestionItem<ToolSuggestionItem> {
    return {
      data: tool,
      score: score,
      displayText: tool.name,
      description: tool.description,
      tokens: 150
    };
  }
}

```

## ui/chat/components/suggesters/TextAreaWorkspaceSuggester.ts

```typescript
/**
 * TextAreaWorkspaceSuggester - Workspace suggester for textarea
 * Triggers on # and suggests available workspaces with fuzzy search
 */

import { App, prepareFuzzySearch, setIcon, Component } from 'obsidian';
import { ContentEditableSuggester } from './ContentEditableSuggester';
import { ContentEditableHelper } from '../../utils/ContentEditableHelper';
import {
  SuggestionItem,
  WorkspaceSuggestionItem,
  WorkspaceReference
} from './base/SuggesterInterfaces';
import { MessageEnhancer } from '../../services/MessageEnhancer';
import { WorkspaceService } from '../../../../services/WorkspaceService';

export class TextAreaWorkspaceSuggester extends ContentEditableSuggester<WorkspaceSuggestionItem> {
  private messageEnhancer: MessageEnhancer;
  private workspaceService: WorkspaceService;

  constructor(
    app: App,
    element: HTMLElement,
    messageEnhancer: MessageEnhancer,
    workspaceService: WorkspaceService,
    component?: Component
  ) {
    super(app, element, {
      trigger: /#(\w*)$/,
      maxSuggestions: 20,
      cacheTTL: 30000,
      debounceDelay: 100
    }, component);

    this.messageEnhancer = messageEnhancer;
    this.workspaceService = workspaceService;
  }

  async getSuggestions(query: string): Promise<SuggestionItem<WorkspaceSuggestionItem>[]> {
    // Get all workspaces sorted by last accessed
    const workspaces = await this.workspaceService.listWorkspaces();

    if (workspaces.length === 0) {
      return [];
    }

    if (!query || query.trim().length === 0) {
      return workspaces
        .slice(0, this.config.maxSuggestions)
        .map(workspace => this.createSuggestion(workspace, 1.0));
    }

    const fuzzySearch = prepareFuzzySearch(query.toLowerCase());
    const suggestions: SuggestionItem<WorkspaceSuggestionItem>[] = [];

    for (const workspace of workspaces) {
      // Try fuzzy match on name first (higher priority)
      const nameMatch = fuzzySearch(workspace.name);
      if (nameMatch) {
        suggestions.push(this.createSuggestion(workspace, nameMatch.score));
        continue;
      }

      // Try fuzzy match on description (lower priority)
      if (workspace.description) {
        const descMatch = fuzzySearch(workspace.description);
        if (descMatch) {
          suggestions.push(this.createSuggestion(workspace, descMatch.score * 0.7));
        }
      }
    }

    return suggestions
      .sort((a, b) => b.score - a.score)
      .slice(0, this.config.maxSuggestions);
  }

  renderSuggestion(item: SuggestionItem<WorkspaceSuggestionItem>, el: HTMLElement): void {
    el.addClass('workspace-suggester-item');

    const icon = el.createDiv({ cls: 'suggester-icon' });
    setIcon(icon, 'folder-tree');

    const content = el.createDiv({ cls: 'suggester-content' });
    content.createDiv({ cls: 'suggester-title', text: item.data.name });

    if (item.data.description) {
      content.createDiv({ cls: 'suggester-description', text: item.data.description });
    } else {
      content.createDiv({ cls: 'suggester-description', text: item.data.rootFolder });
    }
  }

  selectSuggestion(item: SuggestionItem<WorkspaceSuggestionItem>): void {
    // Add to message enhancer
    const workspaceRef: WorkspaceReference = {
      id: item.data.id,
      name: item.data.name,
      description: item.data.description,
      rootFolder: item.data.rootFolder
    };
    this.messageEnhancer.addWorkspace(workspaceRef);

    // Replace # with styled reference badge
    const cursorPos = ContentEditableHelper.getCursorPosition(this.element);
    const text = ContentEditableHelper.getPlainText(this.element);
    const beforeCursor = text.substring(0, cursorPos);
    const match = /#(\w*)$/.exec(beforeCursor);

    if (match) {
      const start = cursorPos - match[0].length;

      // Delete the trigger text
      ContentEditableHelper.deleteTextAtCursor(this.element, start, cursorPos);

      // Insert styled reference
      ContentEditableHelper.insertReferenceNode(
        this.element,
        'workspace',
        `#${item.data.name.replace(/\s+/g, '_')}`,
        item.data.id
      );
    }
  }

  private createSuggestion(
    workspace: { id: string; name: string; description?: string; rootFolder: string; lastAccessed: number },
    score: number
  ): SuggestionItem<WorkspaceSuggestionItem> {
    return {
      data: {
        id: workspace.id,
        name: workspace.name,
        description: workspace.description,
        rootFolder: workspace.rootFolder,
        lastAccessed: workspace.lastAccessed
      },
      score: score,
      displayText: workspace.name,
      description: workspace.description || workspace.rootFolder
    };
  }
}

```

## ui/chat/components/suggesters/ToolSuggester.ts

```typescript
/**
 * ToolSuggester - Provides autocomplete for / tool commands
 * Triggers on / and suggests available MCP tools with fuzzy search
 */

import { App, prepareFuzzySearch, setIcon } from 'obsidian';
import { BaseSuggester } from './base/BaseSuggester';
import {
  SuggestionItem,
  EditorSuggestContext,
  ToolSuggestionItem,
  ToolHint,
  ToolSchema,
  EnhancementType
} from './base/SuggesterInterfaces';
import { MessageEnhancer } from '../../services/MessageEnhancer';
import { ToolListService } from '../../../../handlers/services/ToolListService';
import { IAgent } from '../../../../agents/interfaces/IAgent';

/**
 * Tool suggester for / command autocomplete
 */
export class ToolSuggester extends BaseSuggester<ToolSuggestionItem> {

  private messageEnhancer: MessageEnhancer;
  private toolListService: ToolListService;
  private getAgents: () => Map<string, IAgent>;
  private isVaultEnabled: () => boolean;
  private getVaultName: () => string | undefined;

  constructor(
    app: App,
    messageEnhancer: MessageEnhancer,
    toolListService: ToolListService,
    getAgents: () => Map<string, IAgent>,
    isVaultEnabled: () => boolean,
    getVaultName: () => string | undefined
  ) {
    super(app, {
      // Matches / at start of line followed by word characters
      trigger: /^\/(\w*)$/,
      maxSuggestions: 30,
      cacheTTL: 120000, // 2 minutes - tools don't change often
      debounceDelay: 100
    });

    this.messageEnhancer = messageEnhancer;
    this.toolListService = toolListService;
    this.getAgents = getAgents;
    this.isVaultEnabled = isVaultEnabled;
    this.getVaultName = getVaultName;
  }

  // ==========================================================================
  // Abstract Method Implementations
  // ==========================================================================

  /**
   * Get tool suggestions with fuzzy search
   * @param context - Editor context with query
   * @returns Filtered and ranked tool suggestions
   */
  async getSuggestions(
    context: EditorSuggestContext
  ): Promise<SuggestionItem<ToolSuggestionItem>[]> {

    // Check cache first
    let tools = this.getCached('tools');

    if (!tools) {
      // Fetch tools from service
      const toolData = await this.toolListService.generateToolList(
        this.getAgents(),
        this.isVaultEnabled(),
        this.getVaultName()
      );

      tools = toolData.tools.map(tool => this.convertToToolItem(tool));
      this.setCached('tools', tools);
    }

    if (tools.length === 0) {
      return [];
    }

    // If no query, return all tools (sorted by name)
    if (!context.query || context.query.trim().length === 0) {
      const allSuggestions = tools
        .sort((a, b) => a.name.localeCompare(b.name))
        .slice(0, this.config.maxSuggestions)
        .map(tool => this.createSuggestion(tool, 1.0));

      return allSuggestions;
    }

    // Fuzzy search on tool names and descriptions
    const query = context.query.toLowerCase();
    const fuzzySearch = prepareFuzzySearch(query);

    const suggestions: SuggestionItem<ToolSuggestionItem>[] = [];

    for (const tool of tools) {
      // Try fuzzy match on name first (highest priority)
      const nameMatch = fuzzySearch(tool.name);
      if (nameMatch) {
        suggestions.push(this.createSuggestion(tool, nameMatch.score));
        continue;
      }

      // Try fuzzy match on category (medium priority)
      const categoryMatch = fuzzySearch(tool.category);
      if (categoryMatch) {
        suggestions.push(this.createSuggestion(tool, categoryMatch.score * 0.8));
        continue;
      }

      // Try fuzzy match on description (lower priority)
      const descMatch = fuzzySearch(tool.description);
      if (descMatch) {
        suggestions.push(this.createSuggestion(tool, descMatch.score * 0.6));
      }
    }

    // Sort by score and limit
    return this.limitSuggestions(this.sortByScore(suggestions));
  }

  /**
   * Render tool suggestion in dropdown
   * @param item - Tool suggestion item
   * @param el - HTML element to populate
   */
  renderSuggestion(
    item: SuggestionItem<ToolSuggestionItem>,
    el: HTMLElement
  ): void {
    el.addClass('suggester-item', 'tool-suggester-item');

    // Icon
    const icon = el.createDiv({ cls: 'suggester-icon' });
    setIcon(icon, 'wrench');

    // Content container
    const content = el.createDiv({ cls: 'suggester-content' });

    // Tool name (primary text)
    const name = content.createDiv({ cls: 'suggester-title' });
    name.textContent = item.data.name;

    // Description (secondary text)
    const desc = content.createDiv({ cls: 'suggester-description' });
    desc.textContent = item.data.description;

    // Badge container
    const badgeContainer = el.createDiv({ cls: 'suggester-badge-container' });

    // Category badge
    const categoryBadge = badgeContainer.createSpan({ cls: 'suggester-badge category-badge' });
    categoryBadge.textContent = item.data.category;
  }

  /**
   * Handle tool selection
   * @param item - Selected tool
   * @param evt - Selection event
   */
  selectSuggestion(
    item: SuggestionItem<ToolSuggestionItem>,
    evt: MouseEvent | KeyboardEvent
  ): void {

    if (!this.context) return;

    const { editor, start, end } = this.context;

    // Create tool hint
    const toolHint: ToolHint = {
      name: item.data.name,
      schema: item.data.schema
    };

    // Add to message enhancer
    this.messageEnhancer.addTool(toolHint);

    // Replace / command with cleaned text (remove slash)
    // User intent is clear from the tool hint, so just leave the rest of the message
    editor.replaceRange(
      '', // Remove the /command part
      start,
      end
    );

    // Keep cursor at same position (slash is removed)
    editor.setCursor(start);
  }

  /**
   * Estimate tokens for a tool schema
   * @param item - Tool data
   * @returns Estimated token count
   */
  protected estimateItemTokens(item: ToolSuggestionItem): number {
    // Tool schemas are typically ~150 tokens
    return 150;
  }

  // ==========================================================================
  // Helper Methods
  // ==========================================================================

  /**
   * Convert raw tool data to ToolSuggestionItem
   * @param tool - Raw tool from ToolListService
   * @returns ToolSuggestionItem
   */
  private convertToToolItem(tool: any): ToolSuggestionItem {
    // Extract category from tool name (e.g., "storageManager.list" -> "storageManager")
    const parts = tool.name.split('.');
    const category = parts.length > 1 ? parts[0] : 'general';

    return {
      name: tool.name,
      description: tool.description,
      category: category,
      schema: {
        name: tool.name,
        description: tool.description,
        inputSchema: tool.inputSchema
      }
    };
  }

  /**
   * Create suggestion item from ToolSuggestionItem
   * @param tool - Tool data
   * @param score - Match score
   * @returns Suggestion item
   */
  private createSuggestion(
    tool: ToolSuggestionItem,
    score: number
  ): SuggestionItem<ToolSuggestionItem> {

    return {
      data: tool,
      score: score,
      displayText: tool.name,
      description: tool.description,
      tokens: 150 // Standard tool schema size
    };
  }

  /**
   * Refresh tool cache (call when tools may have changed)
   */
  refreshCache(): void {
    this.clearCacheEntry('tools');
  }
}

```

## ui/chat/components/suggesters/WorkspaceSuggester.ts

```typescript
/**
 * WorkspaceSuggester - Provides autocomplete for #workspace mentions
 * Triggers on # and suggests workspaces with fuzzy search
 */

import { App, prepareFuzzySearch, setIcon } from 'obsidian';
import { BaseSuggester } from './base/BaseSuggester';
import {
  SuggestionItem,
  EditorSuggestContext,
  WorkspaceSuggestionItem,
  WorkspaceReference,
  EnhancementType
} from './base/SuggesterInterfaces';
import { MessageEnhancer } from '../../services/MessageEnhancer';
import { WorkspaceService } from '../../../../services/WorkspaceService';

/**
 * Workspace suggester for # mention autocomplete
 */
export class WorkspaceSuggester extends BaseSuggester<WorkspaceSuggestionItem> {

  private messageEnhancer: MessageEnhancer;
  private workspaceService: WorkspaceService;

  constructor(
    app: App,
    messageEnhancer: MessageEnhancer,
    workspaceService: WorkspaceService
  ) {
    super(app, {
      // Matches # followed by word characters
      trigger: /#(\w*)$/,
      maxSuggestions: 20,
      cacheTTL: 30000, // 30 seconds
      debounceDelay: 100
    });

    this.messageEnhancer = messageEnhancer;
    this.workspaceService = workspaceService;
  }

  // ==========================================================================
  // Abstract Method Implementations
  // ==========================================================================

  /**
   * Get workspace suggestions with fuzzy search
   * @param context - Editor context with query
   * @returns Filtered and ranked workspace suggestions
   */
  async getSuggestions(
    context: EditorSuggestContext
  ): Promise<SuggestionItem<WorkspaceSuggestionItem>[]> {

    // Get workspaces sorted by last accessed
    const workspaces = await this.workspaceService.listWorkspaces();

    if (workspaces.length === 0) {
      return [];
    }

    // If no query, return all workspaces (sorted by last accessed)
    if (!context.query || context.query.trim().length === 0) {
      const allSuggestions = workspaces
        .slice(0, this.config.maxSuggestions)
        .map(workspace => this.createSuggestion(workspace, 1.0));

      return allSuggestions;
    }

    // Fuzzy search on workspace names and descriptions
    const query = context.query.toLowerCase();
    const fuzzySearch = prepareFuzzySearch(query);

    const suggestions: SuggestionItem<WorkspaceSuggestionItem>[] = [];

    for (const workspace of workspaces) {
      // Try fuzzy match on name first (higher priority)
      const nameMatch = fuzzySearch(workspace.name);
      if (nameMatch) {
        suggestions.push(this.createSuggestion(workspace, nameMatch.score));
        continue;
      }

      // Try fuzzy match on description (lower priority)
      if (workspace.description) {
        const descMatch = fuzzySearch(workspace.description);
        if (descMatch) {
          suggestions.push(this.createSuggestion(workspace, descMatch.score * 0.7));
        }
      }
    }

    // Sort by score and limit
    return this.limitSuggestions(this.sortByScore(suggestions));
  }

  /**
   * Render workspace suggestion in dropdown
   * @param item - Workspace suggestion item
   * @param el - HTML element to populate
   */
  renderSuggestion(
    item: SuggestionItem<WorkspaceSuggestionItem>,
    el: HTMLElement
  ): void {
    el.addClass('suggester-item', 'workspace-suggester-item');

    // Icon
    const icon = el.createDiv({ cls: 'suggester-icon' });
    setIcon(icon, 'folder-tree');

    // Content container
    const content = el.createDiv({ cls: 'suggester-content' });

    // Workspace name (primary text)
    const name = content.createDiv({ cls: 'suggester-title' });
    name.textContent = item.data.name;

    // Description or root folder (secondary text)
    const desc = content.createDiv({ cls: 'suggester-description' });
    desc.textContent = item.data.description || item.data.rootFolder;
  }

  /**
   * Handle workspace selection
   * @param item - Selected workspace
   * @param evt - Selection event
   */
  selectSuggestion(
    item: SuggestionItem<WorkspaceSuggestionItem>,
    evt: MouseEvent | KeyboardEvent
  ): void {

    const context = this.context;
    if (!context) return;

    const { editor, start, end } = context;

    // Create workspace reference
    const workspaceRef: WorkspaceReference = {
      id: item.data.id,
      name: item.data.name,
      description: item.data.description,
      rootFolder: item.data.rootFolder
    };

    // Add to message enhancer
    this.messageEnhancer.addWorkspace(workspaceRef);

    // Replace # mention with workspace name (in format that's clear to user)
    const replacement = `#${item.data.name.replace(/\s+/g, '_')}`;

    // Replace text in editor
    editor.replaceRange(
      replacement + ' ', // Add space after for better UX
      start,
      end
    );

    // Move cursor after the mention
    const newCursor = {
      line: start.line,
      ch: start.ch + replacement.length + 1
    };
    editor.setCursor(newCursor);
  }

  // ==========================================================================
  // Helper Methods
  // ==========================================================================

  /**
   * Create suggestion item from workspace metadata
   * @param workspace - Workspace metadata
   * @param score - Match score
   * @returns Suggestion item
   */
  private createSuggestion(
    workspace: { id: string; name: string; description?: string; rootFolder: string; lastAccessed: number },
    score: number
  ): SuggestionItem<WorkspaceSuggestionItem> {

    return {
      data: {
        id: workspace.id,
        name: workspace.name,
        description: workspace.description,
        rootFolder: workspace.rootFolder,
        lastAccessed: workspace.lastAccessed
      },
      score: score,
      displayText: workspace.name,
      description: workspace.description || workspace.rootFolder
    };
  }

  /**
   * Estimate tokens for a workspace item
   * @param item - Workspace suggestion item
   * @returns Estimated token count (0 for workspace references)
   */
  protected estimateItemTokens(item: WorkspaceSuggestionItem): number {
    // Workspace references don't directly add tokens until context is loaded
    // Token estimation will happen when the full workspace is loaded
    return 0;
  }

  /**
   * Refresh cache when workspaces are modified
   */
  refreshCache(): void {
    this.clearCache();
  }
}

```

## ui/chat/controllers/MessageEditController.ts

```typescript
/**
 * MessageEditController - Manages message edit mode functionality
 * Location: /src/ui/chat/controllers/MessageEditController.ts
 *
 * This class is responsible for:
 * - Entering edit mode with textarea interface
 * - Managing edit controls (save/cancel)
 * - Handling keyboard shortcuts (ESC to cancel)
 * - Exiting edit mode and restoring original content
 *
 * Used by MessageBubble to enable editing of user messages,
 * following the Controller pattern for state management.
 */

import { ConversationMessage } from '../../../types/chat/ChatTypes';
import { Component } from 'obsidian';

export class MessageEditController {
  /**
   * Enter edit mode for a message
   */
  static handleEdit(
    message: ConversationMessage,
    element: HTMLElement | null,
    onEdit: (messageId: string, newContent: string) => void,
    component?: Component
  ): void {
    if (!element) return;

    const contentDiv = element.querySelector('.message-bubble .message-content');
    if (!contentDiv) return;

    // Create textarea for editing
    const textarea = document.createElement('textarea');
    textarea.className = 'message-edit-textarea';
    textarea.value = message.content;

    // Create edit controls
    const editControls = document.createElement('div');
    editControls.className = 'message-edit-controls';

    const saveBtn = editControls.createEl('button', {
      text: 'Save',
      cls: 'message-edit-save'
    });

    const cancelBtn = editControls.createEl('button', {
      text: 'Cancel',
      cls: 'message-edit-cancel'
    });

    // Store original content
    const originalContent = contentDiv.innerHTML;

    // Replace content with edit interface
    contentDiv.empty();
    contentDiv.appendChild(textarea);
    contentDiv.appendChild(editControls);

    // Focus textarea
    textarea.focus();

    // Save handler
    const saveHandler = () => {
      const newContent = textarea.value.trim();
      if (newContent && newContent !== message.content) {
        onEdit(message.id, newContent);
      }
      MessageEditController.exitEditMode(contentDiv, originalContent);
    };

    // Cancel handler
    const cancelHandler = () => {
      MessageEditController.exitEditMode(contentDiv, originalContent);
    };

    // ESC key handler
    const keydownHandler = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        MessageEditController.exitEditMode(contentDiv, originalContent);
      }
    };

    component!.registerDomEvent(saveBtn, 'click', saveHandler);
    component!.registerDomEvent(cancelBtn, 'click', cancelHandler);
    component!.registerDomEvent(textarea, 'keydown', keydownHandler);
  }

  /**
   * Exit edit mode and restore original content
   */
  static exitEditMode(contentDiv: Element, originalContent: string): void {
    contentDiv.innerHTML = originalContent;
  }
}

```

## ui/chat/controllers/NexusLoadingController.ts

```typescript
/**
 * NexusLoadingController - Handles Nexus/WebLLM loading overlay logic
 * Location: /src/ui/chat/controllers/NexusLoadingController.ts
 *
 * Manages the loading overlay for Nexus model loading and database initialization.
 * Extracted from ChatView.ts to follow Single Responsibility Principle.
 */

import { Component } from 'obsidian';

/**
 * Controller for Nexus/WebLLM and database loading overlays
 */
export class NexusLoadingController extends Component {
  private overlayEl: HTMLElement | null = null;

  constructor(private containerEl: HTMLElement) {
    super();
    this.findOverlayElement();
  }

  /**
   * Find the loading overlay element in the container
   */
  private findOverlayElement(): void {
    this.overlayEl = this.containerEl.querySelector('.chat-loading-overlay') as HTMLElement;
  }

  /**
   * Show the Nexus model loading overlay
   */
  showNexusLoadingOverlay(): void {
    if (!this.overlayEl) return;

    this.overlayEl.addClass('chat-loading-overlay-visible');
    // Trigger reflow for animation
    this.overlayEl.offsetHeight;
    this.overlayEl.addClass('is-visible');
  }

  /**
   * Update Nexus loading progress
   */
  updateNexusLoadingProgress(progress: number, stage: string): void {
    if (!this.overlayEl) return;

    const statusEl = this.overlayEl.querySelector('[data-status-el]');
    const progressBar = this.overlayEl.querySelector('[data-progress-el]') as HTMLElement;
    const progressText = this.overlayEl.querySelector('[data-progress-text-el]');

    const percent = Math.round(progress * 100);

    if (statusEl) {
      statusEl.textContent = stage || 'Loading Nexus model...';
    }

    if (progressBar) {
      progressBar.style.setProperty('width', `${percent}%`);
    }

    if (progressText) {
      progressText.textContent = `${percent}%`;
    }
  }

  /**
   * Hide the Nexus model loading overlay
   */
  hideNexusLoadingOverlay(): void {
    if (!this.overlayEl) return;

    this.overlayEl.removeClass('is-visible');

    // Wait for transition then hide
    setTimeout(() => {
      this.overlayEl!.removeClass('chat-loading-overlay-visible');
      this.overlayEl!.addClass('chat-loading-overlay-hidden');

      // Reset progress
      const progressBar = this.overlayEl!.querySelector('[data-progress-el]') as HTMLElement;
      const progressText = this.overlayEl!.querySelector('[data-progress-text-el]');
      const statusEl = this.overlayEl!.querySelector('[data-status-el]');

      if (progressBar) progressBar.addClass('chat-progress-bar-reset');
      if (progressText) progressText.textContent = '0%';
      if (statusEl) statusEl.textContent = 'Loading Nexus model...';
    }, 300);
  }

  /**
   * Show database loading overlay
   */
  showDatabaseLoadingOverlay(): void {
    if (!this.overlayEl) return;

    // Update text for database loading
    const statusEl = this.overlayEl.querySelector('[data-status-el]');
    if (statusEl) statusEl.textContent = 'Loading database...';

    this.overlayEl.addClass('chat-loading-overlay-visible');
    this.overlayEl.offsetHeight; // Trigger reflow
    this.overlayEl.addClass('is-visible');
  }

  /**
   * Hide database loading overlay
   */
  hideDatabaseLoadingOverlay(): void {
    if (!this.overlayEl) return;

    this.overlayEl.removeClass('is-visible');
    setTimeout(() => {
      this.overlayEl!.removeClass('chat-loading-overlay-visible');
      this.overlayEl!.addClass('chat-loading-overlay-hidden');
      // Reset text for potential Nexus loading later
      const statusEl = this.overlayEl!.querySelector('[data-status-el]');
      if (statusEl) statusEl.textContent = 'Loading Nexus model...';
    }, 300);
  }

  /**
   * Wait for database to be ready, showing loading overlay if needed
   *
   * @param storageAdapter Storage adapter with isReady() and waitForReady() methods
   */
  async waitForDatabaseReady(storageAdapter: {
    isReady?: () => boolean;
    waitForReady?: () => Promise<boolean>;
  }): Promise<void> {
    if (!storageAdapter) return;

    try {
      // If already ready, no need to show overlay
      if (storageAdapter.isReady?.()) {
        return;
      }

      // Show loading overlay while waiting
      this.showDatabaseLoadingOverlay();

      // Wait for database to be ready
      await storageAdapter.waitForReady?.();

      // Hide overlay
      this.hideDatabaseLoadingOverlay();
    } catch (error) {
      this.hideDatabaseLoadingOverlay();
    }
  }

  /**
   * Clean up resources
   */
  onunload(): void {
    this.overlayEl = null;
  }
}

```

## ui/chat/controllers/StreamingController.ts

```typescript
/**
 * StreamingController - Handles all streaming-related UI updates and animations
 * Now with streaming-markdown integration for progressive markdown rendering
 *
 * ARCHITECTURE NOTE:
 * This controller manages ONLY ephemeral UI animation state:
 * - Loading dot animations (activeAnimations)
 * - Streaming-markdown parser state (streamingStates)
 *
 * It does NOT maintain message lifecycle state (draft/streaming/complete/etc).
 * Message lifecycle state is managed by MessageManager and stored in the
 * message objects themselves. This controller is called by ChatView when
 * streaming events occur, and it updates the UI accordingly.
 *
 * State separation:
 * - Message state (draft/streaming/complete) â†’ MessageManager + Storage
 * - UI animation state (dots, parser) â†’ StreamingController (ephemeral)
 */

import { MarkdownRenderer } from '../utils/MarkdownRenderer';
import { App, Component } from 'obsidian';
import type { StreamingState, ElementWithLoadingInterval } from '../types/streaming';

export interface StreamingControllerEvents {
  onAnimationStarted: (messageId: string) => void;
  onAnimationStopped: (messageId: string) => void;
}

export class StreamingController {
  private activeAnimations = new Map<string, NodeJS.Timeout>(); // messageId -> intervalId
  private streamingStates = new Map<string, StreamingState>(); // messageId -> streaming-markdown state

  constructor(
    private containerEl: HTMLElement,
    private app: App,
    private component: Component,
    private events?: StreamingControllerEvents
  ) {}

  /**
   * Show loading animation for AI response
   */
  showAILoadingState(messageId: string): void {
    // Find the message element and add loading animation
    const messageElement = this.containerEl.querySelector(`[data-message-id="${messageId}"]`);
    if (messageElement) {
      const contentElement = messageElement.querySelector('.message-bubble .message-content');
      if (contentElement) {
        contentElement.empty();
        const loadingSpan = contentElement.createEl('span', { cls: 'ai-loading' });
        loadingSpan.appendText('Thinking');
        loadingSpan.createEl('span', { cls: 'dots', text: '...' });
        this.startLoadingAnimation(contentElement);
      }
    }
  }

  /**
   * Start streaming for a message (initialize streaming-markdown parser)
   */
  startStreaming(messageId: string): void {
    const messageElement = this.containerEl.querySelector(`[data-message-id="${messageId}"]`);
    const contentElement = messageElement?.querySelector('.message-bubble .message-content');

    if (messageElement && contentElement) {
      // Stop loading animation
      this.stopLoadingAnimation(contentElement);

      // Initialize streaming-markdown parser for this message
      const streamingState = MarkdownRenderer.initializeStreamingParser(contentElement as HTMLElement);
      this.streamingStates.set(messageId, streamingState);
    }
  }

  /**
   * Update streaming message with new chunk (progressive rendering)
   */
  updateStreamingChunk(messageId: string, chunk: string): void {
    const streamingState = this.streamingStates.get(messageId);

    if (streamingState) {
      MarkdownRenderer.writeStreamingChunk(streamingState, chunk);
    } else {
      // Initialize streaming if we missed the start
      this.startStreaming(messageId);
      // Try again
      const newStreamingState = this.streamingStates.get(messageId);
      if (newStreamingState) {
        MarkdownRenderer.writeStreamingChunk(newStreamingState, chunk);
      }
    }
  }

  /**
   * Finalize streaming for a message (switch to final Obsidian rendering if needed)
   */
  finalizeStreaming(messageId: string, finalContent: string): void {
    const streamingState = this.streamingStates.get(messageId);
    const messageElement = this.containerEl.querySelector(`[data-message-id="${messageId}"]`);
    
    if (streamingState && messageElement) {
      const contentElement = messageElement.querySelector('.message-bubble .message-content');

      if (contentElement) {
        MarkdownRenderer.finalizeStreamingContent(
          streamingState,
          finalContent,
          contentElement as HTMLElement,
          this.app,
          this.component
        ).then(() => {
          // Clean up streaming state
          this.streamingStates.delete(messageId);
        }).catch(error => {
          console.error('[StreamingController] Error finalizing streaming:', error);
          // Clean up anyway
          this.streamingStates.delete(messageId);
        });
      }
    }
  }

  /**
   * Start loading animation (animated dots)
   */
  startLoadingAnimation(element: Element): void {
    const dotsElement = element.querySelector('.dots');
    if (dotsElement) {
      let dotCount = 0;
      const interval = setInterval(() => {
        dotCount = (dotCount + 1) % 4;
        dotsElement.textContent = '.'.repeat(dotCount);
      }, 500);
      
      // Store interval ID for cleanup
      const messageId = this.getMessageIdFromElement(element);
      if (messageId) {
        this.activeAnimations.set(messageId, interval);
        this.events?.onAnimationStarted(messageId);
      }

      // Also store on element for backward compatibility
      (element as ElementWithLoadingInterval)._loadingInterval = interval;
    }
  }

  /**
   * Stop loading animation
   */
  stopLoadingAnimation(element: Element): void {
    // Clean up from element storage (backward compatibility)
    const elementWithInterval = element as ElementWithLoadingInterval;
    const elementInterval = elementWithInterval._loadingInterval;
    if (elementInterval) {
      clearInterval(elementInterval);
      delete elementWithInterval._loadingInterval;
    }

    // Clean up from our tracking
    const messageId = this.getMessageIdFromElement(element);
    if (messageId) {
      const interval = this.activeAnimations.get(messageId);
      if (interval) {
        clearInterval(interval);
        this.activeAnimations.delete(messageId);
        this.events?.onAnimationStopped(messageId);
      }
    }
  }

  /**
   * Stop all active animations
   */
  stopAllAnimations(): void {
    this.activeAnimations.forEach((interval, messageId) => {
      clearInterval(interval);
      this.events?.onAnimationStopped(messageId);
    });
    this.activeAnimations.clear();
  }

  /**
   * Remove loading message from UI
   */
  removeLoadingMessage(messageId: string): void {
    const messageElement = this.containerEl.querySelector(`[data-message-id="${messageId}"]`);
    if (messageElement) {
      // Stop any active animation for this message
      const contentElement = messageElement.querySelector('.message-bubble .message-content');
      if (contentElement) {
        this.stopLoadingAnimation(contentElement);
      }
      
      // Remove the message element
      messageElement.remove();
    }

    // Clean up from our tracking
    const interval = this.activeAnimations.get(messageId);
    if (interval) {
      clearInterval(interval);
      this.activeAnimations.delete(messageId);
    }
  }

  /**
   * Get message ID from an element by traversing up the DOM
   */
  private getMessageIdFromElement(element: Element): string | null {
    let current = element as Element | null;
    while (current) {
      const messageId = current.getAttribute('data-message-id');
      if (messageId) {
        return messageId;
      }
      current = current.parentElement;
    }
    return null;
  }

  /**
   * Escape HTML for safe display
   */
  private escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Get active animation count (for debugging/monitoring)
   */
  getActiveAnimationCount(): number {
    return this.activeAnimations.size;
  }

  /**
   * Cleanup all resources
   */
  cleanup(): void {
    this.stopAllAnimations();
    // Clean up streaming states
    this.streamingStates.clear();
  }
}
```

## ui/chat/controllers/SubagentController.ts

```typescript
/**
 * SubagentController - Manages subagent infrastructure and lifecycle
 * Location: /src/ui/chat/controllers/SubagentController.ts
 *
 * Extracted from ChatView to follow Single Responsibility Principle.
 * Owns SubagentExecutor, BranchService, MessageQueueService and coordinates
 * their initialization and event handling.
 *
 * ARCHITECTURE NOTE (Dec 2025):
 * A branch IS a conversation with parent metadata. SubagentController creates
 * branch conversations for subagents and coordinates their execution.
 */

import { App, Component } from 'obsidian';
import { BranchService } from '../../../services/chat/BranchService';
import { MessageQueueService } from '../../../services/chat/MessageQueueService';
import { SubagentExecutor } from '../../../services/chat/SubagentExecutor';
import { AgentStatusMenu, createSubagentEventHandlers, getSubagentEventBus } from '../components/AgentStatusMenu';
import { AgentStatusModal } from '../components/AgentStatusModal';
import type { ChatService } from '../../../services/chat/ChatService';
import type { DirectToolExecutor } from '../../../services/chat/DirectToolExecutor';
import type { PromptManagerAgent } from '../../../agents/promptManager/promptManager';
import type { HybridStorageAdapter } from '../../../database/adapters/HybridStorageAdapter';
import type { LLMService } from '../../../services/llm/core/LLMService';
import type { ToolSchemaInfo, AgentStatusItem, BranchViewContext } from '../../../types/branch/BranchTypes';
import type { ConversationData } from '../../../types/chat/ChatTypes';
import type { StreamingController } from './StreamingController';
import type { ToolEventCoordinator } from '../coordinators/ToolEventCoordinator';
import { isSubagentMetadata } from '../../../types/branch/BranchTypes';

/**
 * Dependencies for SubagentController initialization
 */
export interface SubagentControllerDependencies {
  app: App;
  chatService: ChatService;
  directToolExecutor: DirectToolExecutor;
  promptManagerAgent: PromptManagerAgent;
  storageAdapter: HybridStorageAdapter;
  llmService: LLMService;
}

/**
 * Context provider for subagent execution
 * Returns current conversation and model settings
 */
export interface SubagentContextProvider {
  getCurrentConversation: () => ConversationData | null;
  getSelectedModel: () => { providerId?: string; modelId?: string } | null;
  getSelectedPrompt: () => { name?: string; systemPrompt?: string } | null;
  getLoadedWorkspaceData: () => any;
  getContextNotes: () => string[];
  getThinkingSettings: () => { enabled?: boolean; effort?: 'low' | 'medium' | 'high' } | null;
  getSelectedWorkspaceId: () => string | null;
}

/**
 * Events emitted by SubagentController
 */
export interface SubagentControllerEvents {
  onStreamingUpdate: (branchId: string, messageId: string, chunk: string, isComplete: boolean, fullContent: string) => void;
  onToolCallsDetected: (branchId: string, messageId: string, toolCalls: any[]) => void;
  onStatusChanged: () => void;
  onConversationNeedsRefresh?: (conversationId: string) => void;
}

export class SubagentController {
  private branchService: BranchService | null = null;
  private messageQueueService: MessageQueueService | null = null;
  private subagentExecutor: SubagentExecutor | null = null;
  private agentStatusMenu: AgentStatusMenu | null = null;

  private currentBranchContext: BranchViewContext | null = null;
  private initialized = false;
  private navigationCallback: ((branchId: string) => void) | null = null;
  private continueCallback: ((branchId: string) => void) | null = null;

  constructor(
    private app: App,
    private component: Component,
    private events: SubagentControllerEvents
  ) {}

  /**
   * Set navigation callbacks (called by ChatView after initialization)
   */
  setNavigationCallbacks(callbacks: {
    onNavigateToBranch: (branchId: string) => void;
    onContinueAgent: (branchId: string) => void;
  }): void {
    console.log('[SUBAGENT-DEBUG] setNavigationCallbacks called');
    this.navigationCallback = callbacks.onNavigateToBranch;
    this.continueCallback = callbacks.onContinueAgent;
  }

  /**
   * Initialize subagent infrastructure
   * This is async and non-blocking - subagent features available once complete
   */
  async initialize(
    deps: SubagentControllerDependencies,
    contextProvider: SubagentContextProvider,
    streamingController: StreamingController,
    toolEventCoordinator: ToolEventCoordinator,
    settingsButtonContainer?: HTMLElement,
    settingsButton?: HTMLElement
  ): Promise<void> {
    if (this.initialized) return;

    try {
      // Create BranchService with ConversationService (unified model)
      // BranchService is now a facade over ConversationService
      const conversationService = deps.chatService.getConversationService();
      this.branchService = new BranchService({
        conversationService,
      });

      // Create MessageQueueService with processor
      this.messageQueueService = new MessageQueueService();
      this.setupMessageQueueProcessor(deps.chatService, contextProvider);

      // Create SubagentExecutor
      this.subagentExecutor = new SubagentExecutor({
        branchService: this.branchService,
        messageQueueService: this.messageQueueService,
        directToolExecutor: deps.directToolExecutor,
        streamingGenerator: this.createStreamingGenerator(deps.llmService, deps.directToolExecutor),
        getToolSchemas: this.createToolSchemaFetcher(deps.directToolExecutor),
      });

      // Set event handlers
      this.setupEventHandlers(streamingController, toolEventCoordinator);

      // Wire up to PromptManagerAgent
      deps.promptManagerAgent.setSubagentExecutor(
        this.subagentExecutor,
        () => this.buildSubagentContext(contextProvider)
      );

      // Initialize status menu if container provided
      if (settingsButtonContainer && settingsButton) {
        this.agentStatusMenu = new AgentStatusMenu(
          settingsButtonContainer,
          this.subagentExecutor,
          { onOpenModal: () => this.openAgentStatusModal(contextProvider) },
          this.component,
          settingsButton
        );
        this.agentStatusMenu.render();
      }

      this.initialized = true;
    } catch (error) {
      console.error('[SubagentController] Failed to initialize:', error);
      throw error;
    }
  }

  /**
   * Set up the message queue processor for subagent results
   */
  private setupMessageQueueProcessor(
    chatService: ChatService,
    contextProvider: SubagentContextProvider
  ): void {
    if (!this.messageQueueService) return;

    this.messageQueueService.setProcessor(async (message) => {
      console.log('[SUBAGENT-DEBUG] Processor received message:', { type: message.type, hasContent: !!message.content });
      if (message.type !== 'subagent_result') {
        console.log('[SUBAGENT-DEBUG] Skipping non-subagent message');
        return;
      }

      try {
        const result = JSON.parse(message.content || '{}');
        const metadata = message.metadata || {};
        console.log('[SUBAGENT-DEBUG] Parsed result:', { success: result.success, metadata });

        const conversationId = metadata.conversationId;
        if (!conversationId) {
          console.error('[SUBAGENT-DEBUG] No conversationId in metadata, aborting');
          return;
        }

        // Format result for display
        const taskLabel = metadata.subagentTask || 'Task';
        const resultContent = result.success
          ? `[Subagent "${taskLabel}" completed]\n\nResult:\n${result.result || 'Task completed successfully.'}`
          : `[Subagent "${taskLabel}" ${result.status === 'max_iterations' ? 'paused (max iterations)' : 'failed'}]\n\n${result.error || 'Unknown error'}`;

        // Check if viewing parent conversation
        const currentConversation = contextProvider.getCurrentConversation();
        const isViewingParent = currentConversation?.id === conversationId && !this.currentBranchContext;

        // Add result as user message
        console.log('[SUBAGENT-DEBUG] Adding result message to conversation:', conversationId);
        await chatService.addMessage({
          conversationId,
          role: 'user',
          content: resultContent,
          metadata: {
            type: 'subagent_result',
            branchId: metadata.branchId,
            subagentId: metadata.subagentId,
            success: result.success,
            iterations: result.iterations,
            isAutoGenerated: true,
          },
        });
        console.log('[SUBAGENT-DEBUG] Result message added');

        // Trigger LLM response in background
        const parentConversation = await chatService.getConversation(conversationId);
        console.log('[SUBAGENT-DEBUG] Parent conversation loaded:', !!parentConversation);
        if (parentConversation) {
          try {
            console.log('[SUBAGENT-DEBUG] Starting LLM response generation');
            const generator = chatService.generateResponseStreaming(
              parentConversation.id,
              resultContent,
              {}
            );
            for await (const chunk of generator) {
              if (chunk.complete) {
                console.log('[SUBAGENT-DEBUG] LLM response complete');
                break;
              }
            }
            // Notify UI to refresh conversation display
            console.log('[SUBAGENT-DEBUG] Triggering conversation refresh');
            this.events.onConversationNeedsRefresh?.(conversationId);
          } catch (llmError) {
            console.error('[SUBAGENT-DEBUG] LLM response failed:', llmError);
          }
        } else {
          console.error('[SUBAGENT-DEBUG] Could not load parent conversation');
        }
      } catch (error) {
        console.error('[SUBAGENT-DEBUG] Processor error:', error);
      }
    });
  }

  /**
   * Create the streaming generator for SubagentExecutor
   */
  private createStreamingGenerator(
    llmService: LLMService,
    directToolExecutor: DirectToolExecutor
  ) {
    return async function* (
      messages: any[],
      options: {
        provider?: string;
        model?: string;
        systemPrompt?: string;
        abortSignal?: AbortSignal;
        workspaceId?: string;
        sessionId?: string;
      }
    ) {
      try {
        const tools = await directToolExecutor.getAvailableTools();
        const streamOptions = {
          provider: options?.provider,
          model: options?.model,
          systemPrompt: options?.systemPrompt,
          sessionId: options?.sessionId,
          workspaceId: options?.workspaceId,
          tools: tools as any[],
        };

        for await (const chunk of llmService.generateResponseStream(messages, streamOptions)) {
          if (options?.abortSignal?.aborted) return;

          yield {
            chunk: chunk.chunk || '',
            complete: chunk.complete,
            toolCalls: chunk.toolCalls,
            reasoning: chunk.reasoning,
          };
        }
      } catch (error) {
        console.error('[SubagentController] Streaming error:', error);
        throw error;
      }
    };
  }

  /**
   * Create tool schema fetcher for SubagentExecutor
   */
  private createToolSchemaFetcher(directToolExecutor: DirectToolExecutor) {
    return async (agentName: string, toolSlugs: string[]): Promise<ToolSchemaInfo[]> => {
      try {
        const tools = await directToolExecutor.getAvailableTools() as Array<{ name?: string }>;
        return tools.filter(t => t.name && toolSlugs.includes(t.name)) as ToolSchemaInfo[];
      } catch {
        return [];
      }
    };
  }

  /**
   * Set up event handlers for SubagentExecutor
   */
  private setupEventHandlers(
    streamingController: StreamingController,
    toolEventCoordinator: ToolEventCoordinator
  ): void {
    if (!this.subagentExecutor) return;

    const eventHandlers = createSubagentEventHandlers();

    // Track streaming state per message
    let streamingInitialized = false;
    let currentStreamingMessageId = '';

    this.subagentExecutor.setEventHandlers({
      ...eventHandlers,
      onSubagentError: (subagentId: string, error: string) => {
        console.error('[SubagentController] Error:', subagentId, error);
        eventHandlers.onSubagentError?.(subagentId, error);
      },
      onStreamingUpdate: (branchId: string, messageId: string, chunk: string, isComplete: boolean, fullContent: string) => {
        // Only update if viewing this branch
        if (this.currentBranchContext?.branchId !== branchId) return;

        // Reset tracking if message changed
        if (messageId !== currentStreamingMessageId) {
          streamingInitialized = false;
          currentStreamingMessageId = messageId;
        }

        if (!streamingInitialized) {
          streamingController.startStreaming(messageId);
          streamingInitialized = true;
        }

        if (chunk) {
          streamingController.updateStreamingChunk(messageId, chunk);
        }

        if (isComplete) {
          streamingController.finalizeStreaming(messageId, fullContent);
          streamingInitialized = false;
          currentStreamingMessageId = '';
        }

        this.events.onStreamingUpdate(branchId, messageId, chunk, isComplete, fullContent);
      },
      onToolCallsDetected: (branchId: string, messageId: string, toolCalls: any[]) => {
        if (this.currentBranchContext?.branchId !== branchId) return;
        toolEventCoordinator.handleToolCallsDetected(messageId, toolCalls);
        this.events.onToolCallsDetected(branchId, messageId, toolCalls);
      },
    });
  }

  /**
   * Build context for subagent execution from current state
   */
  private buildSubagentContext(contextProvider: SubagentContextProvider) {
    const currentConversation = contextProvider.getCurrentConversation();
    const messages = currentConversation?.messages || [];
    const lastMessage = messages[messages.length - 1];
    const workspaceId = contextProvider.getSelectedWorkspaceId() || undefined;
    const sessionId = currentConversation?.metadata?.chatSettings?.sessionId || undefined;
    const selectedModel = contextProvider.getSelectedModel();
    const selectedPrompt = contextProvider.getSelectedPrompt();
    const workspaceData = contextProvider.getLoadedWorkspaceData();
    const contextNotes = contextProvider.getContextNotes() || [];
    const thinkingSettings = contextProvider.getThinkingSettings();

    return {
      conversationId: currentConversation?.id || 'unknown',
      messageId: lastMessage?.id || 'unknown',
      workspaceId,
      sessionId,
      source: 'internal' as const,
      isSubagentBranch: false,
      provider: selectedModel?.providerId,
      model: selectedModel?.modelId,
      agentPrompt: selectedPrompt?.systemPrompt,
      agentName: selectedPrompt?.name,
      workspaceData,
      contextNotes,
      thinkingEnabled: thinkingSettings?.enabled,
      thinkingEffort: thinkingSettings?.effort,
    };
  }

  /**
   * Get streaming branch messages for live UI updates
   */
  getStreamingBranchMessages(branchId: string) {
    return this.subagentExecutor?.getStreamingBranchMessages(branchId) || null;
  }

  /**
   * Cancel a running subagent
   */
  cancelSubagent(subagentId: string): boolean {
    if (!this.subagentExecutor) return false;
    const cancelled = this.subagentExecutor.cancelSubagent(subagentId);
    if (cancelled) {
      this.agentStatusMenu?.refresh();
    }
    return cancelled;
  }

  /**
   * Get agent status list for UI
   */
  getAgentStatusList(): AgentStatusItem[] {
    return this.subagentExecutor?.getAgentStatusList() || [];
  }

  /**
   * Clear agent status (call when switching conversations)
   */
  clearAgentStatus(): void {
    this.subagentExecutor?.clearAgentStatus();
    getSubagentEventBus().trigger('status-changed');
  }

  /**
   * Set current branch context (for event filtering)
   */
  setCurrentBranchContext(context: BranchViewContext | null): void {
    this.currentBranchContext = context;
  }

  /**
   * Get current branch context
   */
  getCurrentBranchContext(): BranchViewContext | null {
    return this.currentBranchContext;
  }

  /**
   * Update branch header context metadata
   */
  updateBranchHeaderMetadata(subagentId: string, updates: Partial<any>): void {
    const contextMetadata = this.currentBranchContext?.metadata;
    if (isSubagentMetadata(contextMetadata) && contextMetadata.subagentId === subagentId) {
      Object.assign(contextMetadata, updates);
    }
  }

  /**
   * Get branch service (for external queries)
   */
  getBranchService(): BranchService | null {
    return this.branchService;
  }

  /**
   * Get subagent executor (for external queries)
   */
  getSubagentExecutor(): SubagentExecutor | null {
    return this.subagentExecutor;
  }

  /**
   * Open the agent status modal
   */
  private openAgentStatusModal(contextProvider: SubagentContextProvider): void {
    if (!this.subagentExecutor) {
      console.warn('[SubagentController] SubagentExecutor not available');
      return;
    }

    const currentConversation = contextProvider.getCurrentConversation();
    const modal = new AgentStatusModal(
      this.app,
      this.subagentExecutor,
      {
        onViewBranch: (branchId) => {
          console.log('[SubagentController] View branch:', branchId);
          if (this.navigationCallback) {
            this.navigationCallback(branchId);
          } else {
            console.warn('[SubagentController] No navigation callback set');
          }
        },
        onContinueAgent: (branchId) => {
          console.log('[SubagentController] Continue agent:', branchId);
          if (this.continueCallback) {
            this.continueCallback(branchId);
          }
        },
      },
      this.branchService,
      currentConversation?.id ?? null
    );
    modal.open();
  }

  /**
   * Open status modal with custom callbacks
   */
  openStatusModal(
    contextProvider: SubagentContextProvider,
    callbacks: {
      onViewBranch: (branchId: string) => void;
      onContinueAgent: (branchId: string) => void;
    }
  ): void {
    if (!this.subagentExecutor) {
      console.warn('[SubagentController] SubagentExecutor not available');
      return;
    }

    const currentConversation = contextProvider.getCurrentConversation();
    const modal = new AgentStatusModal(
      this.app,
      this.subagentExecutor,
      callbacks,
      this.branchService,
      currentConversation?.id ?? null
    );
    modal.open();
  }

  /**
   * Check if initialized
   */
  isInitialized(): boolean {
    return this.initialized;
  }

  /**
   * Cleanup resources
   */
  cleanup(): void {
    this.agentStatusMenu?.cleanup();
    this.subagentExecutor = null;
    this.branchService = null;
    this.messageQueueService = null;
    this.initialized = false;
  }
}

```

## ui/chat/controllers/UIStateController.ts

```typescript
/**
 * UIStateController - Manages all UI state transitions and visual feedback
 */

import { setIcon, ButtonComponent, Component } from 'obsidian';

export interface UIStateControllerEvents {
  onSidebarToggled: (visible: boolean) => void;
}

export class UIStateController {
  private sidebarVisible = false;
  private onOpenSettings?: () => void;

  constructor(
    private containerEl: HTMLElement,
    private events: UIStateControllerEvents,
    private component?: Component
  ) {}

  /**
   * Set callback for opening settings
   */
  setOpenSettingsCallback(callback: () => void): void {
    this.onOpenSettings = callback;
  }

  /**
   * Get sidebar visibility state
   */
  getSidebarVisible(): boolean {
    return this.sidebarVisible;
  }

  /**
   * Show welcome state when no conversation is selected
   * @param hasConfiguredProviders - Whether any LLM providers are set up
   */
  showWelcomeState(hasConfiguredProviders: boolean = true): void {
    const messageDisplay = this.containerEl.querySelector('.message-display-container');
    if (!messageDisplay) return;

    (messageDisplay as HTMLElement).empty();
    messageDisplay.addClass('message-display');

    const welcome = (messageDisplay as HTMLElement).createDiv('chat-welcome');
    const welcomeContent = welcome.createDiv('chat-welcome-content');

    const welcomeIcon = welcomeContent.createDiv('chat-welcome-icon');

    if (hasConfiguredProviders) {
      // Normal welcome - ready to create conversation
      setIcon(welcomeIcon, 'sparkles');

      welcomeContent.createEl('div', {
        text: 'Welcome to Nexus Chat',
        cls: 'chat-welcome-title'
      });

      welcomeContent.createEl('p', {
        text: 'Your AI assistant for exploring and managing your vault.',
        cls: 'chat-welcome-desc'
      });

      // Hotkey hints in a container
      const hotkeysContainer = welcomeContent.createDiv('chat-welcome-hotkeys-container');
      const hotkeys = hotkeysContainer.createDiv('chat-welcome-hotkeys');

      const hotkeyData = [
        { key: '/', desc: 'Select a tool to use' },
        { key: '@', desc: 'Select an agent to use' },
        { key: '[[', desc: 'Select a note to reference' }
      ];

      hotkeyData.forEach(h => {
        const row = hotkeys.createDiv('chat-welcome-hotkey');
        row.createEl('code', { text: h.key });
        row.createSpan({ text: h.desc });
      });

      welcomeContent.createEl('button', {
        cls: 'chat-welcome-button mod-cta',
        text: 'Start your first conversation'
      });
    } else {
      // Setup needed - no providers configured
      setIcon(welcomeIcon, 'settings');

      welcomeContent.createEl('p', {
        text: 'Configure an LLM provider to start chatting',
        cls: 'chat-welcome-hint'
      });

      const settingsBtn = welcomeContent.createEl('button', {
        cls: 'chat-welcome-button',
        text: 'Open Settings'
      });
      const settingsBtnIcon = settingsBtn.createSpan({ cls: 'chat-welcome-button-icon' });
      setIcon(settingsBtnIcon, 'settings');
      settingsBtn.insertBefore(settingsBtnIcon, settingsBtn.firstChild);
      const settingsHandler = () => {
        if (this.onOpenSettings) {
          this.onOpenSettings();
        }
      };
      this.component!.registerDomEvent(settingsBtn, 'click', settingsHandler);
    }
  }

  /**
   * Show chat state when conversation is selected
   */
  showChatState(): void {
    // Chat state is handled by MessageDisplay component
    // This method exists for state management consistency
  }

  /**
   * Toggle conversation list visibility
   */
  toggleConversationList(): void {
    const sidebar = this.containerEl.querySelector('.chat-sidebar');
    const backdrop = this.containerEl.querySelector('.chat-backdrop');
    if (!sidebar || !backdrop) return;
    
    this.sidebarVisible = !this.sidebarVisible;
    
    if (this.sidebarVisible) {
      sidebar.removeClass('chat-sidebar-hidden');
      sidebar.addClass('chat-sidebar-visible');
      backdrop.addClass('chat-backdrop-visible');
    } else {
      sidebar.removeClass('chat-sidebar-visible');
      sidebar.addClass('chat-sidebar-hidden');
      backdrop.removeClass('chat-backdrop-visible');
    }

    this.events.onSidebarToggled(this.sidebarVisible);
  }

  /**
   * Show error message with auto-dismiss
   */
  showError(message: string): void {
    // Create a temporary error display
    const container = this.containerEl.querySelector('.message-display-container');
    if (container) {
      const errorEl = container.createDiv('chat-error');
      errorEl.textContent = message;
      
      // Auto-remove after 5 seconds
      setTimeout(() => {
        errorEl.remove();
      }, 5000);
    }
  }

  /**
   * Set loading state on chat input
   * Note: ChatInput component now manages its own loading state and stop button
   * This method is kept for backward compatibility but does nothing
   */
  setInputLoading(loading: boolean): void {
    // ChatInput component handles its own state now
    // No-op to avoid conflicts with ChatInput's updateUI()
  }

  /**
   * Set input placeholder text
   */
  setInputPlaceholder(placeholder: string): void {
    const textarea = this.containerEl.querySelector('.chat-textarea') as HTMLTextAreaElement;
    if (textarea) {
      textarea.placeholder = placeholder;
    }
  }

  /**
   * Update context progress display
   */
  updateContextProgress(): void {
    // This will be handled by the ContextProgressBar component
    // Method exists for consistency with the original ChatView interface
  }

  /**
   * Initialize UI event listeners
   */
  initializeEventListeners(): void {
    // Hamburger menu button
    const hamburgerButton = this.containerEl.querySelector('.chat-hamburger-button');
    if (hamburgerButton) {
      const hamburgerHandler = () => this.toggleConversationList();
      this.component!.registerDomEvent(hamburgerButton as HTMLElement, 'click', hamburgerHandler);
    }

    // Backdrop click to close sidebar
    const backdrop = this.containerEl.querySelector('.chat-backdrop');
    if (backdrop) {
      const backdropHandler = () => {
        if (this.sidebarVisible) {
          this.toggleConversationList();
        }
      };
      this.component!.registerDomEvent(backdrop as HTMLElement, 'click', backdropHandler);
    }
  }

  /**
   * Clean up event listeners
   */
  cleanup(): void {
    // Remove event listeners if needed
    // Most listeners are attached to elements that will be removed with the container
  }
}
```

## ui/chat/coordinators/ToolEventCoordinator.ts

```typescript
/**
 * ToolEventCoordinator - Coordinates tool execution events between services and UI
 * Location: /src/ui/chat/coordinators/ToolEventCoordinator.ts
 *
 * This class is responsible for:
 * - Handling tool call detection events
 * - Handling tool execution start events
 * - Handling tool execution completion events
 * - Enriching tool event data with metadata
 * - Extracting and normalizing tool parameters
 *
 * Used by ChatView to coordinate tool events from MessageManager
 * to MessageBubble components, following the Coordinator pattern.
 */

import { getToolNameMetadata } from '../../../utils/toolNameUtils';
import { MessageDisplay } from '../components/MessageDisplay';

export class ToolEventCoordinator {
  constructor(private messageDisplay: MessageDisplay) {}

  /**
   * Handle tool calls detected event
   */
  handleToolCallsDetected(messageId: string, toolCalls: any[]): void {
    const messageBubble = this.messageDisplay.findMessageBubble(messageId);

    if (messageBubble && toolCalls && toolCalls.length > 0) {
      for (const toolCall of toolCalls) {

        const metadata = getToolNameMetadata(
          toolCall.function?.name || toolCall.name
        );

        let parameters = toolCall.parameters || toolCall.arguments;
        if (!parameters && toolCall.function?.arguments) {
          parameters = toolCall.function.arguments;
        }
        if (typeof parameters === 'string') {
          try {
            parameters = JSON.parse(parameters);
          } catch {
            // leave as string if parsing fails
          }
        }

        // Extract the tool call data in the format expected by MessageBubble
        const toolData = {
          id: toolCall.id,
          name: metadata.displayName,
          displayName: metadata.displayName,
          technicalName: metadata.technicalName,
          agentName: metadata.agentName,
          actionName: metadata.actionName,
          rawName: toolCall.function?.name || toolCall.name,
          parameters: parameters,
          isComplete: toolCall.isComplete,
          // Pass through reasoning-specific properties
          type: toolCall.type,
          result: toolCall.result,
          status: toolCall.status,
          isVirtual: toolCall.isVirtual,
          success: toolCall.success
        };

        messageBubble.handleToolEvent('detected', toolData);
      }
    }
  }

  /**
   * Handle tool execution started event
   */
  handleToolExecutionStarted(messageId: string, toolCall: { id: string; name: string; parameters?: any }): void {
    const messageBubble = this.messageDisplay.findMessageBubble(messageId);
    messageBubble?.handleToolEvent('started', toolCall);
  }

  /**
   * Handle tool execution completed event
   */
  handleToolExecutionCompleted(messageId: string, toolId: string, result: any, success: boolean, error?: string): void {
    const messageBubble = this.messageDisplay.findMessageBubble(messageId);
    messageBubble?.handleToolEvent('completed', { toolId, result, success, error });
  }

  /**
   * Handle generic tool event with data enrichment
   */
  handleToolEvent(messageId: string, event: 'detected' | 'updated' | 'started' | 'completed', data: any): void {
    const messageBubble = this.messageDisplay.findMessageBubble(messageId);
    if (!messageBubble) {
      return;
    }

    const enriched = this.enrichToolEventData(data);
    messageBubble.handleToolEvent(event, enriched);
  }

  /**
   * Enrich tool event data with metadata
   */
  private enrichToolEventData(data: any): any {
    if (!data) {
      return data;
    }

    const toolCall = data.toolCall;
    const rawName =
      data.rawName ||
      data.technicalName ||
      data.name ||
      toolCall?.function?.name ||
      toolCall?.name;

    const metadata = getToolNameMetadata(rawName);
    const parameters =
      data.parameters !== undefined
        ? data.parameters
        : this.extractToolParameters(toolCall);

    return {
      ...data,
      name: metadata.displayName,
      displayName: metadata.displayName,
      technicalName: metadata.technicalName,
      agentName: metadata.agentName,
      actionName: metadata.actionName,
      rawName,
      parameters
    };
  }

  /**
   * Extract tool parameters from tool call data
   */
  private extractToolParameters(toolCall: any): any {
    if (!toolCall) {
      return undefined;
    }

    if (toolCall.parameters !== undefined) {
      return toolCall.parameters;
    }

    const raw =
      toolCall.function?.arguments !== undefined
        ? toolCall.function.arguments
        : toolCall.arguments;

    if (raw === undefined) {
      return undefined;
    }

    if (typeof raw === 'string') {
      try {
        return JSON.parse(raw);
      } catch {
        return raw;
      }
    }

    return raw;
  }
}

```

## ui/chat/services/BranchManager.ts

```typescript
/**
 * BranchManager - Handles message-level branching operations
 *
 * Manages creating and switching between branches for individual messages.
 * Works with the unified branch model where both human alternatives and
 * subagent branches share the same data structure.
 *
 * Human branches: inheritContext=true (includes parent context)
 * Subagent branches: inheritContext=false (fresh start)
 */

// import { ConversationRepository } from '../../../database/services/chat/ConversationRepository';
type ConversationRepository = any;
import { ConversationData, ConversationMessage } from '../../../types/chat/ChatTypes';
import type { ConversationBranch, HumanBranchMetadata } from '../../../types/branch/BranchTypes';

export interface BranchManagerEvents {
  onBranchCreated: (messageId: string, branchId: string) => void;
  onBranchSwitched: (messageId: string, branchId: string) => void;
  onError: (message: string) => void;
}

export class BranchManager {
  constructor(
    private conversationRepo: ConversationRepository,
    private events: BranchManagerEvents
  ) {}

  /**
   * Create a human branch (alternative response) for a specific message
   */
  async createHumanBranch(
    conversation: ConversationData,
    messageId: string,
    alternativeResponse: ConversationMessage,
    description?: string
  ): Promise<string | null> {
    try {
      // Find the message in the conversation
      const messageIndex = conversation.messages.findIndex((msg) => msg.id === messageId);
      if (messageIndex === -1) {
        console.error('[BranchManager] Message not found:', messageId);
        return null;
      }

      const message = conversation.messages[messageIndex];

      // Initialize branches array if it doesn't exist
      if (!message.branches) {
        message.branches = [];
      }

      // Create the new branch
      const now = Date.now();
      const branchId = `branch-${now}-${Math.random().toString(36).substring(2, 9)}`;

      const metadata: HumanBranchMetadata = {
        description: description || `Alternative response ${message.branches.length + 1}`,
      };

      const newBranch: ConversationBranch = {
        id: branchId,
        type: 'human',
        inheritContext: true,
        messages: [alternativeResponse],
        created: now,
        updated: now,
        metadata,
      };

      // Add the new branch
      message.branches.push(newBranch);

      // Set the new branch as active
      message.activeAlternativeIndex = message.branches.length; // 1-based (0 = original)

      // Save the updated conversation to repository
      await this.conversationRepo.updateConversation(conversation.id, {
        messages: conversation.messages,
      });

      this.events.onBranchCreated(messageId, branchId);

      return branchId;
    } catch (error) {
      console.error('[BranchManager] Failed to create branch:', error);
      this.events.onError('Failed to create alternative response');
      return null;
    }
  }

  /**
   * Switch to a specific branch by ID
   */
  async switchToBranch(
    conversation: ConversationData,
    messageId: string,
    branchId: string
  ): Promise<boolean> {
    try {
      // Find the message in the conversation
      const messageIndex = conversation.messages.findIndex((msg) => msg.id === messageId);
      if (messageIndex === -1) {
        console.error('[BranchManager] Message not found:', messageId);
        return false;
      }

      const message = conversation.messages[messageIndex];

      // Find the branch index
      if (!message.branches) {
        console.error('[BranchManager] No branches on message:', messageId);
        return false;
      }

      const branchIndex = message.branches.findIndex((b) => b.id === branchId);
      if (branchIndex === -1) {
        console.error('[BranchManager] Branch not found:', branchId);
        return false;
      }

      // Update the active alternative index
      // activeAlternativeIndex: 0 = original, 1+ = branch index + 1
      message.activeAlternativeIndex = branchIndex + 1;

      // Save the updated conversation to repository
      await this.conversationRepo.updateConversation(conversation.id, {
        messages: conversation.messages,
      });

      this.events.onBranchSwitched(messageId, branchId);

      return true;
    } catch (error) {
      console.error('[BranchManager] Failed to switch branch:', error);
      this.events.onError('Failed to switch to branch');
      return false;
    }
  }

  /**
   * Switch to original message (no branch)
   */
  async switchToOriginal(
    conversation: ConversationData,
    messageId: string
  ): Promise<boolean> {
    try {
      const messageIndex = conversation.messages.findIndex((msg) => msg.id === messageId);
      if (messageIndex === -1) {
        return false;
      }

      const message = conversation.messages[messageIndex];
      message.activeAlternativeIndex = 0;

      await this.conversationRepo.updateConversation(conversation.id, {
        messages: conversation.messages,
      });

      this.events.onBranchSwitched(messageId, 'original');
      return true;
    } catch (error) {
      console.error('[BranchManager] Failed to switch to original:', error);
      return false;
    }
  }

  /**
   * Switch to a branch by index (0 = original, 1+ = branch index)
   */
  async switchToBranchByIndex(
    conversation: ConversationData,
    messageId: string,
    index: number
  ): Promise<boolean> {
    if (index === 0) {
      return this.switchToOriginal(conversation, messageId);
    }

    const message = conversation.messages.find((msg) => msg.id === messageId);
    if (!message?.branches) {
      return false;
    }

    const branchIndex = index - 1;
    if (branchIndex < 0 || branchIndex >= message.branches.length) {
      return false;
    }

    return this.switchToBranch(conversation, messageId, message.branches[branchIndex].id);
  }

  /**
   * Get the currently active branch for a message
   */
  getActiveBranch(message: ConversationMessage): ConversationBranch | null {
    const activeIndex = message.activeAlternativeIndex || 0;

    // Index 0 is the original message
    if (activeIndex === 0 || !message.branches) {
      return null;
    }

    const branchIndex = activeIndex - 1;
    if (branchIndex >= 0 && branchIndex < message.branches.length) {
      return message.branches[branchIndex];
    }

    return null;
  }

  /**
   * Get the currently active message content (original or from branch)
   */
  getActiveMessageContent(message: ConversationMessage): string {
    const branch = this.getActiveBranch(message);
    if (branch && branch.messages.length > 0) {
      // Return the last message content from the branch
      return branch.messages[branch.messages.length - 1].content;
    }
    return message.content;
  }

  /**
   * Get the currently active message tool calls
   */
  getActiveMessageToolCalls(message: ConversationMessage): any[] | undefined {
    const branch = this.getActiveBranch(message);
    if (branch && branch.messages.length > 0) {
      return branch.messages[branch.messages.length - 1].toolCalls;
    }
    return message.toolCalls;
  }

  /**
   * Get the currently active message reasoning
   */
  getActiveMessageReasoning(message: ConversationMessage): string | undefined {
    const branch = this.getActiveBranch(message);
    if (branch && branch.messages.length > 0) {
      return branch.messages[branch.messages.length - 1].reasoning;
    }
    return message.reasoning;
  }

  /**
   * Get branch navigation info for a message
   */
  getBranchInfo(message: ConversationMessage): {
    current: number;
    total: number;
    hasBranches: boolean;
    activeBranchId?: string;
    activeBranchType?: 'human' | 'subagent';
  } {
    const activeIndex = message.activeAlternativeIndex || 0;
    const branchCount = message.branches?.length || 0;
    const total = branchCount + 1; // +1 for original

    const branch = this.getActiveBranch(message);

    return {
      current: activeIndex + 1, // 1-based for display
      total,
      hasBranches: branchCount > 0,
      activeBranchId: branch?.id,
      activeBranchType: branch?.type,
    };
  }

  /**
   * Check if a message has any branches
   */
  hasBranches(message: ConversationMessage): boolean {
    return (message.branches?.length || 0) > 0;
  }

  /**
   * Get all branches for a message
   */
  getBranches(message: ConversationMessage): ConversationBranch[] {
    return message.branches || [];
  }

  /**
   * Get branch by ID from a message
   */
  getBranchById(message: ConversationMessage, branchId: string): ConversationBranch | null {
    if (!message.branches) {
      return null;
    }
    return message.branches.find((b) => b.id === branchId) || null;
  }

  /**
   * Check if any branch on a message is a subagent branch
   */
  hasSubagentBranches(message: ConversationMessage): boolean {
    if (!message.branches) {
      return false;
    }
    return message.branches.some((b) => b.type === 'subagent');
  }

  /**
   * Get only subagent branches for a message
   */
  getSubagentBranches(message: ConversationMessage): ConversationBranch[] {
    if (!message.branches) {
      return [];
    }
    return message.branches.filter((b) => b.type === 'subagent');
  }

  /**
   * Get only human branches for a message
   */
  getHumanBranches(message: ConversationMessage): ConversationBranch[] {
    if (!message.branches) {
      return [];
    }
    return message.branches.filter((b) => b.type === 'human');
  }

  /**
   * Navigate to previous branch/original
   */
  getPreviousIndex(message: ConversationMessage): number | null {
    const currentIndex = message.activeAlternativeIndex || 0;
    return currentIndex > 0 ? currentIndex - 1 : null;
  }

  /**
   * Navigate to next branch
   */
  getNextIndex(message: ConversationMessage): number | null {
    const currentIndex = message.activeAlternativeIndex || 0;
    const total = (message.branches?.length || 0) + 1;
    return currentIndex < total - 1 ? currentIndex + 1 : null;
  }
}

```

## ui/chat/services/ContextNotesManager.ts

```typescript
/**
 * ContextNotesManager - Manages context notes for chat conversations
 *
 * Responsibilities:
 * - Maintain list of note paths to include as context
 * - Add/remove/clear context notes
 * - Validate note paths
 * - Provide note list for system prompt building
 *
 * Follows Single Responsibility Principle - only handles context note management.
 */

export class ContextNotesManager {
  private notes: string[] = [];

  /**
   * Get all context note paths
   */
  getNotes(): string[] {
    return [...this.notes];
  }

  /**
   * Set context notes (replaces existing list)
   */
  setNotes(notes: string[]): void {
    this.notes = [...notes];
  }

  /**
   * Add a note to context
   * @param notePath - Path to the note file
   * @returns true if added, false if already exists
   */
  addNote(notePath: string): boolean {
    if (!this.notes.includes(notePath)) {
      this.notes.push(notePath);
      return true;
    }
    return false;
  }

  /**
   * Remove a note from context by index
   * @param index - Index of the note to remove
   * @returns true if removed, false if index invalid
   */
  removeNote(index: number): boolean {
    if (index >= 0 && index < this.notes.length) {
      this.notes.splice(index, 1);
      return true;
    }
    return false;
  }

  /**
   * Remove a note from context by path
   * @param notePath - Path to the note file
   * @returns true if removed, false if not found
   */
  removeNoteByPath(notePath: string): boolean {
    const index = this.notes.indexOf(notePath);
    if (index !== -1) {
      this.notes.splice(index, 1);
      return true;
    }
    return false;
  }

  /**
   * Clear all context notes
   */
  clear(): void {
    this.notes = [];
  }

  /**
   * Check if a note is already in context
   */
  hasNote(notePath: string): boolean {
    return this.notes.includes(notePath);
  }

  /**
   * Get count of context notes
   */
  count(): number {
    return this.notes.length;
  }
}

```

## ui/chat/services/ContextTracker.ts

```typescript
/**
 * ContextTracker - Handles context usage and cost tracking
 * Location: /src/ui/chat/services/ContextTracker.ts
 *
 * Provides context window usage calculations and conversation cost tracking.
 * Delegates token calculation to TokenCalculator utility.
 */

import { ConversationData } from '../../../types/chat/ChatTypes';
import { ModelOption } from '../types/SelectionTypes';
import { ContextUsage } from '../components/ContextProgressBar';
import { TokenCalculator } from '../utils/TokenCalculator';
import type { ModelAgentManager } from './ModelAgentManager';
import type { ConversationManager } from './ConversationManager';

export class ContextTracker {
  constructor(
    private conversationManager: ConversationManager,
    private modelAgentManager: ModelAgentManager
  ) {}

  /**
   * Get current context usage for the active conversation
   * Calculates tokens used vs total context window
   */
  async getContextUsage(): Promise<ContextUsage> {
    const conversation = this.conversationManager.getCurrentConversation();
    const selectedModel = await this.modelAgentManager.getSelectedModelOrDefault();

    const usage = await TokenCalculator.getContextUsage(
      selectedModel,
      conversation,
      await this.modelAgentManager.getCurrentSystemPrompt()
    );
    return usage;
  }

  /**
   * Get conversation cost tracking
   * Returns total cost and currency from conversation metadata
   */
  getConversationCost(): { totalCost: number; currency: string } | null {
    const conversation = this.conversationManager.getCurrentConversation();
    if (!conversation) return null;

    // Prefer structured cost field if present
    if (conversation.cost?.totalCost !== undefined) {
      return {
        totalCost: conversation.cost.totalCost,
        currency: conversation.cost.currency || 'USD'
      };
    }

    // Fallback to metadata (legacy)
    if (conversation.metadata?.cost?.totalCost !== undefined) {
      return {
        totalCost: conversation.metadata.cost.totalCost,
        currency: conversation.metadata.cost.currency || 'USD'
      };
    }

    if (conversation.metadata?.totalCost !== undefined) {
      return {
        totalCost: conversation.metadata.totalCost,
        currency: conversation.metadata.currency || 'USD'
      };
    }

    return null;
  }
}

```

## ui/chat/services/ConversationManager.ts

```typescript
/**
 * ConversationManager - Handles all conversation CRUD operations
 */

import { App } from 'obsidian';
import { ChatService } from '../../../services/chat/ChatService';
import { ConversationData } from '../../../types/chat/ChatTypes';
import { BranchManager } from './BranchManager';
import { ConversationTitleModal } from '../components/ConversationTitleModal';

export interface ConversationManagerEvents {
  onConversationSelected: (conversation: ConversationData) => void;
  onConversationsChanged: () => void;
  onError: (message: string) => void;
}

export class ConversationManager {
  private currentConversation: ConversationData | null = null;
  private conversations: ConversationData[] = [];

  constructor(
    private app: App,
    private chatService: ChatService,
    private branchManager: BranchManager,
    private events: ConversationManagerEvents
  ) {}

  /**
   * Get current conversation
   */
  getCurrentConversation(): ConversationData | null {
    return this.currentConversation;
  }

  /**
   * Get all conversations
   */
  getConversations(): ConversationData[] {
    return this.conversations;
  }

  /**
   * Load conversations from the chat service
   */
  async loadConversations(): Promise<void> {
    try {
      this.conversations = await this.chatService.listConversations({ limit: 50 });

      this.events.onConversationsChanged();

      // Auto-select the most recent conversation
      if (this.conversations.length > 0 && !this.currentConversation) {
        await this.selectConversation(this.conversations[0]);
      }
    } catch (error) {
      this.events.onError('Failed to load conversations');
    }
  }

  /**
   * Select and display a conversation
   */
  async selectConversation(conversation: ConversationData): Promise<void> {
    try {
      this.currentConversation = conversation;

      // Load full conversation data
      const fullConversation = await this.chatService.getConversation(conversation.id);

      if (fullConversation) {
        this.currentConversation = fullConversation;
        this.events.onConversationSelected(fullConversation);
      }
    } catch (error) {
      this.events.onError('Failed to load conversation');
    }
  }

  /**
   * Create a new conversation
   */
  async createNewConversation(title?: string): Promise<void> {
    try {
      // Prompt for title if not provided
      const conversationTitle = title || await this.promptForConversationTitle();
      if (!conversationTitle) return; // User cancelled

      const result = await this.chatService.createConversation(conversationTitle);

      if (result.success && result.conversationId) {
        // Reload conversations and select the new one
        await this.loadConversations();
        const newConversation = await this.chatService.getConversation(result.conversationId);
        if (newConversation) {
          await this.selectConversation(newConversation);
        }
      } else {
        this.events.onError(result.error || 'Failed to create conversation');
      }
    } catch (error) {
      this.events.onError('Failed to create conversation');
    }
  }

  /**
   * Create new conversation with initial message
   */
  async createNewConversationWithMessage(
    message: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
      workspaceId?: string;
      sessionId?: string;
    }
  ): Promise<void> {
    const title = message.length > 50 ? message.substring(0, 47) + '...' : message;

    try {
      const result = await this.chatService.createConversation(
        title,
        message,
        {
          ...options,
          workspaceId: options?.workspaceId
        }
      );

      if (result.success && result.conversationId && result.sessionId) {
        // Reload conversations and select the new one
        await this.loadConversations();
        const newConversation = await this.chatService.getConversation(result.conversationId);

        if (newConversation) {
          await this.selectConversation(newConversation);
        }
      } else if (result.success && result.conversationId) {
        // Fallback for conversations without session ID (shouldn't happen with new code)
        await this.loadConversations();
        const newConversation = await this.chatService.getConversation(result.conversationId);
        if (newConversation) {
          await this.selectConversation(newConversation);
        }
      } else {
        this.events.onError(result.error || 'Failed to create conversation');
      }
    } catch (error) {
      this.events.onError('Failed to create conversation');
    }
  }

  /**
   * Delete a conversation
   */
  async deleteConversation(conversationId: string): Promise<void> {
    try {
      const success = await this.chatService.deleteConversation(conversationId);

      if (success) {
        // If this was the current conversation, clear it
        if (this.currentConversation?.id === conversationId) {
          this.currentConversation = null;
        }

        // Reload conversation list
        await this.loadConversations();
      } else {
        this.events.onError('Failed to delete conversation');
      }
    } catch (error) {
      this.events.onError('Failed to delete conversation');
    }
  }

  /**
   * Rename a conversation
   */
  async renameConversation(conversationId: string, newTitle: string): Promise<void> {
    try {
      const success = await this.chatService.updateConversationTitle(conversationId, newTitle);

      if (success) {
        // Update current conversation title if this is the active one
        if (this.currentConversation?.id === conversationId) {
          this.currentConversation.title = newTitle;
        }

        // Update title in the local conversations list
        const conversation = this.conversations.find(c => c.id === conversationId);
        if (conversation) {
          conversation.title = newTitle;
        }

        // Notify UI of the change
        this.events.onConversationsChanged();
      } else {
        this.events.onError('Failed to rename conversation');
      }
    } catch (error) {
      this.events.onError('Failed to rename conversation');
    }
  }

  /**
   * Update current conversation data
   */
  updateCurrentConversation(conversation: ConversationData): void {
    this.currentConversation = conversation;
  }

  /**
   * Set current conversation directly (no events fired)
   * Used when navigating to branches - the branch IS a conversation
   * but we don't want to fire selection events that would update the list
   */
  setCurrentConversation(conversation: ConversationData | null): void {
    this.currentConversation = conversation;
  }

  /**
   * Prompt user for conversation title using Obsidian's Modal
   */
  private async promptForConversationTitle(): Promise<string | null> {
    return new Promise((resolve) => {
      const modal = new ConversationTitleModal(this.app, (title) => {
        resolve(title);
      });
      modal.open();
    });
  }

}
```

## ui/chat/services/MessageAlternativeService.ts

```typescript
/**
 * Location: /src/ui/chat/services/MessageAlternativeService.ts
 *
 * Purpose: Handles creation of alternative AI responses for message branching
 * Extracted from MessageManager.ts to follow Single Responsibility Principle
 *
 * Used by: MessageManager for retry and alternative response generation
 * Dependencies: ChatService, BranchManager, MessageStreamHandler
 */

import { ChatService } from '../../../services/chat/ChatService';
import { ConversationData, ConversationMessage } from '../../../types/chat/ChatTypes';
import { BranchManager } from './BranchManager';
import { MessageStreamHandler } from './MessageStreamHandler';
import { AbortHandler } from '../utils/AbortHandler';

export interface MessageAlternativeServiceEvents {
  onStreamingUpdate: (messageId: string, content: string, isComplete: boolean, isIncremental?: boolean) => void;
  onConversationUpdated: (conversation: ConversationData) => void;
  onToolCallsDetected: (messageId: string, toolCalls: any[]) => void;
  onLoadingStateChanged: (isLoading: boolean) => void;
  onError: (message: string) => void;
}

/**
 * Service for creating alternative AI responses when retrying messages
 */
export class MessageAlternativeService {
  private currentAbortController: AbortController | null = null;
  private currentStreamingMessageId: string | null = null;

  constructor(
    private chatService: ChatService,
    private branchManager: BranchManager,
    private streamHandler: MessageStreamHandler,
    private abortHandler: AbortHandler,
    private events: MessageAlternativeServiceEvents
  ) {}

  /**
   * Create an alternative response for an AI message
   */
  async createAlternativeResponse(
    conversation: ConversationData,
    aiMessageId: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
      workspaceId?: string;
      sessionId?: string;
    }
  ): Promise<void> {
    const aiMessage = conversation.messages.find(msg => msg.id === aiMessageId);
    if (!aiMessage || aiMessage.role !== 'assistant') return;

    // Find the user message that prompted this AI response
    const aiMessageIndex = conversation.messages.findIndex(msg => msg.id === aiMessageId);
    if (aiMessageIndex === 0) return; // No previous message

    const userMessage = conversation.messages[aiMessageIndex - 1];
    if (!userMessage || userMessage.role !== 'user') return;

    // Store the original content, tool calls, and state before retry
    const originalContent = aiMessage.content;
    const originalToolCalls = aiMessage.toolCalls;
    const originalState = aiMessage.state;

    try {
      console.log('[SUBAGENT-DEBUG] Retry: Starting alternative response', { aiMessageId });
      this.events.onLoadingStateChanged(true);

      // Clear the AI message and show loading state
      const messageIndex = conversation.messages.findIndex(msg => msg.id === aiMessageId);
      if (messageIndex >= 0) {
        conversation.messages[messageIndex].content = '';
        conversation.messages[messageIndex].toolCalls = undefined;
        conversation.messages[messageIndex].isLoading = true;
        conversation.messages[messageIndex].state = 'draft';

        // Clear the bubble immediately and show thinking animation
        this.events.onStreamingUpdate(aiMessageId, '', false, false);
        this.events.onConversationUpdated(conversation);
      }

      // Create abort controller for this request
      this.currentAbortController = new AbortController();
      this.currentStreamingMessageId = aiMessageId;

      console.log('[Retry] Calling streamHandler.streamResponse');
      // Stream new AI response
      const { streamedContent, toolCalls } = await this.streamHandler.streamResponse(
        conversation,
        userMessage.content,
        aiMessageId,
        {
          ...options,
          excludeFromMessageId: aiMessageId, // Exclude AI message being retried from context
          abortSignal: this.currentAbortController.signal
        }
      );
      console.log('[Retry] streamResponse completed', { contentLength: streamedContent?.length, hasToolCalls: !!toolCalls });

      // Restore the original content before creating alternative
      const restoreIndex = conversation.messages.findIndex(msg => msg.id === aiMessageId);
      if (restoreIndex >= 0) {
        conversation.messages[restoreIndex].content = originalContent;
        conversation.messages[restoreIndex].toolCalls = originalToolCalls;
        conversation.messages[restoreIndex].state = originalState || 'complete';
        conversation.messages[restoreIndex].isLoading = false;
      }

      // Create alternative response with the new content
      const alternativeResponse: ConversationMessage = {
        id: `alt_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`,
        role: 'assistant',
        content: streamedContent,
        timestamp: Date.now(),
        conversationId: conversation.id,
        state: 'complete',
        toolCalls: toolCalls
      };

      // Add alternative using BranchManager
      await this.branchManager.createHumanBranch(
        conversation,
        aiMessageId,
        alternativeResponse
      );

      // Reload conversation from storage
      const freshConversation = await this.chatService.getConversation(conversation.id);
      if (freshConversation) {
        Object.assign(conversation, freshConversation);
      }

      // Notify UI to refresh and show the branching controls
      this.events.onConversationUpdated(conversation);

    } catch (error) {
      // Handle abort scenario
      if (error instanceof Error && error.name === 'AbortError') {
        await this.abortHandler.handleAbort(
          conversation,
          aiMessageId,
          async (hasContent, aiMsg) => {
            if (hasContent) {
              // Keep partial content
              aiMsg.toolCalls = undefined;
              aiMsg.isLoading = false;
              aiMsg.state = 'aborted';
              await this.chatService.updateConversation(conversation);
              this.events.onStreamingUpdate(aiMessageId, aiMsg.content, true, false);
              this.events.onConversationUpdated(conversation);
            } else {
              // Restore original content if aborted before any new content
              aiMsg.content = originalContent;
              aiMsg.toolCalls = originalToolCalls;
              aiMsg.state = originalState || 'complete';
              aiMsg.isLoading = false;
              await this.chatService.updateConversation(conversation);
              this.events.onConversationUpdated(conversation);
            }
          }
        );
      } else {
        this.events.onError('Failed to generate alternative response');
      }
    } finally {
      this.currentAbortController = null;
      this.currentStreamingMessageId = null;
      this.events.onLoadingStateChanged(false);
    }
  }

  /**
   * Cancel current alternative generation
   */
  cancel(): void {
    if (this.currentAbortController && this.currentStreamingMessageId) {
      this.currentAbortController.abort();
      this.currentAbortController = null;
      this.currentStreamingMessageId = null;
    }
  }

  /**
   * Check if currently generating an alternative
   */
  isGenerating(): boolean {
    return this.currentAbortController !== null;
  }
}

```

## ui/chat/services/MessageEnhancer.ts

```typescript
/**
 * MessageEnhancer - Builds enhancement metadata from suggester selections
 * Collects tool hints, agent references, and note content for system prompt injection
 */

import {
  MessageEnhancement,
  ToolHint,
  PromptReference,
  NoteReference,
  WorkspaceReference,
  EnhancementType,
  EnhancementData
} from '../components/suggesters/base/SuggesterInterfaces';
import { TokenCalculator } from '../utils/TokenCalculator';

/**
 * Service for building message enhancements from suggester selections
 */
export class MessageEnhancer {

  private tools: ToolHint[] = [];
  private prompts: PromptReference[] = [];
  private notes: NoteReference[] = [];
  private workspaces: WorkspaceReference[] = [];

  constructor() {
    // No initialization needed - TokenCalculator is static
  }

  // ==========================================================================
  // Add Enhancement Data
  // ==========================================================================

  /**
   * Add a tool hint from tool suggester
   * @param tool - Tool hint data
   */
  addTool(tool: ToolHint): void {
    // Avoid duplicates
    if (!this.tools.find(t => t.name === tool.name)) {
      this.tools.push(tool);
    }
  }

  /**
   * Add a prompt reference from prompt suggester
   * @param prompt - Prompt reference data
   */
  addPrompt(prompt: PromptReference): void {
    // Avoid duplicates
    if (!this.prompts.find(p => p.id === prompt.id)) {
      this.prompts.push(prompt);
    }
  }

  /**
   * Add a note reference from note suggester
   * @param note - Note reference data
   */
  addNote(note: NoteReference): void {
    // Avoid duplicates by path
    if (!this.notes.find(n => n.path === note.path)) {
      this.notes.push(note);
    }
  }

  /**
   * Add a workspace reference from workspace suggester
   * @param workspace - Workspace reference data
   */
  addWorkspace(workspace: WorkspaceReference): void {
    // Avoid duplicates by ID
    if (!this.workspaces.find(w => w.id === workspace.id)) {
      this.workspaces.push(workspace);
    }
  }

  /**
   * Add enhancement data based on type
   * @param enhancement - Enhancement data with type discriminator
   */
  addEnhancement(enhancement: EnhancementData): void {
    switch (enhancement.type) {
      case EnhancementType.TOOL:
        this.addTool(enhancement.data as ToolHint);
        break;
      case EnhancementType.PROMPT:
        this.addPrompt(enhancement.data as PromptReference);
        break;
      case EnhancementType.NOTE:
        this.addNote(enhancement.data as NoteReference);
        break;
      case EnhancementType.WORKSPACE:
        this.addWorkspace(enhancement.data as WorkspaceReference);
        break;
    }
  }

  // ==========================================================================
  // Build Enhancement
  // ==========================================================================

  /**
   * Build final message enhancement object
   * @param originalMessage - Original user message with trigger characters
   * @returns Complete message enhancement
   */
  buildEnhancement(originalMessage: string): MessageEnhancement {
    const cleanedMessage = this.cleanMessage(originalMessage);
    const totalTokens = this.calculateTotalTokens();

    return {
      originalMessage,
      cleanedMessage,
      tools: [...this.tools],
      prompts: [...this.prompts],
      notes: [...this.notes],
      workspaces: [...this.workspaces],
      totalTokens
    };
  }

  /**
   * Clean message for optional downstream usage.
   * Currently just trims whitespace so the LLM sees the message exactly as typed.
   * @param message - Original message
   * @returns Cleaned message
   */
  private cleanMessage(message: string): string {
    return message.trim();
  }

  /**
   * Calculate total estimated tokens from all enhancements
   * @returns Total token count
   */
  private calculateTotalTokens(): number {
    let total = 0;

    // Tool schemas (estimated)
    total += this.tools.length * 150; // ~150 tokens per tool schema

    // Prompt content
    total += this.prompts.reduce((sum, prompt) => sum + prompt.tokens, 0);

    // Note content
    total += this.notes.reduce((sum, note) => sum + note.tokens, 0);

    return total;
  }

  // ==========================================================================
  // Query Enhancement State
  // ==========================================================================

  /**
   * Get all current tool hints
   * @returns Array of tool hints
   */
  getTools(): ToolHint[] {
    return [...this.tools];
  }

  /**
   * Get all current prompt references
   * @returns Array of prompt references
   */
  getPrompts(): PromptReference[] {
    return [...this.prompts];
  }

  /**
   * Get all current note references
   * @returns Array of note references
   */
  getNotes(): NoteReference[] {
    return [...this.notes];
  }

  /**
   * Get all current workspace references
   * @returns Array of workspace references
   */
  getWorkspaces(): WorkspaceReference[] {
    return [...this.workspaces];
  }

  /**
   * Get current total token count
   * @returns Estimated token count
   */
  getTotalTokens(): number {
    return this.calculateTotalTokens();
  }

  /**
   * Check if any enhancements have been added
   * @returns True if enhancements exist
   */
  hasEnhancements(): boolean {
    return this.tools.length > 0 || this.prompts.length > 0 || this.notes.length > 0 || this.workspaces.length > 0;
  }

  // ==========================================================================
  // Clear State
  // ==========================================================================

  /**
   * Clear all enhancements
   */
  clearEnhancements(): void {
    this.tools = [];
    this.prompts = [];
    this.notes = [];
    this.workspaces = [];
  }

  /**
   * Remove a specific tool hint
   * @param toolName - Name of tool to remove
   */
  removeTool(toolName: string): void {
    this.tools = this.tools.filter(t => t.name !== toolName);
  }

  /**
   * Remove a specific prompt reference
   * @param promptId - ID of prompt to remove
   */
  removePrompt(promptId: string): void {
    this.prompts = this.prompts.filter(p => p.id !== promptId);
  }

  /**
   * Remove a specific note reference
   * @param notePath - Path of note to remove
   */
  removeNote(notePath: string): void {
    this.notes = this.notes.filter(n => n.path !== notePath);
  }

  /**
   * Remove a specific workspace reference
   * @param workspaceId - ID of workspace to remove
   */
  removeWorkspace(workspaceId: string): void {
    this.workspaces = this.workspaces.filter(w => w.id !== workspaceId);
  }
}

```

## ui/chat/services/MessageManager.ts

```typescript
/**
 * MessageManager - Handles all message operations including sending, editing, retry, and streaming
 * Refactored to use extracted services following SOLID principles
 *
 * ARCHITECTURE NOTE (Dec 2025):
 * A branch IS a conversation with parent metadata. When viewing a branch,
 * the branch is set as currentConversation in ConversationManager.
 * All message operations use the passed conversation (which may be a branch).
 * No special routing is needed - ChatService handles both transparently.
 */

import { ChatService } from '../../../services/chat/ChatService';
import { ConversationData, ConversationMessage } from '../../../types/chat/ChatTypes';
import { BranchManager } from './BranchManager';
import { ReferenceMetadata } from '../utils/ReferenceExtractor';
import { MessageAlternativeService } from './MessageAlternativeService';
import { MessageStreamHandler } from './MessageStreamHandler';
import { MessageStateManager } from './MessageStateManager';
import { AbortHandler } from '../utils/AbortHandler';
import { getWebLLMLifecycleManager } from '../../../services/llm/adapters/webllm/WebLLMLifecycleManager';
import type { MessageQueueService } from '../../../services/chat/MessageQueueService';
import type { QueuedMessage } from '../../../types/branch/BranchTypes';

export interface MessageManagerEvents {
  onMessageAdded: (message: ConversationMessage) => void;
  onAIMessageStarted: (message: ConversationMessage) => void;
  onStreamingUpdate: (messageId: string, content: string, isComplete: boolean, isIncremental?: boolean) => void;
  onConversationUpdated: (conversation: ConversationData) => void;
  onLoadingStateChanged: (isLoading: boolean) => void;
  onError: (message: string) => void;
  onToolCallsDetected: (messageId: string, toolCalls: any[]) => void;
  onToolExecutionStarted: (messageId: string, toolCall: { id: string; name: string; parameters?: any }) => void;
  onToolExecutionCompleted: (messageId: string, toolId: string, result: any, success: boolean, error?: string) => void;
  onMessageIdUpdated: (oldId: string, newId: string, updatedMessage: ConversationMessage) => void;
  onGenerationAborted: (messageId: string, partialContent: string) => void;
  // Token usage for context tracking (optional - for local models)
  onUsageAvailable?: (usage: { promptTokens: number; completionTokens: number; totalTokens: number }) => void;
}

export class MessageManager {
  private isLoading = false;
  private currentAbortController: AbortController | null = null;
  private currentStreamingMessageId: string | null = null;

  // Extracted services
  private streamHandler: MessageStreamHandler;
  private abortHandler: AbortHandler;
  private stateManager: MessageStateManager;
  private alternativeService: MessageAlternativeService;

  // Optional queue service for subagent result processing
  private messageQueueService: MessageQueueService | null = null;

  constructor(
    private chatService: ChatService,
    private branchManager: BranchManager,
    private events: MessageManagerEvents
  ) {
    // Initialize extracted services with appropriate event mappings
    this.streamHandler = new MessageStreamHandler(chatService, {
      onStreamingUpdate: events.onStreamingUpdate,
      onToolCallsDetected: events.onToolCallsDetected
    });

    this.abortHandler = new AbortHandler(chatService, {
      onStreamingUpdate: events.onStreamingUpdate,
      onConversationUpdated: events.onConversationUpdated
    });

    this.stateManager = new MessageStateManager(chatService, {
      onMessageAdded: events.onMessageAdded,
      onAIMessageStarted: events.onAIMessageStarted,
      onMessageIdUpdated: events.onMessageIdUpdated,
      onConversationUpdated: events.onConversationUpdated
    });

    this.alternativeService = new MessageAlternativeService(
      chatService,
      branchManager,
      this.streamHandler,
      this.abortHandler,
      {
        onStreamingUpdate: events.onStreamingUpdate,
        onConversationUpdated: events.onConversationUpdated,
        onToolCallsDetected: events.onToolCallsDetected,
        onLoadingStateChanged: (loading) => this.setLoading(loading),
        onError: events.onError
      }
    );
  }

  /**
   * Get current loading state
   */
  getIsLoading(): boolean {
    return this.isLoading;
  }

  /**
   * Set the message queue service for subagent result processing
   * This enables queued delivery of subagent results
   */
  setMessageQueueService(queueService: MessageQueueService): void {
    console.log('[MessageManager] Setting message queue service');
    this.messageQueueService = queueService;

    // Set up the message processor to handle queued messages
    queueService.setProcessor(async (message: QueuedMessage) => {
      console.log('[MessageManager] Processing queued message:', message.type, message.id);

      if (message.type === 'subagent_result') {
        // Subagent completed - notify UI to refresh/display results
        console.log('[MessageManager] Subagent result:', {
          subagentId: message.metadata?.subagentId,
          branchId: message.metadata?.branchId,
          error: message.metadata?.error,
        });

        // The subagent result is already stored in the branch
        // We just need to trigger a UI update
        // This will be handled by ChatView's event system
        this.events.onConversationUpdated?.(null as any); // Force UI refresh
      }
    });
  }

  /**
   * Send a message in a conversation
   */
  async sendMessage(
    conversation: ConversationData,
    message: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
      workspaceId?: string;
      sessionId?: string;
      enableThinking?: boolean;
      thinkingEffort?: 'low' | 'medium' | 'high';
    },
    metadata?: ReferenceMetadata
  ): Promise<void> {
    let aiMessageId: string | null = null;

    try {
      this.setLoading(true);

      // Record activity for Nexus lifecycle manager (resets idle timer)
      getWebLLMLifecycleManager().recordActivity();

      // Add user message and get real ID from storage
      await this.stateManager.addUserMessage(conversation, message, metadata);

      // Create placeholder AI message
      const placeholderMessage = this.stateManager.createPlaceholderAIMessage(conversation);
      aiMessageId = placeholderMessage.id;

      // Setup abort controller
      this.currentAbortController = new AbortController();
      this.currentStreamingMessageId = aiMessageId;

      // Stream AI response
      const streamResult = await this.streamHandler.streamAndSave(
        conversation,
        message,
        aiMessageId,
        {
          ...options,
          abortSignal: this.currentAbortController.signal
        }
      );

      // Report usage for context tracking (e.g., for local models with limited context)
      if (streamResult.usage && this.events.onUsageAvailable) {
        this.events.onUsageAvailable(streamResult.usage);
      }

      // Reload conversation from storage to sync
      await this.stateManager.reloadConversation(conversation);

      // Notify that conversation has been updated
      this.events.onConversationUpdated(conversation);

    } catch (error) {
      // Handle abort scenario
      const wasAborted = await this.abortHandler.handleIfAbortError(
        error,
        conversation,
        aiMessageId
      );

      if (!wasAborted) {
        this.events.onError('Failed to send message');
      }
    } finally {
      this.currentAbortController = null;
      this.setLoading(false);
    }
  }

  /**
   * Handle retry message action - creates message-level alternatives
   */
  async handleRetryMessage(
    conversation: ConversationData,
    messageId: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
      workspaceId?: string;
      sessionId?: string;
      enableThinking?: boolean;
      thinkingEffort?: 'low' | 'medium' | 'high';
    }
  ): Promise<void> {
    const message = conversation.messages.find(msg => msg.id === messageId);
    if (!message) return;

    try {
      // For user messages, regenerate the AI response
      if (message.role === 'user') {
        await this.regenerateAIResponse(conversation, messageId, options);
      }
      // For AI messages, create an alternative response
      else if (message.role === 'assistant') {
        await this.alternativeService.createAlternativeResponse(conversation, messageId, options);
      }

      // Notify that conversation was updated
      this.events.onConversationUpdated(conversation);

    } catch (error) {
      this.events.onError('Failed to retry message');
    }
  }

  /**
   * Regenerate AI response for a user message
   */
  private async regenerateAIResponse(
    conversation: ConversationData,
    userMessageId: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
      workspaceId?: string;
      sessionId?: string;
    }
  ): Promise<void> {
    const userMessage = conversation.messages.find(msg => msg.id === userMessageId);
    if (!userMessage || userMessage.role !== 'user') return;

    // Find the AI message that follows this user message
    const userMessageIndex = conversation.messages.findIndex(msg => msg.id === userMessageId);
    if (userMessageIndex === -1) return;

    const aiMessageIndex = userMessageIndex + 1;
    const aiMessage = conversation.messages[aiMessageIndex];

    if (aiMessage && aiMessage.role === 'assistant') {
      // Create alternative for existing AI message
      await this.alternativeService.createAlternativeResponse(conversation, aiMessage.id, options);
    } else {
      // No AI response exists - generate a fresh one
      await this.generateFreshAIResponse(conversation, userMessage, options);
    }
  }

  /**
   * Generate a fresh AI response when no response exists
   */
  private async generateFreshAIResponse(
    conversation: ConversationData,
    userMessage: ConversationMessage,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
      workspaceId?: string;
      sessionId?: string;
    }
  ): Promise<void> {
    try {
      this.setLoading(true);

      // Create new AI message placeholder
      const placeholderMessage = this.stateManager.createPlaceholderAIMessage(conversation);
      const aiMessageId = placeholderMessage.id;

      // Setup abort controller
      this.currentAbortController = new AbortController();
      this.currentStreamingMessageId = aiMessageId;

      // Stream the AI response
      const streamResult = await this.streamHandler.streamAndSave(
        conversation,
        userMessage.content,
        aiMessageId,
        {
          ...options,
          abortSignal: this.currentAbortController.signal
        }
      );

      // Report usage for context tracking
      if (streamResult.usage && this.events.onUsageAvailable) {
        this.events.onUsageAvailable(streamResult.usage);
      }

      // Reload conversation from storage
      await this.stateManager.reloadConversation(conversation);

      // Notify that conversation has been updated
      this.events.onConversationUpdated(conversation);

    } catch (error) {
      // Handle abort scenario
      const wasAborted = await this.abortHandler.handleIfAbortError(
        error,
        conversation,
        this.currentStreamingMessageId
      );

      if (!wasAborted) {
        this.events.onError('Failed to generate AI response');
      }
    } finally {
      this.currentAbortController = null;
      this.currentStreamingMessageId = null;
      this.setLoading(false);
    }
  }

  /**
   * Handle edit message action - ONLY updates content, does NOT regenerate
   */
  async handleEditMessage(
    conversation: ConversationData,
    messageId: string,
    newContent: string,
    options?: {
      provider?: string;
      model?: string;
      systemPrompt?: string;
      workspaceId?: string;
      sessionId?: string;
    }
  ): Promise<void> {
    await this.stateManager.updateMessageContent(conversation, messageId, newContent);
  }

  /**
   * Add a user message for optimistic updates
   */
  addUserMessage(conversation: ConversationData, content: string): void {
    const message: ConversationMessage = {
      id: `temp_${Date.now()}`,
      role: 'user',
      content,
      timestamp: Date.now(),
      conversationId: conversation.id
    };

    conversation.messages.push(message);
    this.events.onMessageAdded(message);
  }

  /**
   * Cancel current generation (abort streaming)
   * Always resets loading state even if no active abort controller
   */
  cancelCurrentGeneration(): void {
    const messageId = this.currentStreamingMessageId;

    // Abort the stream if active
    if (this.currentAbortController) {
      this.currentAbortController.abort();
      this.currentAbortController = null;
    }

    // Always reset streaming message ID
    this.currentStreamingMessageId = null;

    // Always reset loading state (prevents stuck state)
    this.setLoading(false);

    // Fire abort event if we had an active message
    if (messageId) {
      this.events.onGenerationAborted(messageId, '');
    }
  }

  /**
   * Set loading state and notify
   */
  private setLoading(loading: boolean): void {
    this.isLoading = loading;
    this.events.onLoadingStateChanged(loading);
  }
}

```

## ui/chat/services/MessageStateManager.ts

```typescript
/**
 * Location: /src/ui/chat/services/MessageStateManager.ts
 *
 * Purpose: Manages message state transitions and updates
 * Extracted from MessageManager.ts to follow Single Responsibility Principle
 *
 * ARCHITECTURE NOTE (Dec 2025):
 * A branch IS a conversation with parent metadata. When viewing a branch,
 * the branch is set as currentConversation. All saves go through ChatService
 * with the current conversation's ID - no special routing needed.
 *
 * Used by: MessageManager for managing message lifecycle states
 * Dependencies: ChatService
 */

import { ConversationData, ConversationMessage } from '../../../types/chat/ChatTypes';
import { ChatService } from '../../../services/chat/ChatService';

export interface MessageStateManagerEvents {
  onMessageAdded: (message: ConversationMessage) => void;
  onAIMessageStarted: (message: ConversationMessage) => void;
  onMessageIdUpdated: (oldId: string, newId: string, updatedMessage: ConversationMessage) => void;
  onConversationUpdated: (conversation: ConversationData) => void;
}

/**
 * Manages message state transitions and lifecycle
 */
export class MessageStateManager {
  constructor(
    private chatService: ChatService,
    private events: MessageStateManagerEvents
  ) {}

  /**
   * Create and add a user message to the conversation
   * Works for both parent conversations and branches (branch IS a conversation)
   */
  async addUserMessage(
    conversation: ConversationData,
    content: string,
    metadata?: any
  ): Promise<ConversationMessage> {
    // Create user message with temporary ID
    const userMessage: ConversationMessage = {
      id: `msg_${Date.now()}_user`,
      role: 'user' as const,
      content: content,
      timestamp: Date.now(),
      conversationId: conversation.id,
      state: 'complete', // User messages are complete when created
      metadata: metadata
    };

    // Add to conversation and display immediately
    conversation.messages.push(userMessage);
    this.events.onMessageAdded(userMessage);

    // Persist to storage (works for both parent and branch conversations)
    const userMessageResult = await this.chatService.addMessage({
      conversationId: conversation.id,
      role: 'user',
      content: content,
      metadata: metadata,
      id: userMessage.id // Use same ID as in-memory message to avoid mismatch
    });

    // Update with real ID from repository
    if (userMessageResult.success && userMessageResult.messageId) {
      await this.updateMessageId(conversation, userMessage.id, userMessageResult.messageId, userMessage);
    }

    return userMessage;
  }

  /**
   * Create and add a placeholder AI message
   */
  createPlaceholderAIMessage(
    conversation: ConversationData,
    customId?: string
  ): ConversationMessage {
    const aiMessageId = customId || `msg_${Date.now()}_ai`;
    const placeholderAiMessage: ConversationMessage = {
      id: aiMessageId,
      role: 'assistant' as const,
      content: '',
      timestamp: Date.now(),
      conversationId: conversation.id,
      state: 'draft', // Placeholder - about to start streaming
      isLoading: true
    };

    // Add placeholder AI message and create bubble for streaming
    conversation.messages.push(placeholderAiMessage);
    this.events.onAIMessageStarted(placeholderAiMessage);

    return placeholderAiMessage;
  }

  /**
   * Update message ID when real ID is received from storage
   */
  private async updateMessageId(
    conversation: ConversationData,
    tempId: string,
    realId: string,
    message: ConversationMessage
  ): Promise<void> {
    const tempMessageIndex = conversation.messages.findIndex(msg => msg.id === tempId);
    if (tempMessageIndex >= 0) {
      const oldId = conversation.messages[tempMessageIndex].id;
      conversation.messages[tempMessageIndex].id = realId;

      // Update the original message object that UI components reference
      message.id = realId;

      // Notify UI about message ID update so MessageBubble can update its reference
      this.events.onMessageIdUpdated(oldId, realId, message);
    }
  }

  /**
   * Remove a message from conversation
   */
  removeMessage(conversation: ConversationData, messageId: string): void {
    const messageIndex = conversation.messages.findIndex(msg => msg.id === messageId);
    if (messageIndex >= 0) {
      conversation.messages.splice(messageIndex, 1);
      this.events.onConversationUpdated(conversation);
    }
  }

  /**
   * Update message content
   * Works for both parent conversations and branches
   */
  async updateMessageContent(
    conversation: ConversationData,
    messageId: string,
    newContent: string
  ): Promise<void> {
    const messageIndex = conversation.messages.findIndex(msg => msg.id === messageId);
    if (messageIndex === -1) return;

    // Update message content in-memory
    conversation.messages[messageIndex].content = newContent;
    if (conversation.messages[messageIndex].metadata) {
      delete conversation.messages[messageIndex].metadata;
    }

    // Persist to storage (works for both parent and branch)
    await this.chatService.updateConversation(conversation);

    // Notify about conversation update
    this.events.onConversationUpdated(conversation);
  }

  /**
   * Update message state
   */
  updateMessageState(
    conversation: ConversationData,
    messageId: string,
    state: 'draft' | 'streaming' | 'complete' | 'aborted' | 'invalid'
  ): void {
    const messageIndex = conversation.messages.findIndex(msg => msg.id === messageId);
    if (messageIndex >= 0) {
      conversation.messages[messageIndex].state = state;
    }
  }

  /**
   * Reload conversation from storage to sync with saved messages
   * Works for both parent conversations and branches
   */
  async reloadConversation(conversation: ConversationData): Promise<void> {
    const freshConversation = await this.chatService.getConversation(conversation.id);
    if (freshConversation) {
      Object.assign(conversation, freshConversation);
    }
  }
}

```

## ui/chat/services/MessageStreamHandler.ts

```typescript
/**
 * Location: /src/ui/chat/services/MessageStreamHandler.ts
 *
 * Purpose: Consolidated streaming loop logic for AI responses
 * Extracted from MessageManager.ts to eliminate DRY violations (4+ repeated streaming patterns)
 *
 * ARCHITECTURE NOTE (Dec 2025):
 * A branch IS a conversation with parent metadata. When viewing a branch,
 * the branch is set as currentConversation. This means all streaming saves
 * go through ChatService.updateConversation() - no special routing needed.
 *
 * Used by: MessageManager, MessageAlternativeService for streaming AI responses
 * Dependencies: ChatService
 */

import { ChatService } from '../../../services/chat/ChatService';
import { ConversationData } from '../../../types/chat/ChatTypes';

export interface StreamHandlerEvents {
  onStreamingUpdate: (messageId: string, content: string, isComplete: boolean, isIncremental?: boolean) => void;
  onToolCallsDetected: (messageId: string, toolCalls: any[]) => void;
}

export interface StreamOptions {
  provider?: string;
  model?: string;
  systemPrompt?: string;
  workspaceId?: string;
  sessionId?: string;
  messageId?: string;
  excludeFromMessageId?: string;
  abortSignal?: AbortSignal;
  enableThinking?: boolean;
  thinkingEffort?: 'low' | 'medium' | 'high';
}

export interface StreamResult {
  streamedContent: string;
  toolCalls?: any[];
  reasoning?: string;  // Accumulated reasoning text
  usage?: {            // Token usage for context tracking
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
}

/**
 * Create a synthetic tool call to represent reasoning/thinking in the UI
 * This allows reasoning to be displayed in the ProgressiveToolAccordion
 */
function createReasoningToolCall(messageId: string, reasoningText: string, isComplete: boolean): any {
  return {
    id: `reasoning_${messageId}`,
    type: 'reasoning',  // Special type for reasoning display
    name: 'Reasoning',
    displayName: 'Reasoning',
    technicalName: 'extended_thinking',
    function: {
      name: 'reasoning',
      arguments: ''  // Not used
    },
    result: reasoningText,
    status: isComplete ? 'completed' : 'streaming',
    success: true,
    isVirtual: true  // Flag to indicate this is not a real tool
  };
}

/**
 * Handles streaming of AI responses with unified logic
 */
export class MessageStreamHandler {
  constructor(
    private chatService: ChatService,
    private events: StreamHandlerEvents
  ) {}

  /**
   * Stream AI response with consolidated logic
   * This eliminates the 4+ repeated streaming loop patterns in MessageManager
   */
  async streamResponse(
    conversation: ConversationData,
    userMessageContent: string,
    aiMessageId: string,
    options: StreamOptions
  ): Promise<StreamResult> {
    console.log('[StreamHandler] streamResponse START', { conversationId: conversation.id, aiMessageId });
    let streamedContent = '';
    let toolCalls: any[] | undefined = undefined;
    let hasStartedStreaming = false;
    let finalUsage: StreamResult['usage'] | undefined = undefined;

    // Reasoning accumulation
    let reasoningAccumulator = '';
    let reasoningEmitted = false;

    // Stream the AI response
    for await (const chunk of this.chatService.generateResponseStreaming(
      conversation.id,
      userMessageContent,
      {
        ...options,
        messageId: aiMessageId
      }
    )) {
      // Handle token chunks
      if (chunk.chunk) {
        streamedContent += chunk.chunk;

        // Update message in conversation object progressively
        // This ensures partial content is preserved if user stops generation
        const messageIndex = conversation.messages.findIndex(msg => msg.id === aiMessageId);
        if (messageIndex >= 0) {
          // Update state to streaming on first chunk
          if (!hasStartedStreaming) {
            hasStartedStreaming = true;
            conversation.messages[messageIndex].state = 'streaming';
            conversation.messages[messageIndex].isLoading = false;
          }
          // Always update content so it's available on abort
          conversation.messages[messageIndex].content = streamedContent;
        }

        // Send only the new chunk to UI for incremental updates
        this.events.onStreamingUpdate(aiMessageId, chunk.chunk, false, true);
      }

      // Handle reasoning/thinking content (Claude, GPT-5, Gemini)
      if (chunk.reasoning) {
        reasoningAccumulator += chunk.reasoning;

        // Emit reasoning as a synthetic tool call for UI display
        const reasoningToolCall = createReasoningToolCall(
          aiMessageId,
          reasoningAccumulator,
          chunk.reasoningComplete || false
        );
        this.events.onToolCallsDetected(aiMessageId, [reasoningToolCall]);
        reasoningEmitted = true;
      }

      // Mark reasoning as complete if signaled
      if (chunk.reasoningComplete && reasoningEmitted) {
        const finalReasoningToolCall = createReasoningToolCall(
          aiMessageId,
          reasoningAccumulator,
          true
        );
        this.events.onToolCallsDetected(aiMessageId, [finalReasoningToolCall]);
      }

      // Extract tool calls when available
      if (chunk.toolCalls) {
        toolCalls = chunk.toolCalls;

        // Emit tool calls event for final chunk
        if (chunk.complete) {
          this.events.onToolCallsDetected(aiMessageId, toolCalls);
        }
      }

      // Capture usage data when available
      if (chunk.usage) {
        finalUsage = {
          promptTokens: chunk.usage.promptTokens || 0,
          completionTokens: chunk.usage.completionTokens || 0,
          totalTokens: chunk.usage.totalTokens || 0
        };
      }

      // Handle completion
      if (chunk.complete) {
        // Check if this is TRULY the final complete
        const hasToolCalls = toolCalls && toolCalls.length > 0;
        const toolCallsHaveResults = hasToolCalls && toolCalls!.some((tc: any) =>
          tc.result !== undefined || tc.success !== undefined
        );
        const isFinalComplete = !hasToolCalls || toolCallsHaveResults;

        if (isFinalComplete) {
          // Update conversation with final content
          const placeholderMessageIndex = conversation.messages.findIndex(msg => msg.id === aiMessageId);
          if (placeholderMessageIndex >= 0) {
            conversation.messages[placeholderMessageIndex] = {
              ...conversation.messages[placeholderMessageIndex],
              content: streamedContent,
              state: 'complete',
              toolCalls: toolCalls,
              // Persist reasoning for re-render from storage
              reasoning: reasoningAccumulator || undefined
            };
          }

          // Send final complete content
          this.events.onStreamingUpdate(aiMessageId, streamedContent, true, false);
          break;
        } else {
          // Intermediate complete - waiting for tool execution results
        }
      }
    }

    return {
      streamedContent,
      toolCalls,
      reasoning: reasoningAccumulator || undefined,
      usage: finalUsage
    };
  }

  /**
   * Stream response and save to storage
   * Convenience method that combines streaming and saving
   *
   * ARCHITECTURE NOTE (Dec 2025):
   * The conversation passed here is the currentConversation, which is
   * either a parent conversation or a branch (branch IS a conversation).
   * ChatService.updateConversation handles both the same way.
   */
  async streamAndSave(
    conversation: ConversationData,
    userMessageContent: string,
    aiMessageId: string,
    options: StreamOptions
  ): Promise<StreamResult> {
    const result = await this.streamResponse(conversation, userMessageContent, aiMessageId, options);

    // Save conversation to storage (works for both parent and branch)
    await this.chatService.updateConversation(conversation);

    return result;
  }
}

```

## ui/chat/services/ModelAgentManager.ts

```typescript
/**
 * ModelAgentManager - Handles model and agent selection, loading, and state management
 * Refactored to use extracted utilities following SOLID principles
 */

import { ModelOption, PromptOption } from '../types/SelectionTypes';
import { WorkspaceContext } from '../../../database/types/workspace/WorkspaceTypes';
import { MessageEnhancement } from '../components/suggesters/base/SuggesterInterfaces';
import { SystemPromptBuilder, PromptSummary, ToolAgentInfo, ContextStatusInfo } from './SystemPromptBuilder';
import { ContextNotesManager } from './ContextNotesManager';
import { ModelSelectionUtility } from '../utils/ModelSelectionUtility';
import { PromptConfigurationUtility } from '../utils/PromptConfigurationUtility';
import { WorkspaceIntegrationService } from './WorkspaceIntegrationService';
import { getWebLLMLifecycleManager } from '../../../services/llm/adapters/webllm/WebLLMLifecycleManager';
import { ThinkingSettings } from '../../../types/llm/ProviderTypes';
import { ContextTokenTracker, ContextStatus } from '../../../services/chat/ContextTokenTracker';
import { CompactedContext } from '../../../services/chat/ContextCompactionService';
import type NexusPlugin from '../../../main';
import type { App } from 'obsidian';

// Context window sizes for providers that need auto-compaction
// Only WebLLM/Nexus needs this - it crashes on context overflow (WebGPU hard limit)
// Ollama/LM Studio handle overflow gracefully and have variable context sizes
const LOCAL_PROVIDER_CONTEXT_WINDOWS: Record<string, number> = {
  webllm: 4096,   // Nexus Quark uses 4K context - NEEDS compaction or crashes
  // ollama and lmstudio omitted - they handle overflow gracefully
};

/**
 * App type with plugin registry access
 */
type AppWithPlugins = {
  plugins?: {
    plugins?: Record<string, NexusPlugin>;
  };
} & Omit<App, 'plugins'>;

/**
 * Plugin interface with settings structure
 */
interface PluginWithSettings {
  settings?: {
    settings?: {
      llmProviders?: {
        defaultThinking?: ThinkingSettings;
      };
      defaultWorkspaceId?: string;
      defaultPromptId?: string;
    };
  };
  serviceManager?: {
    getServiceIfReady?: (name: string) => any;
  };
  connector?: {
    agentRegistry?: {
      getAllAgents: () => Map<string, any>;
    };
  };
}

export interface ModelAgentManagerEvents {
  onModelChanged: (model: ModelOption | null) => void;
  onPromptChanged: (prompt: PromptOption | null) => void;
  onSystemPromptChanged: (systemPrompt: string | null) => void;
}

export class ModelAgentManager {
  private selectedModel: ModelOption | null = null;
  private selectedPrompt: PromptOption | null = null;
  private currentSystemPrompt: string | null = null;
  private selectedWorkspaceId: string | null = null;
  private workspaceContext: WorkspaceContext | null = null;
  private loadedWorkspaceData: any = null; // Full comprehensive workspace data from LoadWorkspaceTool
  private contextNotesManager: ContextNotesManager;
  private currentConversationId: string | null = null;
  private messageEnhancement: MessageEnhancement | null = null;
  private systemPromptBuilder: SystemPromptBuilder;
  private workspaceIntegration: WorkspaceIntegrationService;
  private thinkingSettings: ThinkingSettings = { enabled: false, effort: 'medium' };
  private temperature: number = 0.5;
  private contextTokenTracker: ContextTokenTracker | null = null; // For token-limited models
  private previousContext: CompactedContext | null = null; // Context from compacted conversation

  constructor(
    private app: any, // Obsidian App
    private events: ModelAgentManagerEvents,
    private conversationService?: any, // Optional ConversationService for persistence
    conversationId?: string
  ) {
    this.currentConversationId = conversationId || null;

    // Initialize services
    this.contextNotesManager = new ContextNotesManager();
    this.workspaceIntegration = new WorkspaceIntegrationService(app);
    this.systemPromptBuilder = new SystemPromptBuilder(
      this.workspaceIntegration.readNoteContent.bind(this.workspaceIntegration),
      this.workspaceIntegration.loadWorkspace.bind(this.workspaceIntegration)
    );
  }

  /**
   * Initialize with plugin defaults (model, workspace, agent)
   * Call this when no conversation exists (e.g., welcome state)
   */
  async initializeDefaults(): Promise<void> {
    await this.initializeDefaultModel();
  }

  /**
   * Initialize from conversation metadata (if available), otherwise use plugin default
   */
  async initializeFromConversation(conversationId: string): Promise<void> {
    try {
      // Try to load from conversation metadata first
      if (this.conversationService) {
        const conversation = await this.conversationService.getConversation(conversationId);
        const chatSettings = conversation?.metadata?.chatSettings;

        // Check if chatSettings has meaningful content (not just empty object)
        const hasMeaningfulSettings = chatSettings && (
          chatSettings.providerId ||
          chatSettings.modelId ||
          chatSettings.promptId ||
          chatSettings.workspaceId
        );

        if (hasMeaningfulSettings) {
          await this.restoreFromConversationMetadata(chatSettings);
          return; // Successfully loaded from metadata
        }
      }

      // Fall back to plugin default if no meaningful metadata
      await this.initializeDefaultModel();
    } catch (error) {
      await this.initializeDefaultModel();
    }
  }

  /**
   * Restore settings from conversation metadata
   */
  private async restoreFromConversationMetadata(settings: any): Promise<void> {
    const availableModels = await this.getAvailableModels();
    const availablePrompts = await this.getAvailablePrompts();

    // Restore model
    if (settings.providerId && settings.modelId) {
      const model = availableModels.find(
        m => m.providerId === settings.providerId && m.modelId === settings.modelId
      );

      if (model) {
        this.selectedModel = model;
        this.events.onModelChanged(model);
      } else {
        await this.initializeDefaultModel();
      }
    }

    // Restore prompt
    if (settings.promptId) {
      const prompt = availablePrompts.find(p => p.id === settings.promptId);
      if (prompt) {
        this.selectedPrompt = prompt;
        this.currentSystemPrompt = prompt.systemPrompt || null;
        this.events.onPromptChanged(prompt);
      }
    }

    // Restore workspace
    if (settings.workspaceId) {
      await this.restoreWorkspace(settings.workspaceId, settings.sessionId);
    }

    // Restore context notes
    if (settings.contextNotes && Array.isArray(settings.contextNotes)) {
      this.contextNotesManager.setNotes(settings.contextNotes);
    }

    // Restore thinking settings
    if (settings.thinking) {
      this.thinkingSettings = {
        enabled: settings.thinking.enabled ?? false,
        effort: settings.thinking.effort ?? 'medium'
      };
    }

    // Restore temperature
    if (typeof settings.temperature === 'number') {
      this.temperature = Math.max(0, Math.min(1, settings.temperature));
    }
  }

  /**
   * Restore workspace from settings - loads full comprehensive data
   */
  private async restoreWorkspace(workspaceId: string, sessionId?: string): Promise<void> {
    this.selectedWorkspaceId = workspaceId;

    try {
      // Load full comprehensive workspace data (same as #workspace suggester)
      const fullWorkspaceData = await this.workspaceIntegration.loadWorkspace(workspaceId);

      if (fullWorkspaceData) {
        this.loadedWorkspaceData = fullWorkspaceData;
        // Also extract basic context for backward compatibility
        this.workspaceContext = fullWorkspaceData.context || fullWorkspaceData.workspaceContext || null;
      }

      // Bind session to workspace
      await this.workspaceIntegration.bindSessionToWorkspace(sessionId, workspaceId);
    } catch (error) {
      console.error('[ModelAgentManager] Failed to restore workspace:', error);
      // Clear workspace data on failure
      this.loadedWorkspaceData = null;
      this.workspaceContext = null;
    }
  }

  /**
   * Initialize from plugin settings defaults (model, workspace, prompt, thinking)
   */
  private async initializeDefaultModel(): Promise<void> {
    try {
      // Initialize default model
      const availableModels = await this.getAvailableModels();
      const defaultModel = await ModelSelectionUtility.findDefaultModelOption(this.app, availableModels);

      if (defaultModel) {
        this.selectedModel = defaultModel;
        this.events.onModelChanged(defaultModel);
      }

      // Clear state first
      this.selectedPrompt = null;
      this.currentSystemPrompt = null;
      this.selectedWorkspaceId = null;
      this.workspaceContext = null;
      this.loadedWorkspaceData = null;
      this.contextNotesManager.clear();

      // Get plugin settings for defaults
      const { getNexusPlugin } = await import('../../../utils/pluginLocator');
      const plugin = getNexusPlugin<NexusPlugin>(this.app) as unknown as PluginWithSettings | null;
      const settings = plugin?.settings?.settings;

      // Load default thinking settings
      const llmProviders = settings?.llmProviders;
      if (llmProviders?.defaultThinking) {
        this.thinkingSettings = {
          enabled: llmProviders.defaultThinking.enabled ?? false,
          effort: llmProviders.defaultThinking.effort ?? 'medium'
        };
      }

      // Load default workspace if set
      if (settings?.defaultWorkspaceId) {
        try {
          await this.restoreWorkspace(settings.defaultWorkspaceId, undefined);
        } catch (error) {
          // Failed to load default workspace
        }
      }

      // Load default prompt if set
      if (settings?.defaultPromptId) {
        try {
          const availablePrompts = await this.getAvailablePrompts();
          const defaultPrompt = availablePrompts.find(p => p.id === settings.defaultPromptId || p.name === settings.defaultPromptId);
          if (defaultPrompt) {
            this.selectedPrompt = defaultPrompt;
            this.currentSystemPrompt = defaultPrompt.systemPrompt || null;
            this.events.onPromptChanged(defaultPrompt);
            this.events.onSystemPromptChanged(this.currentSystemPrompt);
            return; // Prompt was set, don't reset
          }
        } catch (error) {
          // Failed to load default prompt
        }
      }

      // Notify listeners about the state (no prompt selected)
      this.events.onPromptChanged(null);
      this.events.onSystemPromptChanged(null);
    } catch (error) {
      // Failed to initialize defaults
    }
  }

  /**
   * Save current selections to conversation metadata
   */
  async saveToConversation(conversationId: string): Promise<void> {
    if (!this.conversationService) {
      return;
    }

    try {
      // Load existing metadata first to preserve sessionId
      const existingConversation = await this.conversationService.getConversation(conversationId);
      const existingSessionId = existingConversation?.metadata?.chatSettings?.sessionId;

      const metadata = {
        chatSettings: {
          providerId: this.selectedModel?.providerId,
          modelId: this.selectedModel?.modelId,
          promptId: this.selectedPrompt?.id,
          workspaceId: this.selectedWorkspaceId,
          contextNotes: this.contextNotesManager.getNotes(),
          sessionId: existingSessionId, // Preserve the session ID
          thinking: this.thinkingSettings,
          temperature: this.temperature
        }
      };

      await this.conversationService.updateConversationMetadata(conversationId, metadata);
    } catch (error) {
      // Failed to save to conversation
    }
  }

  /**
   * Get current selected model (sync - returns null if none selected)
   */
  getSelectedModel(): ModelOption | null {
    return this.selectedModel;
  }

  /**
   * Get current selected model or default (async - fetches default if none selected)
   */
  async getSelectedModelOrDefault(): Promise<ModelOption | null> {
    if (this.selectedModel) {
      return this.selectedModel;
    }

    // Get the default model
    const availableModels = await this.getAvailableModels();
    const defaultModel = await ModelSelectionUtility.findDefaultModelOption(this.app, availableModels);

    return defaultModel;
  }

  /**
   * Get current selected prompt
   */
  getSelectedPrompt(): PromptOption | null {
    return this.selectedPrompt;
  }

  /**
   * Get current system prompt (includes workspace context if set)
   */
  async getCurrentSystemPrompt(): Promise<string | null> {
    return await this.buildSystemPromptWithWorkspace();
  }

  /**
   * Get selected workspace ID
   */
  getSelectedWorkspaceId(): string | null {
    return this.selectedWorkspaceId;
  }

  /**
   * Get workspace context
   */
  getWorkspaceContext(): WorkspaceContext | null {
    return this.workspaceContext;
  }

  /**
   * Get full loaded workspace data (sessions, states, files, etc.)
   * This is the comprehensive data used in system prompts
   */
  getLoadedWorkspaceData(): any {
    return this.loadedWorkspaceData;
  }

  /**
   * Handle model selection change
   */
  handleModelChange(model: ModelOption | null): void {
    const previousProvider = this.selectedModel?.providerId || '';
    const newProvider = model?.providerId || '';

    this.selectedModel = model;
    this.events.onModelChanged(model);

    // Initialize or clear context token tracker based on provider
    this.updateContextTokenTracker(newProvider);

    // Notify Nexus lifecycle manager of provider changes
    if (previousProvider !== newProvider) {
      const lifecycleManager = getWebLLMLifecycleManager();
      lifecycleManager.handleProviderChanged(previousProvider, newProvider).catch(() => {
        // Lifecycle manager error handling
      });
    }
  }

  /**
   * Update context token tracker based on provider
   * Only local providers with limited context windows need tracking
   */
  private updateContextTokenTracker(provider: string): void {
    const contextWindow = LOCAL_PROVIDER_CONTEXT_WINDOWS[provider];

    if (contextWindow) {
      // Initialize or update tracker for local provider
      if (!this.contextTokenTracker) {
        this.contextTokenTracker = new ContextTokenTracker(contextWindow);
      } else {
        this.contextTokenTracker.setMaxTokens(contextWindow);
        this.contextTokenTracker.reset();
      }
    } else {
      // Clear tracker for API providers (they handle context internally)
      this.contextTokenTracker = null;
    }
  }

  /**
   * Handle prompt selection change
   */
  async handlePromptChange(prompt: PromptOption | null): Promise<void> {
    this.selectedPrompt = prompt;
    this.currentSystemPrompt = prompt?.systemPrompt || null;

    this.events.onPromptChanged(prompt);
    this.events.onSystemPromptChanged(await this.buildSystemPromptWithWorkspace());
  }

  /**
   * Set workspace context - loads full comprehensive data
   * When a workspace is selected in chat settings, load the same rich data
   * as the #workspace suggester (file structure, sessions, states, etc.)
   */
  async setWorkspaceContext(workspaceId: string, context: WorkspaceContext): Promise<void> {
    this.selectedWorkspaceId = workspaceId;
    this.workspaceContext = context; // Keep basic context for backward compatibility

    // Load full comprehensive workspace data (same as #workspace suggester)
    try {
      const fullWorkspaceData = await this.workspaceIntegration.loadWorkspace(workspaceId);
      if (fullWorkspaceData) {
        this.loadedWorkspaceData = fullWorkspaceData;
      }
    } catch (error) {
      console.error('[ModelAgentManager] Failed to load full workspace data:', error);
      this.loadedWorkspaceData = null;
    }

    // Get session ID from current conversation
    const sessionId = await this.getCurrentSessionId();

    if (sessionId) {
      await this.workspaceIntegration.bindSessionToWorkspace(sessionId, workspaceId);
    }

    this.events.onSystemPromptChanged(await this.buildSystemPromptWithWorkspace());
  }

  /**
   * Clear workspace context
   */
  async clearWorkspaceContext(): Promise<void> {
    this.selectedWorkspaceId = null;
    this.workspaceContext = null;
    this.loadedWorkspaceData = null;
    this.events.onSystemPromptChanged(await this.buildSystemPromptWithWorkspace());
  }

  /**
   * Get context notes
   */
  getContextNotes(): string[] {
    return this.contextNotesManager.getNotes();
  }

  /**
   * Set context notes
   */
  async setContextNotes(notes: string[]): Promise<void> {
    this.contextNotesManager.setNotes(notes);
    this.events.onSystemPromptChanged(await this.buildSystemPromptWithWorkspace());
  }

  /**
   * Add context note
   */
  async addContextNote(notePath: string): Promise<void> {
    if (this.contextNotesManager.addNote(notePath)) {
      this.events.onSystemPromptChanged(await this.buildSystemPromptWithWorkspace());
    }
  }

  /**
   * Remove context note by index
   */
  async removeContextNote(index: number): Promise<void> {
    if (this.contextNotesManager.removeNote(index)) {
      this.events.onSystemPromptChanged(await this.buildSystemPromptWithWorkspace());
    }
  }

  /**
   * Get thinking settings
   */
  getThinkingSettings(): ThinkingSettings {
    return { ...this.thinkingSettings };
  }

  /**
   * Set thinking settings
   */
  setThinkingSettings(settings: ThinkingSettings): void {
    this.thinkingSettings = { ...settings };
  }

  /**
   * Get temperature
   */
  getTemperature(): number {
    return this.temperature;
  }

  /**
   * Set temperature (clamped to 0.0-1.0)
   */
  setTemperature(temperature: number): void {
    this.temperature = Math.max(0, Math.min(1, temperature));
  }

  // ========== Context Token Tracking (for local providers) ==========

  /**
   * Record token usage from a generation response
   * Call this after streaming completes with actual usage data
   */
  recordTokenUsage(promptTokens: number, completionTokens: number): void {
    if (this.contextTokenTracker) {
      this.contextTokenTracker.recordUsage(promptTokens, completionTokens);
    }
  }

  /**
   * Get current context status (for UI display or compaction checks)
   */
  getContextStatus(): ContextStatus | null {
    return this.contextTokenTracker?.getStatus() || null;
  }

  /**
   * Check if message should trigger compaction before sending
   */
  shouldCompactBeforeSending(message: string): boolean {
    return this.contextTokenTracker?.shouldCompactBeforeSending(message) || false;
  }

  /**
   * Reset token tracker (after compaction or new conversation)
   */
  resetTokenTracker(): void {
    this.contextTokenTracker?.reset();
  }

  /**
   * Check if using a token-limited local model
   */
  isUsingLocalModel(): boolean {
    return this.contextTokenTracker !== null;
  }

  /**
   * Get the context token tracker (for direct access if needed)
   */
  getContextTokenTracker(): ContextTokenTracker | null {
    return this.contextTokenTracker;
  }

  // ========== Previous Context (from compaction) ==========

  /**
   * Set previous context from compaction
   * This will be injected into the system prompt as <previous_context>
   */
  setPreviousContext(context: CompactedContext): void {
    this.previousContext = context;
  }

  /**
   * Get the current previous context
   */
  getPreviousContext(): CompactedContext | null {
    return this.previousContext;
  }

  /**
   * Clear previous context (on new conversation or manual clear)
   */
  clearPreviousContext(): void {
    this.previousContext = null;
  }

  /**
   * Check if there is previous context from compaction
   */
  hasPreviousContext(): boolean {
    return this.previousContext !== null && this.previousContext.summary.length > 0;
  }

  /**
   * Set message enhancement from suggesters
   */
  setMessageEnhancement(enhancement: MessageEnhancement | null): void {
    this.messageEnhancement = enhancement;
  }

  /**
   * Get current message enhancement
   */
  getMessageEnhancement(): MessageEnhancement | null {
    return this.messageEnhancement;
  }

  /**
   * Clear message enhancement (call after message is sent)
   */
  clearMessageEnhancement(): void {
    this.messageEnhancement = null;
  }

  /**
   * Get available models from validated providers
   */
  async getAvailableModels(): Promise<ModelOption[]> {
    return await ModelSelectionUtility.getAvailableModels(this.app);
  }

  /**
   * Get available prompts from prompt manager
   */
  async getAvailablePrompts(): Promise<PromptOption[]> {
    return await PromptConfigurationUtility.getAvailablePrompts(this.app);
  }

  /**
   * Get message options for current selection (includes workspace context)
   */
  async getMessageOptions(): Promise<{
    provider?: string;
    model?: string;
    systemPrompt?: string;
    workspaceId?: string;
    sessionId?: string;
    enableThinking?: boolean;
    thinkingEffort?: 'low' | 'medium' | 'high';
    temperature?: number;
  }> {
    const sessionId = await this.getCurrentSessionId();

    return {
      provider: this.selectedModel?.providerId,
      model: this.selectedModel?.modelId,
      systemPrompt: await this.buildSystemPromptWithWorkspace() || undefined,
      workspaceId: this.selectedWorkspaceId || undefined,
      sessionId: sessionId,
      enableThinking: this.thinkingSettings.enabled,
      thinkingEffort: this.thinkingSettings.effort,
      temperature: this.temperature
    };
  }

  /**
   * Build system prompt with workspace context and dynamic context
   * Dynamic context (vault structure, workspaces, agents) is always fetched fresh
   */
  private async buildSystemPromptWithWorkspace(): Promise<string | null> {
    const sessionId = await this.getCurrentSessionId();

    // Fetch dynamic context (always fresh)
    const vaultStructure = this.workspaceIntegration.getVaultStructure();
    const availableWorkspaces = await this.workspaceIntegration.listAvailableWorkspaces();
    const availablePrompts = await this.getAvailablePromptSummaries();
    const toolAgents = this.getToolAgentInfo();

    // Skip tools section for Nexus/WebLLM - it's pre-trained on the toolset
    const isNexusModel = this.selectedModel?.providerId === 'webllm';

    // Get context status for token-limited models
    let contextStatus: ContextStatusInfo | null = null;
    if (this.contextTokenTracker) {
      const status = this.contextTokenTracker.getStatus();
      contextStatus = {
        usedTokens: status.usedTokens,
        maxTokens: status.maxTokens,
        percentUsed: status.percentUsed,
        status: status.status,
        statusMessage: this.contextTokenTracker.getStatusForPrompt()
      };
    }

    return await this.systemPromptBuilder.build({
      sessionId,
      workspaceId: this.selectedWorkspaceId || undefined,
      contextNotes: this.contextNotesManager.getNotes(),
      messageEnhancement: this.messageEnhancement,
      customPrompt: this.currentSystemPrompt,
      workspaceContext: this.workspaceContext,
      loadedWorkspaceData: this.loadedWorkspaceData, // Full comprehensive workspace data
      // Dynamic context (always loaded fresh)
      vaultStructure,
      availableWorkspaces,
      availablePrompts,
      toolAgents,
      // Nexus models are pre-trained on the toolset - skip tools section
      skipToolsSection: isNexusModel,
      // Context status for token-limited models
      contextStatus,
      // Previous context from compaction (if any)
      previousContext: this.previousContext
    });
  }

  /**
   * Get available prompts as summaries for system prompt
   * Note: These are user-created prompts, displayed in system prompt for LLM awareness
   */
  private async getAvailablePromptSummaries(): Promise<PromptSummary[]> {
    const prompts = await this.getAvailablePrompts();
    return prompts.map(prompt => ({
      id: prompt.id,
      name: prompt.name,
      description: prompt.description || 'Custom prompt'
    }));
  }

  /**
   * Get tool agents info from agent registry for system prompt
   * Returns agent names, descriptions, and their available tools
   */
  private getToolAgentInfo(): ToolAgentInfo[] {
    try {
      // Access plugin from app
      const appWithPlugins = this.app as AppWithPlugins;
      const plugin = appWithPlugins.plugins?.plugins?.['claudesidian-mcp'] as unknown as PluginWithSettings | undefined;
      if (!plugin) {
        return [];
      }

      // Try agentRegistrationService first (works on both desktop and mobile)
      const agentService = plugin.serviceManager?.getServiceIfReady?.('agentRegistrationService');
      if (agentService) {
        const agents = agentService.getAllAgents();
        const agentMap = agents instanceof Map ? agents : new Map(agents.map((a: any) => [a.name, a]));

        return Array.from(agentMap.entries()).map(([name, agent]: [string, any]) => {
          const agentTools = agent.getTools?.() || [];
          return {
            name,
            description: agent.description || '',
            tools: agentTools.map((t: any) => t.slug || t.name || 'unknown')
          };
        });
      }

      // Fallback to connector's agentRegistry (desktop only)
      const connector = plugin.connector;
      if (connector?.agentRegistry) {
        const agents = connector.agentRegistry.getAllAgents() as Map<string, any>;
        const result: ToolAgentInfo[] = [];

        for (const [name, agent] of agents) {
          const agentTools = agent.getTools?.() || [];
          result.push({
            name,
            description: agent.description || '',
            tools: agentTools.map((t: any) => t.slug || t.name || 'unknown')
          });
        }

        return result;
      }

      return [];
    } catch (error) {
      return [];
    }
  }

  /**
   * Get current session ID from conversation
   */
  private async getCurrentSessionId(): Promise<string | undefined> {
    if (!this.currentConversationId || !this.conversationService) {
      return undefined;
    }

    try {
      const conversation = await this.conversationService.getConversation(this.currentConversationId);
      return conversation?.metadata?.chatSettings?.sessionId;
    } catch (error) {
      return undefined;
    }
  }
}

```

## ui/chat/services/SuggesterRegistry.ts

```typescript
/**
 * SuggesterRegistry - Manages all suggester instances
 * Coordinates activation, tracks state, and provides central access point
 */

import { App } from 'obsidian';
import { BaseSuggester } from '../components/suggesters/base/BaseSuggester';
import {
  SuggesterType,
  SuggesterStatus
} from '../components/suggesters/base/SuggesterInterfaces';
import { MessageEnhancer } from './MessageEnhancer';

/**
 * Central registry for managing all suggester instances
 */
export class SuggesterRegistry {

  private app: App;
  private suggesters = new Map<SuggesterType, BaseSuggester<any>>();
  private messageEnhancer: MessageEnhancer;
  private activeSuggesters = new Set<SuggesterType>();

  constructor(app: App) {
    this.app = app;
    this.messageEnhancer = new MessageEnhancer();
  }

  // ==========================================================================
  // Registration
  // ==========================================================================

  /**
   * Register a suggester instance
   * @param type - Suggester type
   * @param suggester - Suggester instance
   */
  register<T>(type: SuggesterType, suggester: BaseSuggester<T>): void {
    this.suggesters.set(type, suggester);
  }

  /**
   * Unregister a suggester
   * @param type - Suggester type
   */
  unregister(type: SuggesterType): void {
    const suggester = this.suggesters.get(type);
    if (suggester) {
      // Clean up suggester resources
      if (typeof suggester.onDestroy === 'function') {
        suggester.onDestroy();
      }
      this.suggesters.delete(type);
      this.activeSuggesters.delete(type);
    }
  }

  /**
   * Unregister all suggesters
   */
  unregisterAll(): void {
    this.suggesters.forEach((suggester, type) => {
      this.unregister(type);
    });
  }

  // ==========================================================================
  // Access
  // ==========================================================================

  /**
   * Get a specific suggester
   * @param type - Suggester type
   * @returns Suggester instance or undefined
   */
  get<T>(type: SuggesterType): BaseSuggester<T> | undefined {
    return this.suggesters.get(type);
  }

  /**
   * Get all registered suggesters
   * @returns Map of all suggesters
   */
  getAll(): Map<SuggesterType, BaseSuggester<any>> {
    return new Map(this.suggesters);
  }

  /**
   * Get message enhancer instance
   * @returns MessageEnhancer
   */
  getMessageEnhancer(): MessageEnhancer {
    return this.messageEnhancer;
  }

  // ==========================================================================
  // State Management
  // ==========================================================================

  /**
   * Mark a suggester as active
   * @param type - Suggester type
   */
  setActive(type: SuggesterType): void {
    this.activeSuggesters.add(type);
  }

  /**
   * Mark a suggester as inactive
   * @param type - Suggester type
   */
  setInactive(type: SuggesterType): void {
    this.activeSuggesters.delete(type);
  }

  /**
   * Check if a suggester is active
   * @param type - Suggester type
   * @returns True if active
   */
  isActive(type: SuggesterType): boolean {
    return this.activeSuggesters.has(type);
  }

  /**
   * Get all active suggester types
   * @returns Set of active suggester types
   */
  getActiveTypes(): Set<SuggesterType> {
    return new Set(this.activeSuggesters);
  }

  /**
   * Check if any suggester is active
   * @returns True if at least one suggester is active
   */
  hasActiveSuggester(): boolean {
    return this.activeSuggesters.size > 0;
  }

  /**
   * Deactivate all suggesters
   */
  deactivateAll(): void {
    this.activeSuggesters.clear();
  }

  /**
   * Get status for a specific suggester
   * @param type - Suggester type
   * @returns Status object
   */
  getStatus(type: SuggesterType): SuggesterStatus {
    return {
      active: this.isActive(type)
    };
  }

  /**
   * Get status for all suggesters
   * @returns Map of statuses
   */
  getAllStatuses(): Map<SuggesterType, SuggesterStatus> {
    const statuses = new Map<SuggesterType, SuggesterStatus>();

    this.suggesters.forEach((_, type) => {
      statuses.set(type, this.getStatus(type));
    });

    return statuses;
  }

  // ==========================================================================
  // Utility
  // ==========================================================================

  /**
   * Check if a suggester type is registered
   * @param type - Suggester type
   * @returns True if registered
   */
  has(type: SuggesterType): boolean {
    return this.suggesters.has(type);
  }

  /**
   * Get count of registered suggesters
   * @returns Number of suggesters
   */
  count(): number {
    return this.suggesters.size;
  }

  /**
   * Clear all suggester caches
   */
  clearAllCaches(): void {
    this.suggesters.forEach(suggester => {
      if (typeof suggester.clearCache === 'function') {
        suggester.clearCache();
      }
    });
  }

  /**
   * Reset the message enhancer
   */
  resetMessageEnhancer(): void {
    this.messageEnhancer.clearEnhancements();
  }

  /**
   * Clean up all resources
   */
  destroy(): void {
    this.unregisterAll();
    this.messageEnhancer.clearEnhancements();
  }
}

```

## ui/chat/services/SystemPromptBuilder.ts

```typescript
/**
 * SystemPromptBuilder - Constructs system prompts for chat conversations
 *
 * Responsibilities:
 * - Build multi-section XML system prompts
 * - Inject session/workspace context for tool calls
 * - Add enhancement data from suggesters (tools, prompts, notes)
 * - Include custom prompts and workspace context
 * - Delegate file content reading to FileContentService
 *
 * Follows Single Responsibility Principle - only handles prompt composition.
 */

import { WorkspaceContext } from '../../../database/types/workspace/WorkspaceTypes';
import { MessageEnhancement } from '../components/suggesters/base/SuggesterInterfaces';
import { CompactedContext } from '../../../services/chat/ContextCompactionService';
import { formatWorkspaceDataForPrompt, extractWorkspaceData } from '../../../utils/WorkspaceDataFormatter';

/**
 * Vault structure for system prompt context
 */
export interface VaultStructure {
  rootFolders: string[];
  rootFiles: string[];
}

/**
 * Available workspace summary for system prompt
 */
export interface WorkspaceSummary {
  id: string;
  name: string;
  description?: string;
  rootFolder: string;
}

/**
 * Available prompt summary for system prompt (user-created prompts)
 */
export interface PromptSummary {
  id: string;
  name: string;
  description: string;
}

/**
 * Tool agent info for system prompt
 */
export interface ToolAgentInfo {
  name: string;
  description: string;
  tools: string[];
}

/**
 * Context status for token-limited models (e.g., Nexus 4K context)
 */
export interface ContextStatusInfo {
  usedTokens: number;
  maxTokens: number;
  percentUsed: number;
  status: 'ok' | 'warning' | 'critical';
  statusMessage: string;
}

export interface SystemPromptOptions {
  sessionId?: string;
  workspaceId?: string;
  contextNotes?: string[];
  messageEnhancement?: MessageEnhancement | null;
  customPrompt?: string | null;
  workspaceContext?: WorkspaceContext | null;
  // Full comprehensive workspace data from LoadWorkspaceTool (when workspace selected in settings)
  loadedWorkspaceData?: any | null;
  // Dynamic context (always loaded fresh)
  vaultStructure?: VaultStructure | null;
  availableWorkspaces?: WorkspaceSummary[];
  availablePrompts?: PromptSummary[];
  // Tool agents with their tools (dynamically loaded from agent registry)
  toolAgents?: ToolAgentInfo[];
  // Skip the tools section for models that are pre-trained on the toolset (e.g., Nexus)
  skipToolsSection?: boolean;
  // Context status for token-limited models (enables context awareness)
  contextStatus?: ContextStatusInfo | null;
  // Previous context from compaction (when conversation was truncated)
  previousContext?: CompactedContext | null;
}

export class SystemPromptBuilder {
  constructor(
    private readNoteContent: (notePath: string) => Promise<string>,
    private loadWorkspace?: (workspaceId: string) => Promise<any>
  ) {}

  /**
   * Build complete system prompt with all sections
   */
  async build(options: SystemPromptOptions): Promise<string | null> {
    const sections: string[] = [];

    // 0. Context status (for token-limited models like Nexus)
    // This goes FIRST so the model is immediately aware of its constraints
    if (options.contextStatus) {
      const contextStatusSection = this.buildContextStatusSection(options.contextStatus);
      if (contextStatusSection) {
        sections.push(contextStatusSection);
      }
    }

    // 0.5. Previous context (from compaction - truncated conversation summary)
    // This comes right after status so the model knows what came before
    if (options.previousContext && options.previousContext.summary) {
      const previousContextSection = this.buildPreviousContextSection(options.previousContext);
      if (previousContextSection) {
        sections.push(previousContextSection);
      }
    }

    // 1. Session context with tools overview (skip for pre-trained models like Nexus)
    if (!options.skipToolsSection) {
      const sessionSection = this.buildSessionContext(options.sessionId, options.workspaceId, options.toolAgents);
      if (sessionSection) {
        sections.push(sessionSection);
      }
    }

    // 2. Vault structure (dynamic - always fresh)
    const vaultStructureSection = this.buildVaultStructureSection(options.vaultStructure);
    if (vaultStructureSection) {
      sections.push(vaultStructureSection);
    }

    // 3. Available workspaces (dynamic - always fresh)
    const availableWorkspacesSection = this.buildAvailableWorkspacesSection(options.availableWorkspaces);
    if (availableWorkspacesSection) {
      sections.push(availableWorkspacesSection);
    }

    // 4. Available prompts (dynamic - always fresh)
    const availablePromptsSection = this.buildAvailablePromptsSection(options.availablePrompts);
    if (availablePromptsSection) {
      sections.push(availablePromptsSection);
    }

    // 5. Context files section
    const filesSection = await this.buildFilesSection(
      options.contextNotes || [],
      options.messageEnhancement
    );
    if (filesSection) {
      sections.push(filesSection);
    }

    // 6. Tool hints from /suggester
    const toolHintsSection = this.buildToolHintsSection(options.messageEnhancement);
    if (toolHintsSection) {
      sections.push(toolHintsSection);
    }

    // 7. Custom prompts from @suggester
    const customPromptsSection = this.buildCustomPromptsSection(options.messageEnhancement);
    if (customPromptsSection) {
      sections.push(customPromptsSection);
    }

    // 8. Workspace references from #suggester
    const workspaceReferencesSection = await this.buildWorkspaceReferencesSection(options.messageEnhancement);
    if (workspaceReferencesSection) {
      sections.push(workspaceReferencesSection);
    }

    // 9. Custom prompt (if prompt selected)
    const customPromptSection = this.buildSelectedPromptSection(options.customPrompt);
    if (customPromptSection) {
      sections.push(customPromptSection);
    }

    // 10. Selected workspace context (comprehensive data from settings selection)
    const workspaceSection = this.buildSelectedWorkspaceSection(
      options.loadedWorkspaceData,
      options.workspaceContext
    );
    if (workspaceSection) {
      sections.push(workspaceSection);
    }

    return sections.length > 0 ? sections.join('\n') : null;
  }

  /**
   * Build session context section for tool calls
   * Includes tools overview and context parameter instructions
   */
  private buildSessionContext(sessionId?: string, workspaceId?: string, toolAgents?: ToolAgentInfo[]): string | null {
    const effectiveSessionId = sessionId || `session_${Date.now()}`;
    const effectiveWorkspaceId = workspaceId || 'default';

    let prompt = '<tools_and_context>\n';

    // Tools overview - dynamically built from registered agents
    prompt += `AVAILABLE AGENTS AND TOOLS:
You have two meta-tools: getTools (discover) and useTools (execute).

`;

    if (toolAgents && toolAgents.length > 0) {
      // Dynamic list from agent registry - always use live tool manifest
      for (const agent of toolAgents) {
        prompt += `- ${agent.name}: ${agent.description}\n`;
        prompt += `  Tools: ${agent.tools.join(', ')}\n\n`;
      }
    } else {
      // No static fallback - use getTools to discover available tools
      prompt += `Use getTools to discover available agents and their tools.\n\n`;
    }

    prompt += `HOW TO USE TOOLS:

1. DISCOVER: Call getTools to get parameter schemas for tools you need
2. EXECUTE: Call useTools with context and calls array

Context (REQUIRED in every useTools call):
- workspaceId: "${effectiveWorkspaceId}"
- sessionId: "${effectiveSessionId}"
- memory: 1-3 sentences summarizing conversation so far
- goal: 1-3 sentences describing current objective
- constraints: (optional) any rules or limits

Calls array: [{ agent: "agentName", tool: "toolName", params: {...} }]

IMPORTANT:
- Keep workspaceId and sessionId EXACTLY as shown
- Update memory and goal as conversation evolves
- Use "params" (not "parameters") for tool-specific arguments
`;

    prompt += '</tools_and_context>';

    return prompt;
  }

  /**
   * Build files section with context notes and enhancement notes
   */
  private async buildFilesSection(
    contextNotes: string[],
    messageEnhancement?: MessageEnhancement | null
  ): Promise<string | null> {
    const hasContextNotes = contextNotes.length > 0;
    const hasEnhancementNotes = messageEnhancement && messageEnhancement.notes.length > 0;

    if (!hasContextNotes && !hasEnhancementNotes) {
      return null;
    }

    let prompt = '<files>\n';

    // Add context notes
    for (const notePath of contextNotes) {
      const xmlTag = this.normalizePathToXmlTag(notePath);
      const content = await this.readNoteContent(notePath);

      prompt += `<${xmlTag}>\n`;
      prompt += `${notePath}\n\n`;
      prompt += content || '[File content unavailable]';
      prompt += `\n</${xmlTag}>\n`;
    }

    // Add enhancement notes from [[suggester]]
    if (hasEnhancementNotes) {
      for (const note of messageEnhancement!.notes) {
        const xmlTag = this.normalizePathToXmlTag(note.path);
        prompt += `<${xmlTag}>\n`;
        prompt += `${note.path}\n\n`;
        prompt += this.escapeXmlContent(note.content);
        prompt += `\n</${xmlTag}>\n`;
      }
    }

    prompt += '</files>';

    return prompt;
  }

  /**
   * Build tool hints section from /suggester
   */
  private buildToolHintsSection(messageEnhancement?: MessageEnhancement | null): string | null {
    if (!messageEnhancement || messageEnhancement.tools.length === 0) {
      return null;
    }

    let prompt = '<tool_hints>\n';
    prompt += 'The user has requested to use the following tools:\n\n';

    for (const tool of messageEnhancement.tools) {
      prompt += `Tool: ${tool.name}\n`;
      prompt += `Description: ${tool.schema.description}\n`;
      prompt += 'Please prioritize using this tool when applicable.\n\n';
    }

    prompt += '</tool_hints>';

    return prompt;
  }

  /**
   * Build custom prompts section from @suggester
   */
  private buildCustomPromptsSection(messageEnhancement?: MessageEnhancement | null): string | null {
    if (!messageEnhancement || messageEnhancement.prompts.length === 0) {
      return null;
    }

    let prompt = '<custom_prompts>\n';
    prompt += 'The user has mentioned the following custom prompts. Apply their instructions:\n\n';

    for (const customPrompt of messageEnhancement.prompts) {
      prompt += `<prompt name="${this.escapeXmlAttribute(customPrompt.name)}">\n`;
      prompt += this.escapeXmlContent(customPrompt.prompt);
      prompt += `\n</prompt>\n\n`;
    }

    prompt += '</custom_prompts>';

    return prompt;
  }

  /**
   * Build workspace references section from #suggester
   * This provides comprehensive workspace data similar to the loadWorkspace tool
   */
  private async buildWorkspaceReferencesSection(messageEnhancement?: MessageEnhancement | null): Promise<string | null> {
    if (!messageEnhancement || messageEnhancement.workspaces.length === 0) {
      return null;
    }

    if (!this.loadWorkspace) {
      // If workspace loader not provided, just include basic info
      let prompt = '<workspaces>\n';
      prompt += 'The user has referenced the following workspaces:\n\n';

      for (const workspace of messageEnhancement.workspaces) {
        prompt += `Workspace: ${workspace.name}\n`;
        if (workspace.description) {
          prompt += `Description: ${workspace.description}\n`;
        }
        prompt += `Root Folder: ${workspace.rootFolder}\n\n`;
      }

      prompt += '</workspaces>';
      return prompt;
    }

    // Load full workspace data for each reference
    let prompt = '<workspaces>\n';
    prompt += 'The user has referenced the following workspaces. Use their context for your responses:\n\n';

    for (const workspaceRef of messageEnhancement.workspaces) {
      try {
        const workspaceData = await this.loadWorkspace(workspaceRef.id);
        if (workspaceData) {
          // Check if this is comprehensive data from LoadWorkspaceTool or basic workspace object
          const isComprehensive = workspaceData.context && typeof workspaceData.context === 'object' && 'name' in workspaceData.context;

          if (isComprehensive) {
            // Comprehensive workspace data from LoadWorkspaceTool
            const workspaceName = workspaceData.context?.name || workspaceRef.name;
            prompt += `<workspace name="${this.escapeXmlAttribute(workspaceName)}" id="${this.escapeXmlAttribute(workspaceRef.id)}">\n`;

            // Use shared utility for formatting
            prompt += this.escapeXmlContent(formatWorkspaceDataForPrompt(workspaceData));

            prompt += `\n</workspace>\n\n`;
          } else {
            // Basic workspace object (fallback)
            prompt += `<workspace name="${this.escapeXmlAttribute(workspaceData.name || workspaceRef.name)}" id="${this.escapeXmlAttribute(workspaceRef.id)}">\n`;

            prompt += this.escapeXmlContent(JSON.stringify({
              name: workspaceData.name,
              description: workspaceData.description,
              rootFolder: workspaceData.rootFolder,
              context: workspaceData.context
            }, null, 2));

            prompt += `\n</workspace>\n\n`;
          }
        }
      } catch (error) {
        console.error(`Failed to load workspace ${workspaceRef.id}:`, error);
        // Continue with other workspaces
      }
    }

    prompt += '</workspaces>';
    return prompt;
  }

  /**
   * Build selected prompt section (if prompt selected)
   */
  private buildSelectedPromptSection(customPrompt?: string | null): string | null {
    if (!customPrompt) {
      return null;
    }

    return `<selected_prompt>\n${customPrompt}\n</selected_prompt>`;
  }

  /**
   * Build selected workspace section with comprehensive data
   * When a workspace is selected in chat settings, include the full workspace data
   * (same rich context as the #workspace suggester)
   */
  private buildSelectedWorkspaceSection(
    loadedWorkspaceData?: any | null,
    workspaceContext?: WorkspaceContext | null
  ): string | null {
    // If we have full comprehensive data, use that
    if (loadedWorkspaceData) {
      const workspaceName = loadedWorkspaceData.context?.name ||
                           loadedWorkspaceData.name ||
                           'Selected Workspace';
      const workspaceId = loadedWorkspaceData.id || 'unknown';

      let prompt = `<selected_workspace name="${this.escapeXmlAttribute(workspaceName)}" id="${this.escapeXmlAttribute(workspaceId)}">\n`;
      prompt += 'This workspace is currently selected. Use its context for your responses:\n\n';

      // Use shared utility for formatting
      prompt += this.escapeXmlContent(formatWorkspaceDataForPrompt(loadedWorkspaceData));
      prompt += '\n</selected_workspace>';

      return prompt;
    }

    // Fallback to basic context if no comprehensive data
    if (!workspaceContext) {
      return null;
    }

    return `<selected_workspace>\n${JSON.stringify(workspaceContext, null, 2)}\n</selected_workspace>`;
  }

  /**
   * Build vault structure section (dynamic - shows root folders and files)
   * Provides the LLM with awareness of the vault's organization
   */
  private buildVaultStructureSection(vaultStructure?: VaultStructure | null): string | null {
    if (!vaultStructure) {
      return null;
    }

    const { rootFolders, rootFiles } = vaultStructure;

    // Don't include section if vault is empty
    if (rootFolders.length === 0 && rootFiles.length === 0) {
      return null;
    }

    let prompt = '<vault_structure>\n';
    prompt += 'The following is the root-level structure of the Obsidian vault:\n\n';

    if (rootFolders.length > 0) {
      prompt += 'Folders:\n';
      for (const folder of rootFolders) {
        prompt += `  - ${folder}/\n`;
      }
      prompt += '\n';
    }

    if (rootFiles.length > 0) {
      prompt += 'Files:\n';
      for (const file of rootFiles) {
        prompt += `  - ${file}\n`;
      }
    }

    prompt += '\nUse storageManager or searchManager tools to explore subfolders or search for specific content.\n';
    prompt += '</vault_structure>';

    return prompt;
  }

  /**
   * Build available workspaces section (dynamic - lists all workspaces)
   * Helps the LLM understand what workspaces exist and can be loaded
   */
  private buildAvailableWorkspacesSection(workspaces?: WorkspaceSummary[]): string | null {
    if (!workspaces || workspaces.length === 0) {
      return null;
    }

    let prompt = '<available_workspaces>\n';
    prompt += 'The following workspaces are available in this vault:\n\n';

    for (const workspace of workspaces) {
      prompt += `- ${this.escapeXmlContent(workspace.name)} (id: "${workspace.id}")\n`;
      if (workspace.description) {
        prompt += `  Description: ${this.escapeXmlContent(workspace.description)}\n`;
      }
      prompt += `  Root folder: ${workspace.rootFolder}\n`;
      prompt += '\n';
    }

    prompt += 'Use memoryManager with loadWorkspace mode to get full workspace context.\n';
    prompt += '</available_workspaces>';

    return prompt;
  }

  /**
   * Build available prompts section (dynamic - lists custom prompts)
   * Informs the LLM about custom prompts that can be used
   */
  private buildAvailablePromptsSection(prompts?: PromptSummary[]): string | null {
    if (!prompts || prompts.length === 0) {
      return null;
    }

    let prompt = '<available_prompts>\n';
    prompt += 'The following custom prompts are available:\n\n';

    for (const customPrompt of prompts) {
      prompt += `- ${this.escapeXmlContent(customPrompt.name)} (id: "${customPrompt.id}")\n`;
      prompt += `  ${this.escapeXmlContent(customPrompt.description)}\n\n`;
    }

    prompt += '</available_prompts>';

    return prompt;
  }

  /**
   * Normalize file path to valid XML tag name
   * Example: "Notes/Style Guide.md" -> "Notes_Style_Guide"
   */
  private normalizePathToXmlTag(path: string): string {
    return path
      .replace(/\.md$/i, '')  // Remove .md extension
      .replace(/[^a-zA-Z0-9_]/g, '_')  // Replace non-alphanumeric with underscore
      .replace(/^_+|_+$/g, '')  // Remove leading/trailing underscores
      .replace(/_+/g, '_');  // Collapse multiple underscores
  }

  /**
   * Escape XML content (text nodes)
   */
  private escapeXmlContent(content: string): string {
    return content
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
  }

  /**
   * Escape XML attribute values
   */
  private escapeXmlAttribute(value: string): string {
    return value
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }

  /**
   * Build context status section for token-limited models
   * Gives the model awareness of its context window usage
   */
  private buildContextStatusSection(contextStatus: ContextStatusInfo): string | null {
    let prompt = '<context_status>\n';
    prompt += `Tokens: ${contextStatus.usedTokens}/${contextStatus.maxTokens} (${contextStatus.percentUsed}% used)\n`;
    prompt += `Status: ${contextStatus.status.toUpperCase()}\n`;

    if (contextStatus.status === 'warning') {
      prompt += '\nIMPORTANT: Context is filling up. Consider:\n';
      prompt += '- Using saveState to preserve important context\n';
      prompt += '- Being concise in responses\n';
      prompt += '- Focusing on the current task\n';
    } else if (contextStatus.status === 'critical') {
      prompt += '\nCRITICAL: Context nearly full! Action required:\n';
      prompt += '- Use saveState NOW to preserve conversation before truncation\n';
      prompt += '- The system will auto-save state when threshold is reached\n';
    }

    prompt += '</context_status>';
    return prompt;
  }

  /**
   * Build previous context section from compacted conversation
   * This provides the model with a summary of what was discussed before truncation
   */
  private buildPreviousContextSection(previousContext: CompactedContext): string | null {
    let prompt = '<previous_context>\n';
    prompt += 'Note: Earlier conversation was compacted to stay within context limits.\n\n';

    // Main summary
    prompt += `Summary: ${previousContext.summary}\n`;

    // Files referenced (if any)
    if (previousContext.filesReferenced && previousContext.filesReferenced.length > 0) {
      prompt += `\nFiles discussed: ${previousContext.filesReferenced.slice(0, 5).join(', ')}`;
      if (previousContext.filesReferenced.length > 5) {
        prompt += ` (+${previousContext.filesReferenced.length - 5} more)`;
      }
      prompt += '\n';
    }

    // Topics (if any)
    if (previousContext.topics && previousContext.topics.length > 0) {
      prompt += `\nKey tasks: ${previousContext.topics.join('; ')}\n`;
    }

    // Stats
    prompt += `\n(${previousContext.messagesRemoved} messages compacted, ${previousContext.messagesKept} retained)`;

    prompt += '\n</previous_context>';
    return prompt;
  }
}

```

## ui/chat/services/WorkspaceIntegrationService.ts

```typescript
/**
 * Location: /src/ui/chat/services/WorkspaceIntegrationService.ts
 *
 * Purpose: Handles workspace loading, session binding, and dynamic context retrieval
 * Extracted from ModelAgentManager.ts to follow Single Responsibility Principle
 *
 * Used by: ModelAgentManager for workspace operations and dynamic context
 * Dependencies: WorkspaceService, SessionContextManager, Obsidian Vault API
 */

import { App, TFile, TFolder } from 'obsidian';
import { WorkspaceContext } from '../../../database/types/workspace/WorkspaceTypes';
import { VaultStructure, WorkspaceSummary } from './SystemPromptBuilder';
import { getNexusPlugin } from '../../../utils/pluginLocator';
import type NexusPlugin from '../../../main';
import type { WorkspaceService } from '../../../services/WorkspaceService';
import type { SessionContextManager } from '../../../services/SessionContextManager';
import type { AgentManager } from '../../../services/AgentManager';
import type { IAgent } from '../../../agents/interfaces/IAgent';

/**
 * Service for workspace integration with chat
 */
export class WorkspaceIntegrationService {
  constructor(private app: App) {}

  /**
   * Load workspace by ID with full context (like loadWorkspace tool)
   * This executes the LoadWorkspaceTool to get comprehensive data including file structure
   */
  async loadWorkspace(workspaceId: string): Promise<Record<string, unknown> | null> {
    try {
      const plugin = getNexusPlugin<NexusPlugin>(this.app);
      if (!plugin) {
        return null;
      }

      // Try to get the agentManager and memoryManager agent
      const agentManager = await plugin.getService<AgentManager>('agentManager');

      if (agentManager) {
        try {
          const memoryManager = agentManager.getAgent('memoryManager');

          if (memoryManager) {
            // Execute loadWorkspace tool to get comprehensive workspace data
            const result = await memoryManager.executeTool('loadWorkspace', {
              id: workspaceId,
              limit: 3 // Get recent sessions, states, and activity
            });

            if (result.success && result.data) {
              // Return the comprehensive workspace data from the tool
              return {
                id: workspaceId,
                ...result.data,
                // Keep the workspace context from the result
                workspaceContext: result.workspaceContext
              };
            }
          }
        } catch (agentError) {
          // If agent execution fails, fall through to basic workspace loading
          console.error('[WorkspaceIntegrationService] Agent execution failed:', agentError);
        }
      }

      // Fallback: just load basic workspace data if LoadWorkspaceTool fails
      const workspaceService = await plugin.getService<WorkspaceService>('workspaceService');
      if (workspaceService) {
        const workspace = await workspaceService.getWorkspace(workspaceId);
        // Convert IndividualWorkspace to Record<string, unknown> for dynamic usage
        return workspace as unknown as Record<string, unknown>;
      }

      return null;
    } catch (error) {
      console.error(`Error loading workspace ${workspaceId}:`, error);

      // Fallback: try basic workspace loading
      try {
        const plugin = getNexusPlugin<NexusPlugin>(this.app);
        const workspaceService = await plugin?.getService<WorkspaceService>('workspaceService');
        if (workspaceService) {
          const workspace = await workspaceService.getWorkspace(workspaceId);
          // Convert IndividualWorkspace to Record<string, unknown> for dynamic usage
          return workspace as unknown as Record<string, unknown>;
        }
      } catch (fallbackError) {
        console.error(`Fallback workspace loading also failed:`, fallbackError);
      }

      return null;
    }
  }

  /**
   * Read note content from vault
   */
  async readNoteContent(notePath: string): Promise<string> {
    try {
      const file = this.app.vault.getAbstractFileByPath(notePath);

      if (file instanceof TFile) {
        const content = await this.app.vault.read(file);
        return content;
      }

      return '[File not found]';
    } catch (error) {
      return '[Error reading file]';
    }
  }

  /**
   * Bind a session to a workspace in SessionContextManager
   */
  async bindSessionToWorkspace(sessionId: string | undefined, workspaceId: string): Promise<void> {
    if (!sessionId) {
      return;
    }

    try {
      const plugin = getNexusPlugin<NexusPlugin>(this.app);
      if (!plugin) {
        return;
      }

      const sessionContextManager = await plugin.getService<SessionContextManager>('sessionContextManager');

      if (sessionContextManager) {
        sessionContextManager.setWorkspaceContext(sessionId, {
          workspaceId: workspaceId,
          activeWorkspace: true
        });
      }
    } catch (error) {
      console.error('[WorkspaceIntegrationService] Failed to bind session to workspace:', error);
    }
  }

  /**
   * Get the root-level vault structure (folders and files)
   * Used to give the LLM awareness of the vault's organization
   */
  getVaultStructure(): VaultStructure {
    const rootFolders: string[] = [];
    const rootFiles: string[] = [];

    try {
      const root = this.app.vault.getRoot();

      if (root && root.children) {
        for (const child of root.children) {
          if (child instanceof TFolder) {
            // Skip hidden folders (starting with .)
            if (!child.name.startsWith('.')) {
              rootFolders.push(child.name);
            }
          } else if (child instanceof TFile) {
            // Skip hidden files (starting with .)
            if (!child.name.startsWith('.')) {
              rootFiles.push(child.name);
            }
          }
        }
      }

      // Sort alphabetically for consistent presentation
      rootFolders.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
      rootFiles.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
    } catch (error) {
      console.error('[WorkspaceIntegrationService] Failed to get vault structure:', error);
    }

    return { rootFolders, rootFiles };
  }

  /**
   * Get all available workspaces with summary information
   * Used to give the LLM awareness of what workspaces exist
   */
  async listAvailableWorkspaces(): Promise<WorkspaceSummary[]> {
    try {
      const plugin = getNexusPlugin<NexusPlugin>(this.app);
      if (!plugin) {
        return [];
      }

      const workspaceService = await plugin.getService<WorkspaceService>('workspaceService');

      if (!workspaceService) {
        return [];
      }

      // Use listWorkspaces for lightweight index-based listing
      const workspaces = await workspaceService.listWorkspaces();

      return workspaces.map((ws) => ({
        id: ws.id,
        name: ws.name,
        description: ws.description || undefined,
        rootFolder: ws.rootFolder || '/'
      }));
    } catch (error) {
      console.error('[WorkspaceIntegrationService] Failed to list workspaces:', error);
      return [];
    }
  }
}

```

## ui/chat/types/SelectionTypes.ts

```typescript
/**
 * Selection Types - Interfaces for model and prompt selection
 *
 * Used by: ModelSelectionUtility, TokenCalculator, ModelAgentManager
 */

export interface ModelOption {
  providerId: string;
  providerName: string;
  modelId: string;
  modelName: string;
  contextWindow: number;
  supportsThinking?: boolean;
}

export interface PromptOption {
  id: string;
  name: string;
  description?: string;
  systemPrompt: string;
}

```

## ui/chat/types/streaming.ts

```typescript
/**
 * Type definitions for streaming markdown state
 */

import type { Parser, Default_Renderer } from 'streaming-markdown';

/**
 * Streaming state for a message being rendered with streaming-markdown
 */
export interface StreamingState {
  parser: Parser;
  renderer: Default_Renderer;
  contentDiv: HTMLElement;
}

/**
 * Extended Element interface to support legacy loading interval storage
 */
export interface ElementWithLoadingInterval extends Element {
  _loadingInterval?: NodeJS.Timeout;
}

```

## ui/chat/utils/AbortHandler.ts

```typescript
/**
 * Location: /src/ui/chat/utils/AbortHandler.ts
 *
 * Purpose: Unified abort handling utility for AI message generation
 * Extracted from MessageManager.ts to eliminate DRY violations (4+ repeated abort patterns)
 *
 * Used by: MessageManager, MessageAlternativeService for handling abort scenarios
 * Dependencies: ChatService
 */

import { ConversationData, ConversationMessage } from '../../../types/chat/ChatTypes';
import { ChatService } from '../../../services/chat/ChatService';

export interface AbortHandlerEvents {
  onStreamingUpdate: (messageId: string, content: string, isComplete: boolean, isIncremental?: boolean) => void;
  onConversationUpdated: (conversation: ConversationData) => void;
}

/**
 * Handles abort scenarios for AI message generation
 * Consolidates repeated abort handling logic throughout MessageManager
 */
export class AbortHandler {
  constructor(
    private chatService: ChatService,
    private events: AbortHandlerEvents
  ) {}

  /**
   * Handle abort for an AI message being generated
   *
   * @param conversation - The conversation containing the message
   * @param aiMessageId - ID of the AI message being generated
   * @param customHandler - Optional custom handler for specific abort scenarios
   */
  async handleAbort(
    conversation: ConversationData,
    aiMessageId: string | null,
    customHandler?: (hasContent: boolean, aiMessage: ConversationMessage) => Promise<void>
  ): Promise<void> {
    if (!aiMessageId) return;

    const aiMessageIndex = conversation.messages.findIndex(msg => msg.id === aiMessageId);
    if (aiMessageIndex < 0) return;

    const aiMessage = conversation.messages[aiMessageIndex];
    const hasContent = aiMessage.content && aiMessage.content.trim();

    // Use custom handler if provided
    if (customHandler) {
      await customHandler(!!hasContent, aiMessage);
      return;
    }

    // Default abort handling
    if (hasContent) {
      // Keep partial response - clean up incomplete tool calls
      aiMessage.toolCalls = undefined; // Remove incomplete tool calls
      aiMessage.isLoading = false;
      aiMessage.state = 'aborted'; // Mark as aborted (will be included in context)

      // Save conversation with cleaned partial message
      await this.chatService.updateConversation(conversation);

      // Finalize streaming with partial content (stops animation, renders final content)
      this.events.onStreamingUpdate(aiMessageId, aiMessage.content, true, false);

      // Update UI to show final partial message
      this.events.onConversationUpdated(conversation);
    } else {
      // No content generated - mark as invalid and delete
      aiMessage.state = 'invalid'; // Mark as invalid (will be filtered from context)
      aiMessage.isLoading = false;

      // Delete the empty message entirely
      conversation.messages.splice(aiMessageIndex, 1);

      // Save conversation without the empty message
      await this.chatService.updateConversation(conversation);

      // Update UI to remove the empty message bubble
      this.events.onConversationUpdated(conversation);
    }
  }

  /**
   * Check if an error is an abort error
   */
  isAbortError(error: unknown): boolean {
    return error instanceof Error && error.name === 'AbortError';
  }

  /**
   * Handle abort with error checking
   * Convenience method that checks if error is abort before handling
   */
  async handleIfAbortError(
    error: unknown,
    conversation: ConversationData,
    aiMessageId: string | null,
    customHandler?: (hasContent: boolean, aiMessage: ConversationMessage) => Promise<void>
  ): Promise<boolean> {
    if (this.isAbortError(error)) {
      await this.handleAbort(conversation, aiMessageId, customHandler);
      return true;
    }
    return false;
  }
}

```

## ui/chat/utils/ChatEventBinder.ts

```typescript
/**
 * ChatEventBinder - Binds event handlers to chat UI elements
 * Location: /src/ui/chat/utils/ChatEventBinder.ts
 *
 * This class is responsible for:
 * - Wiring up new chat button event
 * - Wiring up settings button event
 * - Wiring up welcome screen button event
 *
 * Used by ChatView to bind event handlers to UI elements,
 * following the Single Responsibility Principle.
 */

import { Component } from 'obsidian';

export class ChatEventBinder {
  /**
   * Wire up new chat button
   */
  static bindNewChatButton(button: HTMLElement, createNewConversation: () => void, component: Component): void {
    component.registerDomEvent(button, 'click', () => createNewConversation());
  }

  /**
   * Wire up settings button
   */
  static bindSettingsButton(button: HTMLElement, openSettings: () => void, component: Component): void {
    component.registerDomEvent(button, 'click', () => openSettings());
  }

  /**
   * Wire up welcome screen button
   */
  static bindWelcomeButton(container: HTMLElement, createNewConversation: () => void, component: Component): void {
    const welcomeButton = container.querySelector('.chat-welcome-button');
    if (welcomeButton) {
      component.registerDomEvent(welcomeButton as HTMLElement, 'click', () => createNewConversation());
    }
  }
}

```

## ui/chat/utils/ContentEditableHelper.ts

```typescript
/**
 * ContentEditableHelper - Utility functions for contenteditable operations
 *
 * Provides DOM manipulation and cursor management for contenteditable elements
 */

export class ContentEditableHelper {
  /**
   * Get current cursor position as offset from start
   */
  static getCursorPosition(element: HTMLElement): number {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) return 0;

    const range = selection.getRangeAt(0);
    const preCaretRange = range.cloneRange();
    preCaretRange.selectNodeContents(element);
    preCaretRange.setEnd(range.endContainer, range.endOffset);

    return preCaretRange.toString().length;
  }

  /**
   * Set cursor position by offset from start
   */
  static setCursorPosition(element: HTMLElement, offset: number): void {
    const selection = window.getSelection();
    if (!selection) return;

    const range = this.createRangeAtOffset(element, offset);
    if (range) {
      selection.removeAllRanges();
      selection.addRange(range);
    }
  }

  /**
   * Create a Range at a specific text offset
   */
  private static createRangeAtOffset(element: HTMLElement, offset: number): Range | null {
    const range = document.createRange();
    let currentOffset = 0;

    const traverse = (node: Node): boolean => {
      if (node.nodeType === Node.TEXT_NODE) {
        const textLength = node.textContent?.length || 0;
        if (currentOffset + textLength >= offset) {
          range.setStart(node, offset - currentOffset);
          range.setEnd(node, offset - currentOffset);
          return true;
        }
        currentOffset += textLength;
      } else {
        for (const child of Array.from(node.childNodes)) {
          if (traverse(child)) return true;
        }
      }
      return false;
    };

    if (traverse(element)) {
      return range;
    }

    // If offset is beyond content, place at end
    range.selectNodeContents(element);
    range.collapse(false);
    return range;
  }

  /**
   * Get text before cursor on current line
   */
  static getTextBeforeCursor(element: HTMLElement): string {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) return '';

    const range = selection.getRangeAt(0);
    const preCaretRange = range.cloneRange();
    preCaretRange.selectNodeContents(element);
    preCaretRange.setEnd(range.endContainer, range.endOffset);

    return preCaretRange.toString();
  }

  /**
   * Insert a styled reference node at cursor position
   */
  static insertReferenceNode(
    element: HTMLElement,
    type: 'tool' | 'prompt' | 'note' | 'workspace',
    displayText: string,
    technicalName: string
  ): void {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) return;

    const range = selection.getRangeAt(0);

    // Create reference span
    const refSpan = document.createElement('span');
    refSpan.className = `chat-reference chat-reference-${type}`;
    refSpan.contentEditable = 'false';
    refSpan.setAttribute('data-type', type);
    refSpan.setAttribute('data-name', technicalName);
    refSpan.textContent = displayText;

    // Add space after reference
    const space = document.createTextNode(' ');

    // Insert nodes
    range.deleteContents();
    range.insertNode(space);
    range.insertNode(refSpan);

    // Move cursor after space
    range.setStartAfter(space);
    range.setEndAfter(space);
    selection.removeAllRanges();
    selection.addRange(range);

    // Trigger input event
    element.dispatchEvent(new Event('input', { bubbles: true }));
  }

  /**
   * Delete text at cursor position
   */
  static deleteTextAtCursor(element: HTMLElement, startOffset: number, endOffset: number): void {
    const range = this.createRangeAtOffset(element, startOffset);
    if (!range) return;

    const endRange = this.createRangeAtOffset(element, endOffset);
    if (!endRange) return;

    range.setEnd(endRange.endContainer, endRange.endOffset);
    range.deleteContents();

    // Update selection
    const selection = window.getSelection();
    if (selection) {
      selection.removeAllRanges();
      selection.addRange(range);
    }

    element.dispatchEvent(new Event('input', { bubbles: true }));
  }

  /**
   * Get plain text content from contenteditable element
   */
  static getPlainText(element: HTMLElement): string {
    return element.textContent || '';
  }

  /**
   * Set plain text content (replaces all content)
   */
  static setPlainText(element: HTMLElement, text: string): void {
    element.textContent = text;
  }

  /**
   * Clear all content
   */
  static clear(element: HTMLElement): void {
    element.innerHTML = '';
  }

  /**
   * Focus the contenteditable element
   */
  static focus(element: HTMLElement): void {
    element.focus();

    // Place cursor at end
    const selection = window.getSelection();
    if (selection) {
      const range = document.createRange();
      range.selectNodeContents(element);
      range.collapse(false);
      selection.removeAllRanges();
      selection.addRange(range);
    }
  }

  /**
   * Check if element is empty (no text content)
   */
  static isEmpty(element: HTMLElement): boolean {
    return !element.textContent?.trim();
  }

  /**
   * Insert text at cursor position
   */
  static insertTextAtCursor(element: HTMLElement, text: string): void {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) return;

    const range = selection.getRangeAt(0);
    const textNode = document.createTextNode(text);

    range.deleteContents();
    range.insertNode(textNode);

    // Move cursor after inserted text
    range.setStartAfter(textNode);
    range.setEndAfter(textNode);
    selection.removeAllRanges();
    selection.addRange(range);

    element.dispatchEvent(new Event('input', { bubbles: true }));
  }
}

```

## ui/chat/utils/ContentProcessor.ts

```typescript
/**
 * ContentProcessor - Handles content formatting, escaping, and processing utilities
 */

export class ContentProcessor {
  /**
   * Escape HTML for safe display
   */
  static escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Unescape HTML entities
   */
  static unescapeHtml(html: string): string {
    const doc = new DOMParser().parseFromString(html, 'text/html');
    return doc.body.textContent || '';
  }

  /**
   * Process markdown content for display (basic implementation)
   */
  static processMarkdown(content: string): string {
    // Simple markdown processing - can be enhanced later
    let processed = content;
    
    // Code blocks
    processed = processed.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code class="language-$1">$2</code></pre>');
    
    // Inline code
    processed = processed.replace(/`([^`]+)`/g, '<code>$1</code>');
    
    // Bold
    processed = processed.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    
    // Italic
    processed = processed.replace(/\*([^*]+)\*/g, '<em>$1</em>');
    
    // Headers
    processed = processed.replace(/^### (.*$)/gim, '<h3>$1</h3>');
    processed = processed.replace(/^## (.*$)/gim, '<h2>$1</h2>');
    processed = processed.replace(/^# (.*$)/gim, '<h1>$1</h1>');
    
    // Lists
    processed = processed.replace(/^[\s]*\* (.+)$/gm, '<li>$1</li>');
    processed = processed.replace(/^[\s]*- (.+)$/gm, '<li>$1</li>');
    
    // Wrap consecutive list items in ul tags  
    processed = processed.replace(/(<li>.*<\/li>)/g, '<ul>$1</ul>');
    
    // Line breaks
    processed = processed.replace(/\n/g, '<br>');
    
    return processed;
  }

  /**
   * Sanitize content to prevent XSS
   */
  static sanitizeContent(content: string): string {
    // Remove potentially dangerous tags and attributes
    const dangerous = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;
    let sanitized = content.replace(dangerous, '');
    
    // Remove javascript: and data: URLs
    sanitized = sanitized.replace(/javascript:/gi, '');
    sanitized = sanitized.replace(/data:/gi, '');
    
    // Remove on* event handlers
    sanitized = sanitized.replace(/on\w+\s*=/gi, '');
    
    return sanitized;
  }

  /**
   * Truncate text to specified length with ellipsis
   */
  static truncateText(text: string, maxLength: number, ellipsis: string = '...'): string {
    if (text.length <= maxLength) {
      return text;
    }
    
    return text.substring(0, maxLength - ellipsis.length) + ellipsis;
  }

  /**
   * Extract plain text from HTML content
   */
  static extractPlainText(html: string): string {
    const doc = new DOMParser().parseFromString(html, 'text/html');
    return doc.body.textContent || '';
  }

  /**
   * Format conversation preview text
   */
  static formatConversationPreview(lastMessage: string, maxLength: number = 100): string {
    // Remove markdown formatting for preview
    let preview = lastMessage
      .replace(/```[\s\S]*?```/g, '[code block]') // Replace code blocks
      .replace(/`([^`]+)`/g, '$1') // Remove inline code backticks
      .replace(/\*\*([^*]+)\*\*/g, '$1') // Remove bold
      .replace(/\*([^*]+)\*/g, '$1') // Remove italic
      .replace(/^#+\s*/gm, '') // Remove headers
      .replace(/^\s*[-*]\s*/gm, '') // Remove list markers
      .replace(/\n+/g, ' ') // Replace newlines with spaces
      .trim();
    
    return this.truncateText(preview, maxLength);
  }

  /**
   * Validate and clean message content
   */
  static cleanMessageContent(content: string): string {
    // Trim whitespace
    let cleaned = content.trim();
    
    // Remove excessive whitespace
    cleaned = cleaned.replace(/\s+/g, ' ');
    
    // Remove null bytes
    cleaned = cleaned.replace(/\0/g, '');
    
    return cleaned;
  }

  /**
   * Check if content is safe for display
   */
  static isContentSafe(content: string): boolean {
    // Check for dangerous patterns
    const dangerousPatterns = [
      /<script/i,
      /javascript:/i,
      /data:text\/html/i,
      /vbscript:/i,
      /on\w+\s*=/i
    ];
    
    return !dangerousPatterns.some(pattern => pattern.test(content));
  }

  /**
   * Format file size for display
   */
  static formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 B';
    
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  }
}
```

## ui/chat/utils/MarkdownRenderer.ts

```typescript
/**
 * Enhanced Markdown Renderer Service
 * 
 * Provides streaming markdown rendering using streaming-markdown library
 * with fallback to Obsidian's native MarkdownRenderer API for final rendering.
 */

import { App, Component, MarkdownRenderer as ObsidianMarkdownRenderer } from 'obsidian';
import * as smd from 'streaming-markdown';
import type { StreamingState } from '../types/streaming';

export class MarkdownRenderer {
  
  /**
   * Render complete markdown content using Obsidian's native renderer
   * This provides full markdown support including blockquotes, checkboxes, strikethrough, etc.
   */
  static async renderMarkdown(
    content: string, 
    container: HTMLElement, 
    app: App, 
    component: Component
  ): Promise<void> {
    try {
      // Clear container first
      container.empty();
      
      // Use Obsidian's native markdown renderer
      await ObsidianMarkdownRenderer.render(
        app,
        content,
        container,
        '', // sourcePath - empty for chat context
        component
      );
      
    } catch (error) {
      console.error('[MarkdownRenderer] Error rendering markdown:', error);
      // Fallback to plain text if rendering fails
      this.renderPlainText(content, container);
    }
  }

  /**
   * Initialize streaming markdown parser for progressive rendering
   */
  static initializeStreamingParser(container: HTMLElement): StreamingState {
    
    // Clear container
    container.empty();
    
    // Create dedicated content container for streaming-markdown
    const contentDiv = document.createElement('div');
    contentDiv.className = 'streaming-content';
    container.appendChild(contentDiv);
    
    
    // Initialize streaming-markdown renderer with content div
    const renderer = smd.default_renderer(contentDiv);
    const parser = smd.parser(renderer);
    
    
    return { parser, renderer, contentDiv };
  }

  /**
   * Write chunk to streaming markdown parser
   */
  static writeStreamingChunk(streamingState: StreamingState, chunk: string): void {
    
    if (streamingState && streamingState.parser) {
      try {
        smd.parser_write(streamingState.parser, chunk);
        
      } catch (error) {
        console.error('[MarkdownRenderer] Error writing streaming chunk:', error);
      }
    }
  }

  /**
   * Finalize streaming parser and optionally render with Obsidian
   */
  static async finalizeStreamingContent(
    streamingState: StreamingState,
    finalContent: string,
    container: HTMLElement,
    app: App,
    component: Component,
    useObsidianRenderer: boolean = true
  ): Promise<void> {
    // Finalize streaming parser
    if (streamingState && streamingState.parser) {
      try {
        smd.parser_end(streamingState.parser);
      } catch (error) {
        console.error('[MarkdownRenderer] Error finalizing streaming parser:', error);
      }
    }
    
    // Optionally replace with Obsidian's native renderer for advanced features
    if (useObsidianRenderer && this.hasAdvancedMarkdownFeatures(finalContent)) {
      // Remove streaming content
      const streamingContent = container.querySelector('.streaming-content');
      if (streamingContent) {
        streamingContent.remove();
      }
      
      // Render final content with full Obsidian renderer
      const finalDiv = document.createElement('div');
      finalDiv.className = 'final-content';
      container.appendChild(finalDiv);
      
      try {
        await ObsidianMarkdownRenderer.render(
          app,
          finalContent,
          finalDiv,
          '',
          component
        );
      } catch (error) {
        console.error('[MarkdownRenderer] Error finalizing with Obsidian renderer:', error);
        // Keep the streaming-markdown result
        if (streamingContent) {
          container.appendChild(streamingContent);
        }
      }
    }
  }

  /**
   * Check if content has advanced markdown features that benefit from Obsidian renderer
   */
  private static hasAdvancedMarkdownFeatures(content: string): boolean {
    const advancedPatterns = [
      /^-\s\[[x\s]\]/m, // Checkboxes
      /^\>/m, // Blockquotes  
      /\[\[.*\]\]/m, // Internal links
      /!\[\[.*\]\]/m, // Embedded files
      /^\|.*\|/m, // Tables
      /^```\w/m, // Code blocks with language
    ];
    
    return advancedPatterns.some(pattern => pattern.test(content));
  }

  /**
   * Fallback plain text rendering
   */
  private static renderPlainText(content: string, container: HTMLElement): void {
    const pre = document.createElement('pre');
    pre.className = 'markdown-renderer-plaintext';
    pre.textContent = content;
    container.appendChild(pre);
  }

  /**
   * Escape HTML for safe display
   */
  private static escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  /**
   * Check if content appears to be markdown (has common markdown patterns)
   */
  static hasMarkdownFormatting(content: string): boolean {
    const markdownPatterns = [
      /^#{1,6}\s/, // Headers
      /^\*\s|\d+\.\s/, // Lists
      /^\>\s/, // Blockquotes
      /^-\s\[[\sx]\]\s/, // Checkboxes
      /\*\*.*\*\*/, // Bold
      /\*.*\*/, // Italic
      /`.*`/, // Inline code
      /```/, // Code blocks
      /~~.*~~/, // Strikethrough
    ];
    
    return markdownPatterns.some(pattern => pattern.test(content));
  }
}
```

## ui/chat/utils/ModelSelectionUtility.ts

```typescript
/**
 * Location: /src/ui/chat/utils/ModelSelectionUtility.ts
 *
 * Purpose: Utility for model selection and discovery
 * Extracted from ModelAgentManager.ts to follow Single Responsibility Principle
 *
 * Used by: ModelAgentManager for model-related operations
 * Dependencies: LLMService, ProviderUtils
 */

import { Plugin } from 'obsidian';
import { ModelOption } from '../types/SelectionTypes';
import { ProviderUtils } from '../utils/ProviderUtils';
import { getNexusPlugin } from '../../../utils/pluginLocator';
import { getAvailableProviders } from '../../../utils/platform';
import { ModelWithProvider } from '../../../services/llm/core/ModelDiscoveryService';
import { Settings } from '../../../settings';

/**
 * Interface for LLMService with getAvailableModels method
 */
interface LLMServiceWithModels {
  getAvailableModels(): Promise<ModelWithProvider[]>;
}

/**
 * Extended plugin interface with required properties
 */
interface NexusPluginExtended extends Plugin {
  settings: Settings;
  getService<T>(name: string): Promise<T | null>;
  loadData(): Promise<any>;
}

/**
 * Utility class for model selection and management
 */
export class ModelSelectionUtility {
  /**
   * Get available models from validated providers
   */
  static async getAvailableModels(app: any): Promise<ModelOption[]> {
    try {
      // Get plugin instance to access LLMService
      const plugin = getNexusPlugin<NexusPluginExtended>(app);
      if (!plugin) {
        return [];
      }

      // Get LLMService which has ModelDiscoveryService
      const llmService = await plugin.getService<LLMServiceWithModels>('llmService');
      if (!llmService) {
        return [];
      }

      // Allowed providers for chat view
      const allowedProviders = getAvailableProviders();

      // Get all available models from ModelDiscoveryService (via LLMService)
      const allModels = await llmService.getAvailableModels();

      // Filter to allowed providers and convert to ModelOption format
      const models: ModelOption[] = allModels
        .filter((model: ModelWithProvider) => allowedProviders.includes(model.provider))
        .map((model: ModelWithProvider) => ModelSelectionUtility.mapToModelOption(model));

      return models;
    } catch (error) {
      return [];
    }
  }

  /**
   * Get the configured default model from plugin settings
   */
  static async getDefaultModel(app: any): Promise<{ provider: string; model: string }> {
    try {
      const plugin = getNexusPlugin<NexusPluginExtended>(app);
      if (!plugin) {
        throw new Error('Plugin not found');
      }

      // Try to get from in-memory settings first (more reliable)
      const settingsManager = plugin.settings;
      const inMemorySettings = settingsManager?.settings?.llmProviders?.defaultModel;

      if (inMemorySettings?.provider && inMemorySettings?.model) {
        return inMemorySettings;
      }

      // Fallback to raw data.json
      const pluginData = await plugin.loadData();
      const defaultModel = pluginData?.llmProviders?.defaultModel;

      if (defaultModel?.provider && defaultModel?.model) {
        return defaultModel;
      }

      // If still no default, return the hardcoded default (openai/gpt-4o)
      // This prevents errors during initial setup
      return { provider: 'openai', model: 'gpt-4o' };
    } catch (error) {
      // Return fallback instead of throwing to prevent UI errors
      return { provider: 'openai', model: 'gpt-4o' };
    }
  }

  /**
   * Find default model in available models
   */
  static async findDefaultModelOption(
    app: any,
    availableModels: ModelOption[]
  ): Promise<ModelOption | null> {
    try {
      const defaultModelConfig = await ModelSelectionUtility.getDefaultModel(app);

      const defaultModel = availableModels.find(
        m => m.providerId === defaultModelConfig.provider &&
             m.modelId === defaultModelConfig.model
      );

      return defaultModel || null;
    } catch (error) {
      console.error('[ModelSelectionUtility] Failed to find default model:', error);
      return null;
    }
  }

  /**
   * Convert ModelWithProvider to ModelOption format
   */
  static mapToModelOption(model: ModelWithProvider): ModelOption {
    return {
      providerId: model.provider,
      providerName: ModelSelectionUtility.getProviderDisplayName(model.provider),
      modelId: model.id,
      modelName: model.name,
      contextWindow: model.contextWindow || 128000, // Default if not specified
      supportsThinking: model.supportsThinking || false
    };
  }

  /**
   * Get display name for provider with tool calling indicator
   */
  static getProviderDisplayName(providerId: string): string {
    return ProviderUtils.getProviderDisplayNameWithTools(providerId);
  }
}

```

## ui/chat/utils/PromptConfigurationUtility.ts

```typescript
/**
 * Location: /src/ui/chat/utils/PromptConfigurationUtility.ts
 *
 * Purpose: Utility for custom prompt discovery and configuration
 * Extracted from ModelAgentManager.ts to follow Single Responsibility Principle
 *
 * Used by: ModelAgentManager for prompt-related operations
 * Dependencies: PromptDiscoveryService
 */

import { PromptOption } from '../types/SelectionTypes';
import { PromptDiscoveryService, PromptInfo } from '../../../services/agent/PromptDiscoveryService';
import { getNexusPlugin } from '../../../utils/pluginLocator';
import type { App } from 'obsidian';
import type NexusPlugin from '../../../main';

/**
 * Utility class for prompt configuration and discovery
 */
export class PromptConfigurationUtility {
  private static promptDiscoveryService: PromptDiscoveryService | null = null;

  /**
   * Initialize prompt discovery service
   */
  static async initializeDiscoveryService(app: App): Promise<PromptDiscoveryService | null> {
    if (PromptConfigurationUtility.promptDiscoveryService) {
      return PromptConfigurationUtility.promptDiscoveryService;
    }

    try {
      const plugin = getNexusPlugin<NexusPlugin>(app);
      if (!plugin) {
        return null;
      }

      const customPromptStorageService = await plugin.getService('customPromptStorageService');
      if (!customPromptStorageService) {
        return null;
      }

      PromptConfigurationUtility.promptDiscoveryService = new PromptDiscoveryService(customPromptStorageService);
      return PromptConfigurationUtility.promptDiscoveryService;
    } catch (error) {
      console.error('[PromptConfigurationUtility] Failed to initialize discovery service:', error);
      return null;
    }
  }

  /**
   * Get available prompts from prompt manager
   */
  static async getAvailablePrompts(app: App): Promise<PromptOption[]> {
    try {
      // Initialize PromptDiscoveryService if needed
      const discoveryService = await PromptConfigurationUtility.initializeDiscoveryService(app);
      if (!discoveryService) {
        return [];
      }

      // Get enabled prompts from discovery service
      const prompts = await discoveryService.getEnabledPrompts();

      // Convert to PromptOption format
      return prompts.map(prompt => PromptConfigurationUtility.mapToPromptOption(prompt));
    } catch (error) {
      console.error('[PromptConfigurationUtility] Failed to get available prompts:', error);
      return [];
    }
  }

  /**
   * Convert PromptInfo to PromptOption format
   */
  static mapToPromptOption(promptData: PromptInfo): PromptOption {
    return {
      id: promptData.id,
      name: promptData.name || 'Unnamed Prompt',
      description: promptData.description || 'Custom prompt',
      systemPrompt: promptData.prompt
    };
  }

  /**
   * Reset discovery service (for testing or reinitialization)
   */
  static resetDiscoveryService(): void {
    PromptConfigurationUtility.promptDiscoveryService = null;
  }
}

```

## ui/chat/utils/ProviderUtils.ts

```typescript
/**
 * ProviderUtils - Utilities for provider and display name formatting
 */

export class ProviderUtils {
  /**
   * Get display name for provider
   */
  static getProviderDisplayName(providerId: string): string {
    const displayNames: Record<string, string> = {
      'openai': 'OpenAI',
      'anthropic': 'Anthropic',
      'mistral': 'Mistral AI',
      'ollama': 'Ollama',
      'lmstudio': 'LM Studio',
      'webllm': 'Nexus (Local)',
      'openrouter': 'OpenRouter',
      'google': 'Google',
      'cohere': 'Cohere',
      'huggingface': 'Hugging Face',
      'groq': 'Groq',
      'perplexity': 'Perplexity',
      'requesty': 'Requesty'
    };
    return displayNames[providerId] || this.capitalizeString(providerId);
  }

  /**
   * Capitalize agent name for display
   */
  static capitalizeAgentName(agentId: string): string {
    return agentId
      .split(/[-_]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  /**
   * Capitalize a string
   */
  static capitalizeString(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  /**
   * Format model name for display
   */
  static formatModelName(modelId: string, modelName?: string): string {
    if (modelName) {
      return modelName;
    }
    
    // Convert model IDs to readable names
    const modelDisplayNames: Record<string, string> = {
      'gpt-4': 'GPT-4',
      'gpt-4-turbo': 'GPT-4 Turbo',
      'gpt-3.5-turbo': 'GPT-3.5 Turbo',
      'claude-3-opus': 'Claude 3 Opus',
      'claude-3-sonnet': 'Claude 3 Sonnet',
      'claude-3-haiku': 'Claude 3 Haiku',
      'mistral-large': 'Mistral Large',
      'mistral-medium': 'Mistral Medium',
      'mistral-small': 'Mistral Small'
    };

    return modelDisplayNames[modelId] || this.capitalizeString(modelId.replace(/-/g, ' '));
  }

  /**
   * Get provider color for UI theming
   */
  static getProviderColor(providerId: string): string {
    const colors: Record<string, string> = {
      'openai': '#10a37f',
      'anthropic': '#d97757',
      'mistral': '#ff6b35',
      'ollama': '#000000',
      'lmstudio': '#4A90E2',
      'webllm': '#00d4aa',  // WebGPU green
      'openrouter': '#8b5cf6',
      'google': '#4285f4',
      'cohere': '#39c6b9',
      'huggingface': '#ff9a00'
    };
    return colors[providerId] || '#6b7280';
  }

  /**
   * Get provider icon (emoji or symbol)
   */
  static getProviderIcon(providerId: string): string {
    const icons: Record<string, string> = {
      'openai': 'ðŸ¤–',
      'anthropic': 'ðŸ§ ',
      'mistral': 'ðŸŒªï¸',
      'ollama': 'ðŸ¦™',
      'lmstudio': 'ðŸ–¥ï¸',
      'webllm': 'ðŸŒ',
      'openrouter': 'ðŸ”€',
      'google': 'ðŸ”',
      'cohere': 'ðŸ§¬',
      'huggingface': 'ðŸ¤—'
    };
    return icons[providerId] || 'ðŸ¤–';
  }

  /**
   * Format context window size for display
   */
  static formatContextWindow(contextWindow: number): string {
    if (contextWindow >= 1000000) {
      return `${(contextWindow / 1000000).toFixed(1)}M tokens`;
    } else if (contextWindow >= 1000) {
      return `${(contextWindow / 1000).toFixed(0)}K tokens`;
    } else {
      return `${contextWindow} tokens`;
    }
  }

  /**
   * Get short provider abbreviation
   */
  static getProviderAbbreviation(providerId: string): string {
    const abbreviations: Record<string, string> = {
      'openai': 'OAI',
      'anthropic': 'ANT',
      'mistral': 'MST',
      'ollama': 'OLL',
      'lmstudio': 'LMS',
      'webllm': 'WEB',
      'openrouter': 'OR',
      'google': 'GGL',
      'cohere': 'COH',
      'huggingface': 'HF'
    };
    return abbreviations[providerId] || providerId.substring(0, 3).toUpperCase();
  }

  /**
   * Check if provider supports streaming
   */
  static supportsStreaming(providerId: string): boolean {
    const streamingProviders = [
      'openai',
      'anthropic',
      'mistral',
      'ollama',
      'lmstudio',    // âœ… LM Studio streaming via OpenAI-compatible API
      'webllm',      // âœ… WebLLM streaming via MLC.ai WebGPU
      'openrouter',
      'google',      // âœ… Google Gemini streaming via generateContentStream
      'groq'         // âœ… Groq streaming support
    ];
    return streamingProviders.includes(providerId);
  }

  /**
   * Check if provider supports function calling (tool calling)
   * Based on API documentation research as of 2024-2025
   */
  static supportsFunctionCalling(providerId: string): boolean {
    const functionCallingProviders = [
      'openai',      // âœ… Native OpenAI function calling
      'lmstudio',    // âœ… OpenAI-compatible function calling (model-dependent)
      'webllm',      // âœ… [TOOL_CALLS] content format for fine-tuned models
      'openrouter',  // âœ… OpenAI-compatible function calling
      'groq',        // âœ… OpenAI-compatible function calling
      'mistral',     // âœ… Native Mistral function calling
      'requesty',    // âœ… OpenAI-compatible function calling
      'anthropic',   // âœ… Native Claude tool calling
      'google'       // âœ… Native Google Gemini function calling (functionDeclarations)
    ];
    // Note: Perplexity does NOT support function calling (web search focused)
    return functionCallingProviders.includes(providerId);
  }

  /**
   * Get lucide wrench icon SVG for providers that support function calling
   */
  static getToolIconSVG(): string {
    return '<svg class="lucide lucide-wrench" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>';
  }

  /**
   * Get provider display name with tool icon if supported
   * For optgroup labels, uses text-based indicator since HTML isn't supported
   */
  static getProviderDisplayNameWithTools(providerId: string): string {
    const displayName = this.getProviderDisplayName(providerId);
    const supportsTools = this.supportsFunctionCalling(providerId);
    
    if (supportsTools) {
      return `${displayName} ðŸ”§`; // Using emoji for optgroup compatibility
    }
    return displayName;
  }

  /**
   * Get provider display name with HTML tool icon for other UI contexts
   * Returns HTML string with SVG icon for tool-capable providers
   */
  static getProviderDisplayNameWithToolsHTML(providerId: string): string {
    const displayName = this.getProviderDisplayName(providerId);
    const supportsTools = this.supportsFunctionCalling(providerId);
    
    if (supportsTools) {
      return `${displayName} ${this.getToolIconSVG()}`;
    }
    return displayName;
  }

  /**
   * Get provider capabilities
   */
  static getProviderCapabilities(providerId: string): {
    streaming: boolean;
    functionCalling: boolean;
    imageInput: boolean;
    jsonMode: boolean;
  } {
    return {
      streaming: this.supportsStreaming(providerId),
      functionCalling: this.supportsFunctionCalling(providerId),
      imageInput: ['openai', 'anthropic', 'google'].includes(providerId),
      jsonMode: ['openai', 'mistral'].includes(providerId)
    };
  }
}
```

## ui/chat/utils/ReferenceExtractor.ts

```typescript
/**
 * ReferenceExtractor - Extract references and plain text from contenteditable
 *
 * Handles conversion of styled HTML content to plain text for message sending
 */

import {
  ToolHint,
  PromptReference,
  NoteReference,
  WorkspaceReference
} from '../components/suggesters/base/SuggesterInterfaces';

export interface ExtractedContent {
  /** Plain text message (without reference markers) */
  plainText: string;
  /** Tool references found */
  tools: ToolHint[];
  /** Prompt references found */
  prompts: PromptReference[];
  /** Note references found */
  notes: NoteReference[];
  /** Workspace references found */
  workspaces: WorkspaceReference[];
  /** Reference metadata for badge reconstruction */
  references: ExtractedReference[];
}

export interface ExtractedReference {
  type: 'tool' | 'prompt' | 'note' | 'workspace';
  displayText: string;
  technicalName: string;
  position: number;
}

export interface ReferenceMetadata {
  references: ExtractedReference[];
}

export class ReferenceExtractor {
  /**
   * Type guard to check if a Node is an HTMLElement
   */
  private static isHTMLElement(node: Node): node is HTMLElement {
    return node.nodeType === Node.ELEMENT_NODE;
  }

  /**
   * Extract all content from contenteditable element
   */
  static extractContent(element: HTMLElement): ExtractedContent {
    const tools: ToolHint[] = [];
    const prompts: PromptReference[] = [];
    const notes: NoteReference[] = [];
    const workspaces: WorkspaceReference[] = [];
    const textParts: string[] = [];
    const references: ExtractedReference[] = [];
    let currentOffset = 0;

    const traverse = (node: Node): void => {
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent || '';
        if (text) {
          textParts.push(text);
          currentOffset += text.length;
        }
      } else if (this.isHTMLElement(node)) {
        const element = node;

        // Check if this is a reference node
        if (element.classList.contains('chat-reference')) {
          const type = element.getAttribute('data-type');
          const name = element.getAttribute('data-name');
          const displayText = element.textContent || '';

          if (type && name && (type === 'tool' || type === 'prompt' || type === 'note' || type === 'workspace')) {
            references.push({
              type,
              displayText,
              technicalName: name,
              position: currentOffset
            });
          }
          // Do not return early - keep traversing children so the display text
          // remains part of the plain-text message sent to the LLM.
        }

        // Traverse children
        for (const child of Array.from(node.childNodes)) {
          traverse(child);
        }

        // Add line break for block elements
        if (this.isBlockElement(element)) {
          textParts.push('\n');
          currentOffset += 1;
        }
      }
    };

    traverse(element);

    const rawText = textParts.join('');
    const leadingWhitespace = rawText.length - rawText.trimStart().length;
    const plainText = rawText.trim();
    const normalizedReferences = references.map(reference => {
      const adjustedPosition = Math.max(0, reference.position - leadingWhitespace);
      const boundedPosition = Math.min(adjustedPosition, plainText.length);
      return {
        ...reference,
        position: boundedPosition
      };
    });

    return {
      plainText,
      tools,
      prompts,
      notes,
      workspaces,
      references: normalizedReferences
    };
  }

  /**
   * Get just the plain text (for display/processing)
   */
  static getPlainText(element: HTMLElement): string {
    return this.extractContent(element).plainText;
  }

  /**
   * Check if an element is a block-level element
   */
  private static isBlockElement(element: HTMLElement): boolean {
    const blockTags = ['DIV', 'P', 'BR', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'UL', 'OL', 'LI'];
    return blockTags.includes(element.tagName);
  }

  /**
   * Extract references by type
   */
  static extractReferencesByType(
    element: HTMLElement,
    type: 'tool' | 'prompt' | 'note' | 'workspace'
  ): Array<{ displayText: string; technicalName: string }> {
    const references: Array<{ displayText: string; technicalName: string }> = [];

    const traverse = (node: Node): void => {
      if (this.isHTMLElement(node)) {
        const el = node;

        if (
          el.classList.contains('chat-reference') &&
          el.getAttribute('data-type') === type
        ) {
          const name = el.getAttribute('data-name');
          const displayText = el.textContent || '';
          if (name) {
            references.push({ displayText, technicalName: name });
          }
        }

        // Traverse children
        for (const child of Array.from(node.childNodes)) {
          traverse(child);
        }
      }
    };

    traverse(element);
    return references;
  }

  /**
   * Count references in the element
   */
  static countReferences(element: HTMLElement): {
    tools: number;
    prompts: number;
    notes: number;
    workspaces: number;
    total: number;
  } {
    const tools = this.extractReferencesByType(element, 'tool').length;
    const prompts = this.extractReferencesByType(element, 'prompt').length;
    const notes = this.extractReferencesByType(element, 'note').length;
    const workspaces = this.extractReferencesByType(element, 'workspace').length;

    return {
      tools,
      prompts,
      notes,
      workspaces,
      total: tools + prompts + notes + workspaces
    };
  }

  /**
   * Check if element has any references
   */
  static hasReferences(element: HTMLElement): boolean {
    return element.querySelector('.chat-reference') !== null;
  }

  /**
   * Remove all references from element (for testing/cleanup)
   */
  static removeAllReferences(element: HTMLElement): void {
    const references = element.querySelectorAll('.chat-reference');
    references.forEach(ref => ref.remove());
  }
}

```

## ui/chat/utils/TokenCalculator.ts

```typescript
/**
 * TokenCalculator - Handles token counting and context usage calculations
 */

import { ConversationData } from '../../../types/chat/ChatTypes';
import { ModelOption } from '../types/SelectionTypes';
import { ContextUsage } from '../components/ContextProgressBar';

export class TokenCalculator {
  /**
   * Get current context usage for a conversation and model
   */
  static async getContextUsage(
    selectedModel: ModelOption | null,
    currentConversation: ConversationData | null,
    currentSystemPrompt: string | null
  ): Promise<ContextUsage> {
    try {
      if (!selectedModel || !currentConversation) {
        return { used: 0, total: 0, percentage: 0 };
      }

      // Estimate token count for current conversation
      const totalTokens = this.estimateTokenCount(currentConversation, currentSystemPrompt);
      const contextWindow = selectedModel.contextWindow;
      const percentage = (totalTokens / contextWindow) * 100;

      return {
        used: totalTokens,
        total: contextWindow,
        percentage: Math.min(percentage, 100)
      };
    } catch (error) {
      console.error('[TokenCalculator] Error calculating context usage:', error);
      return { used: 0, total: 0, percentage: 0 };
    }
  }

  /**
   * Estimate token count for a conversation
   */
  static estimateTokenCount(
    conversation: ConversationData,
    currentSystemPrompt?: string | null
  ): number {
    let totalTokens = 0;
    let hasActualUsageData = false;

    // Add system prompt tokens if provided (always estimated)
    if (currentSystemPrompt) {
      const systemPromptTokens = this.estimateTextTokens(currentSystemPrompt);
      totalTokens += systemPromptTokens;
    }

    // Add message tokens - USE ACTUAL USAGE DATA when available
    conversation.messages.forEach((message: any, index) => {
      // Check if message has actual usage data from API response
      if (message.usage) {
        hasActualUsageData = true;
        // Use actual token counts from OpenAI/Anthropic/etc API
        const promptTokens = message.usage.prompt_tokens || message.usage.input_tokens || 0;
        const completionTokens = message.usage.completion_tokens || message.usage.output_tokens || 0;
        const totalMessageTokens = message.usage.total_tokens || (promptTokens + completionTokens);

        totalTokens += totalMessageTokens;
      } else {
        // Fallback to estimation if no usage data
        const messageTokens = this.estimateTextTokens(message.content);
        totalTokens += messageTokens;

        // Add tokens for tool calls if present (estimated)
        if (message.toolCalls) {
          message.toolCalls.forEach((toolCall: any) => {
            if (toolCall.parameters) {
              const paramTokens = this.estimateTextTokens(JSON.stringify(toolCall.parameters));
              totalTokens += paramTokens;
            }
            if (toolCall.result) {
              const resultText = typeof toolCall.result === 'string'
                ? toolCall.result
                : JSON.stringify(toolCall.result);
              const resultTokens = this.estimateTextTokens(resultText);
              totalTokens += resultTokens;
            }
          });
        }
      }
    });
    return totalTokens;
  }

  /**
   * Rough estimation of token count for text (4 chars â‰ˆ 1 token)
   */
  static estimateTextTokens(text: string | null | undefined): number {
    if (!text) return 0;
    return Math.ceil(text.length / 4);
  }

  /**
   * Check if conversation is approaching context limits
   */
  static getContextWarningLevel(percentage: number): 'safe' | 'moderate' | 'warning' | 'critical' {
    if (percentage < 50) return 'safe';
    if (percentage < 70) return 'moderate';
    if (percentage < 85) return 'warning';
    return 'critical';
  }

  /**
   * Get warning message for context usage
   */
  static getContextWarningMessage(percentage: number): string | null {
    const level = this.getContextWarningLevel(percentage);
    
    switch (level) {
      case 'warning':
        return 'Context approaching limit. Consider starting a new conversation.';
      case 'critical':
        return 'Context limit nearly reached. Responses may be truncated.';
      default:
        return null;
    }
  }

  /**
   * Estimate tokens for a single message before sending
   */
  static estimateMessageTokens(
    message: string,
    systemPrompt?: string | null
  ): number {
    let tokens = this.estimateTextTokens(message);
    
    if (systemPrompt) {
      tokens += this.estimateTextTokens(systemPrompt);
    }
    
    return tokens;
  }

  /**
   * Check if a new message would exceed context limits
   */
  static wouldExceedContextLimit(
    currentUsage: ContextUsage,
    newMessage: string,
    systemPrompt?: string | null,
    bufferPercentage: number = 10 // Leave 10% buffer
  ): boolean {
    const newMessageTokens = this.estimateMessageTokens(newMessage, systemPrompt);
    const projectedUsage = currentUsage.used + newMessageTokens;
    const maxAllowed = currentUsage.total * (100 - bufferPercentage) / 100;
    
    return projectedUsage > maxAllowed;
  }
}

```

## ui/chat/utils/ToolEventParser.ts

```typescript
/**
 * ToolEventParser - Parses and enriches tool event data
 * Location: /src/ui/chat/utils/ToolEventParser.ts
 *
 * This class is responsible for:
 * - Extracting tool information from event data
 * - Parsing tool parameters from various formats
 * - Normalizing tool names and metadata
 *
 * Used by MessageBubble to process tool events from the MessageManager,
 * ensuring consistent data structure for ProgressiveToolAccordion.
 */

import { formatToolDisplayName, normalizeToolName } from '../../../utils/toolNameUtils';

/**
 * Represents a tool call object that may have arguments in different locations
 * depending on the provider format (OpenAI-style vs direct arguments)
 */
interface ToolCallWithArguments {
  function?: {
    name?: string;
    arguments?: string;
  };
  arguments?: string;
  [key: string]: any;
}

export interface ToolEventInfo {
  toolId: string | null;
  displayName: string;
  technicalName?: string;
  parameters?: any;
  isComplete: boolean;
  // Reasoning-specific properties
  type?: string;
  result?: any;
  status?: string;
  isVirtual?: boolean;
}

export class ToolEventParser {
  /**
   * Extract tool event information from raw event data
   */
  static getToolEventInfo(data: any): ToolEventInfo {
    const toolCall = data?.toolCall;
    const toolId = data?.id ?? data?.toolId ?? toolCall?.id ?? null;
    const rawName =
      data?.rawName ??
      data?.technicalName ??
      data?.name ??
      toolCall?.function?.name ??
      toolCall?.name;

    const displayName =
      typeof data?.displayName === 'string' && data.displayName.trim().length > 0
        ? data.displayName
        : formatToolDisplayName(rawName);

    const technicalNameCandidate =
      typeof data?.technicalName === 'string' && data.technicalName.trim().length > 0
        ? data.technicalName
        : rawName;

    const technicalName = technicalNameCandidate
      ? normalizeToolName(technicalNameCandidate) ?? technicalNameCandidate
      : undefined;

    const parameters = this.extractToolParametersFromEvent(data);
    const isComplete =
      data?.isComplete !== undefined
        ? Boolean(data.isComplete)
        : Boolean(toolCall?.parametersComplete);

    // Extract reasoning-specific properties
    const type = data?.type;
    const result = data?.result;
    const status = data?.status;
    const isVirtual = data?.isVirtual;

    return {
      toolId,
      displayName,
      technicalName,
      parameters,
      isComplete,
      // Include reasoning properties if present
      type,
      result,
      status,
      isVirtual
    };
  }

  /**
   * Extract tool parameters from event data
   */
  static extractToolParametersFromEvent(data: any): any {
    if (!data) {
      return undefined;
    }

    if (data.parameters !== undefined) {
      return this.parseParameterValue(data.parameters);
    }

    const toolCall = data.toolCall;
    if (!toolCall) {
      return undefined;
    }

    if (toolCall.parameters !== undefined) {
      return this.parseParameterValue(toolCall.parameters);
    }

    const rawArguments = this.getToolCallArguments(toolCall);
    return this.parseParameterValue(rawArguments);
  }

  /**
   * Parse parameter value from string or object
   */
  static parseParameterValue(value: any): any {
    if (value === undefined || value === null) {
      return undefined;
    }

    if (typeof value === 'string') {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }

    return value;
  }

  /**
   * Get tool call arguments from various formats
   */
  static getToolCallArguments(toolCall: any): any {
    if (!toolCall) {
      return undefined;
    }

    const typedToolCall = toolCall as ToolCallWithArguments;

    if (typedToolCall.function && typeof typedToolCall.function === 'object' && 'arguments' in typedToolCall.function) {
      return typedToolCall.function.arguments;
    }

    return typedToolCall.arguments;
  }
}

```

## utils/AsyncLock.ts

```typescript
/**
 * Simple async lock to prevent race conditions in file operations
 */
export class AsyncLock {
  private promise: Promise<void>;

  constructor() {
    this.promise = Promise.resolve();
  }

  /**
   * Acquire the lock and run the task
   * @param task Async function to execute
   */
  async acquire<T>(task: () => Promise<T>): Promise<T> {
    // Chain the new task to the existing promise
    const result = this.promise.then(() => task());
    
    // Update the promise to wait for this task (handling errors)
    this.promise = result.then(() => {}, () => {});
    
    return result;
  }
}

/**
 * Map of locks for specific resources (e.g. file paths)
 */
export class NamedLocks {
  private locks: Map<string, AsyncLock> = new Map();

  /**
   * Acquire a lock for a specific name/path
   */
  async acquire<T>(name: string, task: () => Promise<T>): Promise<T> {
    if (!this.locks.has(name)) {
      this.locks.set(name, new AsyncLock());
    }
    return this.locks.get(name)!.acquire(task);
  }
}

```

## utils/branchStatusUtils.ts

```typescript
/**
 * Branch status utilities
 * Shared across UI components for consistent status display
 */

import { setIcon } from 'obsidian';
import type { BranchState, SubagentBranchMetadata } from '../types/branch/BranchTypes';

/**
 * Obsidian icon names for each branch state
 */
const STATE_ICONS: Record<BranchState, string> = {
  running: 'loader-2',      // Spinning loader
  complete: 'check',        // Checkmark
  cancelled: 'x',           // X mark
  max_iterations: 'pause',  // Pause icon
  abandoned: 'alert-triangle', // Warning triangle
};

/**
 * Get the Obsidian icon name for a branch state
 * @param state The branch state
 * @returns Obsidian icon name
 */
export function getStateIconName(state: BranchState): string {
  return STATE_ICONS[state] || 'help-circle';
}

/**
 * Render a status icon into an element using Obsidian's setIcon
 * @param element The element to render the icon into
 * @param state The branch state
 */
export function renderStateIcon(element: HTMLElement, state: BranchState): void {
  const iconName = getStateIconName(state);
  setIcon(element, iconName);

  // Add state-specific class for styling (e.g., spinning animation for running)
  element.addClass(`nexus-state-icon-${state}`);
}

/**
 * Create a status icon element
 * @param state The branch state
 * @param parent Optional parent element to append to
 * @returns The created icon element
 */
export function createStateIcon(state: BranchState, parent?: HTMLElement): HTMLElement {
  const iconEl = document.createElement('span');
  iconEl.addClass('nexus-state-icon');
  renderStateIcon(iconEl, state);

  if (parent) {
    parent.appendChild(iconEl);
  }

  return iconEl;
}

/**
 * Get status text for subagent metadata
 * @param metadata Subagent branch metadata
 * @returns Human-readable status text
 */
export function getStatusText(metadata: SubagentBranchMetadata): string {
  const { state, iterations, maxIterations } = metadata;

  switch (state) {
    case 'running':
      return `Running ${iterations || 0}/${maxIterations || 10}`;
    case 'complete':
      return `Complete (${iterations || 0} iterations)`;
    case 'cancelled':
      return 'Cancelled';
    case 'max_iterations':
      return `Paused ${iterations || 0}/${maxIterations || 10}`;
    case 'abandoned':
      return 'Abandoned';
    default:
      return '';
  }
}

/**
 * Build a full description for agent status display
 * @param metadata Subagent branch metadata
 * @param timeAgo Formatted time string (from formatTimeAgo)
 * @returns Full description string
 */
export function buildStatusDescription(
  metadata: SubagentBranchMetadata,
  timeAgo: string
): string {
  const { state, iterations, maxIterations } = metadata;

  switch (state) {
    case 'running':
      return `${iterations}/${maxIterations} iterations Â· Started ${timeAgo}`;
    case 'complete':
      return `Completed in ${iterations} iterations Â· ${timeAgo}`;
    case 'cancelled':
      return `Cancelled after ${iterations} iterations Â· ${timeAgo}`;
    case 'max_iterations':
      return `Paused at max iterations (${iterations}/${maxIterations}) Â· ${timeAgo}`;
    case 'abandoned':
      return `Abandoned after ${iterations} iterations Â· ${timeAgo}`;
    default:
      return `${iterations} iterations Â· ${timeAgo}`;
  }
}

```

## utils/connectorContent.ts

```typescript
/**
 * Auto-generated file containing the embedded connector.js content.
 * This is used by ConnectorEnsurer to recreate connector.js if it's missing.
 *
 * DO NOT EDIT MANUALLY - This file is regenerated during the build process.
 * To update, modify connector.ts and rebuild.
 *
 * Generated: 2025-12-29T12:27:50.350Z
 */

export const CONNECTOR_JS_CONTENT = `"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var net_1 = require("net");
var path_1 = require("path");
/**
 * Creates a connection to the MCP server
 * This connector is used by Claude Desktop to communicate with our Obsidian plugin
 * Uses named pipes on Windows and Unix domain sockets on macOS/Linux
 *
 * The IPC path now includes the vault name to support multiple vaults
 */
/**
 * Sanitizes a vault name for use in identifiers, filenames, and configuration keys
 *
 * This function standardizes vault names by:
 * - Converting to lowercase
 * - Removing special characters (keeping only alphanumeric, spaces, and hyphens)
 * - Replacing spaces with hyphens
 * - Normalizing multiple consecutive hyphens to a single hyphen
 *
 * @param vaultName - The original vault name to sanitize
 * @returns A sanitized version of the vault name suitable for use in identifiers
 */
var sanitizeVaultName = function (vaultName) {
    if (!vaultName)
        return '';
    return vaultName
        .toLowerCase() // Convert to lowercase
        .replace(/[^\\w\\s-]/g, '') // Remove special characters (keep alphanumeric, spaces, hyphens)
        .replace(/\\s+/g, '-') // Replace spaces with hyphens
        .replace(/-+/g, '-'); // Replace multiple consecutive hyphens with a single one
};
/**
 * Extracts the vault name from the script execution path
 *
 * The script path follows the pattern:
 * /path/to/vault_name/.obsidian/plugins/nexus/connector.js
 *
 * We need to go up 4 levels from the script path to reach the vault name:
 * 1. dirname(scriptPath) -> /path/to/vault_name/.obsidian/plugins/nexus
 * 2. dirname() -> /path/to/vault_name/.obsidian/plugins
 * 3. dirname() -> /path/to/vault_name/.obsidian
 * 4. dirname() -> /path/to/vault_name
 * 5. basename() -> vault_name
 *
 * @returns The extracted vault name or empty string if not found
 */
var extractVaultName = function () {
    try {
        // Get the script path from process.argv
        var scriptPath = process.argv[1];
        if (!scriptPath) {
            process.stderr.write('DEBUG: Script path is undefined or empty\\n');
            return '';
        }
        process.stderr.write("DEBUG: Script path: ".concat(scriptPath, "\\n"));
        // Go up 4 levels in the directory hierarchy to reach the vault name
        // 1. nexus plugin directory
        var pluginDir = (0, path_1.dirname)(scriptPath);
        process.stderr.write("DEBUG: Plugin directory: ".concat(pluginDir, "\\n"));
        // 2. plugins directory
        var pluginsDir = (0, path_1.dirname)(pluginDir);
        process.stderr.write("DEBUG: Plugins directory: ".concat(pluginsDir, "\\n"));
        // 3. .obsidian directory
        var obsidianDir = (0, path_1.dirname)(pluginsDir);
        process.stderr.write("DEBUG: Obsidian directory: ".concat(obsidianDir, "\\n"));
        // 4. vault directory (parent of .obsidian)
        var vaultDir = (0, path_1.dirname)(obsidianDir);
        process.stderr.write("DEBUG: Vault directory: ".concat(vaultDir, "\\n"));
        // The vault name is the basename of the vault directory
        var vaultName = (0, path_1.basename)(vaultDir);
        process.stderr.write("DEBUG: Extracted vault name: ".concat(vaultName, "\\n"));
        if (!vaultName) {
            process.stderr.write('WARNING: Extracted vault name is empty\\n');
            return '';
        }
        return vaultName;
    }
    catch (error) {
        process.stderr.write("ERROR: Failed to extract vault name: ".concat(error, "\\n"));
        process.stderr.write("ERROR: Stack trace: ".concat(error.stack, "\\n"));
        return '';
    }
};
/**
 * Gets the IPC path with vault name included
 *
 * This creates a unique IPC path for each vault to prevent conflicts
 * between different vault instances.
 *
 * @returns The IPC path string with vault name included
 */
var getIPCPath = function () {
    // Extract and sanitize the vault name
    var vaultName = extractVaultName();
    var sanitizedVaultName = sanitizeVaultName(vaultName);
    // Add the sanitized vault name to the IPC path
    return process.platform === 'win32'
        ? "\\\\\\\\.\\\\pipe\\\\nexus_mcp_".concat(sanitizedVaultName)
        : "/tmp/nexus_mcp_".concat(sanitizedVaultName, ".sock");
};
// Maximum number of connection attempts
var MAX_RETRIES = 3;
var retryCount = 0;
/**
 * Attempts to connect to the MCP server with retry logic
 *
 * This function:
 * 1. Creates a connection to the IPC path
 * 2. Sets up error handling with detailed diagnostics
 * 3. Implements retry logic with backoff
 * 4. Provides helpful error messages for troubleshooting
 */
function connectWithRetry() {
    var ipcPath = getIPCPath();
    process.stderr.write("Attempting to connect to MCP server (attempt ".concat(retryCount + 1, "/").concat(MAX_RETRIES, ")...\\n"));
    process.stderr.write("Using IPC path: ".concat(ipcPath, "\\n"));
    try {
        var socket = (0, net_1.createConnection)(ipcPath);
        // Pipe stdin/stdout to/from the socket
        process.stdin.pipe(socket);
        socket.pipe(process.stdout);
        // Enhanced error handling with detailed diagnostics
        socket.on('error', function (err) {
            var errorMessage = "IPC connection error: ".concat(err);
            process.stderr.write("ERROR: ".concat(errorMessage, "\\n"));
            // Provide specific guidance based on error type
            // Cast error to NodeJS.ErrnoException to access the code property
            var nodeErr = err;
            if (nodeErr.code === 'ENOENT') {
                process.stderr.write("The IPC path does not exist. This may indicate:\\n");
                process.stderr.write("1. Obsidian is not running\\n");
                process.stderr.write("2. The Nexus plugin is not enabled\\n");
                process.stderr.write("3. The vault name extraction failed (extracted: \\"".concat(sanitizeVaultName(extractVaultName()), "\\")\\n"));
            }
            else if (nodeErr.code === 'ECONNREFUSED') {
                process.stderr.write("Connection refused. The server may have stopped or is not listening.\\n");
            }
            if (retryCount < MAX_RETRIES - 1) {
                retryCount++;
                var retryDelay = 1000 * retryCount; // Increasing backoff
                process.stderr.write("Retrying connection in ".concat(retryDelay / 1000, " second(s)...\\n"));
                setTimeout(connectWithRetry, retryDelay);
            }
            else {
                process.stderr.write("Maximum retry attempts reached. Please ensure:\\n");
                process.stderr.write("1. Obsidian is running\\n");
                process.stderr.write("2. The Nexus plugin is enabled\\n");
                process.stderr.write("3. The plugin settings are correctly configured\\n");
                process.stderr.write("4. Check the extracted vault name: \\"".concat(extractVaultName(), "\\"\\n"));
                process.exit(1);
            }
        });
        socket.on('connect', function () {
            process.stderr.write('Connected to MCP server successfully\\n');
        });
        socket.on('close', function () {
            process.stderr.write('Connection to MCP server closed\\n');
            process.exit(0);
        });
    }
    catch (error) {
        // Provide more detailed error information
        process.stderr.write("ERROR: Failed to create connection: ".concat(error, "\\n"));
        // Add stack trace for debugging
        if (error instanceof Error && error.stack) {
            process.stderr.write("Stack trace: ".concat(error.stack, "\\n"));
        }
        // Log the IPC path that was being used
        process.stderr.write("Was attempting to connect to: ".concat(getIPCPath(), "\\n"));
        process.stderr.write("Extracted vault name: \\"".concat(extractVaultName(), "\\"\\n"));
        process.exit(1);
    }
}
// Start the connection process
connectWithRetry();
`;

```

## utils/ConnectorEnsurer.ts

```typescript
import { Plugin } from 'obsidian';
import { CONNECTOR_JS_CONTENT } from './connectorContent';

/**
 * Ensures connector.js exists in the plugin folder.
 *
 * The connector.js file is required for Claude Desktop and other MCP clients
 * to communicate with the Obsidian plugin. If it's missing (e.g., due to
 * incomplete installation or accidental deletion), this utility will
 * automatically recreate it from the embedded content.
 */
export class ConnectorEnsurer {
    constructor(private plugin: Plugin) {}

    /**
     * Check if connector.js exists, and create it if missing.
     * @returns true if connector.js exists (or was created), false on error
     */
    async ensureConnectorExists(): Promise<boolean> {
        const pluginDir = this.plugin.manifest.dir;
        if (!pluginDir) {
            console.error('[ConnectorEnsurer] Plugin directory not available');
            return false;
        }

        const connectorPath = `${pluginDir}/connector.js`;

        try {
            // Use Obsidian's adapter.exists() method
            const exists = await this.plugin.app.vault.adapter.exists(connectorPath);

            if (exists) {
                return true;
            }

            // File doesn't exist - write it out
            await this.plugin.app.vault.adapter.write(connectorPath, CONNECTOR_JS_CONTENT);
            return true;

        } catch (error) {
            console.error('[ConnectorEnsurer] Failed to ensure connector.js:', error);
            return false;
        }
    }

    /**
     * Force recreate connector.js even if it exists.
     * Useful for updates or repairs.
     * @returns true if successful, false on error
     */
    async recreateConnector(): Promise<boolean> {
        const pluginDir = this.plugin.manifest.dir;
        if (!pluginDir) {
            console.error('[ConnectorEnsurer] Plugin directory not available');
            return false;
        }

        const connectorPath = `${pluginDir}/connector.js`;

        try {
            await this.plugin.app.vault.adapter.write(connectorPath, CONNECTOR_JS_CONTENT);
            return true;
        } catch (error) {
            console.error('[ConnectorEnsurer] Failed to recreate connector.js:', error);
            return false;
        }
    }
}

```

## utils/contextUtils.ts

```typescript
import { CommonParameters, CommonResult, ModeCallResult, ModeCall } from '../types';

/**
 * Interface for workspace context
 */
export interface WorkspaceContext {
  workspaceId: string;
  workspacePath?: string[];
  activeWorkspace?: boolean;
}

/**
 * Parse workspace context from parameters
 * @param workspaceContext String or object representation of workspace context  
 * @param fallbackId Optional fallback workspace ID if parsing fails
 * @param contextParam Optional context parameter containing workspaceId
 * @returns Parsed workspace context or null if not provided
 */
export function parseWorkspaceContext(
  workspaceContext: CommonParameters['workspaceContext'] | null | undefined,
  fallbackId = 'default-workspace',
  contextParam?: any
): WorkspaceContext | null {
  // First, try to get workspaceId from context parameter if available
  let workspaceId: string | undefined;

  if (contextParam?.workspaceId) {
    workspaceId = contextParam.workspaceId;
  }

  if (!workspaceContext) {
    // If no workspaceContext but we have workspaceId from context, create a minimal context
    if (workspaceId) {
      return {
        workspaceId: workspaceId,
        workspacePath: [],
        activeWorkspace: true
      };
    }
    return null;
  }

  let parsedContext: Partial<WorkspaceContext> = {};

  // Handle string vs object format
  if (typeof workspaceContext === 'string') {
    try {
      parsedContext = JSON.parse(workspaceContext);
    } catch (e) {
      return {
        workspaceId: workspaceId || fallbackId,
        workspacePath: [],
        activeWorkspace: true
      };
    }
  } else if (typeof workspaceContext === 'object' && workspaceContext !== null) {
    parsedContext = workspaceContext;
  }

  // Use workspaceId from context if available, otherwise from workspaceContext
  const finalWorkspaceId = workspaceId || parsedContext.workspaceId;

  if (!finalWorkspaceId) {
    return {
      workspaceId: fallbackId,
      workspacePath: [],
      activeWorkspace: true
    };
  }

  return {
    workspaceId: finalWorkspaceId,
    workspacePath: parsedContext.workspacePath || [],
    activeWorkspace: parsedContext.activeWorkspace !== undefined ? parsedContext.activeWorkspace : true
  };
}

/**
 * Serialize workspace context to a string (for storage or parameters)
 * @param context Workspace context object
 * @returns Serialized JSON string
 */
export function serializeWorkspaceContext(context: WorkspaceContext): string {
  return JSON.stringify(context);
}

/**
 * Merge workspace contexts from two different sources
 * Handles conflicts by prioritizing the context from the priority source
 * 
 * @param context1 First workspace context
 * @param context2 Second workspace context
 * @param priorityContext Which context to prioritize if both have the same workspace ID ('first' or 'second')
 * @returns Merged workspace context or null if contexts are from different workspaces
 */
export function mergeWorkspaceContexts(
  context1: WorkspaceContext | null | undefined,
  context2: WorkspaceContext | null | undefined,
  priorityContext: 'first' | 'second' = 'first'
): WorkspaceContext | null {
  // Handle null/undefined cases
  if (!context1 && !context2) {
    return null;
  }
  
  if (!context1) {
    return context2 || null;
  }
  
  if (!context2) {
    return context1;
  }
  
  // If the contexts are from different workspaces, return the priority one
  if (context1.workspaceId !== context2.workspaceId) {
    return priorityContext === 'first' ? context1 : context2;
  }
  
  // Same workspace, so merge them with priority
  const priority = priorityContext === 'first' ? context1 : context2;
  const secondary = priorityContext === 'first' ? context2 : context1;
  
  return {
    workspaceId: priority.workspaceId,
    // Combine paths if both have workspace paths (using priority's if only one has a path)
    workspacePath: priority.workspacePath || secondary.workspacePath || [],
    // Use priority's activeWorkspace flag if present
    activeWorkspace: priority.activeWorkspace !== undefined ? 
      priority.activeWorkspace : 
      secondary.activeWorkspace !== undefined ? 
        secondary.activeWorkspace : 
        true
  };
}

/**
 * Track and merge workspace contexts from multiple mode calls
 * This function processes an array of mode call results and returns the best workspace context
 * 
 * @param results Array of mode call results
 * @param originalContext Original workspace context (optional baseline)
 * @returns The most appropriate workspace context to use
 */
export function trackWorkspaceContexts(
  results: ModeCallResult[],
  originalContext?: WorkspaceContext | null
): WorkspaceContext | null {
  if (!results || results.length === 0) {
    return originalContext || null;
  }
  
  // Filter only successful results with workspace context
  const successfulResults = results.filter(r => r.success && r.workspaceContext);
  
  if (successfulResults.length === 0) {
    return originalContext || null;
  }
  
  // Start with the original context
  let currentContext = originalContext || null;
  
  // Process each result in sequence, merging contexts as we go
  for (const result of successfulResults) {
    currentContext = mergeWorkspaceContexts(currentContext, result.workspaceContext, 'second');
  }
  
  return currentContext;
}

/**
 * Prepare mode call parameters with appropriate context
 * This helps maintain consistent session and workspace context
 * 
 * @param modeCall Mode call definition
 * @param sessionId Current session ID
 * @param currentContext Current workspace context
 * @returns Prepared parameters with context
 */
export function prepareModeCallParams(
  modeCall: ModeCall,
  sessionId: string | undefined,
  currentContext: WorkspaceContext | null | undefined
): any {
  // Start with a copy of the original parameters
  const params = { ...modeCall.parameters };
  
  // Apply session ID if not already present
  if (sessionId && !params.sessionId) {
    params.sessionId = sessionId;
  }
  
  // Apply workspace context if not already present
  if (currentContext && (!params.workspaceContext || !parseWorkspaceContext(params.workspaceContext)?.workspaceId)) {
    params.workspaceContext = currentContext;
  }
  
  return params;
}

/**
 * Extract context information from parameters for use in prepareResult calls
 * This function handles both legacy string context and enhanced object context
 * @param params Parameters object that may contain context information
 * @returns Context suitable for prepareResult calls
 */
export function extractContextFromParams(params: any): CommonResult['context'] {
  if (params.context !== undefined) {
    return normalizeContextForResult(params.context);
  }
  return undefined;
}

/**
 * Normalize context for result output - handles both string and object formats
 * @param context Context in either string or enhanced object format
 * @returns Normalized context for result
 */
export function normalizeContextForResult(context: any): CommonResult['context'] {
  if (typeof context === 'string') {
    return context;
  } else if (typeof context === 'object' && context !== null) {
    // Return the enhanced context object as-is
    return context;
  }
  return undefined;
}
```

## utils/directoryTreeUtils.ts

```typescript
import { App, TFile, TFolder } from 'obsidian';
import { sanitizePath } from './pathUtils';

/**
 * Directory tree node representing a file or folder
 */
export interface DirectoryTreeNode {
  /**
   * Name of the file or folder
   */
  name: string;
  
  /**
   * Full path to the file or folder
   */
  path: string;
  
  /**
   * Type of the node
   */
  type: 'file' | 'folder';
  
  /**
   * Children nodes (only for folders)
   */
  children?: DirectoryTreeNode[];
  
  /**
   * File extension (only for files)
   */
  extension?: string;
  
  /**
   * Last modified timestamp (only for files)
   */
  lastModified?: number;
  
  /**
   * File size in bytes (only for files)
   */
  size?: number;
  
  
  /**
   * Whether this file is in the workspace's related files
   */
  isRelatedFile?: boolean;
  
  /**
   * Description from frontmatter (only for markdown files)
   */
  description?: string;
}

/**
 * Options for building directory trees
 */
export interface DirectoryTreeOptions {
  /**
   * Maximum depth to traverse (0 = unlimited)
   */
  maxDepth?: number;
  
  /**
   * Whether to include file metadata (size, lastModified)
   */
  includeMetadata?: boolean;
  
  /**
   * File extensions to include (empty = all files)
   */
  includeExtensions?: string[];
  
  /**
   * File extensions to exclude
   */
  excludeExtensions?: string[];
  
  
  /**
   * List of related files to mark
   */
  relatedFiles?: string[];
}

/**
 * Build a directory tree structure for a given root folder
 */
export class DirectoryTreeBuilder {
  private app: App;
  
  constructor(app: App) {
    this.app = app;
  }
  
  /**
   * Build a directory tree for the given root path
   */
  async buildTree(rootPath: string, options: DirectoryTreeOptions = {}): Promise<DirectoryTreeNode | null> {
    const normalizedRootPath = sanitizePath(rootPath, false);
    
    // Get the root folder
    const rootFolder = this.app.vault.getAbstractFileByPath(normalizedRootPath);
    
    if (!rootFolder) {
      return null;
    }
    
    if (rootFolder instanceof TFile) {
      // If root is a file, return a single file node
      return await this.buildFileNode(rootFolder, options);
    }
    
    if (rootFolder instanceof TFolder) {
      // Build tree from folder
      return await this.buildFolderNode(rootFolder, options, 0);
    }
    
    return null;
  }
  
  /**
   * Build a directory tree for multiple root paths
   */
  async buildMultiTree(rootPaths: string[], options: DirectoryTreeOptions = {}): Promise<DirectoryTreeNode[]> {
    const trees: DirectoryTreeNode[] = [];
    
    for (const rootPath of rootPaths) {
      const tree = await this.buildTree(rootPath, options);
      if (tree) {
        trees.push(tree);
      }
    }
    
    return trees;
  }
  
  /**
   * Build a flattened list of all files in the directory tree
   */
  async getFileList(rootPath: string, options: DirectoryTreeOptions = {}): Promise<string[]> {
    const tree = await this.buildTree(rootPath, options);
    if (!tree) {
      return [];
    }
    
    return this.flattenTree(tree);
  }
  
  /**
   * Build a node for a file
   */
  private async buildFileNode(file: TFile, options: DirectoryTreeOptions): Promise<DirectoryTreeNode> {
    const node: DirectoryTreeNode = {
      name: file.name,
      path: file.path,
      type: 'file',
      extension: file.extension
    };
    
    // Add metadata if requested
    if (options.includeMetadata && file.stat) {
      node.lastModified = file.stat.mtime;
    }
    
    
    // Mark as related file if in the list
    if (options.relatedFiles && options.relatedFiles.includes(file.path)) {
      node.isRelatedFile = true;
    }
    
    // Get description from frontmatter for markdown files
    if (file.extension === 'md') {
      try {
        const content = await this.app.vault.read(file);
        const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
        
        if (frontmatterMatch) {
          const frontmatter = frontmatterMatch[1];
          // Look for description field
          const descMatch = frontmatter.match(/description\s*:\s*["']?([^\n"']+)["']?/);
          if (descMatch) {
            node.description = descMatch[1].trim();
          }
        }
      } catch (error) {
        // Ignore errors reading file
      }
    }
    
    return node;
  }
  
  /**
   * Build a node for a folder
   */
  private async buildFolderNode(
    folder: TFolder, 
    options: DirectoryTreeOptions, 
    currentDepth: number
  ): Promise<DirectoryTreeNode> {
    const node: DirectoryTreeNode = {
      name: folder.name,
      path: folder.path,
      type: 'folder',
      children: []
    };
    
    // Check depth limit
    if (options.maxDepth && currentDepth >= options.maxDepth) {
      return node;
    }
    
    // Process children
    for (const child of folder.children) {
      if (child instanceof TFile) {
        // Filter by extensions if specified
        if (options.includeExtensions && options.includeExtensions.length > 0) {
          if (!options.includeExtensions.includes(child.extension)) {
            continue;
          }
        }
        
        if (options.excludeExtensions && options.excludeExtensions.includes(child.extension)) {
          continue;
        }
        
        const fileNode = await this.buildFileNode(child, options);
        node.children!.push(fileNode);
      } else if (child instanceof TFolder) {
        const folderNode = await this.buildFolderNode(child, options, currentDepth + 1);
        node.children!.push(folderNode);
      }
    }
    
    // Sort children: folders first by name, then files by last modified (newest first)
    node.children!.sort((a, b) => {
      // Folders come before files
      if (a.type === 'folder' && b.type === 'file') return -1;
      if (a.type === 'file' && b.type === 'folder') return 1;
      
      // Between folders, sort alphabetically
      if (a.type === 'folder' && b.type === 'folder') {
        return a.name.localeCompare(b.name);
      }
      
      // Between files, sort by last modified (newest first)
      if (a.type === 'file' && b.type === 'file') {
        const aTime = a.lastModified || 0;
        const bTime = b.lastModified || 0;
        return bTime - aTime;
      }
      
      return 0;
    });
    
    return node;
  }
  
  
  /**
   * Flatten a directory tree into a list of file paths
   */
  private flattenTree(node: DirectoryTreeNode): string[] {
    const files: string[] = [];
    
    if (node.type === 'file') {
      files.push(node.path);
    } else if (node.children) {
      for (const child of node.children) {
        files.push(...this.flattenTree(child));
      }
    }
    
    return files;
  }
  
  /**
   * Find a node in the tree by path
   */
  findNodeByPath(tree: DirectoryTreeNode, targetPath: string): DirectoryTreeNode | null {
    const normalizedTarget = sanitizePath(targetPath, false);
    const normalizedCurrentPath = sanitizePath(tree.path, false);
    
    if (normalizedCurrentPath === normalizedTarget) {
      return tree;
    }
    
    if (tree.children) {
      for (const child of tree.children) {
        const found = this.findNodeByPath(child, targetPath);
        if (found) {
          return found;
        }
      }
    }
    
    return null;
  }
  
  
  /**
   * Get all files marked as related files in the tree
   */
  getRelatedFiles(tree: DirectoryTreeNode): string[] {
    const relatedFiles: string[] = [];
    
    if (tree.type === 'file' && tree.isRelatedFile) {
      relatedFiles.push(tree.path);
    } else if (tree.children) {
      for (const child of tree.children) {
        relatedFiles.push(...this.getRelatedFiles(child));
      }
    }
    
    return relatedFiles;
  }
}

/**
 * Utility functions for working with directory trees
 */
export class DirectoryTreeUtils {
  /**
   * Convert a directory tree to a simple text representation
   */
  static treeToText(tree: DirectoryTreeNode, indent = ''): string {
    let result = '';
    const _isLast = true; // We'll handle this in the caller
    
    const prefix = tree.type === 'folder' ? 'ðŸ“ ' : 'ðŸ“„ ';
    const keyIndicator = '';
    const relatedIndicator = tree.isRelatedFile ? ' ðŸ”—' : '';
    const description = tree.description ? ` - ${tree.description}` : '';
    
    result += `${indent}${prefix}${tree.name}${keyIndicator}${relatedIndicator}${description}\n`;
    
    if (tree.children && tree.children.length > 0) {
      for (let i = 0; i < tree.children.length; i++) {
        const isChildLast = i === tree.children.length - 1;
        const childIndent = indent + (isChildLast ? '    ' : 'â”‚   ');
        const childPrefix = isChildLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';
        
        result += `${indent}${childPrefix}`;
        result += this.treeToText(tree.children[i], childIndent).substring(indent.length + 4);
      }
    }
    
    return result;
  }
  
  /**
   * Get statistics about a directory tree
   */
  static getTreeStats(tree: DirectoryTreeNode): {
    totalFiles: number;
    totalFolders: number;
    relatedFiles: number;
    maxDepth: number;
  } {
    const stats = {
      totalFiles: 0,
      totalFolders: 0,
      relatedFiles: 0,
      maxDepth: 0
    };
    
    this.calculateStats(tree, stats, 0);
    
    return stats;
  }
  
  private static calculateStats(
    node: DirectoryTreeNode, 
    stats: any, 
    currentDepth: number
  ): void {
    stats.maxDepth = Math.max(stats.maxDepth, currentDepth);
    
    if (node.type === 'file') {
      stats.totalFiles++;
      if (node.isRelatedFile) stats.relatedFiles++;
    } else {
      stats.totalFolders++;
    }
    
    if (node.children) {
      for (const child of node.children) {
        this.calculateStats(child, stats, currentDepth + 1);
      }
    }
  }
}
```

## utils/errors.ts

```typescript
/**
 * Mobile-safe error utilities
 *
 * These provide similar functionality to MCP SDK errors but without
 * pulling in Node.js dependencies. On desktop, the actual MCP SDK
 * errors are used; on mobile, these lightweight equivalents are used.
 */

/**
 * Error codes matching MCP SDK ErrorCode enum
 */
export enum NexusErrorCode {
    InternalError = -32603,
    InvalidParams = -32602,
    MethodNotFound = -32601,
    ParseError = -32700,
    InvalidRequest = -32600,
}

/**
 * Lightweight error class that mimics McpError structure
 */
export class NexusError extends Error {
    public readonly code: number;
    public readonly data?: unknown;

    constructor(code: NexusErrorCode, message: string, data?: unknown) {
        super(message);
        this.name = 'NexusError';
        this.code = code;
        this.data = data;
    }
}

```

## utils/errorUtils.ts

```typescript
/**
 * Utility functions for error handling
 */

/**
 * Extracts a readable message from any error type
 * @param error Any error type (Error, string, unknown, etc.)
 * @returns A string message representing the error
 */
export function getErrorMessage(error: unknown): string {
  if (error instanceof Error) {
    return error.message;
  } else if (typeof error === 'string') {
    return error;
  } else if (error && typeof error === 'object' && 'message' in error && typeof error.message === 'string') {
    return error.message;
  } else if (error === null) {
    return 'Null error';
  } else if (error === undefined) {
    return 'Undefined error';
  } else {
    return String(error);
  }
}

/**
 * Creates a prefixed error message from any error type
 * @param prefix The prefix to add to the error message (e.g. "Failed to create folder: ")
 * @param error Any error type (Error, string, unknown, etc.)
 * @returns A string message with the prefix and the error
 */
export function createErrorMessage(prefix: string, error: unknown): string {
  return `${prefix}${getErrorMessage(error)}`;
}
```

## utils/filterUtils.ts

```typescript
/**
 * Utility functions for handling filter patterns in various modes
 */

/**
 * Create a regex from a filter pattern that supports both glob patterns and regex
 * @param pattern The filter pattern (can be glob pattern like "*test*" or regex)
 * @param flags Optional regex flags (default: 'i' for case-insensitive)
 * @returns RegExp object for filtering
 */
export function createFilterRegex(pattern: string, flags = 'i'): RegExp {
  try {
    // First, try to use the pattern as-is (might be a valid regex)
    return new RegExp(pattern, flags);
  } catch (error) {
    // If it fails, treat it as a simple glob pattern and convert to regex
    // Convert glob patterns to regex: * becomes .*, ? becomes .
    const escapedPattern = pattern
      .replace(/[.+^${}()|[\]\\]/g, '\\$&') // Escape regex special chars except * and ?
      .replace(/\*/g, '.*') // Convert * to .*
      .replace(/\?/g, '.'); // Convert ? to .
    return new RegExp(escapedPattern, flags);
  }
}

/**
 * Filter an array of items by name using a pattern
 * @param items Array of items with a 'name' property
 * @param pattern Filter pattern (glob or regex)
 * @returns Filtered array
 */
export function filterByName<T extends { name: string }>(items: T[], pattern: string): T[] {
  if (!pattern) return items;
  
  const filterRegex = createFilterRegex(pattern);
  return items.filter(item => filterRegex.test(item.name));
}

/**
 * Filter an array of items by a custom property using a pattern
 * @param items Array of items
 * @param pattern Filter pattern (glob or regex)
 * @param getProperty Function to extract the property to filter by
 * @returns Filtered array
 */
export function filterByProperty<T>(
  items: T[], 
  pattern: string, 
  getProperty: (item: T) => string
): T[] {
  if (!pattern) return items;
  
  const filterRegex = createFilterRegex(pattern);
  return items.filter(item => filterRegex.test(getProperty(item)));
}

/**
 * Standard filter description for use in parameter schemas
 */
export const FILTER_DESCRIPTION = 'Optional filter pattern. Supports glob patterns (* for any chars, ? for single char) or regular expressions. Examples: "*deep*", "test*", ".*regex.*"';
```

## utils/jsonUtils.ts

```typescript
/**
 * Utility functions for JSON operations
 * This module provides reusable functions for handling JSON-related operations
 * across the codebase, particularly focused on safe stringification and array parsing.
 */

/**
 * Safely stringify an object, handling circular references
 * @param obj - Object to stringify
 * @returns JSON string representation of the object
 * 
 * Example:
 * ```ts
 * const obj = { a: 1 };
 * obj.self = obj; // circular reference
 * console.log(safeStringify(obj)); // {"a":1,"self":"[Circular Reference]"}
 * ```
 */
export function safeStringify(obj: any): string {
    const seen = new WeakSet();
    return JSON.stringify(obj, (_, value) => {
        if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
                return '[Circular Reference]';
            }
            seen.add(value);
        }
        return value;
    }, 2);
}

/**
 * Parse string representations of JSON arrays in arguments
 * Handles cases where array parameters might be passed as stringified JSON
 * 
 * @param args - Arguments object to parse
 * @returns Parsed arguments object with proper arrays
 * 
 * Example:
 * ```ts
 * const args = { paths: '["file1.txt","file2.txt"]' };
 * const parsed = parseJsonArrays(args);
 * console.log(parsed.paths); // ['file1.txt', 'file2.txt']
 * ```
 */
export function parseJsonArrays(args: any): any {
    if (!args || typeof args !== 'object') {
        return args;
    }

    const result: any = {};
    
    // Process each property in the arguments object
    for (const [key, value] of Object.entries(args)) {
        // Check if the value is a string that looks like a JSON array
        if (typeof value === 'string' &&
            value.trim().startsWith('[') &&
            value.trim().endsWith(']')) {
            try {
                // Attempt to parse the string as JSON
                result[key] = JSON.parse(value);
            } catch (error) {
                // If parsing fails, keep the original string value
                result[key] = value;
            }
        } else {
            // For non-array strings or other types, keep the original value
            result[key] = value;
        }
    }
    
    return result;
}

```

## utils/logger.ts

```typescript
/**
 * Enhanced logger that handles different types of logging.
 * Used to replace all console.log/warn/error calls with a centralized system
 * that can be configured to show only necessary logs.
 */
export const logger = {
    /**
     * Log fatal system errors that prevent core functionality
     */
    systemError(error: Error, context?: string) {
        console.error(
            `SYSTEM ERROR${context ? ` [${context}]` : ''}: ${error.message}`
        );
    },
    
    /**
     * Log system warnings that don't prevent functionality but indicate issues
     */
    systemWarn(message: string, context?: string) {
        // No-op
    },
    
    /**
     * Log informational messages during development
     */
    systemLog(message: string, context?: string) {
        // No-op
    }
    
    // operationError function removed to eliminate unnecessary console logs
};

```

## utils/nudgeHelpers.ts

```typescript
/**
 * Helper functions for dynamic tool nudges
 * Provides common logic for nudge triggers based on the dynamic tool nudges specification
 */

import { Recommendation } from './recommendationUtils';

/**
 * Helper functions for analyzing tool results and creating nudges
 */
export class NudgeHelpers {
  
  /**
   * Check if multiple files were found (>3 files) to suggest batch operations
   */
  static checkMultipleFiles(fileCount: number): Recommendation | null {
    if (fileCount > 3) {
      return {
        type: "efficiency",
        message: "Multiple files found. Consider using ContentManager batchContent to read several files efficiently in one operation."
      };
    }
    return null;
  }

  /**
   * Check if files are from different folders to suggest organization
   */
  static checkDifferentFolders(filePaths: string[]): Recommendation | null {
    if (filePaths.length === 0) return null;
    
    // Extract unique folder paths
    const folders = new Set(filePaths.map(path => {
      const lastSlash = path.lastIndexOf('/');
      return lastSlash === -1 ? '' : path.substring(0, lastSlash);
    }));
    
    if (folders.size > 1) {
      return {
        type: "organization", 
        message: "Found related files across multiple folders. You might want to consider organizing them with VaultManager."
      };
    }
    return null;
  }

  /**
   * Check if content is large (>7,000 characters) to suggest state saving
   */
  static checkLargeContent(contentLength: number): Recommendation | null {
    if (contentLength > 7000) {
      return {
        type: "save",
        message: "Large document read. Consider using MemoryManager createState to capture key insights before continuing."
      };
    }
    return null;
  }

  /**
   * Always suggest frontmatter and wikilinks for new files
   */
  static suggestObsidianFeatures(): Recommendation {
    return {
      type: "obsidian_features",
      message: "New file created. Consider adding frontmatter for metadata and wikilinks [[like this]] to connect with other notes."
    };
  }

  /**
   * Check session for multiple file creations to suggest state saving
   */
  static checkMultipleFilesInSession(sessionContext: any): Recommendation | null {
    // This would need session tracking - for now return null and implement later with full session context
    // In the future, this could check session memory for previous file creation operations
    return null;
  }

  /**
   * Check for many files read in batch (>3) to suggest state saving
   */
  static checkBatchReadOperations(readCount: number): Recommendation | null {
    if (readCount > 3) {
      return {
        type: "save",
        message: "Multiple files reviewed. Consider using MemoryManager createState to capture your findings."
      };
    }
    return null;
  }

  /**
   * Check for many files created in batch (>2) to suggest agent creation
   */
  static checkBatchCreateOperations(createCount: number): Recommendation | null {
    if (createCount > 2) {
      return {
        type: "agent_suggestion",
        message: "Creating multiple similar files? Consider using AgentManager to create a custom agent for this type of content generation."
      };
    }
    return null;
  }

  /**
   * Always suggest link checking after moving files
   */
  static suggestLinkChecking(): Recommendation {
    return {
      type: "link_check",
      message: "Files moved. Consider checking if any internal links need updating with ContentManager."
    };
  }

  /**
   * Always suggest customization after duplicating files
   */
  static suggestCustomization(): Recommendation {
    return {
      type: "customization",
      message: "File duplicated. Consider using ContentManager to customize the copy for its new purpose."
    };
  }

  /**
   * Always suggest impact awareness after command execution
   */
  static suggestImpactAwareness(): Recommendation {
    return {
      type: "awareness",
      message: "Obsidian command executed. If this changed settings or enabled features, consider how it might affect your current workflow."
    };
  }

  /**
   * Always suggest state saving after prompt execution
   */
  static suggestCaptureProgress(): Recommendation {
    return {
      type: "capture",
      message: "Agent analysis complete. Consider using MemoryManager createState to save this progress."
    };
  }

  /**
   * Always suggest workspace integration for new agents
   */
  static suggestWorkspaceIntegration(): Recommendation {
    return {
      type: "workspace_integration",
      message: "New agent created. Consider associating it with your current workspace using MemoryManager updateWorkspace for automatic availability."
    };
  }

  /**
   * Check for large workspace (>20 files) to suggest exploration tools
   */
  static checkLargeWorkspace(fileCount: number): Recommendation | null {
    if (fileCount > 20) {
      return {
        type: "exploration",
        message: "Large workspace loaded. Consider using storageManager.list to explore the structure, or searchManager to find specific content."
      };
    }
    return null;
  }

  /**
   * Always suggest next steps after state creation
   */
  static suggestNextSteps(): Recommendation {
    return {
      type: "next_steps",
      message: "Progress saved. Consider what you'd like to work on next, or use promptManager if you want to automate similar future workflows."
    };
  }

  /**
   * Check memory search results for previous states
   */
  static checkPreviousStates(results: any[]): Recommendation | null {
    // Look for states in memory search results
    const hasStates = results.some(result => 
      result.category === 'states' || 
      (result.metadata && result.metadata.type === 'state')
    );
    
    if (hasStates) {
      return {
        type: "context_restoration",
        message: "Relevant previous work found. Consider using MemoryManager loadState to restore that context."
      };
    }
    return null;
  }

  /**
   * Check memory search results for workspace sessions
   */
  static checkWorkspaceSessions(results: any[]): Recommendation | null {
    // Look for sessions in memory search results
    const hasSessions = results.some(result => 
      result.category === 'sessions' || 
      (result.metadata && result.metadata.type === 'session')
    );
    
    if (hasSessions) {
      return {
        type: "session_continuation",
        message: "Related workspace data found. Consider memoryManager loadState to continue previous work."
      };
    }
    return null;
  }

  /**
   * Helper to extract file paths from search results
   */
  static extractFilePathsFromResults(results: any[]): string[] {
    if (!Array.isArray(results)) return [];
    
    return results
      .map(result => result.filePath || result.path || result.file)
      .filter(path => typeof path === 'string')
      .filter(Boolean);
  }

  /**
   * Helper to count file operations in batch results
   */
  static countOperationsByType(operations: any[]): { read: number; create: number; total: number } {
    if (!Array.isArray(operations)) return { read: 0, create: 0, total: 0 };

    const read = operations.filter(op => op.operation === 'read' || op.type === 'read').length;
    const create = operations.filter(op => op.operation === 'create' || op.type === 'create').length;

    return { read, create, total: operations.length };
  }

  // ===================
  // AgentManager Nudges
  // ===================

  /**
   * Check if prompt execution suggests creating a reusable agent
   * @param hasWorkspace Whether user is in a workspace context
   */
  static checkAgentCreationOpportunity(hasWorkspace: boolean): Recommendation | null {
    if (hasWorkspace) {
      return {
        type: "agent_suggestion",
        message: "Running prompts in a workspace? Consider creating a custom agent for repeated tasks."
      };
    }
    return null;
  }

  /**
   * Check batch operations for agent automation opportunity
   * @param operationCount Number of operations in batch
   */
  static checkBatchAgentOpportunity(operationCount: number): Recommendation | null {
    if (operationCount > 2) {
      return {
        type: "automation",
        message: "Batch operations suggest routine workflows. A custom agent could automate this pattern."
      };
    }
    return null;
  }

  /**
   * Check if prompt list shows opportunity for workspace binding
   * @param promptCount Number of prompts available
   * @param hasWorkspace Whether user is in a workspace context
   */
  static checkPromptBindingOpportunity(promptCount: number, hasWorkspace: boolean): Recommendation | null {
    if (promptCount > 0 && hasWorkspace) {
      return {
        type: "workspace_binding",
        message: "Bind frequently used prompts to your workspace for automatic availability."
      };
    }
    return null;
  }

  /**
   * Suggest testing after prompt creation/update
   */
  static suggestPromptTesting(): Recommendation {
    return {
      type: "testing",
      message: "Test your prompt with executePrompts to verify it works as expected."
    };
  }
}
```

## utils/parameterHintUtils.ts

```typescript
/**
 * Utilities for generating helpful parameter hints for users
 */
import { getErrorMessage } from './errorUtils';
import { ValidationError } from './validationUtils';

/**
 * Parameter hint for a specific tool parameter
 */
export interface ParameterHint {
    name: string;
    description: string;
    type: string;
    required: boolean;
    defaultValue?: unknown;
    constraints?: string;
    example?: unknown;
}

/**
 * Contextual help for a specific tool
 */
export interface ToolHelp {
    toolName: string;
    description: string;
    parameters: ParameterHint[];
    examples?: {
        description: string;
        parameters: Record<string, unknown>;
    }[];
}

/**
 * @deprecated Use ToolHelp instead
 */
export type ModeHelp = ToolHelp;

/**
 * Generate structured parameter hints from a JSON schema
 * 
 * @param schema JSON schema to generate hints from
 * @returns Parameter hints for all properties in the schema
 */
export function generateStructuredHints(schema: any): ParameterHint[] {
    if (!schema || !schema.properties || typeof schema.properties !== 'object') {
        return [];
    }
    
    const requiredProps = Array.isArray(schema.required) ? schema.required : [];
    const hints: ParameterHint[] = [];
    
    for (const [propName, propSchema] of Object.entries<any>(schema.properties)) {
        if (!propSchema) continue;
        
        const hint: ParameterHint = {
            name: propName,
            description: propSchema.description || 'No description provided',
            type: getTypeFromSchema(propSchema),
            required: requiredProps.includes(propName)
        };
        
        // Add default value if present
        if (propSchema.default !== undefined) {
            hint.defaultValue = propSchema.default;
        }
        
        // Add constraints if present
        const constraints = getConstraintsFromSchema(propSchema);
        if (constraints) {
            hint.constraints = constraints;
        }
        
        // Add example if present
        if (propSchema.examples && propSchema.examples.length > 0) {
            hint.example = propSchema.examples[0];
        } else if (propSchema.example !== undefined) {
            hint.example = propSchema.example;
        }
        
        hints.push(hint);
    }
    
    // Sort required parameters first, then alphabetically
    return hints.sort((a, b) => {
        if (a.required && !b.required) return -1;
        if (!a.required && b.required) return 1;
        return a.name.localeCompare(b.name);
    });
}

/**
 * Generate structured tool help from a tool's schema and metadata
 *
 * @param toolName Name of the tool
 * @param description Description of the tool
 * @param schema JSON schema for the tool parameters
 * @param examples Optional examples of tool usage
 * @returns Structured help object for the tool
 */
export function generateToolHelp(
    toolName: string,
    description: string,
    schema: Record<string, unknown>,
    examples?: { description: string; parameters: Record<string, unknown> }[]
): ToolHelp {
    return {
        toolName,
        description,
        parameters: generateStructuredHints(schema),
        examples
    };
}

/**
 * @deprecated Use generateToolHelp instead
 */
export function generateModeHelp(
    modeName: string,
    description: string,
    schema: Record<string, unknown>,
    examples?: { description: string; parameters: Record<string, unknown> }[]
): ToolHelp {
    return generateToolHelp(modeName, description, schema, examples);
}

/**
 * Format tool help into a user-friendly string
 *
 * @param help Structured tool help object
 * @returns Formatted help string
 */
export function formatToolHelp(help: ToolHelp): string {
    let output = `## ${help.toolName}\n\n${help.description}\n\n### Parameters:\n\n`;

    for (const param of help.parameters) {
        output += `**${param.name}**${param.required ? ' (Required)' : ' (Optional)'}: ${param.description}\n`;
        output += `- Type: ${param.type}\n`;

        if (param.defaultValue !== undefined) {
            output += `- Default: ${JSON.stringify(param.defaultValue)}\n`;
        }

        if (param.constraints) {
            output += `- Constraints: ${param.constraints}\n`;
        }

        if (param.example !== undefined) {
            output += `- Example: ${JSON.stringify(param.example)}\n`;
        }

        output += '\n';
    }

    if (help.examples && help.examples.length > 0) {
        output += `### Examples:\n\n`;

        for (const example of help.examples) {
            output += `#### ${example.description}\n\`\`\`json\n${JSON.stringify(example.parameters, null, 2)}\n\`\`\`\n\n`;
        }
    }

    return output;
}

/**
 * @deprecated Use formatToolHelp instead
 */
export function formatModeHelp(help: ToolHelp): string {
    return formatToolHelp(help);
}

/**
 * Generate parameter hints for validation errors
 * 
 * @param errors Array of validation errors
 * @param schema JSON schema used for validation
 * @returns Array of hint strings for each error
 */
export function generateHintsForErrors(errors: ValidationError[], schema: any): Record<string, string> {
    const hints: Record<string, string> = {};
    
    if (!schema || !schema.properties) {
        return hints;
    }
    
    for (const error of errors) {
        // Skip errors already having hints
        if (error.hint) continue;
        
        // Get parameter name from the error path
        const paramName = error.path.length > 0 ? error.path[0] : '';
        if (!paramName || typeof paramName !== 'string') continue;
        
        // Get schema for this parameter
        const paramSchema = schema.properties[paramName];
        if (!paramSchema) continue;
        
        // Generate hint based on error code
        let hint = '';
        
        switch (error.code) {
            case 'MISSING_REQUIRED':
                hint = `Required parameter. ${paramSchema.description || ''}`;
                break;
                
            case 'TYPE_ERROR':
                hint = `Must be ${getTypeFromSchema(paramSchema)}. ${paramSchema.description || ''}`;
                break;
                
            case 'ENUM_ERROR':
                if (paramSchema.enum && Array.isArray(paramSchema.enum)) {
                    hint = `Must be one of: ${paramSchema.enum.map((v: any) => JSON.stringify(v)).join(', ')}`;
                }
                break;
                
            case 'MIN_ERROR':
                hint = `Must be at least ${paramSchema.minimum}`;
                break;
                
            case 'MAX_ERROR':
                hint = `Must be at most ${paramSchema.maximum}`;
                break;
                
            case 'MIN_LENGTH_ERROR':
                hint = `Must be at least ${paramSchema.minLength} characters long`;
                break;
                
            case 'MAX_LENGTH_ERROR':
                hint = `Must be at most ${paramSchema.maxLength} characters long`;
                break;
                
            case 'PATTERN_ERROR':
                hint = `Must match pattern: ${paramSchema.pattern}`;
                break;
                
            default:
                // For unknown error codes, provide general parameter information
                hint = paramSchema.description || '';
                if (paramSchema.type) {
                    hint += ` Type: ${getTypeFromSchema(paramSchema)}.`;
                }
        }
        
        if (hint) {
            hints[paramName] = hint;
        }
    }
    
    return hints;
}

/**
 * Extract type information from a schema property
 * 
 * @param schema Schema property to extract type from
 * @returns String representation of the property type
 */
function getTypeFromSchema(schema: any): string {
    if (!schema) return 'any';
    
    if (schema.enum && Array.isArray(schema.enum)) {
        return `enum (${schema.enum.map((v: any) => JSON.stringify(v)).join(', ')})`;
    }
    
    if (schema.type) {
        if (schema.type === 'array' && schema.items) {
            const itemType = schema.items.type || 'any';
            return `array of ${itemType}`;
        }
        
        if (schema.type === 'object' && schema.properties) {
            const propNames = Object.keys(schema.properties);
            if (propNames.length === 0) {
                return 'object';
            }
            return `object with properties: ${propNames.join(', ')}`;
        }
        
        return Array.isArray(schema.type) ? schema.type.join(' | ') : schema.type;
    }
    
    return 'any';
}

/**
 * Extract constraints from a schema property
 * 
 * @param schema Schema property to extract constraints from
 * @returns String representation of constraints, or undefined if none
 */
function getConstraintsFromSchema(schema: any): string | undefined {
    if (!schema) return undefined;
    
    const constraints: string[] = [];
    
    if (schema.minLength !== undefined) {
        constraints.push(`min length: ${schema.minLength}`);
    }
    
    if (schema.maxLength !== undefined) {
        constraints.push(`max length: ${schema.maxLength}`);
    }
    
    if (schema.pattern) {
        constraints.push(`pattern: ${schema.pattern}`);
    }
    
    if (schema.minimum !== undefined) {
        constraints.push(`min: ${schema.minimum}`);
    }
    
    if (schema.maximum !== undefined) {
        constraints.push(`max: ${schema.maximum}`);
    }
    
    if (schema.minItems !== undefined) {
        constraints.push(`min items: ${schema.minItems}`);
    }
    
    if (schema.maxItems !== undefined) {
        constraints.push(`max items: ${schema.maxItems}`);
    }
    
    return constraints.length > 0 ? constraints.join(', ') : undefined;
}
```

## utils/PathManager.ts

```typescript
/**
 * PathManager - Centralized path management utility for Obsidian plugin
 * Location: src/utils/PathManager.ts
 * 
 * This class provides centralized path construction, validation, and conversion
 * to eliminate path duplication issues in the Electron environment.
 * 
 * Usage:
 * - By DirectoryService for consistent path operations
 * - By storage services for data path construction
 * - By any service that needs reliable path handling
 */

import { App, Plugin, normalizePath, FileSystemAdapter } from 'obsidian';

export interface PathValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  normalizedPath: string;
}

export interface ConversionResult {
  success: boolean;
  relativePath?: string;
  error?: string;
  strategy?: string;
}

/**
 * Core PathManager class - handles all path operations for the plugin
 */
export class PathManager {
  private readonly vaultBasePath: string | null;
  private readonly pluginId: string;

  constructor(
    private readonly app: App,
    private readonly plugin: Plugin
  ) {
    this.pluginId = plugin.manifest.id;
    this.vaultBasePath = this.detectVaultBasePath();
  }

  /**
   * Detect the vault base path from Obsidian's FileSystemAdapter
   */
  private detectVaultBasePath(): string | null {
    try {
      const adapter = this.app.vault.adapter;
      if (adapter instanceof FileSystemAdapter) {
        return adapter.getBasePath();
      }
      return null; // Mobile or non-FileSystemAdapter
    } catch {
      return null;
    }
  }

  /**
   * Create plugin-relative path - always returns path relative to vault root
   */
  createPluginPath(subPath?: string): string {
    const basePath = `.obsidian/plugins/${this.pluginId}`;
    if (!subPath) return basePath;
    
    const sanitizedSubPath = this.sanitizePath(subPath);
    return `${basePath}/${sanitizedSubPath}`;
  }

  /**
   * Create data directory path - always returns relative path
   */
  createDataPath(subPath?: string): string {
    const dataPath = this.createPluginPath('data');
    if (!subPath) return dataPath;
    
    const sanitizedSubPath = this.sanitizePath(subPath);
    return `${dataPath}/${sanitizedSubPath}`;
  }

  /**
   * Create data storage path - always returns relative path
   */
  createDataStoragePath(subPath: string): string {
    const sanitizedPath = this.sanitizePath(subPath);
    return this.createDataPath(`storage/${sanitizedPath}`);
  }

  /**
   * Convert absolute path to vault-relative path
   * This is the core method that prevents path duplication
   */
  makeVaultRelative(absolutePath: string): string {
    if (!this.vaultBasePath) {
      return this.extractPluginPathFallback(absolutePath);
    }

    try {
      // Strategy 1: Direct base path removal
      const directResult = this.attemptDirectConversion(absolutePath, this.vaultBasePath);
      if (directResult.success && directResult.relativePath) {
        return directResult.relativePath;
      }

      // Strategy 2: Plugin path extraction using regex
      const regexResult = this.attemptRegexConversion(absolutePath);
      if (regexResult.success && regexResult.relativePath) {
        return regexResult.relativePath;
      }

      // Strategy 3: Fallback to safe plugin path
      return this.createDataPath('storage');

    } catch (error) {
      console.error('[PathManager] Path conversion error:', error);
      return this.createDataPath('storage');
    }
  }

  /**
   * Direct conversion strategy - remove vault base path
   */
  private attemptDirectConversion(absolutePath: string, basePath: string): ConversionResult {
    const normalizedAbsolute = this.normalizeSeparators(absolutePath);
    const normalizedBase = this.normalizeSeparators(basePath);

    if (normalizedAbsolute.startsWith(normalizedBase)) {
      let relativePath = normalizedAbsolute.substring(normalizedBase.length);
      
      // Remove leading separator
      if (relativePath.startsWith('/')) {
        relativePath = relativePath.substring(1);
      }
      
      if (relativePath) {
        return {
          success: true,
          relativePath,
          strategy: 'direct'
        };
      }
    }
    
    return {
      success: false,
      error: 'Path does not start with base path'
    };
  }

  /**
   * Regex conversion strategy - extract plugin path pattern
   */
  private attemptRegexConversion(absolutePath: string): ConversionResult {
    const normalized = this.normalizeSeparators(absolutePath);
    
    // Pattern to match: any-prefix/(.obsidian/plugins/plugin-id/...)
    const pattern = /.*[\/\\](\.obsidian[\/\\]plugins[\/\\][^\/\\]+[\/\\].*)$/;
    const match = normalized.match(pattern);
    
    if (match) {
      const relativePath = match[1].replace(/\\/g, '/');
      return {
        success: true,
        relativePath,
        strategy: 'regex'
      };
    }
    
    return {
      success: false,
      error: 'Plugin path pattern not found'
    };
  }

  /**
   * Fallback extraction when other methods fail
   */
  private extractPluginPathFallback(path: string): string {
    const normalized = this.normalizeSeparators(path);
    
    // Look for .obsidian/plugins anywhere in path
    const obsidianIndex = normalized.indexOf('.obsidian/plugins/');
    if (obsidianIndex >= 0) {
      return normalized.substring(obsidianIndex);
    }

    // Ultimate fallback - return safe default
    return this.createDataPath('storage');
  }

  /**
   * Validate path format and detect potential issues
   */
  validatePath(path: string): PathValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Check for absolute path indicators
    if (this.isAbsolutePath(path)) {
      errors.push('Path should be relative to vault root, not absolute');
    }

    // Check for backslashes (should use forward slashes)
    if (path.includes('\\')) {
      warnings.push('Path contains backslashes, should use forward slashes');
    }

    // Check for path traversal
    if (path.includes('..')) {
      errors.push('Path traversal sequences (..) are not allowed');
    }

    // Check for duplicated base paths
    if (this.vaultBasePath && this.detectDuplicatedPath(path)) {
      errors.push('Duplicated base path detected');
    }

    // Check path length limits
    if (path.length > 260) {
      warnings.push('Path length exceeds recommended limits for cross-platform compatibility');
    }

    const normalizedPath = this.normalizeSeparators(path);

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      normalizedPath
    };
  }

  /**
   * Detect if path contains duplicated base path
   */
  private detectDuplicatedPath(path: string): boolean {
    if (!this.vaultBasePath) return false;

    const normalizedPath = this.normalizeSeparators(path);
    const normalizedBase = this.normalizeSeparators(this.vaultBasePath);
    
    // Count occurrences of base path
    const basePathPattern = this.escapeRegExp(normalizedBase);
    const matches = normalizedPath.match(new RegExp(basePathPattern, 'g'));
    
    return (matches?.length ?? 0) > 1;
  }

  /**
   * Check if path is absolute
   */
  private isAbsolutePath(path: string): boolean {
    return /^[A-Za-z]:|^\//.test(path);
  }

  /**
   * Normalize path separators to forward slashes
   */
  private normalizeSeparators(path: string): string {
    return path.replace(/\\/g, '/');
  }

  /**
   * Sanitize path component for filesystem safety
   */
  private sanitizePath(path: string): string {
    return path
      .replace(/[<>:"|?*]/g, '_')  // Replace invalid filesystem chars
      .replace(/\\/g, '/')         // Normalize separators
      .replace(/\/+/g, '/')        // Remove duplicate separators
      .replace(/^\/|\/$/g, '')     // Remove leading/trailing separators
      .substring(0, 255);          // Limit length for filesystem compatibility
  }

  /**
   * Escape string for use in regular expression
   */
  private escapeRegExp(string: string): string {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  /**
   * Safe path operation wrapper - validates path before operation
   */
  async safePathOperation<T>(
    path: string,
    operation: (validPath: string) => Promise<T>,
    operationName: string = 'unknown'
  ): Promise<T> {
    try {
      // Convert to relative if absolute
      const relativePath = this.isAbsolutePath(path) 
        ? this.makeVaultRelative(path) 
        : path;

      // Validate the path
      const validation = this.validatePath(relativePath);
      if (!validation.isValid) {
        throw new Error(`Path validation failed: ${validation.errors.join(', ')}`);
      }

      // Normalize and execute operation
      const normalizedPath = normalizePath(relativePath);
      return await operation(normalizedPath);

    } catch (error) {
      console.error(`[PathManager] Safe operation '${operationName}' failed for path: ${path}`, error);
      throw error;
    }
  }

  /**
   * Get vault base path if available
   */
  getVaultBasePath(): string | null {
    return this.vaultBasePath;
  }

  /**
   * Check if vault base path is available
   */
  isVaultPathAvailable(): boolean {
    return this.vaultBasePath !== null;
  }
}
```

## utils/pathUtils.ts

```typescript
/**
 * Utilities for handling file paths safely
 */

/**
 * Basic path normalization - removes leading slash for Obsidian compatibility
 * @param path Path to normalize
 * @returns Normalized path without leading slash
 */
export function normalizePath(path: string): string {
    return path.startsWith('/') ? path.slice(1) : path;
}

/**
 * Determines if a path should be treated as absolute
 */
export function isAbsolutePath(path: string): boolean {
    // Check for absolute path patterns
    return path.startsWith('/') || /^[A-Z]:\\/i.test(path) || path.startsWith('\\\\');
}

/**
 * Sanitizes a filename or folder name
 * @param name The name to sanitize
 * @param useUnderscores Whether to replace spaces with underscores
 */
export function sanitizeName(name: string, useUnderscores = false): string {
    if (!name || typeof name !== 'string') {
        return '_unnamed_';
    }

    let sanitized = name
        // Replace characters invalid in Windows paths
        .replace(/[<>:"\\|?*]/g, '_')
        // Remove leading/trailing periods and spaces
        .replace(/^[\s.]+|[\s.]+$/g, '');

    if (useUnderscores) {
        sanitized = sanitized
            // Replace multiple spaces/underscores with single underscore
            .replace(/\s+/g, '_')
            .replace(/_+/g, '_');
    }

    // Ensure name isn't empty after sanitization
    return sanitized || '_unnamed_';
}

/**
 * Sanitizes a file path by replacing invalid characters with safe alternatives
 * @param path The file path to sanitize
 * @param preserveLeadingSlash Whether to preserve a leading slash if present
 * @returns A sanitized path safe for file system operations
 */
export function sanitizePath(path: string, preserveLeadingSlash = false): string {
    // Handle empty or invalid input
    if (!path || typeof path !== 'string') {
        return '';
    }

    // Detect if path had a leading slash
    const hadLeadingSlash = path.startsWith('/');

    // Normalize path separators
    const normalizedPath = path.replace(/\\/g, '/');

    // Split path into parts
    const parts = normalizedPath.split('/');

    // Sanitize each part while preserving structure
    const sanitizedParts = parts.map((part, index) => {
        // Skip empty parts, dots, and root indicators
        if (!part || part === '.' || part === '..' || 
            (index === 0 && isAbsolutePath(path))) {
            return part;
        }

        return sanitizeName(part, false);
    });

    // Reconstruct path
    let result = sanitizedParts.join('/');
    
    // Handle leading slash consistently
    if (hadLeadingSlash && preserveLeadingSlash) {
        // Ensure path starts with exactly one slash
        result = '/' + result.replace(/^\/+/, '');
    } else {
        // Remove any leading slashes
        result = result.replace(/^\/+/, '');
    }

    return result;
}

/**
 * Ensures a path has a .md extension
 * @param path The file path to check
 * @returns Path with .md extension
 */
export function ensureMdExtension(path: string): string {
    if (!path.toLowerCase().endsWith('.md')) {
        return path + '.md';
    }
    return path;
}

/**
 * Operation types for path normalization
 */
export type OperationType = 'NOTE' | 'DIRECTORY' | 'GENERIC';

/**
 * Smart path normalization that handles missing file extensions
 * Only adds .md extension for note operations when no extension is present
 * @param path The file path to normalize
 * @param preserveLeadingSlash Whether to preserve a leading slash if present
 * @param operationType Type of operation to determine extension handling
 * @returns Normalized path with appropriate extension handling
 */
export function smartNormalizePath(
    path: string, 
    preserveLeadingSlash = false, 
    operationType: OperationType = 'GENERIC'
): string {
    if (!path || typeof path !== 'string') {
        return '';
    }

    // First apply standard path sanitization
    const sanitizedPath = sanitizePath(path, preserveLeadingSlash);
    
    // Only add .md extension for note operations when no extension is present
    if (operationType === 'NOTE' && 
        sanitizedPath && 
        !sanitizedPath.endsWith('/') && 
        !hasFileExtension(sanitizedPath)) {
        return sanitizedPath + '.md';
    }
    
    return sanitizedPath;
}

/**
 * Checks if a path has any file extension
 * @param path The path to check
 * @returns True if path has an extension, false otherwise
 */
function hasFileExtension(path: string): boolean {
    const lastSlashIndex = path.lastIndexOf('/');
    const lastDotIndex = path.lastIndexOf('.');
    
    // Extension must come after the last slash (if any) and not be the first character of filename
    return lastDotIndex > lastSlashIndex && lastDotIndex > lastSlashIndex + 1;
}

// Removed isLikelyFolder function - no longer needed with explicit operation types

/**
 * Gets the parent folder path from a file path
 * @param path The file path
 * @returns The parent folder path
 */
export function getFolderPath(path: string): string {
    const parts = path.split('/');
    return parts.slice(0, -1).join('/');
}

/**
 * Validates a file path for basic safety
 * @param path The file path to validate
 * @returns True if path is valid, false otherwise
 */
export function isValidPath(path: string): boolean {
    if (!path || typeof path !== 'string') {
        return false;
    }

    // Check for absolute paths or directory traversal
    if (path.startsWith('/') || path.includes('..')) {
        return false;
    }

    // Check for invalid characters
    const invalidChars = /[<>:"\\|?*\x00-\x1F]/;
    if (invalidChars.test(path)) {
        return false;
    }

    return true;
}

/**
 * Checks if a string contains glob characters
 */
export function isGlobPattern(pattern: string): boolean {
    return /[*?\[\]{}]/.test(pattern);
}

/**
 * Converts a glob pattern to a RegExp
 * Supports * (wildcard), ** (recursive wildcard), ? (single char)
 */
export function globToRegex(pattern: string): RegExp {
    // Escape special regex characters except *, ?, [, ], {, }
    let regexString = pattern
        .replace(/[.+^${}()|\\]/g, '\\$&')
        // Handle ** (recursive wildcard)
        .replace(/\*\*/g, '.*')
        // Handle * (single level wildcard) - matches anything except /
        .replace(/(?<!\.)\*/g, '[^/]*')
        // Handle ? (single char)
        .replace(/\?/g, '.')
        // Handle brackets []
        .replace(/\[!/g, '[^')
        .replace(/\[/g, '[')
        .replace(/\]/g, ']')
        // Handle braces {} - simplified support for {a,b}
        .replace(/\{([^}]+)\}/g, (_, options) => `(${options.replace(/,/g, '|')})`);
    
    // Anchor to start and end
    return new RegExp(`^${regexString}$`);
}

```

## utils/platform.ts

```typescript
/**
 * Platform detection utilities for mobile compatibility.
 * Uses Obsidian's Platform API which is the official way to detect platform.
 *
 * Key notes:
 * - Node.js and Electron APIs are NOT available on mobile (will crash)
 * - iOS does not support regex lookbehind (?<=...)
 * - Tablets use desktop layout, .is-mobile only applies to phones
 * - Use body.is-mobile in CSS for mobile-specific styles
 */

import { Platform } from 'obsidian';

/**
 * Extended Node.js process interface with optional version fields
 */
interface NodeProcess {
    versions?: {
        node?: string;
        electron?: string;
    };
}

/**
 * Check if running on mobile (iOS or Android phone)
 */
export const isMobile = (): boolean => {
    return Platform.isMobile;
};

/**
 * Check if running on desktop (Mac, Windows, Linux)
 */
export const isDesktop = (): boolean => {
    // Platform.isMobile can be true on some macOS Catalyst/simulator environments.
    // For feature gating (Node/Electron-only APIs), we treat those as "mobile-like".
    return Platform.isDesktop && !Platform.isMobile;
};

/**
 * Check if Node.js runtime APIs are available.
 * Obsidian desktop (Electron) provides Node; mobile does not.
 */
export const hasNodeRuntime = (): boolean => {
    return typeof process !== 'undefined' && !!((process as NodeProcess).versions?.node);
};

/**
 * Check if running inside Electron.
 * Helpful for gating features that depend on Electron/Node integration.
 */
export const isElectron = (): boolean => {
    return typeof process !== 'undefined' && !!((process as NodeProcess).versions?.electron);
};

/**
 * Check if running on iOS
 */
export const isIOS = (): boolean => {
    return Platform.isIosApp;
};

/**
 * Check if running on Android
 */
export const isAndroid = (): boolean => {
    return Platform.isAndroidApp;
};

/**
 * Check if running on macOS
 */
export const isMacOS = (): boolean => {
    return Platform.isMacOS;
};

/**
 * Check if running on Windows
 */
export const isWindows = (): boolean => {
    return Platform.isWin;
};

/**
 * Check if running on Linux
 */
export const isLinux = (): boolean => {
    return Platform.isLinux;
};

/**
 * Check if local LLM providers are supported (Ollama, LM Studio).
 * These require localhost servers which only work on desktop.
 */
export const supportsLocalLLM = (): boolean => {
    return isDesktop() && hasNodeRuntime();
};

/**
 * Check if MCP bridge is supported.
 * MCP requires Node.js HTTP server (Express) which is not available on mobile.
 */
export const supportsMCPBridge = (): boolean => {
    return isDesktop() && hasNodeRuntime();
};

/**
 * Check if WebLLM/Nexus local is supported.
 * Requires desktop + WebGPU support.
 * Known issue: Multi-turn tool continuations may crash on Apple Silicon.
 */
export const supportsWebLLM = (): boolean => {
    // Re-enabled Dec 2025 - lazy initialization prevents startup hangs
    // WebGPU availability is checked on first use, not here
    return isDesktop();
};

/**
 * Get a human-readable platform name for logging/display
 * Note: Platform.isMobile can be true even on macOS (Catalyst/simulator)
 */
export const getPlatformName = (): string => {
    if (Platform.isIosApp) return 'iOS';
    if (Platform.isAndroidApp) return 'Android';
    // Note: isMacOS can be true alongside isMobile for Mac Catalyst builds
    if (Platform.isMacOS) return 'macOS';
    if (Platform.isWin) return 'Windows';
    if (Platform.isLinux) return 'Linux';
    return 'Unknown';
};

/**
 * Get detailed platform info for debugging
 */
export const getPlatformDebugInfo = (): Record<string, boolean> => {
    return {
        isMobile: Platform.isMobile,
        isDesktop: Platform.isDesktop,
        isIosApp: Platform.isIosApp,
        isAndroidApp: Platform.isAndroidApp,
        isMacOS: Platform.isMacOS,
        isWin: Platform.isWin,
        isLinux: Platform.isLinux,
    };
};

/**
 * List of features unavailable on mobile
 */
export const getMobileUnavailableFeatures = (): string[] => {
    if (!isMobile()) return [];

    return [
        'MCP Server (Claude Desktop bridge)',
        'Local LLM providers (Ollama, LM Studio)',
        'WebLLM/Nexus local models',
        'SDK-based providers (OpenAI, Anthropic, Google, Mistral, Groq)',
    ];
};

/**
 * LLM providers that work on mobile (use fetch/requestUrl, no Node.js SDKs)
 * These providers make direct HTTP requests without SDK dependencies.
 */
export const MOBILE_COMPATIBLE_PROVIDERS = [
    'openrouter',   // Uses fetch - 400+ models via unified API
    'requesty',     // Uses fetch - Router for multiple providers
    'perplexity',   // Uses fetch - Web search focused
] as const;

/**
 * LLM providers that require Node.js SDKs (desktop only)
 * These use official SDK packages that have Node.js dependencies.
 */
export const DESKTOP_ONLY_PROVIDERS = [
    'openai',       // Uses openai SDK
    'anthropic',    // Uses @anthropic-ai/sdk
    'google',       // Uses @google/genai
    'mistral',      // Uses @mistralai/mistralai
    'groq',         // Uses groq-sdk
    'ollama',       // Local server - desktop only
    'lmstudio',     // Local server - desktop only
    'webllm',       // WebGPU - disabled due to bugs
] as const;

/**
 * Check if a provider is compatible with the current platform
 */
export const isProviderCompatible = (providerId: string): boolean => {
    // Explicit feature gating for special providers
    if (providerId === 'webllm') {
        return supportsWebLLM();
    }
    if (providerId === 'ollama' || providerId === 'lmstudio') {
        return supportsLocalLLM();
    }

    if (isDesktop()) {
        return true; // All non-special providers work on desktop
    }

    // On mobile, only allow fetch-based providers
    return (MOBILE_COMPATIBLE_PROVIDERS as readonly string[]).includes(providerId);
};

/**
 * Get list of providers available on current platform
 */
export const getAvailableProviders = (): string[] => {
    const candidates = isDesktop()
        ? [...MOBILE_COMPATIBLE_PROVIDERS, ...DESKTOP_ONLY_PROVIDERS]
        : [...MOBILE_COMPATIBLE_PROVIDERS];

    return candidates.filter(isProviderCompatible);
};

```

## utils/pluginLocator.ts

```typescript
import type { App, Plugin } from 'obsidian';
import { getAllPluginIds } from '../constants/branding';

export function getNexusPlugin<T extends Plugin = Plugin>(app: App): T | null {
    for (const id of getAllPluginIds()) {
        const plugin = app.plugins.getPlugin(id);
        if (plugin) {
            return plugin as T;
        }
    }

    return null;
}

export function getNexusPluginFromRegistry<T = Plugin>(
    registry: Record<string, T>
): T | null {
    if (!registry) {
        return null;
    }

    for (const id of getAllPluginIds()) {
        const plugin = registry[id];
        if (plugin) {
            return plugin;
        }
    }

    return null;
}

```

## utils/recommendationUtils.ts

```typescript
/**
 * Utility for standardized recommendation injection into mode results
 * Used across agents to provide consistent recommendation arrays in MCP responses
 */

export interface Recommendation {
	type: string;
	message: string;
}

/**
 * Adds recommendations array to any mode result object
 * @param result - The base result object from a mode execution
 * @param recommendations - Array of recommendations to inject
 * @returns Enhanced result with recommendations field
 */
export function addRecommendations(result: any, recommendations: Recommendation[]): any {
	return { ...result, recommendations };
}
```

## utils/schemas/builders/BatchExecuteSchemaBuilder.ts

```typescript
/**
 * BatchExecuteSchemaBuilder - Handles complex batch LLM execution schemas
 * Location: /src/utils/schemas/builders/BatchExecuteSchemaBuilder.ts
 *
 * This builder handles schema generation for batch execution of multiple LLM prompts
 * with support for sequences, parallel groups, context passing, and actions.
 *
 * Used by: AgentManager batch execution mode for MCP tool definitions
 */

import { ISchemaBuilder, SchemaContext } from '../SchemaTypes';
import { LLMProviderManager } from '../../../services/llm/providers/ProviderManager';
import { mergeWithCommonSchema } from '../../schemaUtils';
import { SchemaBuilder } from '../SchemaBuilder';

/**
 * Batch Execute Schema Builder - Handles complex batch LLM execution schemas
 */
export class BatchExecuteSchemaBuilder implements ISchemaBuilder {
  constructor(private providerManager: LLMProviderManager | null) {}

  buildParameterSchema(context: SchemaContext): any {
    const builder = new SchemaBuilder(this.providerManager);
    const commonProps = builder.buildCommonProperties({
      includeProviders: true,
      includeActions: true
    });

    const batchSchema = {
      type: 'object',
      title: 'Batch Execute LLM Prompts Parameters',
      description: 'Execute multiple LLM prompts concurrently across different providers with context support.',
      properties: {
        prompts: {
          type: 'array',
          description: 'Array of prompts to execute concurrently',
          items: {
            type: 'object',
            title: 'Individual Prompt Configuration',
            description: 'Configuration for a single LLM prompt execution',
            properties: {
              prompt: {
                type: 'string',
                description: 'The prompt text to send to the LLM',
                examples: [
                  'Summarize this document',
                  'Generate unit tests for this code',
                  'Explain this concept in simple terms'
                ]
              },
              provider: commonProps.provider,
              model: commonProps.model,
              contextFiles: {
                type: 'array',
                description: 'Optional context files to include with this prompt',
                items: { type: 'string' }
              },
              workspace: {
                type: 'string',
                description: 'Optional workspace for context'
              },
              id: {
                type: 'string',
                description: 'Custom identifier for this prompt'
              },
              sequence: {
                type: 'number',
                description: 'Sequence number for ordered execution. Prompts with same sequence run in parallel, sequences execute in numerical order (0, 1, 2, etc.). If not specified, defaults to 0.',
                minimum: 0,
                examples: [0, 1, 2, 3]
              },
              parallelGroup: {
                type: 'string',
                description: 'Parallel group within sequence - prompts with same parallelGroup run together, different groups run sequentially within the sequence',
                examples: ['groupA', 'groupB', 'preprocessing', 'analysis']
              },
              includePreviousResults: {
                type: 'boolean',
                description: 'Whether to include previous sequence results as context for this prompt. Only applies when sequence > 0.',
                default: false
              },
              contextFromSteps: {
                type: 'array',
                description: 'Specific IDs of previous steps to include as context (if not specified, includes all previous results when includePreviousResults is true)',
                items: { type: 'string' }
              },
              action: commonProps.action,
              agent: {
                type: 'string',
                description: 'Optional custom agent/prompt to use for this prompt'
              }
            },
            required: ['prompt']
          },
          minItems: 1,
          maxItems: 100
        },
        mergeResponses: {
          type: 'boolean',
          description: 'Whether to merge all responses into a single result (default: false)',
          default: false
        }
      },
      required: ['prompts'],
      additionalProperties: false
    };

    return mergeWithCommonSchema(batchSchema);
  }

  buildResultSchema(context: SchemaContext): any {
    return {
      type: 'object',
      properties: {
        success: {
          type: 'boolean',
          description: 'Whether the batch execution was successful'
        },
        results: {
          type: 'array',
          description: 'Individual prompt results (if mergeResponses is false)',
          items: this.buildPromptResultSchema()
        },
        merged: {
          type: 'object',
          description: 'Merged response (if mergeResponses is true)',
          properties: {
            totalPrompts: {
              type: 'number',
              description: 'Total number of prompts executed'
            },
            successfulPrompts: {
              type: 'number',
              description: 'Number of prompts that succeeded'
            },
            combinedResponse: {
              type: 'string',
              description: 'All responses combined into a single string'
            },
            providersUsed: {
              type: 'array',
              description: 'List of providers that were used',
              items: { type: 'string' }
            }
          }
        },
        stats: {
          type: 'object',
          description: 'Execution statistics',
          properties: {
            totalExecutionTimeMS: {
              type: 'number',
              description: 'Total execution time in milliseconds'
            },
            promptsExecuted: {
              type: 'number',
              description: 'Number of prompts executed'
            },
            promptsFailed: {
              type: 'number',
              description: 'Number of prompts that failed'
            },
            avgExecutionTimeMS: {
              type: 'number',
              description: 'Average execution time per prompt'
            },
            tokensUsed: {
              type: 'number',
              description: 'Total tokens used (if available)'
            }
          }
        },
        error: {
          type: 'string',
          description: 'Error message if batch execution failed'
        }
      },
      required: ['success'],
      additionalProperties: false
    };
  }

  private buildPromptResultSchema(): any {
    return {
      type: 'object',
      properties: {
        id: { type: 'string', description: 'Custom identifier for this prompt' },
        prompt: { type: 'string', description: 'The original prompt text' },
        success: { type: 'boolean', description: 'Whether this individual prompt succeeded' },
        response: { type: 'string', description: 'The LLM response (if successful)' },
        provider: { type: 'string', description: 'The provider that was used' },
        model: { type: 'string', description: 'The model that was used' },
        error: { type: 'string', description: 'Error message (if failed)' },
        executionTime: { type: 'number', description: 'Execution time in milliseconds' },
        sequence: { type: 'number', description: 'Sequence number this prompt was executed in' },
        parallelGroup: { type: 'string', description: 'Parallel group this prompt was executed in' },
        agent: { type: 'string', description: 'The custom agent that was used' },
        actionPerformed: {
          type: 'object',
          description: 'Details about any action performed with the response',
          properties: {
            type: { type: 'string', description: 'Type of action performed' },
            targetPath: { type: 'string', description: 'Target path for the action' },
            success: { type: 'boolean', description: 'Whether the action was successful' },
            error: { type: 'string', description: 'Error message if action failed' }
          }
        }
      }
    };
  }
}

```

## utils/schemas/builders/ContentBatchSchemaBuilder.ts

```typescript
/**
 * ContentBatchSchemaBuilder - Handles batch content operations schemas
 * Location: /src/utils/schemas/builders/ContentBatchSchemaBuilder.ts
 *
 * This builder handles schema generation for batch content operations including
 * read, create, append, prepend, replace, delete, and findReplace operations.
 *
 * Used by: ContentManager batch mode for MCP tool definitions
 */

import { ISchemaBuilder, SchemaContext } from '../SchemaTypes';

/**
 * Content Batch Schema Builder - Handles batch content operations
 */
export class ContentBatchSchemaBuilder implements ISchemaBuilder {
  buildParameterSchema(context: SchemaContext): any {
    return {
      type: 'object',
      properties: {
        operations: {
          type: 'array',
          description: 'Array of operations to perform',
          items: {
            type: 'object',
            properties: {
              type: {
                type: 'string',
                enum: ['read', 'create', 'append', 'prepend', 'replace', 'replaceByLine', 'delete', 'findReplace'],
                description: 'Type of operation'
              },
              params: {
                type: 'object',
                description: 'Operation-specific parameters. IMPORTANT: All operations require a "filePath" parameter.'
              }
            },
            required: ['type', 'params']
          }
        },
        workspaceContext: {
          type: 'object',
          description: 'Workspace context for the operation'
        },
        sessionId: {
          type: 'string',
          description: 'Session identifier for tracking'
        },
      },
      required: ['operations']
    };
  }

  buildResultSchema(context: SchemaContext): any {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean', description: 'Whether the operation succeeded' },
        error: { type: 'string', description: 'Error message if success is false' },
        data: {
          type: 'object',
          properties: {
            results: {
              type: 'array',
              description: 'Array of operation results',
              items: {
                type: 'object',
                properties: {
                  success: { type: 'boolean', description: 'Whether the operation succeeded' },
                  error: { type: 'string', description: 'Error message if success is false' },
                  data: { type: 'object', description: 'Operation-specific result data' },
                  type: { type: 'string', description: 'Type of operation' },
                  filePath: { type: 'string', description: 'File path for the operation' }
                },
                required: ['success', 'type', 'filePath']
              }
            }
          },
          required: ['results']
        },
        workspaceContext: {
          type: 'object',
          properties: {
            workspaceId: { type: 'string', description: 'ID of the workspace' },
            workspacePath: {
              type: 'array',
              items: { type: 'string' },
              description: 'Path of the workspace'
            },
            activeWorkspace: { type: 'boolean', description: 'Whether this is the active workspace' }
          }
        },
      },
      required: ['success']
    };
  }
}

```

## utils/schemas/builders/ExecuteSchemaBuilder.ts

```typescript
/**
 * ExecuteSchemaBuilder - Handles single prompt execution schemas
 * Location: /src/utils/schemas/builders/ExecuteSchemaBuilder.ts
 *
 * This builder handles schema generation for single LLM prompt execution
 * with support for custom agents, file context, model parameters, and actions.
 *
 * Used by: AgentManager execute mode for MCP tool definitions
 */

import { ISchemaBuilder, SchemaContext } from '../SchemaTypes';
import { LLMProviderManager } from '../../../services/llm/providers/ProviderManager';
import { mergeWithCommonSchema } from '../../schemaUtils';
import { SchemaBuilder } from '../SchemaBuilder';

/**
 * Execute Schema Builder - Handles single prompt execution schemas
 */
export class ExecuteSchemaBuilder implements ISchemaBuilder {
  constructor(private providerManager: LLMProviderManager | null) {}

  buildParameterSchema(context: SchemaContext): any {
    const builder = new SchemaBuilder(this.providerManager);
    const commonProps = builder.buildCommonProperties({
      includeProviders: true,
      includeActions: true
    });

    return mergeWithCommonSchema({
      properties: {
        agent: {
          type: 'string',
          description: 'Custom prompt agent name/id to use as system prompt (optional - if not provided, uses raw prompt only)'
        },
        filepaths: {
          type: 'array',
          items: { type: 'string' },
          description: 'Optional array of file paths to include content as context'
        },
        prompt: {
          type: 'string',
          description: 'User prompt/question to send to the LLM'
        },
        provider: commonProps.provider,
        model: commonProps.model,
        temperature: {
          type: 'number',
          minimum: 0,
          maximum: 1,
          description: 'Temperature setting for response randomness (0.0-1.0)'
        },
        maxTokens: {
          type: 'number',
          description: 'Maximum tokens to generate'
        },
        action: commonProps.action
      },
      required: ['prompt']
    });
  }

  buildResultSchema(context: SchemaContext): any {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean' },
        error: { type: 'string' },
        data: {
          type: 'object',
          properties: {
            response: { type: 'string' },
            model: { type: 'string' },
            provider: { type: 'string' },
            agentUsed: { type: 'string' },
            usage: {
              type: 'object',
              properties: {
                promptTokens: { type: 'number' },
                completionTokens: { type: 'number' },
                totalTokens: { type: 'number' }
              },
              required: ['promptTokens', 'completionTokens', 'totalTokens']
            },
            cost: {
              type: 'object',
              properties: {
                inputCost: { type: 'number' },
                outputCost: { type: 'number' },
                totalCost: { type: 'number' },
                currency: { type: 'string' }
              },
              required: ['inputCost', 'outputCost', 'totalCost', 'currency']
            },
            filesIncluded: {
              type: 'array',
              items: { type: 'string' }
            },
            actionPerformed: {
              type: 'object',
              properties: {
                type: { type: 'string' },
                targetPath: { type: 'string' },
                success: { type: 'boolean' },
                error: { type: 'string' }
              },
              required: ['type', 'targetPath', 'success']
            }
          },
          required: ['response', 'model', 'provider', 'agentUsed']
        },
        sessionId: { type: 'string' },
        context: { type: 'string' }
      },
      required: ['success', 'sessionId']
    };
  }
}

```

## utils/schemas/builders/index.ts

```typescript
/**
 * Schema Builders Index
 * Location: /src/utils/schemas/builders/index.ts
 *
 * Centralized exports for all concrete schema builder implementations.
 * Re-exports all builder classes for clean imports.
 */

export { BatchExecuteSchemaBuilder } from './BatchExecuteSchemaBuilder';
export { ExecuteSchemaBuilder } from './ExecuteSchemaBuilder';
export { ContentBatchSchemaBuilder } from './ContentBatchSchemaBuilder';
export { SessionSchemaBuilder } from './SessionSchemaBuilder';

```

## utils/schemas/builders/SessionSchemaBuilder.ts

```typescript
/**
 * SessionSchemaBuilder - Handles session creation schemas
 * Location: /src/utils/schemas/builders/SessionSchemaBuilder.ts
 *
 * This builder handles schema generation for session creation with support for
 * context tracing, workspace context, tags, and memory continuity.
 *
 * Used by: MemoryManager session creation mode for MCP tool definitions
 */

import { ISchemaBuilder, SchemaContext } from '../SchemaTypes';

/**
 * Session Schema Builder - Handles session creation schemas
 */
export class SessionSchemaBuilder implements ISchemaBuilder {
  buildParameterSchema(context: SchemaContext): any {
    return {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name for the session' },
        description: { type: 'string', description: 'Description of the session purpose' },
        context: {
          type: 'string',
          description: 'Purpose or goal of this session - IMPORTANT: This will be stored with the session and used in memory operations',
          minLength: 1
        },
        generateContextTrace: {
          type: 'boolean',
          description: 'Whether to generate an initial memory trace with session context',
          default: true
        },
        sessionGoal: { type: 'string', description: 'The goal or purpose of this session (for memory context)' },
        previousSessionId: { type: 'string', description: 'Reference to previous session ID to establish continuity' },
        tags: {
          type: 'array',
          items: { type: 'string' },
          description: 'Tags to associate with this session'
        },
        contextDepth: {
          type: 'string',
          enum: ['minimal', 'standard', 'comprehensive'],
          description: 'How much context to include in the initial memory trace',
          default: 'standard'
        },
        workspaceContext: {
          oneOf: [
            {
              type: 'object',
              properties: {
                workspaceId: { type: 'string', description: 'Workspace identifier (optional - uses default workspace if not provided)' },
                workspacePath: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Path from root workspace to specific phase/task'
                }
              },
              description: 'Optional workspace context object - if not provided, uses a default workspace'
            },
            {
              type: 'string',
              description: 'Optional workspace context as JSON string - must contain workspaceId field'
            }
          ],
          description: 'Optional workspace context - if not provided, uses a default workspace'
        }
      }
    };
  }

  buildResultSchema(context: SchemaContext): any {
    return {
      type: 'object',
      properties: {
        success: { type: 'boolean', description: 'Whether the operation was successful' },
        data: {
          type: 'object',
          properties: {
            sessionId: { type: 'string', description: 'ID of the created session' },
            name: { type: 'string', description: 'Name of the created session' },
            workspaceId: { type: 'string', description: 'ID of the workspace' },
            startTime: { type: 'number', description: 'Session start timestamp' },
            previousSessionId: { type: 'string', description: 'ID of the previous session (if continuing)' },
            purpose: { type: 'string', description: 'The purpose of this session extracted from context parameter' },
            context: { type: 'string', description: 'Contextual information about the operation (from CommonResult)' },
            memoryContext: {
              type: 'object',
              description: 'Detailed contextual information about the session',
              properties: {
                summary: { type: 'string', description: 'Summary of the workspace state at session start' },
                purpose: { type: 'string', description: 'The purpose or goal of this session derived from context parameter' },
                relevantFiles: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Key files relevant to this session'
                },
                recentActivities: {
                  type: 'array',
                  items: {
                    type: 'object',
                    properties: {
                      timestamp: { type: 'number', description: 'When the activity occurred' },
                      description: { type: 'string', description: 'Description of the activity' },
                      type: { type: 'string', description: 'Type of activity' }
                    }
                  },
                  description: 'Recent activities in the workspace'
                },
                tags: {
                  type: 'array',
                  items: { type: 'string' },
                  description: 'Tags describing this session'
                }
              },
              required: ['summary', 'tags']
            }
          },
          required: ['sessionId', 'workspaceId', 'startTime']
        },
        error: { type: 'string', description: 'Error message if operation failed' },
        context: { type: 'string', description: 'The purpose and context of this session creation' }
      },
      required: ['success']
    };
  }
}

```

## utils/schemas/SchemaBuilder.ts

```typescript
/**
 * SchemaBuilder - Unified schema building system for all agent modes
 * Location: /src/utils/schemas/SchemaBuilder.ts
 *
 * This file consolidates 4 duplicate schema builders into a single, unified system:
 * - agentManager/modes/batchExecutePrompt/utils/SchemaBuilder.ts
 * - agentManager/modes/execute/services/SchemaBuilder.ts
 * - contentManager/modes/batch/schemas/SchemaBuilder.ts
 * - memoryManager/modes/session/create/services/SessionSchemaBuilder.ts
 *
 * Used by all agent modes requiring schema generation for MCP tool definitions.
 *
 * Refactored: Extracted concrete builders to separate files for better maintainability.
 */

import {
  SchemaType,
  SchemaContext,
  ISchemaBuilder,
  ProviderInfo,
  CommonSchemaProperties,
  SchemaValidationResult,
  SchemaStatistics
} from './SchemaTypes';

// Re-export SchemaType for consumers
export { SchemaType } from './SchemaTypes';
import { LLMProviderManager } from '../../services/llm/providers/ProviderManager';
import { mergeWithCommonSchema } from '../schemaUtils';
import { ProviderInfoService } from './services/ProviderInfoService';
import { BatchExecuteSchemaBuilder } from './builders/BatchExecuteSchemaBuilder';
import { ExecuteSchemaBuilder } from './builders/ExecuteSchemaBuilder';
import { ContentBatchSchemaBuilder } from './builders/ContentBatchSchemaBuilder';
import { SessionSchemaBuilder } from './builders/SessionSchemaBuilder';

/**
 * Unified schema builder that handles all schema generation across the application
 * Eliminates code duplication and provides consistent schema patterns
 */
export class SchemaBuilder {
  private providerManager: LLMProviderManager | null;
  private providerInfoService: ProviderInfoService;

  constructor(providerManager?: LLMProviderManager | null) {
    this.providerManager = providerManager || null;
    this.providerInfoService = new ProviderInfoService(this.providerManager);
  }

  /**
   * Main entry point - builds schema based on type and context
   */
  static buildSchema(type: SchemaType, context: SchemaContext): {
    parameterSchema: any;
    resultSchema: any;
  } {
    const builder = new SchemaBuilder(context.providerManager);
    const concreteBuilder = builder.getBuilder(type);

    return {
      parameterSchema: concreteBuilder.buildParameterSchema(context),
      resultSchema: concreteBuilder.buildResultSchema(context)
    };
  }

  /**
   * Instance method for parameter schema building
   */
  buildParameterSchema(type: SchemaType, context: SchemaContext): any {
    const builder = this.getBuilder(type);
    return builder.buildParameterSchema(context);
  }

  /**
   * Instance method for result schema building
   */
  buildResultSchema(type: SchemaType, context: SchemaContext): any {
    const builder = this.getBuilder(type);
    return builder.buildResultSchema(context);
  }

  /**
   * Backward-compatible method for getting parameter schema (ContentBatch type)
   * Used by BatchContentMode
   */
  getParameterSchema(): any {
    const context: SchemaContext = {
      mode: 'batchContent',
      providerManager: this.providerManager
    };
    return this.buildParameterSchema(SchemaType.ContentBatch, context);
  }

  /**
   * Backward-compatible method for getting result schema (ContentBatch type)
   * Used by BatchContentMode
   */
  getResultSchema(): any {
    const context: SchemaContext = {
      mode: 'batchContent',
      providerManager: this.providerManager
    };
    return this.buildResultSchema(SchemaType.ContentBatch, context);
  }

  /**
   * Get specific builder for schema type
   */
  private getBuilder(type: SchemaType): ISchemaBuilder {
    switch (type) {
      case SchemaType.BatchExecute:
        return new BatchExecuteSchemaBuilder(this.providerManager);
      case SchemaType.Execute:
        return new ExecuteSchemaBuilder(this.providerManager);
      case SchemaType.ContentBatch:
        return new ContentBatchSchemaBuilder();
      case SchemaType.Session:
        return new SessionSchemaBuilder();
      default:
        throw new Error(`Unknown schema type: ${type}`);
    }
  }

  /**
   * Update provider manager instance
   */
  updateProviderManager(providerManager: LLMProviderManager | null): void {
    this.providerManager = providerManager;
    this.providerInfoService.updateProviderManager(providerManager);
  }

  /**
   * Get provider information for schema building
   */
  getProviderInfo(): ProviderInfo {
    return this.providerInfoService.getProviderInfo();
  }

  /**
   * Build common schema properties used across multiple types
   */
  buildCommonProperties(options: {
    includeProviders?: boolean;
    includeActions?: boolean;
  } = {}): CommonSchemaProperties {
    const properties: CommonSchemaProperties = {};

    if (options.includeProviders) {
      const providerInfo = this.getProviderInfo();
      const defaultModel = this.providerInfoService.getDefaultModel();

      properties.provider = {
        type: 'string',
        description: `LLM provider name (optional, defaults to: ${defaultModel?.provider || 'not configured'}). Use listModels to see available providers.`,
        default: defaultModel?.provider
      };

      properties.model = {
        type: 'string',
        description: `Model name (optional, defaults to: ${defaultModel?.model || 'not configured'}). Use listModels to see available models.`,
        default: defaultModel?.model
      };
    }

    if (options.includeActions) {
      properties.action = this.buildActionSchema();
    }

    return properties;
  }

  /**
   * Build action schema for content operations
   */
  private buildActionSchema(): any {
    return {
      type: 'object',
      description: 'Optional action to perform with the LLM response',
      properties: {
        type: {
          type: 'string',
          enum: ['create', 'append', 'prepend', 'replace', 'findReplace'],
          description: 'Type of content action to perform'
        },
        targetPath: {
          type: 'string',
          description: 'Path to the target file for the action'
        },
        position: {
          type: 'number',
          description: 'Line position for replace actions'
        },
        findText: {
          type: 'string',
          description: 'Text to find and replace (required for findReplace action)'
        },
        replaceAll: {
          type: 'boolean',
          description: 'Whether to replace all occurrences (default: false)',
          default: false
        },
        caseSensitive: {
          type: 'boolean',
          description: 'Whether search is case sensitive (default: true)',
          default: true
        },
        wholeWord: {
          type: 'boolean',
          description: 'Whether to match whole words only (default: false)',
          default: false
        }
      },
      required: ['type', 'targetPath']
    };
  }

  /**
   * Validate schema configuration
   */
  validateConfiguration(): SchemaValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!this.providerManager) {
      warnings.push('Provider manager not available - schema will not include dynamic provider/model information');
    }

    const enabledProviders = this.providerInfoService.getEnabledProviders();
    if (enabledProviders.length === 0) {
      warnings.push('No providers are currently enabled - users may not be able to execute prompts');
    }

    const availableModels = this.providerInfoService.getAvailableModels();
    if (availableModels.length === 0) {
      warnings.push('No models are available - users may not be able to execute prompts');
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings
    };
  }

  /**
   * Get schema building statistics
   */
  getStatistics(): SchemaStatistics {
    const providerInfo = this.getProviderInfo();

    return {
      parameterProperties: 0, // Will be set by concrete implementations
      resultProperties: 0, // Will be set by concrete implementations
      supportedTypes: Object.values(SchemaType),
      hasProviderManager: !!this.providerManager,
      enabledProvidersCount: providerInfo.enabledProviders.length,
      availableModelsCount: providerInfo.availableModels.length
    };
  }
}

```

## utils/schemas/SchemaTypes.ts

```typescript
/**
 * SchemaTypes - Centralized type definitions for unified schema builder system
 * Location: /src/utils/schemas/SchemaTypes.ts
 * 
 * This file provides type definitions and enums for the unified schema builder,
 * consolidating patterns from 4 duplicate schema builders across the codebase.
 * Used by SchemaBuilder.ts to maintain type safety and consistent schema generation.
 */

import { LLMProviderManager } from '../../services/llm/providers/ProviderManager';

/**
 * Schema types supported by the unified builder
 */
export const SchemaType = {
  BatchExecute: 'batchExecute',
  Execute: 'execute', 
  ContentBatch: 'contentBatch',
  Session: 'session',
  State: 'state'
} as const;

export type SchemaType = typeof SchemaType[keyof typeof SchemaType];

/**
 * Context information for schema building
 */
export interface SchemaContext {
  mode: string;
  parameters?: any;
  options?: SchemaOptions;
  providerManager?: LLMProviderManager | null;
}

/**
 * Options for customizing schema generation
 */
export interface SchemaOptions {
  includeProviderInfo?: boolean;
  includeActions?: boolean;
  includeSession?: boolean;
  includeWorkspace?: boolean;
  maxItems?: number;
  minItems?: number;
}

/**
 * Base interface for all schema builders
 */
export interface ISchemaBuilder {
  buildParameterSchema(context: SchemaContext): any;
  buildResultSchema(context: SchemaContext): any;
}

/**
 * Provider and model information for dynamic schemas
 */
export interface ProviderInfo {
  enabledProviders: string[];
  availableModels: string[];
  hasProviderManager: boolean;
}

/**
 * Action schema configuration
 */
export interface ActionConfig {
  type: 'create' | 'append' | 'prepend' | 'replace' | 'findReplace';
  targetPath: string;
  position?: number;
  findText?: string;
  replaceAll?: boolean;
  caseSensitive?: boolean;
  wholeWord?: boolean;
}

/**
 * Content operation types for batch operations
 */
export type ContentOperationType = 
  | 'read' 
  | 'create' 
  | 'append' 
  | 'prepend' 
  | 'replace' 
  | 'replaceByLine' 
  | 'delete' 
  | 'findReplace';

/**
 * Session context depth options
 */
export type ContextDepth = 'minimal' | 'standard' | 'comprehensive';

/**
 * Execution sequence configuration
 */
export interface SequenceConfig {
  sequence?: number;
  parallelGroup?: string;
  includePreviousResults?: boolean;
  contextFromSteps?: string[];
}

/**
 * Usage and cost information
 */
export interface UsageInfo {
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;
}

export interface CostInfo {
  inputCost: number;
  outputCost: number;
  totalCost: number;
  currency: string;
}

/**
 * Common schema properties that appear across multiple schema types
 */
export interface CommonSchemaProperties {
  // Provider/Model properties
  provider?: {
    type: string;
    description: string;
    enum?: string[];
    examples?: string[];
    default?: string;
  };
  model?: {
    type: string;
    description: string;
    enum?: string[];
    examples?: string[];
    default?: string;
  };
  
  // Action properties
  action?: any;
  
  // Session properties
  sessionId?: {
    type: string;
    description: string;
  };
  
  // Workspace properties
  workspaceContext?: any;
  
  // Context properties
  context?: any;
}

/**
 * Schema validation result
 */
export interface SchemaValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

/**
 * Schema builder statistics
 */
export interface SchemaStatistics {
  parameterProperties: number;
  resultProperties: number;
  supportedTypes: SchemaType[];
  hasProviderManager: boolean;
  enabledProvidersCount: number;
  availableModelsCount: number;
}
```

## utils/schemas/services/index.ts

```typescript
/**
 * Schema Services Index
 * Location: /src/utils/schemas/services/index.ts
 *
 * Centralized exports for schema-related services.
 * Re-exports all service classes for clean imports.
 */

export { ProviderInfoService } from './ProviderInfoService';

```

## utils/schemas/services/ProviderInfoService.ts

```typescript
/**
 * ProviderInfoService - Handles LLM provider and model information retrieval
 * Location: /src/utils/schemas/services/ProviderInfoService.ts
 *
 * This service provides methods for retrieving provider and model information
 * from the LLMProviderManager for use in schema generation.
 *
 * Used by: SchemaBuilder and concrete builder implementations
 */

import { LLMProviderManager } from '../../../services/llm/providers/ProviderManager';
import { StaticModelsService } from '../../../services/StaticModelsService';
import { ProviderInfo } from '../SchemaTypes';

/**
 * Service for retrieving LLM provider and model information
 */
export class ProviderInfoService {
  constructor(private providerManager: LLMProviderManager | null) {}

  /**
   * Get comprehensive provider information for schema building
   */
  getProviderInfo(): ProviderInfo {
    if (!this.providerManager) {
      return {
        enabledProviders: [],
        availableModels: [],
        hasProviderManager: false
      };
    }

    return {
      enabledProviders: this.getEnabledProviders(),
      availableModels: this.getAvailableModels(),
      hasProviderManager: true
    };
  }

  /**
   * Get list of enabled providers from provider manager
   */
  getEnabledProviders(): string[] {
    if (!this.providerManager) return [];

    try {
      const settings = this.providerManager.getSettings();
      return Object.keys(settings.providers)
        .filter(id => settings.providers[id]?.enabled && settings.providers[id]?.apiKey);
    } catch (error) {
      return [];
    }
  }

  /**
   * Get list of available models from enabled providers
   */
  getAvailableModels(): string[] {
    if (!this.providerManager) return [];

    try {
      const staticModelsService = StaticModelsService.getInstance();
      const enabledProviders = this.getEnabledProviders();
      const models: string[] = [];

      enabledProviders.forEach(providerId => {
        try {
          const providerModels = staticModelsService.getModelsForProvider(providerId);
          models.push(...providerModels.map((m: any) => m.id));
        } catch (error) {
        }
      });

      return [...new Set(models)]; // Remove duplicates
    } catch (error) {
      return [];
    }
  }

  /**
   * Get default model from provider manager settings
   */
  getDefaultModel(): { provider: string; model: string } | null {
    if (!this.providerManager) return null;

    try {
      const settings = this.providerManager.getSettings();
      return settings.defaultModel || null;
    } catch (error) {
      return null;
    }
  }

  /**
   * Update the provider manager instance
   */
  updateProviderManager(providerManager: LLMProviderManager | null): void {
    this.providerManager = providerManager;
  }
}

```

## utils/schemaUtils.ts

```typescript
import type { CommonResult } from '../types';
import { enhanceSchemaDocumentation } from './validationUtils';

/**
 * Utility functions for handling JSON schemas in a DRY way
 */

/**
 * Get schema for workspace context parameters
 * @returns JSON schema for workspace context
 */
export function getWorkspaceContextSchema(): any {
  return enhanceSchemaDocumentation({
    workspaceContext: {
      oneOf: [
        {
          type: 'object',
          properties: {
            workspaceId: { 
              type: 'string',
              description: 'Workspace identifier (optional - uses default workspace if not provided)' 
            },
            workspacePath: { 
              type: 'array', 
              items: { type: 'string' },
              description: 'Path from root workspace to specific phase/task'
            },
            contextDepth: {
              type: 'string',
              enum: ['minimal', 'standard', 'comprehensive'],
              description: 'Level of context to include in results'
            }
          },
          description: 'Optional workspace context object - if not provided, uses a default workspace'
        },
        {
          type: 'string',
          description: 'Optional workspace context as JSON string - must contain workspaceId field'
        }
      ],
      description: 'Optional workspace context - if not provided, uses a default workspace'
    }
  });
}

/**
 * Get schema for a single mode call
 * @returns JSON schema for a mode call
 */
export function getModeCallSchema(): any {
  return enhanceSchemaDocumentation({
    type: 'object',
    properties: {
      tool: { 
        type: 'string',
        description: 'Agent name to execute mode on' 
      },
      mode: { 
        type: 'string',
        description: 'Mode to execute' 
      },
      parameters: { 
        type: 'object',
        description: 'Parameters to pass to the mode'
      },
      returnHere: { 
        type: 'boolean',
        description: 'Whether to return results to original agent'
      },
      continueOnFailure: {
        type: 'boolean',
        description: 'Whether to continue execution if this mode fails'
      },
      strategy: {
        type: 'string',
        enum: ['serial', 'parallel'],
        description: 'Execution strategy for this mode call'
      },
      callName: {
        type: 'string',
        description: 'Optional name to identify this mode call in the results'
      }
    },
    required: ['tool', 'mode', 'parameters'],
    description: 'Mode call definition'
  });
}


/**
 * Get schema for session parameters (now part of context - kept for backward compatibility)
 * @returns Empty schema since session fields are now in context
 */
export function getSessionSchema(): any {
  return {};
}

/**
 * Get schema for context parameter - NEW ToolContext format
 * Uses memory â†’ goal â†’ constraints flow (1-3 sentences each)
 *
 * Note: When tools are accessed via toolManager_useTool, context is injected automatically.
 * This schema is used for direct tool access (backward compatibility).
 *
 * @returns JSON schema for context
 */
export function getContextSchema(): any {
  return enhanceSchemaDocumentation({
    context: {
      type: 'object',
      properties: {
        workspaceId: {
          type: 'string',
          description: 'Workspace scope identifier'
        },
        sessionId: {
          type: 'string',
          description: 'Session identifier for tracking'
        },
        memory: {
          type: 'string',
          description: 'Essence of conversation so far (1-3 sentences)'
        },
        goal: {
          type: 'string',
          description: 'Current objective (1-3 sentences)'
        },
        constraints: {
          type: 'string',
          description: 'Rules/limits to follow (1-3 sentences, optional)'
        }
      },
      required: ['workspaceId', 'sessionId', 'memory', 'goal'],
      description: 'Context for this tool call. Use toolManager_useTool for automatic context handling.'
    }
  });
}

export function getCommonParameterSchema(): any {
  return {
    ...getSessionSchema(),
    ...getWorkspaceContextSchema(),
    ...getContextSchema()
  };
}

/**
 * Get schema for common result
 * @returns JSON schema for common result
 */
export function getCommonResultSchema(): any {
  return enhanceSchemaDocumentation({
    type: 'object',
    properties: {
      success: {
        type: 'boolean',
        description: 'Whether the operation was successful'
      },
      error: {
        type: 'string',
        description: 'Error message if operation failed'
      },
      data: {
        type: 'object',
        description: 'Operation-specific result data'
      },
      context: {
        type: 'string',
        description: 'Background information and purpose for running this tool'
      },
      workspaceContext: {
        type: 'object',
        properties: {
          workspaceId: { 
            type: 'string',
            description: 'Workspace identifier'
          },
          workspacePath: { 
            type: 'array', 
            items: { type: 'string' },
            description: 'Path from root workspace to specific phase/task'
          },
          sessionId: {
            type: 'string',
            description: 'Session identifier used for this operation'
          },
          activeWorkspace: { 
            type: 'boolean',
            description: 'Whether this workspace is currently active'
          },
          contextDepth: {
            type: 'string',
            enum: ['minimal', 'standard', 'comprehensive'],
            description: 'Level of context included in results'
          }
        },
        description: 'Workspace context that was used'
      },
      sessionId: {
        type: 'string',
        description: 'Session identifier used for tracking tool calls'
      }
    },
    required: ['success', 'sessionId']
  });
}

/**
 * Merge custom parameter schema with common parameter schema
 * @param customSchema The mode-specific schema
 * @returns Merged schema with common parameters
 */
export function mergeWithCommonSchema(customSchema: any): any {
  const commonSchema = getCommonParameterSchema();
  
  // Merge properties without duplication
  const mergedProperties = {
    ...customSchema.properties,
    ...commonSchema
  };
  
  // Merge required arrays without duplicates
  const customRequired = customSchema.required || [];
  const commonRequired = ['sessionId', 'context'];
  const mergedRequired = Array.from(new Set([...customRequired, ...commonRequired]));
  
  return {
    type: 'object',
    properties: mergedProperties,
    required: mergedRequired
  };
}

/**
 * Create a standardized result object
 * @param success Whether the operation was successful
 * @param data Operation-specific data
 * @param error Error message if operation failed
 * @param workspaceContext Workspace context used
 * @param sessionId Session identifier
 * @param context Contextual information (rich object or string for backward compatibility)
 * @param additionalProps Additional properties to include in the result
 * @returns Standardized result object
 */
export function createResult<T extends CommonResult>(
  success: boolean,
  data?: any,
  error?: string,
  workspaceContext?: CommonResult['workspaceContext'],
  sessionId?: string,
  context?: CommonResult['context'] | string,
  additionalProps?: Record<string, any>
): T {
  const result: any = {
    success,
    ...(data !== undefined && { data }),
    ...(error !== undefined && { error }),
    ...(workspaceContext !== undefined && { workspaceContext }),
    ...(sessionId !== undefined && { sessionId }),
    ...(context !== undefined && { context })
  };
  
  // Add any additional properties
  if (additionalProps) {
    Object.assign(result, additionalProps);
  }
  
  return result as T;
}
```

## utils/sessionUtils.ts

```typescript
/**
 * Session utility functions for consistent session management
 * Provides standardized methods for generating and working with session IDs
 */

/**
 * Generate a standardized session ID based on current datetime
 * @returns Session ID in the format s-YYYYMMDDhhmmss
 */
export function generateSessionId(): string {
    const now = new Date();
    const formattedDate = now.toISOString().replace(/[-:.TZ]/g, '').slice(0, 14);
    return `s-${formattedDate}`;
}

/**
 * Format session instructions for Claude
 * @param sessionId The session ID to include in instructions
 * @returns Formatted instruction string
 */
export function formatSessionInstructions(sessionId: string): string {
    return `ðŸ”„ SESSION ID: ${sessionId} - MANDATORY: Use this ID in all future requests, do NOT use the name.`;
}

/**
 * Determines if a session ID is new (created by us) or externally provided
 * This is useful for deciding when to show session instructions
 * 
 * @param sessionId The session ID to check
 * @returns Boolean indicating if this appears to be a session ID in our format
 */
export function isStandardSessionId(sessionId: string): boolean {
    // Check if it follows our s-YYYYMMDDhhmmss format
    return /^s-\d{14}$/.test(sessionId);
}

/**
 * Enhances a context string with session instructions
 * 
 * @param sessionId The session ID to include in instructions
 * @param contextString The original context string
 * @returns Enhanced context string with instructions
 */
export function enhanceContextWithSessionInstructions(
    sessionId: string, 
    contextString?: string
): string {
    const instructions = formatSessionInstructions(sessionId);
    if (!contextString) {
        return instructions;
    }
    return `${instructions}\n\n${contextString}`;
}
```

## utils/timeUtils.ts

```typescript
/**
 * Time formatting utilities
 * Shared across UI components for consistent time display
 */

/**
 * Format a timestamp as relative time (e.g., "5m ago", "2h ago")
 * @param timestamp Unix timestamp in milliseconds
 * @returns Human-readable relative time string
 */
export function formatTimeAgo(timestamp: number): string {
  const seconds = Math.floor((Date.now() - timestamp) / 1000);

  if (seconds < 60) return 'just now';

  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes}m ago`;

  const hours = Math.floor(minutes / 60);
  if (hours < 24) return `${hours}h ago`;

  const days = Math.floor(hours / 24);
  return `${days}d ago`;
}

/**
 * Format duration in milliseconds to human-readable string
 * @param ms Duration in milliseconds
 * @returns Human-readable duration (e.g., "2.5s", "1m 30s")
 */
export function formatDuration(ms: number): string {
  if (ms < 1000) return `${ms}ms`;

  const seconds = Math.floor(ms / 1000);
  if (seconds < 60) return `${seconds}s`;

  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;

  if (minutes < 60) {
    return remainingSeconds > 0 ? `${minutes}m ${remainingSeconds}s` : `${minutes}m`;
  }

  const hours = Math.floor(minutes / 60);
  const remainingMinutes = minutes % 60;
  return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;
}

```

## utils/toolNameUtils.ts

```typescript
export interface ToolNameMetadata {
  displayName: string;
  technicalName?: string;
  agentName?: string;
  actionName?: string;
}

/**
 * Replace underscores with dots for consistent agent.mode formatting.
 */
export function normalizeToolName(name?: string): string | undefined {
  if (!name) {
    return undefined;
  }
  return name.replace(/_/g, '.');
}

/**
 * Convert a technical tool identifier to a human-friendly display label.
 * Falls back to the original value when formatting fails.
 */
export function formatToolDisplayName(name?: string): string {
  if (!name || typeof name !== 'string') {
    return 'Tool';
  }

  const normalized = normalizeToolName(name) ?? name;
  const segments = normalized.split('.');
  const actionSegment = segments.length > 1 ? segments[segments.length - 1] : normalized;

  const title = toTitleCase(actionSegment);
  return title || name;
}

/**
 * Extract useful name metadata for display (agent/action/technical).
 */
export function getToolNameMetadata(name?: string): ToolNameMetadata {
  const technicalName = normalizeToolName(name);
  const segments = technicalName ? technicalName.split('.') : [];
  const agentSegment = segments.length > 1 ? segments[0] : undefined;
  const actionSegment = segments.length > 0 ? segments[segments.length - 1] : undefined;

  return {
    displayName: formatToolDisplayName(name),
    technicalName: technicalName ?? name,
    agentName: agentSegment ? toTitleCase(agentSegment) : undefined,
    actionName: actionSegment ? toTitleCase(actionSegment) : undefined
  };
}

function toTitleCase(value: string): string {
  return value
    .replace(/[_\-]/g, ' ')
    .replace(/([a-z0-9])([A-Z])/g, '$1 $2')
    .replace(/\s+/g, ' ')
    .trim()
    .split(' ')
    .filter(part => part.length > 0)
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ');
}

```

## utils/UpdateManager.ts

```typescript
import { Notice, Plugin, requestUrl } from 'obsidian';
import { MCPSettings } from '../types';

interface ReleaseAsset {
    name: string;
    browser_download_url: string;
}

interface GitHubRelease {
    tag_name: string;
    assets: ReleaseAsset[];
}

/**
 * UpdateManager handles checking for and applying plugin updates from GitHub releases
 * Fetches the latest release info and downloads required files:
 * - main.js
 * - connector.js
 * - styles.css
 * - manifest.json
 */
export class UpdateManager {
    private readonly GITHUB_API_ENDPOINTS = [
        'https://api.github.com/repos/ProfSynapse/nexus',
        'https://api.github.com/repos/ProfSynapse/claudesidian-mcp'
    ];
    private readonly REQUIRED_FILES = ['main.js', 'connector.js', 'styles.css', 'manifest.json'];

    constructor(private plugin: Plugin) {}

    /**
     * Check if a new version is available
     * @returns true if update available, false if current
     */
    async checkForUpdate(): Promise<boolean> {
        try {
            const release = await this.fetchLatestRelease();
            const latestVersion = release.tag_name.replace('v', '');
            const currentVersion = this.plugin.manifest.version;

            return this.compareVersions(latestVersion, currentVersion) > 0;
        } catch (error) {
            console.error('Failed to check for updates:', error);
            throw new Error('Failed to check for updates: ' + (error as Error).message);
        }
    }

    /**
     * Get the latest available version
     * @returns version string without 'v' prefix
     */
    async getLatestVersion(): Promise<string> {
        const release = await this.fetchLatestRelease();
        return release.tag_name.replace('v', '');
    }

    /**
     * Download and install the latest version of the plugin
     */
    async updatePlugin(): Promise<void> {
        try {
            const release = await this.fetchLatestRelease();
            const latestVersion = release.tag_name.replace('v', '');
            
            // Verify all required files exist in release
            const assets = release.assets;
            const missingFiles = this.REQUIRED_FILES.filter(file => 
                !assets.some(asset => asset.name === file)
            );

            if (missingFiles.length > 0) {
                throw new Error(`Release is missing required files: ${missingFiles.join(', ')}`);
            }

            // Download and save each file
            for (const fileName of this.REQUIRED_FILES) {
                const asset = assets.find((a: ReleaseAsset) => a.name === fileName);
                if (!asset) continue;

                const content = await this.downloadFile(asset.browser_download_url);
                
                // Handle file content appropriately based on type
                await this.plugin.app.vault.adapter.writeBinary(
                    `${this.plugin.manifest.dir}/${fileName}`,
                    content
                );
            }

            // Update settings to reflect the latest version
            // Note: The manifest.json file has already been written to disk above
            // The in-memory manifest will be updated when Obsidian restarts
            await this.updateVersionInSettings(latestVersion);

            new Notice(`Plugin updated successfully to version ${latestVersion}! Please refresh Obsidian to apply changes.`);
        } catch (error) {
            console.error('Failed to update plugin:', error);
            new Notice('Failed to update plugin: ' + (error as Error).message);
            throw error;
        }
    }

    /**
     * Update the version in the plugin settings
     * @param version The version to set
     */
    private async updateVersionInSettings(version: string): Promise<void> {
        try {
            // Load current settings
            const currentData = await this.plugin.loadData() as MCPSettings;
            
            // Create updated settings with version info
            const updatedData = {
                ...currentData,
                lastUpdateVersion: version,
                lastUpdateDate: new Date().toISOString()
            };
            
            // Save the updated settings
            await this.plugin.saveData(updatedData);
        } catch (error) {
            console.error('Failed to update version in settings:', error);
            // Don't throw here to prevent blocking the update process
        }
    }

    /**
     * Compare two version strings
     * @returns 1 if v1 > v2, -1 if v1 < v2, 0 if equal
     */
    private compareVersions(v1: string, v2: string): number {
        const parts1 = v1.split('.').map(Number);
        const parts2 = v2.split('.').map(Number);

        for (let i = 0; i < 3; i++) {
            if (parts1[i] > parts2[i]) return 1;
            if (parts1[i] < parts2[i]) return -1;
        }
        
        return 0;
    }

    /**
     * Fetch latest release information from GitHub
     */
    private async fetchLatestRelease(): Promise<GitHubRelease> {
        const errors: Error[] = [];

        for (const endpoint of this.GITHUB_API_ENDPOINTS) {
            try {
                const response = await requestUrl({
                    url: `${endpoint}/releases/latest`,
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'User-Agent': 'Obsidian-Plugin-Updater'
                    }
                });

                if (response.status === 200) {
                    return response.json;
                }

                errors.push(new Error(`GitHub API error: ${response.status} (${endpoint})`));
            } catch (error) {
                const err = error as Error;
                errors.push(err);
            }
        }

        const lastError = errors[errors.length - 1];
        throw new Error(`Failed to fetch release info: ${lastError?.message ?? 'Unknown error'}`);
    }

    /**
     * Download file content from URL
     */
    private async downloadFile(url: string): Promise<ArrayBuffer> {
        const response = await requestUrl({
            url: url,
            method: 'GET'
        });
        
        if (response.status !== 200) {
            throw new Error(`Failed to download file: ${response.status}`);
        }
        
        return response.arrayBuffer;
    }
}

```

## utils/uuid.ts

```typescript
/**
 * Mobile-compatible UUID generator
 *
 * MOBILE COMPATIBILITY (Dec 2025):
 * The 'uuid' npm package uses crypto.randomUUID() which may not be available
 * in all mobile environments. This provides a fallback implementation.
 *
 * Priority:
 * 1. crypto.randomUUID() - Modern browsers and Node.js 19+
 * 2. crypto.getRandomValues() - Web Crypto API fallback
 * 3. Math.random() - Last resort fallback (not cryptographically secure)
 */

/**
 * Generate a UUID v4 compatible with mobile platforms
 */
export function generateUUID(): string {
  // Try native randomUUID first (fastest and most secure)
  if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
    return crypto.randomUUID();
  }

  // Fall back to Web Crypto API getRandomValues
  if (typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function') {
    const bytes = new Uint8Array(16);
    crypto.getRandomValues(bytes);

    // Set version (4) and variant (RFC4122)
    bytes[6] = (bytes[6] & 0x0f) | 0x40;  // Version 4
    bytes[8] = (bytes[8] & 0x3f) | 0x80;  // Variant RFC4122

    // Convert to hex string
    const hex = Array.from(bytes)
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');

    return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
  }

  // Last resort: Math.random() based UUID (not cryptographically secure)
  // This should rarely if ever be needed, but provides ultimate fallback
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

// Alias for compatibility with uuid package API
export const v4 = generateUUID;

```

## utils/validation/CommonValidators.ts

```typescript
/**
 * Location: /src/utils/validation/CommonValidators.ts
 * Purpose: Reusable validation functions for the most common parameter patterns
 * 
 * This utility provides standardized validation functions that eliminate duplication
 * across modes by centralizing common validation patterns like required strings,
 * file paths, session context, and other frequently validated parameter types.
 * 
 * Used by: All modes for parameter validation via BaseMode.validateCustom()
 * Integrates with: ValidationResultHelper, BaseMode, CommonParameters
 */

import { CommonParameters } from '../../types/mcp/AgentTypes';
import { ValidationError } from './ValidationResultHelper';

/**
 * String validation options interface
 */
export interface StringValidationOptions {
  /**
   * Minimum length (default: 1)
   */
  minLength?: number;
  
  /**
   * Maximum length (default: 500)
   */
  maxLength?: number;
  
  /**
   * Allow empty strings (default: false)
   */
  allowEmpty?: boolean;
  
  /**
   * Trim whitespace before validation (default: true)
   */
  trimWhitespace?: boolean;
  
  /**
   * Regular expression pattern to match
   */
  pattern?: string;
  
  /**
   * Hint for pattern requirements
   */
  patternHint?: string;
}

/**
 * File path validation options interface
 */
export interface FilePathValidationOptions {
  /**
   * Apply Obsidian-specific validation rules (default: true)
   */
  obsidianValidation?: boolean;
  
  /**
   * Allow glob patterns like *.md (default: false)
   */
  allowGlobs?: boolean;
  
  /**
   * Allow directory paths (default: true)
   */
  allowDirectories?: boolean;
  
  /**
   * Required file extension
   */
  requiredExtension?: string;
  
  /**
   * Maximum path length (default: 1000)
   */
  maxLength?: number;
}

/**
 * Session context validation options interface
 */
export interface SessionContextOptions {
  /**
   * Require session ID to be present (default: true)
   */
  requireSessionId?: boolean;
  
  /**
   * Require workspace context (default: false)
   */
  requireWorkspace?: boolean;
  
  /**
   * Minimum length for context fields (default: 5)
   */
  minContextLength?: number;
}

/**
 * Validation rule function type
 */
export type ValidationRule<T> = (value: any, fieldName: string) => ValidationError | null;

/**
 * Validation rule set type
 */
export type ValidationRuleSet<T> = {
  [K in keyof T]?: ValidationRule<T[K]>;
};

/**
 * CommonValidators - Centralized validation utilities for common parameter patterns
 */
export class CommonValidators {
  /**
   * Validate required string with comprehensive error reporting
   * 
   * Provides detailed validation for string fields with customizable constraints
   * and consistent error messaging across all modes.
   * 
   * @param value Value to validate
   * @param fieldName Name of the field being validated
   * @param options Validation options
   * @returns ValidationError if validation fails, null if valid
   */
  static requiredString(
    value: any,
    fieldName: string,
    options: StringValidationOptions = {}
  ): ValidationError | null {
    const opts: Required<StringValidationOptions> = {
      minLength: 1,
      maxLength: 500,
      allowEmpty: false,
      trimWhitespace: true,
      pattern: undefined as unknown as string,
      patternHint: undefined as unknown as string,
      ...options
    };

    // Check for null/undefined
    if (value === null || value === undefined) {
      return this.createFieldError(fieldName, 'FIELD_REQUIRED', 
        `${fieldName} is required`, 'Please provide a value');
    }

    // Check type
    if (typeof value !== 'string') {
      return this.createFieldError(fieldName, 'TYPE_ERROR',
        `${fieldName} must be a string`, 
        `Expected string, received ${typeof value}`);
    }

    const processedValue = opts.trimWhitespace ? value.trim() : value;

    // Check empty string
    if (!opts.allowEmpty && processedValue.length === 0) {
      return this.createFieldError(fieldName, 'EMPTY_STRING',
        `${fieldName} cannot be empty`,
        'Please provide a non-empty value');
    }

    // Check minimum length
    if (processedValue.length < opts.minLength) {
      return this.createFieldError(fieldName, 'MIN_LENGTH',
        `${fieldName} must be at least ${opts.minLength} characters`,
        `Current length: ${processedValue.length}`);
    }

    // Check maximum length
    if (processedValue.length > opts.maxLength) {
      return this.createFieldError(fieldName, 'MAX_LENGTH',
        `${fieldName} must not exceed ${opts.maxLength} characters`,
        `Current length: ${processedValue.length}`);
    }

    // Check pattern
    if (opts.pattern && !new RegExp(opts.pattern).test(processedValue)) {
      return this.createFieldError(fieldName, 'PATTERN_MISMATCH',
        `${fieldName} format is invalid`,
        opts.patternHint || 'Please check the required format');
    }

    return null;
  }

  /**
   * Validate file path with Obsidian-specific constraints
   * 
   * Handles file path validation including Obsidian-specific rules for
   * invalid characters, reserved names, and path length constraints.
   * 
   * @param value Value to validate
   * @param fieldName Name of the field being validated
   * @param options Validation options
   * @returns ValidationError if validation fails, null if valid
   */
  static filePath(
    value: any, 
    fieldName: string = 'filePath',
    options: FilePathValidationOptions = {}
  ): ValidationError | null {
    // First validate as required string
    const stringError = this.requiredString(value, fieldName, {
      minLength: 1,
      maxLength: options.maxLength || 1000
    });
    if (stringError) return stringError;

    const path = value.trim();
    
    // Obsidian-specific file path validation
    if (options.obsidianValidation !== false) {
      // Check for invalid characters in Obsidian file paths
      const invalidChars = /[<>:"|?*\u0000-\u001f]/;
      if (!options.allowGlobs && invalidChars.test(path)) {
        return this.createFieldError(fieldName, 'INVALID_PATH_CHARS',
          `${fieldName} contains invalid characters`,
          'File paths cannot contain: < > : " | ? * or control characters');
      }

      // Allow glob patterns if specified
      if (options.allowGlobs) {
        const invalidGlobChars = /[<>:"|]/;
        if (invalidGlobChars.test(path)) {
          return this.createFieldError(fieldName, 'INVALID_GLOB_CHARS',
            `${fieldName} contains invalid characters for glob patterns`,
            'Glob patterns cannot contain: < > : " | or control characters');
        }
      }

      // Check for reserved names (Windows-specific but good practice)
      const reservedNames = /^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])(\.|$)/i;
      const fileName = path.split(/[/\\]/).pop() || '';
      if (reservedNames.test(fileName)) {
        return this.createFieldError(fieldName, 'RESERVED_NAME',
          `${fieldName} uses a reserved file name`,
          'Avoid reserved names like CON, PRN, AUX, etc.');
      }
    }

    // Check required extension
    if (options.requiredExtension && !path.toLowerCase().endsWith(`.${options.requiredExtension.toLowerCase()}`)) {
      return this.createFieldError(fieldName, 'MISSING_EXTENSION',
        `${fieldName} must have .${options.requiredExtension} extension`,
        `Add .${options.requiredExtension} to the file path`);
    }

    return null;
  }

  /**
   * Validate session context (common across all modes)
   * 
   * Validates the CommonParameters context structure including session ID,
   * workspace context, and other contextual information required for proper
   * session tracking and tool operation.
   * 
   * @param params CommonParameters to validate
   * @param mode Mode instance for context inheritance
   * @param options Validation options
   * @returns Array of validation errors
   */
  static validateSessionContext(
    params: CommonParameters,
    mode?: unknown,
    options: SessionContextOptions = {}
  ): ValidationError[] {
    const errors: ValidationError[] = [];
    const opts: Required<SessionContextOptions> = {
      requireSessionId: true,
      requireWorkspace: false,
      minContextLength: 5,
      ...options
    };

    // Validate context object structure
    if (!params.context) {
      if (opts.requireSessionId) {
        errors.push(this.createFieldError(
          'context',
          'CONTEXT_REQUIRED',
          'Context object is required',
          'Provide context with sessionId and other required fields'
        ));
      }
      return errors;
    }

    // Session ID validation
    if (opts.requireSessionId) {
      const sessionId = params.context.sessionId;
      if (!sessionId) {
        errors.push(this.createFieldError(
          'context.sessionId',
          'SESSION_ID_REQUIRED',
          'Session ID is required for tool tracking',
          'Ensure context.sessionId is provided'
        ));
      } else if (typeof sessionId !== 'string' || sessionId.trim().length === 0) {
        errors.push(this.createFieldError(
          'context.sessionId',
          'SESSION_ID_INVALID',
          'Session ID must be a non-empty string',
          'Provide a valid session identifier'
        ));
      }
    }

    // Workspace ID validation (required in context)
    if (!params.context.workspaceId) {
      errors.push(this.createFieldError(
        'context.workspaceId',
        'WORKSPACE_ID_REQUIRED',
        'Workspace ID is required in context',
        'Provide workspaceId in the context object'
      ));
    }

    // Validate context field lengths (new format: memory, goal, constraints)
    const contextFields = [
      { key: 'memory', name: 'Memory', required: true },
      { key: 'goal', name: 'Goal', required: true },
      { key: 'constraints', name: 'Constraints', required: false }
    ];

    for (const field of contextFields) {
      const contextObj = params.context as unknown as Record<string, unknown>;
      const value = contextObj[field.key];
      // Only validate if field is present or required
      if (value !== undefined && (typeof value !== 'string' || value.trim().length < opts.minContextLength)) {
        errors.push(this.createFieldError(
          `context.${field.key}`,
          'CONTEXT_FIELD_TOO_SHORT',
          `${field.name} must be at least ${opts.minContextLength} characters`,
          `Provide meaningful ${field.name.toLowerCase()}`
        ));
      }
    }

    // Workspace context validation if required
    if (opts.requireWorkspace && mode) {
      const modeObj = mode as { getInheritedWorkspaceContext?: (params: CommonParameters) => unknown };
      if (typeof modeObj.getInheritedWorkspaceContext === 'function') {
        try {
          const workspaceContext = modeObj.getInheritedWorkspaceContext(params) as { workspaceId?: string } | undefined;
          if (!workspaceContext?.workspaceId) {
            errors.push(this.createFieldError(
              'workspaceContext',
              'WORKSPACE_CONTEXT_REQUIRED',
              'Workspace context is required',
              'Provide workspaceContext or ensure inherited context is available'
            ));
          }
        } catch (error) {
        }
      }
    }

    return errors;
  }

  /**
   * Batch field validation with comprehensive error collection
   * 
   * Validates multiple fields using provided validators and collects all errors
   * in a single pass, providing comprehensive validation feedback.
   * 
   * @param params Object containing fields to validate
   * @param validators Mapping of field names to validation functions
   * @returns Array of validation errors
   */
  static validateFields<T>(
    params: T,
    validators: ValidationRuleSet<T>
  ): ValidationError[] {
    const errors: ValidationError[] = [];
    const startTime = performance.now();

    for (const [fieldName, validator] of Object.entries(validators)) {
      try {
        if (typeof validator === 'function') {
          const paramsObj = params as Record<string, unknown>;
          const fieldValue = paramsObj[fieldName];
          const error = validator(fieldValue, fieldName);
          if (error) {
            errors.push(error);
          }
        }
      } catch (validationError) {
        errors.push(this.createFieldError(
          fieldName,
          'VALIDATION_ERROR',
          `Validation failed for ${fieldName}`,
          String(validationError)
        ));
      }
    }

    // Track validation performance
    this.trackValidationPerformance('validateFields', startTime, errors.length === 0);

    return errors;
  }

  /**
   * Validate boolean flag with type checking
   * 
   * @param value Value to validate
   * @param fieldName Name of the field being validated
   * @param required Whether the field is required
   * @returns ValidationError if validation fails, null if valid
   */
  static booleanFlag(
    value: any,
    fieldName: string,
    required: boolean = false
  ): ValidationError | null {
    if (value === undefined || value === null) {
      if (required) {
        return this.createFieldError(fieldName, 'FIELD_REQUIRED',
          `${fieldName} is required`, 'Provide true or false');
      }
      return null;
    }

    if (typeof value !== 'boolean') {
      return this.createFieldError(fieldName, 'TYPE_ERROR',
        `${fieldName} must be a boolean`, 
        `Expected true or false, received ${typeof value}`);
    }

    return null;
  }

  /**
   * Validate numeric value with range constraints
   * 
   * @param value Value to validate
   * @param fieldName Name of the field being validated
   * @param options Validation options
   * @returns ValidationError if validation fails, null if valid
   */
  static numericValue(
    value: any,
    fieldName: string,
    options: {
      minimum?: number;
      maximum?: number;
      integer?: boolean;
      required?: boolean;
    } = {}
  ): ValidationError | null {
    if (value === undefined || value === null) {
      if (options.required) {
        return this.createFieldError(fieldName, 'FIELD_REQUIRED',
          `${fieldName} is required`, 'Provide a numeric value');
      }
      return null;
    }

    if (typeof value !== 'number' || isNaN(value)) {
      return this.createFieldError(fieldName, 'TYPE_ERROR',
        `${fieldName} must be a number`, 
        `Expected number, received ${typeof value}`);
    }

    if (options.integer && !Number.isInteger(value)) {
      return this.createFieldError(fieldName, 'INTEGER_REQUIRED',
        `${fieldName} must be an integer`, 
        `Received ${value}, expected whole number`);
    }

    if (options.minimum !== undefined && value < options.minimum) {
      return this.createFieldError(fieldName, 'MINIMUM_VALUE',
        `${fieldName} must be at least ${options.minimum}`,
        `Current value: ${value}`);
    }

    if (options.maximum !== undefined && value > options.maximum) {
      return this.createFieldError(fieldName, 'MAXIMUM_VALUE',
        `${fieldName} must not exceed ${options.maximum}`,
        `Current value: ${value}`);
    }

    return null;
  }

  /**
   * Extract session ID from CommonParameters
   * 
   * Helper method to safely extract session ID with fallbacks
   * 
   * @param params CommonParameters to extract from
   * @returns Session ID or undefined
   */
  static extractSessionId(params: CommonParameters): string | undefined {
    return params.context?.sessionId;
  }

  /**
   * Create standardized field error
   * 
   * @param fieldName Name of the field that failed validation
   * @param code Machine-readable error code
   * @param message Human-readable error message
   * @param hint Optional hint to help resolve the issue
   * @returns ValidationError object
   */
  private static createFieldError(
    fieldName: string,
    code: string,
    message: string,
    hint?: string
  ): ValidationError {
    return {
      path: fieldName.split('.'),
      message,
      code,
      hint,
      severity: 'error',
      context: { fieldName }
    };
  }

  /**
   * Track validation performance for monitoring
   * 
   * Integrates with existing CompatibilityMonitor system when available
   * 
   * @param operation Name of the validation operation
   * @param startTime Start time of the operation
   * @param success Whether validation succeeded
   */
  private static trackValidationPerformance(
    operation: string,
    startTime: number,
    success: boolean
  ): void {
    const duration = performance.now() - startTime;

    // Integration with existing CompatibilityMonitor
    const globalObj = globalThis as Record<string, unknown>;
    const compatMonitor = globalObj.CompatibilityMonitor as {
      trackValidation?: (source: string, op: string, start: number, end: number, success: boolean) => void
    } | undefined;

    if (compatMonitor && typeof compatMonitor.trackValidation === 'function') {
      compatMonitor.trackValidation(
        'CommonValidators',
        operation,
        startTime,
        performance.now(),
        success
      );
    }

  }
}
```

## utils/validation/index.ts

```typescript
/**
 * Location: /src/utils/validation/index.ts
 * Purpose: Export barrel for validation utilities providing clean import interface
 * 
 * This file centralizes all validation utility exports for easy access throughout
 * the application, providing a clean interface for importing validation functionality.
 * 
 * Used by: All modes and utilities requiring validation functionality
 * Exports: All core validation utilities from Phase 1 implementation
 */

// Core validation utilities
export {
  ValidationResultHelper
} from './ValidationResultHelper';

export type {
  ValidationError,
  ValidationResult,
  ValidationMetadata
} from './ValidationResultHelper';

export {
  CommonValidators
} from './CommonValidators';

export type {
  StringValidationOptions,
  FilePathValidationOptions,
  SessionContextOptions,
  ValidationRule,
  ValidationRuleSet
} from './CommonValidators';

export {
  SchemaBlocks
} from './SchemaBlocks';

export type {
  JSONSchema,
  SchemaBlockOptions
} from './SchemaBlocks';


// Re-export commonly used patterns for convenience
// Note: Individual imports are preferred to avoid circular dependencies
// and provide better tree-shaking for the build process.
```

## utils/validation/SchemaBlocks.ts

```typescript
/**
 * Location: /src/utils/validation/SchemaBlocks.ts
 * Purpose: Provide reusable, composable schema components to reduce schema definition duplication
 * 
 * This utility provides standardized schema building blocks that can be composed together
 * to create consistent JSON schemas across all modes, reducing duplication and ensuring
 * consistent parameter validation and documentation.
 * 
 * Used by: All modes for parameter schema definition via getParameterSchema()
 * Integrates with: JSON Schema, BaseMode.getMergedSchema(), existing schemaUtils
 */

/**
 * JSON Schema type definition
 */
export interface JSONSchema {
  type?: string;
  properties?: Record<string, any>;
  required?: string[];
  description?: string;
  minLength?: number;
  maxLength?: number;
  minimum?: number;
  maximum?: number;
  pattern?: string;
  format?: string;
  examples?: any[];
  items?: JSONSchema;
  enum?: any[];
  oneOf?: JSONSchema[];
  allOf?: JSONSchema[];
  not?: JSONSchema;
  if?: JSONSchema;
  then?: JSONSchema;
  anyOf?: JSONSchema[];
  dependencies?: Record<string, string[]>;
  additionalProperties?: boolean;
  default?: any;
  title?: string;
  
  // Custom extensions for tooling
  'x-sensitive'?: boolean;
  'x-pattern-hint'?: string;
  'x-labels'?: Record<string, string>;
}

/**
 * Schema block options for enhanced configuration
 */
export interface SchemaBlockOptions {
  description: string;
  required?: boolean;
  examples?: string[];
  constraints?: Record<string, any>;
  metadata?: Record<string, any>;
}

/**
 * SchemaBlocks - Composable schema building components for consistent schema creation
 */
export class SchemaBlocks {
  
  /**
   * Create validated string schema with comprehensive constraints
   * 
   * Provides a standardized string schema with common validation constraints
   * and consistent formatting across all modes.
   * 
   * @param options Configuration for the string schema
   * @returns JSON Schema for validated string
   */
  static validatedString(options: {
    description: string;
    minLength?: number;
    maxLength?: number;
    pattern?: string;
    patternHint?: string;
    examples?: string[];
    format?: 'email' | 'uri' | 'date-time' | 'password';
    sensitive?: boolean;
    required?: boolean;
  }): JSONSchema {
    const schema: JSONSchema = {
      type: 'string',
      description: options.description
    };

    // Apply length constraints
    if (options.minLength !== undefined) schema.minLength = options.minLength;
    if (options.maxLength !== undefined) schema.maxLength = options.maxLength;
    
    // Apply pattern validation
    if (options.pattern) schema.pattern = options.pattern;
    if (options.format) schema.format = options.format;
    if (options.examples) schema.examples = options.examples;

    // Add metadata for enhanced tooling
    if (options.sensitive) schema['x-sensitive'] = true;
    if (options.patternHint) schema['x-pattern-hint'] = options.patternHint;

    return schema;
  }

  /**
   * Entity name schema with intelligent defaults based on entity type
   * 
   * Provides consistent naming schemas for different entity types with
   * appropriate length limits and character constraints.
   * 
   * @param entityType Type of entity being named
   * @param options Additional configuration options
   * @returns JSON Schema for entity name
   */
  static entityName(entityType: string, options: {
    maxLength?: number;
    allowSpecialChars?: boolean;
    uniqueConstraint?: boolean;
    examples?: string[];
  } = {}): JSONSchema {
    const maxLength = options.maxLength || this.getDefaultMaxLength(entityType);
    const pattern = options.allowSpecialChars 
      ? '^[a-zA-Z0-9\\s\\-_.@#+]+$'
      : '^[a-zA-Z0-9\\s\\-_]+$';
    
    const description = `Name of the ${entityType}${
      options.uniqueConstraint ? ' (must be unique)' : ''
    }`;
    
    const examples = options.examples || this.generateEntityExamples(entityType);

    return this.validatedString({
      description,
      minLength: 1,
      maxLength,
      pattern,
      patternHint: 'Letters, numbers, spaces, hyphens, and underscores allowed',
      examples
    });
  }

  /**
   * Search query schema with context-aware examples and constraints
   * 
   * Provides specialized schemas for different search contexts with appropriate
   * examples and validation rules.
   * 
   * @param context Type of search being performed
   * @param options Additional configuration options
   * @returns JSON Schema for search query
   */
  static searchQuery(context: 'content' | 'files' | 'memory' | 'universal' = 'universal', options: {
    maxLength?: number;
    allowEmpty?: boolean;
    examples?: string[];
  } = {}): JSONSchema {
    const contextExamples = {
      content: ['project planning', 'typescript validation', 'API documentation'],
      files: ['README.md', '*.ts', 'config'],
      memory: ['recent sessions', 'workspace activity', 'tool usage'],
      universal: ['project planning', 'machine learning', 'typescript', 'notes']
    };

    return this.validatedString({
      description: `Search query for ${context} search`,
      minLength: options.allowEmpty ? 0 : 1,
      maxLength: options.maxLength || 1000,
      examples: options.examples || contextExamples[context]
    });
  }

  /**
   * File path schema with Obsidian-specific validation
   * 
   * Provides file path validation appropriate for different file operations
   * with Obsidian-specific constraints and examples.
   * 
   * @param context Type of file operation
   * @param options Additional configuration options
   * @returns JSON Schema for file path
   */
  static filePath(context: 'read' | 'write' | 'search' = 'read', options: {
    allowGlobs?: boolean;
    allowDirectories?: boolean;
    requiredExtension?: string;
    examples?: string[];
  } = {}): JSONSchema {
    const contextDescriptions = {
      read: 'Path to file to read',
      write: 'Path where file will be created or modified',
      search: 'Path to restrict search scope'
    };

    let pattern = '^[^<>:"|?*\\x00-\\x1f]+$'; // Basic file path validation
    if (options.allowGlobs) {
      pattern = '^[^<>:"|\\x00-\\x1f]+$'; // Allow * and ? for globs
    }

    return this.validatedString({
      description: contextDescriptions[context],
      minLength: 1,
      maxLength: 1000,
      pattern,
      patternHint: 'Valid file path without reserved characters',
      examples: options.examples || this.generateFilePathExamples(context, options)
    });
  }

  /**
   * Boolean flag schema with enhanced UX
   * 
   * Provides consistent boolean schemas with user-friendly labels
   * and clear descriptions.
   * 
   * @param purpose What the boolean flag controls
   * @param defaultValue Default value for the flag
   * @param options Additional configuration
   * @returns JSON Schema for boolean flag
   */
  static booleanFlag(purpose: string, defaultValue: boolean = false, options: {
    description?: string;
    trueLabel?: string;
    falseLabel?: string;
  } = {}): JSONSchema {
    const schema: JSONSchema = {
      type: 'boolean',
      description: options.description || `Whether to ${purpose}`,
      default: defaultValue
    };

    // Add labels for better UX in tools
    if (options.trueLabel && options.falseLabel) {
      schema['x-labels'] = {
        true: options.trueLabel,
        false: options.falseLabel
      };
    }

    return schema;
  }

  /**
   * Numeric limit schema with context-aware defaults
   * 
   * Provides number schemas with appropriate defaults and constraints
   * based on the usage context.
   * 
   * @param context Usage context for the numeric value
   * @param options Additional configuration options
   * @returns JSON Schema for numeric limit
   */
  static numericLimit(context: 'search' | 'list' | 'batch' = 'search', options: {
    defaultValue?: number;
    minimum?: number;
    maximum?: number;
    allowUnlimited?: boolean;
    description?: string;
  } = {}): JSONSchema {
    const contextDefaults = {
      search: { default: 10, min: 1, max: 50 },
      list: { default: 20, min: 1, max: 100 },
      batch: { default: 10, min: 1, max: 1000 }
    };

    const defaults = contextDefaults[context];
    const defaultValue = options.defaultValue ?? defaults.default;
    const minimum = options.minimum ?? defaults.min;
    const maximum = options.maximum ?? defaults.max;

    const schema: JSONSchema = {
      type: 'number',
      description: options.description || `Maximum number of results (default: ${defaultValue})`,
      minimum,
      default: defaultValue
    };

    if (!options.allowUnlimited) {
      schema.maximum = maximum;
    }

    return schema;
  }

  /**
   * Enum selection schema with descriptive options
   * 
   * Creates enum schemas with clear descriptions and examples
   * for better user experience.
   * 
   * @param values Array of allowed values
   * @param options Configuration options
   * @returns JSON Schema for enum selection
   */
  static enumSelection<T extends string>(values: T[], options: {
    description: string;
    default?: T;
    labels?: Record<T, string>;
  }): JSONSchema {
    const schema: JSONSchema = {
      type: 'string',
      enum: values,
      description: options.description
    };

    if (options.default) {
      schema.default = options.default;
    }

    if (options.labels) {
      schema['x-labels'] = options.labels;
    }

    return schema;
  }

  /**
   * Advanced schema composition with validation rules
   * 
   * Composes multiple schema blocks together with advanced JSON Schema
   * features like conditional validation and mutual exclusivity.
   * 
   * @param blocks Schema blocks to compose
   * @param options Composition configuration
   * @returns Composed JSON Schema
   */
  static composeSchema(blocks: Record<string, JSONSchema>, options: {
    required?: string[];
    conditionalRequired?: Record<string, string[]>;
    mutuallyExclusive?: string[][];
    dependencies?: Record<string, string[]>;
    additionalProperties?: boolean;
    title?: string;
    description?: string;
  } = {}): JSONSchema {
    const schema: JSONSchema = {
      type: 'object',
      properties: blocks,
      additionalProperties: options.additionalProperties ?? false
    };

    if (options.title) schema.title = options.title;
    if (options.description) schema.description = options.description;
    if (options.required) schema.required = options.required;

    // Advanced JSON Schema features
    if (options.conditionalRequired) {
      schema.allOf = [];
      for (const [condition, requiredFields] of Object.entries(options.conditionalRequired)) {
        schema.allOf.push({
          if: { properties: { [condition]: { const: true } } },
          then: { required: requiredFields }
        });
      }
    }

    if (options.mutuallyExclusive && options.mutuallyExclusive.length > 0) {
      schema.not = {
        anyOf: options.mutuallyExclusive.map(group => ({
          allOf: group.map(field => ({ required: [field] }))
        }))
      };
    }

    if (options.dependencies) {
      schema.dependencies = options.dependencies;
    }

    return schema;
  }

  /**
   * Context field schema for ToolContext (memory/goal/constraints format)
   *
   * Provides standardized schema for context fields used in session tracking
   * and tool operation context. Uses the new format instead of legacy
   * sessionDescription/sessionMemory/subgoal fields.
   *
   * @param fieldType Type of context field (memory, goal, or constraints)
   * @param options Configuration options
   * @returns JSON Schema for context field
   */
  static contextField(fieldType: 'memory' | 'goal' | 'constraints', options: {
    minLength?: number;
    maxLength?: number;
    examples?: string[];
  } = {}): JSONSchema {
    const fieldConfig = {
      memory: {
        desc: 'Essence of conversation so far (1-3 sentences)',
        defaultMin: 5,
        defaultMax: 500,
        examples: ['Implemented validation utilities, now working on schema blocks', 'Fixed search bug, testing results', 'User wants to organize their notes into workspaces']
      },
      goal: {
        desc: 'Current objective (1-3 sentences)',
        defaultMin: 5,
        defaultMax: 300,
        examples: ['Implement validation standardization', 'Fix search performance issues', 'Create workspace for research project']
      },
      constraints: {
        desc: 'Optional rules/limits to follow (1-3 sentences)',
        defaultMin: 0,
        defaultMax: 300,
        examples: ['Only modify files in the src/ folder', 'Keep response under 500 words', 'Use TypeScript patterns from existing codebase']
      }
    };

    const config = fieldConfig[fieldType];

    return this.validatedString({
      description: config.desc,
      minLength: options.minLength ?? config.defaultMin,
      maxLength: options.maxLength || config.defaultMax,
      examples: options.examples || config.examples
    });
  }

  // Helper methods for generating defaults and examples

  /**
   * Get default maximum length for different entity types
   * 
   * @param entityType Type of entity
   * @returns Default maximum length
   */
  private static getDefaultMaxLength(entityType: string): number {
    const defaults: Record<string, number> = {
      prompt: 100,
      session: 150,
      workspace: 100,
      file: 255,
      description: 500,
      content: 5000,
      query: 1000,
      name: 100
    };
    return defaults[entityType] || 100;
  }

  /**
   * Generate appropriate examples for entity types
   * 
   * @param entityType Type of entity
   * @returns Array of example names
   */
  private static generateEntityExamples(entityType: string): string[] {
    const examples: Record<string, string[]> = {
      prompt: ['Code Reviewer', 'Technical Writer', 'Research Assistant'],
      session: ['Daily Planning', 'Code Review Session', 'Research Notes'],
      workspace: ['Project Alpha', 'Research Workspace', 'Client Work'],
      file: ['README.md', 'config.json', 'main.ts'],
      query: ['search term', 'project planning', 'typescript validation'],
      name: ['My Item', 'New Entity', 'Custom Name']
    };
    return examples[entityType] || [`My ${entityType}`, `${entityType} name`];
  }

  /**
   * Generate file path examples based on context and options
   * 
   * @param context File operation context
   * @param options Configuration options
   * @returns Array of example file paths
   */
  private static generateFilePathExamples(
    context: 'read' | 'write' | 'search',
    options: any
  ): string[] {
    const baseExamples = {
      read: ['path/to/file.md', 'notes/daily-notes.txt', 'docs/README.md'],
      write: ['output/result.md', 'generated/summary.txt', 'exports/data.json'],
      search: ['notes/', 'projects/**/*.md', 'docs/']
    };

    let examples = baseExamples[context];

    if (options.allowGlobs) {
      examples = [...examples, '**/*.ts', 'src/**/*', '*.{md,txt}'];
    }

    if (options.requiredExtension) {
      examples = examples.map(ex => 
        ex.includes('.') ? ex : `${ex}.${options.requiredExtension}`
      );
    }

    return examples;
  }
}
```

## utils/validation/ValidationResultHelper.ts

```typescript
/**
 * Location: /src/utils/validation/ValidationResultHelper.ts
 * Purpose: Centralized result creation patterns to ensure consistency across all tools
 *
 * This utility provides standardized methods for creating error and success results,
 * ensuring consistent error handling, context extraction, and response formatting
 * across all agents and tools.
 *
 * Used by: All BaseTool implementations for standardized result creation
 * Integrates with: BaseTool, CommonParameters, CommonResult, contextUtils
 */

import { CommonParameters, CommonResult } from '../../types/mcp/AgentTypes';
import { extractContextFromParams, WorkspaceContext } from '../contextUtils';
import { getErrorMessage } from '../errorUtils';
import { createResult } from '../schemaUtils';

/**
 * Type for BaseTool interface without direct import to avoid file casing conflicts
 * Exported for use by BaseTool and other classes that need to match this interface
 */
export interface ToolInterface {
  slug: string;
  name: string;
  description: string;
  version: string;
  constructor: { name: string };
}

/**
 * @deprecated Use ToolInterface instead
 */
export type ModeInterface = ToolInterface;

/**
 * Validation error interface for detailed error reporting
 */
export interface ValidationError {
  /**
   * Path to the field that failed validation (e.g., ['name'] or ['workspaceContext', 'workspaceId'])
   */
  path: string[];
  
  /**
   * Human-readable error message
   */
  message: string;
  
  /**
   * Machine-readable error code for categorization
   */
  code: string;
  
  /**
   * Optional hint to help users resolve the issue
   */
  hint?: string;
  
  /**
   * Error severity level
   */
  severity?: 'error' | 'warning';
  
  /**
   * Additional context information
   */
  context?: Record<string, any>;
}

/**
 * Validation result interface for comprehensive validation outcomes
 */
export interface ValidationResult<T> {
  /**
   * Whether validation succeeded
   */
  success: boolean;
  
  /**
   * Validated data (original or transformed)
   */
  data: T;
  
  /**
   * Array of validation errors
   */
  errors: ValidationError[];
  
  /**
   * Optional warnings that don't prevent success
   */
  warnings?: string[];
  
  /**
   * Optional metadata about the validation process
   */
  metadata?: ValidationMetadata;
}

/**
 * Metadata about the validation process
 */
export interface ValidationMetadata {
  /**
   * Time taken to perform validation (milliseconds)
   */
  duration?: number;

  /**
   * Number of fields validated
   */
  fieldCount?: number;

  /**
   * Whether fallback validation was used
   */
  usedFallback?: boolean;

  /**
   * Additional context-specific metadata
   */
  [key: string]: any;
}

/**
 * Interface for CompatibilityMonitor if available on globalThis
 */
interface CompatibilityMonitor {
  trackValidation(
    component: string,
    operation: string,
    startTime: number,
    endTime: number,
    success: boolean
  ): void;
}

/**
 * Extended globalThis interface with optional CompatibilityMonitor
 */
interface GlobalWithMonitor {
  CompatibilityMonitor?: CompatibilityMonitor;
}

/**
 * Context extraction result
 */
interface ContextExtractionResult {
  sessionId?: string;
  workspaceContext?: WorkspaceContext;
  contextString?: string;
}

/**
 * ValidationResultHelper - Centralized result creation for consistent error and success handling
 */
export class ValidationResultHelper {
  /**
   * Create standardized error result with automatic context handling
   *
   * This method provides consistent error formatting across all tools, ensuring
   * proper session tracking, workspace context handling, and error message formatting.
   *
   * @param tool The tool instance creating the result
   * @param error Error string, Error object, or array of ValidationErrors
   * @param params Original parameters (for context extraction)
   * @param additionalContext Additional context to include in result
   * @returns Standardized error result
   */
  static createErrorResult<TResult extends CommonResult>(
    tool: ToolInterface,
    error: string | Error | ValidationError[],
    params?: CommonParameters,
    additionalContext?: Record<string, any>
  ): TResult {
    const startTime = performance.now();

    try {
      // Extract context information
      const contextResult = this.extractAndValidateContext(params, tool);

      // Format error message
      let errorMessage: string;
      let errorCode: string = 'VALIDATION_ERROR';
      let errorDetails: any = {};
      
      if (Array.isArray(error)) {
        // Handle ValidationError array
        const primaryErrors = error.filter(e => e.severity !== 'warning');
        if (primaryErrors.length > 0) {
          errorMessage = primaryErrors.map(e => e.message).join('; ');
          errorCode = primaryErrors[0].code || 'VALIDATION_ERROR';
          errorDetails = {
            validationErrors: error,
            errorCount: primaryErrors.length,
            warningCount: error.filter(e => e.severity === 'warning').length
          };
        } else {
          errorMessage = 'Validation failed with warnings';
          errorDetails = { validationErrors: error };
        }
      } else if (error instanceof Error) {
        errorMessage = error.message;
        errorCode = error.name || 'ERROR';
        errorDetails = {
          errorType: error.constructor.name,
          stack: error.stack
        };
      } else {
        errorMessage = error;
      }
      
      // Track error creation performance
      this.trackPerformance(
        tool.constructor.name,
        'error-result-creation',
        startTime,
        false,
        { errorCode, hasValidationErrors: Array.isArray(error) }
      );

      // Create standardized result - don't echo back context fields the LLM already knows
      return createResult<TResult>(
        false,
        null,
        errorMessage,
        undefined,
        undefined,
        undefined,
        {
          errorCode,
          errorDetails,
          timestamp: Date.now(),
          tool: tool.name,
          ...additionalContext
        }
      );

    } catch (resultError) {
      // Fallback error creation if the main process fails
      console.error(`Error creating error result in ${tool.constructor.name}:`, resultError);
      
      return createResult<TResult>(
        false,
        null,
        `Error creating error result: ${getErrorMessage(resultError)}. Original error: ${getErrorMessage(error)}`,
        undefined,
        undefined,
        undefined,
        undefined
      );
    }
  }
  
  /**
   * Create standardized success result with context propagation
   *
   * Ensures consistent success result formatting with proper context handling
   * and session tracking across all tools.
   *
   * @param tool The tool instance creating the result
   * @param data Result data to include
   * @param params Original parameters (for context extraction)
   * @param additionalData Additional properties to include in result
   * @returns Standardized success result
   */
  static createSuccessResult<TResult extends CommonResult>(
    tool: ToolInterface,
    data: any,
    params?: CommonParameters,
    additionalData?: Record<string, any>
  ): TResult {
    const startTime = performance.now();

    try {
      // Extract context information
      const contextResult = this.extractAndValidateContext(params, tool);

      // Track success result creation performance
      this.trackPerformance(
        tool.constructor.name,
        'success-result-creation',
        startTime,
        true,
        { hasData: !!data, dataType: typeof data }
      );

      // Create standardized result - don't echo back context fields the LLM already knows
      return createResult<TResult>(
        true,
        data,
        undefined,
        undefined,
        undefined,
        undefined,
        {
          timestamp: Date.now(),
          tool: tool.name,
          ...additionalData
        }
      );

    } catch (resultError) {
      console.error(`Error creating success result in ${tool.constructor.name}:`, resultError);

      // Fallback to error result if success result creation fails
      return this.createErrorResult(
        tool,
        `Error creating success result: ${getErrorMessage(resultError)}`,
        params
      );
    }
  }
  
  /**
   * Create validation result for field-level validation operations
   * 
   * @param data Original data being validated
   * @param errors Array of validation errors
   * @param warnings Optional array of warnings
   * @param metadata Optional validation metadata
   * @returns Validation result
   */
  static createValidationResult<T>(
    data: T,
    errors: ValidationError[] = [],
    warnings?: string[],
    metadata?: ValidationMetadata
  ): ValidationResult<T> {
    return {
      success: errors.filter(e => e.severity !== 'warning').length === 0,
      data,
      errors,
      warnings,
      metadata
    };
  }
  
  /**
   * Extract and validate session context from parameters
   *
   * Handles the complex logic of extracting session IDs, workspace context,
   * and contextual information from parameters with proper fallbacks.
   *
   * @param params Parameters to extract context from
   * @param tool Tool instance for context inheritance
   * @returns Extracted context information
   */
  private static extractAndValidateContext(
    params?: CommonParameters,
    tool?: ToolInterface
  ): ContextExtractionResult {
    const result: ContextExtractionResult = {};
    
    if (!params) {
      return result;
    }
    
    // Extract session ID from context
    if (params.context?.sessionId) {
      result.sessionId = params.context.sessionId;
    }
    
    // Extract workspace context from params if available
    // Note: We only extract from params here. BaseTool's getInheritedWorkspaceContext
    // handles inheritance logic internally, but we don't call it directly as it's protected.
    if (params.workspaceContext) {
      try {
        // If it's already an object, use it directly; otherwise it might be a string representation
        if (typeof params.workspaceContext === 'object') {
          result.workspaceContext = params.workspaceContext;
        }
      } catch (error) {
      }
    }
    
    // Extract context string from parameters
    if (params.context) {
      if (typeof params.context === 'string') {
        result.contextString = params.context;
      } else {
        // Convert rich context object to string
        const contextResult = extractContextFromParams(params);
        if (typeof contextResult === 'string') {
          result.contextString = contextResult;
        } else if (contextResult) {
          // Convert object to readable string
          result.contextString = Object.entries(contextResult)
            .filter(([_, value]) => value)
            .map(([key, value]) => `${key}: ${value}`)
            .join(', ');
        }
      }
    }
    
    return result;
  }
  
  /**
   * Track performance metrics for validation operations
   *
   * Integrates with existing CompatibilityMonitor system when available
   *
   * @param toolName Name of the tool performing validation
   * @param operation Type of operation being tracked
   * @param startTime Start time of the operation
   * @param success Whether the operation succeeded
   * @param metadata Additional metadata to track
   */
  private static trackPerformance(
    toolName: string,
    operation: string,
    startTime: number,
    success: boolean,
    metadata?: Record<string, any>
  ): void {
    const duration = performance.now() - startTime;

    // Integration with existing CompatibilityMonitor if available
    // Type-safe access using defined interface
    const global = globalThis as GlobalWithMonitor;
    if (global.CompatibilityMonitor) {
      global.CompatibilityMonitor.trackValidation(
        `ValidationResultHelper_${toolName}`,
        operation,
        startTime,
        performance.now(),
        success
      );
    }

  }
}
```

## utils/validationUtils.ts

```typescript
/**
 * Specialized utilities for parameter validation and providing helpful feedback
 */
// import { getErrorMessage } from './errorUtils';

/**
 * Represents a parameter validation error
 */
export interface ValidationError {
    path: string[];    // Path to the parameter that failed validation
    message: string;   // Error message
    code: string;      // Error code for classification
    hint?: string;     // Optional hint for fixing the issue
    expectedType?: string; // Expected type or format
    receivedType?: string; // Received type or format
    allowedValues?: any[]; // Allowed values if enum
}

/**
 * Validates parameters against a schema with enhanced error reporting
 * 
 * @param params Parameters to validate
 * @param schema Schema to validate against
 * @returns An array of validation errors, empty if validation passed
 */
export function validateParams(params: any, schema: any): ValidationError[] {
    const errors: ValidationError[] = [];
    
    // Check if schema exists
    if (!schema || typeof schema !== 'object') {
        return [{
            path: [],
            message: 'Invalid schema: Schema is missing or not an object',
            code: 'INVALID_SCHEMA'
        }];
    }
    
    // Handle required properties
    const requiredProps = Array.isArray(schema.required) ? schema.required : [];
    for (const prop of requiredProps) {
        if (!hasProperty(params, prop)) {
            errors.push({
                path: [prop],
                message: `Missing required parameter: ${prop}`,
                code: 'MISSING_REQUIRED',
                hint: `The parameter '${prop}' is required and must be provided`
            });
        }
    }
    
    // Validate properties that are provided
    if (schema.properties) {
        validateObjectProperties(params, schema.properties, [], errors);
    }
    
    // Check for conditional validations (allOf, anyOf, oneOf)
    if (schema.allOf && Array.isArray(schema.allOf)) {
        validateAllOf(params, schema.allOf, errors);
    }
    
    if (schema.anyOf && Array.isArray(schema.anyOf)) {
        validateAnyOf(params, schema.anyOf, errors);
    }
    
    if (schema.oneOf && Array.isArray(schema.oneOf)) {
        validateOneOf(params, schema.oneOf, errors);
    }
    
    return errors;
}

/**
 * Validate object properties against schema
 */
function validateObjectProperties(
    obj: any, 
    propSchemas: Record<string, any>, 
    path: string[], 
    errors: ValidationError[]
): void {
    if (!obj || typeof obj !== 'object' || Array.isArray(obj)) {
        errors.push({
            path,
            message: 'Expected an object',
            code: 'TYPE_ERROR',
            expectedType: 'object',
            receivedType: Array.isArray(obj) ? 'array' : typeof obj
        });
        return;
    }
    
    for (const [propName, propValue] of Object.entries(obj)) {
        const propPath = [...path, propName];
        const propSchema = propSchemas[propName];
        
        // Skip validation if no schema for this property
        if (!propSchema) continue;
        
        // Validate property value against its schema
        validateProperty(propValue, propSchema, propPath, errors);
    }
}

/**
 * Validate a specific property value against its schema
 */
function validateProperty(
    value: any, 
    schema: any, 
    path: string[], 
    errors: ValidationError[]
): void {
    // Handle type validation
    if (schema.type) {
        const typeValid = validateType(value, schema.type);
        if (!typeValid) {
            errors.push({
                path,
                message: `Invalid type for ${path.join('.')}`,
                code: 'TYPE_ERROR',
                expectedType: schema.type,
                receivedType: Array.isArray(value) ? 'array' : typeof value,
                hint: `This parameter expects ${getTypeDescription(schema.type)}`
            });
            // If type is invalid, skip further validation to avoid cascading errors
            return;
        }
    }
    
    // Handle minimum/maximum for numbers
    if (schema.type === 'number' || schema.type === 'integer') {
        if (schema.minimum !== undefined && value < schema.minimum) {
            errors.push({
                path,
                message: `Value ${value} is less than minimum ${schema.minimum}`,
                code: 'MIN_ERROR',
                hint: `The minimum allowed value is ${schema.minimum}`
            });
        }
        
        if (schema.maximum !== undefined && value > schema.maximum) {
            errors.push({
                path,
                message: `Value ${value} is greater than maximum ${schema.maximum}`,
                code: 'MAX_ERROR',
                hint: `The maximum allowed value is ${schema.maximum}`
            });
        }
    }
    
    // Handle minLength/maxLength for strings
    if (schema.type === 'string') {
        if (schema.minLength !== undefined && value.length < schema.minLength) {
            errors.push({
                path,
                message: `String length ${value.length} is less than minLength ${schema.minLength}`,
                code: 'MIN_LENGTH_ERROR',
                hint: `The string must be at least ${schema.minLength} characters long`
            });
        }
        
        if (schema.maxLength !== undefined && value.length > schema.maxLength) {
            errors.push({
                path,
                message: `String length ${value.length} is greater than maxLength ${schema.maxLength}`,
                code: 'MAX_LENGTH_ERROR',
                hint: `The string must be at most ${schema.maxLength} characters long`
            });
        }
        
        // Handle pattern for strings
        if (schema.pattern) {
            const pattern = new RegExp(schema.pattern);
            if (!pattern.test(value)) {
                errors.push({
                    path,
                    message: `String does not match pattern: ${schema.pattern}`,
                    code: 'PATTERN_ERROR',
                    hint: schema.patternHint || `The string must match the pattern: ${schema.pattern}`
                });
            }
        }
    }
    
    // Handle enum validation
    if (schema.enum && Array.isArray(schema.enum)) {
        if (!schema.enum.includes(value)) {
            errors.push({
                path,
                message: `Value is not one of the allowed values`,
                code: 'ENUM_ERROR',
                allowedValues: schema.enum,
                hint: `Valid values are: ${schema.enum.join(', ')}`
            });
        }
    }
    
    // Handle array validation
    if (schema.type === 'array' && Array.isArray(value)) {
        // Validate minItems/maxItems
        if (schema.minItems !== undefined && value.length < schema.minItems) {
            errors.push({
                path,
                message: `Array length ${value.length} is less than minItems ${schema.minItems}`,
                code: 'MIN_ITEMS_ERROR',
                hint: `The array must have at least ${schema.minItems} items`
            });
        }
        
        if (schema.maxItems !== undefined && value.length > schema.maxItems) {
            errors.push({
                path,
                message: `Array length ${value.length} is greater than maxItems ${schema.maxItems}`,
                code: 'MAX_ITEMS_ERROR',
                hint: `The array must have at most ${schema.maxItems} items`
            });
        }
        
        // Validate array items
        if (schema.items) {
            for (let i = 0; i < value.length; i++) {
                validateProperty(value[i], schema.items, [...path, i.toString()], errors);
            }
        }
    }
    
    // Validate nested object properties
    if (schema.type === 'object' && schema.properties && typeof value === 'object' && value !== null) {
        validateObjectProperties(value, schema.properties, path, errors);
    }
}

/**
 * Validate all conditions in allOf must be satisfied
 */
function validateAllOf(obj: any, schemas: any[], errors: ValidationError[]): void {
    for (const schema of schemas) {
        const subErrors = validateParams(obj, schema);
        errors.push(...subErrors);
    }
}

/**
 * Validate at least one condition in anyOf must be satisfied
 */
function validateAnyOf(obj: any, schemas: any[], errors: ValidationError[]): void {
    const allSubErrors: ValidationError[][] = [];
    
    // Check if at least one schema is valid
    const isValid = schemas.some(schema => {
        const subErrors = validateParams(obj, schema);
        allSubErrors.push(subErrors);
        return subErrors.length === 0;
    });
    
    if (!isValid) {
        // Find the schema with the fewest errors (closest match)
        let minErrorCount = Infinity;
        let bestMatchErrors: ValidationError[] = [];
        
        for (const subErrors of allSubErrors) {
            if (subErrors.length < minErrorCount) {
                minErrorCount = subErrors.length;
                bestMatchErrors = subErrors;
            }
        }
        
        // Add the errors from the closest match
        errors.push({
            path: [],
            message: 'None of the anyOf conditions were satisfied',
            code: 'ANY_OF_ERROR',
            hint: 'The input must satisfy at least one of the specified conditions'
        });
        
        errors.push(...bestMatchErrors);
    }
}

/**
 * Validate exactly one condition in oneOf must be satisfied
 */
function validateOneOf(obj: any, schemas: any[], errors: ValidationError[]): void {
    const validSchemas = schemas.filter(schema => validateParams(obj, schema).length === 0);
    
    if (validSchemas.length === 0) {
        // Same approach as anyOf for providing helpful errors
        let minErrorCount = Infinity;
        let bestMatchErrors: ValidationError[] = [];
        
        for (const schema of schemas) {
            const subErrors = validateParams(obj, schema);
            if (subErrors.length < minErrorCount) {
                minErrorCount = subErrors.length;
                bestMatchErrors = subErrors;
            }
        }
        
        errors.push({
            path: [],
            message: 'None of the oneOf conditions were satisfied',
            code: 'ONE_OF_ERROR',
            hint: 'The input must satisfy exactly one of the specified conditions'
        });
        
        errors.push(...bestMatchErrors);
    } else if (validSchemas.length > 1) {
        errors.push({
            path: [],
            message: `${validSchemas.length} oneOf conditions were satisfied, but exactly one is required`,
            code: 'ONE_OF_MULTIPLE_ERROR',
            hint: 'The input must satisfy exactly one of the specified conditions, not multiple'
        });
    }
}

/**
 * Check if an object has a given property
 */
function hasProperty(obj: any, prop: string): boolean {
    return obj && typeof obj === 'object' && prop in obj;
}

/**
 * Validate a value against a JSON Schema type
 */
function validateType(value: any, type: string | string[]): boolean {
    const types = Array.isArray(type) ? type : [type];
    
    return types.some(t => {
        switch (t) {
            case 'string':
                return typeof value === 'string';
            case 'number':
                return typeof value === 'number' && !isNaN(value);
            case 'integer':
                return typeof value === 'number' && !isNaN(value) && Number.isInteger(value);
            case 'boolean':
                return typeof value === 'boolean';
            case 'array':
                return Array.isArray(value);
            case 'object':
                return typeof value === 'object' && value !== null && !Array.isArray(value);
            case 'null':
                return value === null;
            default:
                return false;
        }
    });
}

/**
 * Get a human-readable description of a type
 */
function getTypeDescription(type: string | string[]): string {
    if (Array.isArray(type)) {
        if (type.length === 1) {
            return getTypeDescription(type[0]);
        }
        
        const descriptions = type.map(t => getTypeDescription(t));
        const lastDesc = descriptions.pop();
        return descriptions.length > 0
            ? `${descriptions.join(', ')} or ${lastDesc}`
            : lastDesc as string;
    }
    
    switch (type) {
        case 'string': return 'a string';
        case 'number': return 'a number';
        case 'integer': return 'an integer';
        case 'boolean': return 'a boolean (true or false)';
        case 'array': return 'an array';
        case 'object': return 'an object';
        case 'null': return 'null';
        default: return `a ${type}`;
    }
}

/**
 * Format validation errors into a detailed error message
 * 
 * @param errors Array of validation errors
 * @returns Formatted error message
 */
export function formatValidationErrors(errors: ValidationError[]): string {
    if (errors.length === 0) {
        return '';
    }
    
    let message = 'Parameter validation failed:\n';
    
    for (const error of errors) {
        const pathStr = error.path.length > 0 ? error.path.join('.') : 'root';
        message += `- ${pathStr}: ${error.message}\n`;
        
        if (error.hint) {
            message += `  Hint: ${error.hint}\n`;
        }
        
        if (error.expectedType && error.receivedType) {
            message += `  Expected ${error.expectedType}, received ${error.receivedType}\n`;
        }
        
        if (error.allowedValues && error.allowedValues.length > 0) {
            const valuesStr = error.allowedValues.map(v => JSON.stringify(v)).join(', ');
            message += `  Allowed values: [${valuesStr}]\n`;
        }
    }
    
    return message;
}

/**
 * Utility function to generate parameter hints from a schema
 * 
 * @param schema The schema to generate hints from
 * @returns Object with parameter hints
 */
export function generateParameterHints(schema: any): Record<string, string> {
    const hints: Record<string, string> = {};
    
    if (!schema || !schema.properties) {
        return hints;
    }
    
    const requiredProps = Array.isArray(schema.required) ? schema.required : [];
    
    for (const [propName, propSchema] of Object.entries<any>(schema.properties)) {
        const isRequired = requiredProps.includes(propName);
        const typeInfo = getTypeInfo(propSchema);
        const constraints = getConstraints(propSchema);
        
        let hint = `${isRequired ? 'Required' : 'Optional'} - ${propSchema.description || 'No description'}`;
        
        if (typeInfo) {
            hint += `\nType: ${typeInfo}`;
        }
        
        if (constraints) {
            hint += `\nConstraints: ${constraints}`;
        }
        
        hints[propName] = hint;
    }
    
    return hints;
}

/**
 * Get type information from a schema property
 */
function getTypeInfo(schema: any): string {
    if (!schema) return '';
    
    if (schema.enum && Array.isArray(schema.enum)) {
        return `One of: [${schema.enum.map((v: any) => JSON.stringify(v)).join(', ')}]`;
    }
    
    if (schema.type) {
        if (schema.type === 'array' && schema.items) {
            const itemType = schema.items.type || 'any';
            return `Array of ${itemType}`;
        }
        return Array.isArray(schema.type) ? schema.type.join(' | ') : schema.type;
    }
    
    return '';
}

/**
 * Get constraints information from a schema property
 */
function getConstraints(schema: any): string {
    if (!schema) return '';
    
    const constraints: string[] = [];
    
    if (schema.minLength !== undefined) {
        constraints.push(`min length: ${schema.minLength}`);
    }
    
    if (schema.maxLength !== undefined) {
        constraints.push(`max length: ${schema.maxLength}`);
    }
    
    if (schema.pattern) {
        constraints.push(`pattern: ${schema.pattern}`);
    }
    
    if (schema.minimum !== undefined) {
        constraints.push(`min: ${schema.minimum}`);
    }
    
    if (schema.maximum !== undefined) {
        constraints.push(`max: ${schema.maximum}`);
    }
    
    if (schema.minItems !== undefined) {
        constraints.push(`min items: ${schema.minItems}`);
    }
    
    if (schema.maxItems !== undefined) {
        constraints.push(`max items: ${schema.maxItems}`);
    }
    
    return constraints.join(', ');
}

/**
 * Utility function to enhance a schema with detailed parameter documentation
 * This updates descriptions with type information and required/optional status
 * 
 * @param schema The schema to enhance
 * @returns The enhanced schema
 */
export function enhanceSchemaDocumentation(schema: any): any {
    if (!schema || !schema.properties) {
        return schema;
    }
    
    // Create a deep copy to avoid modifying the original
    const enhancedSchema = JSON.parse(JSON.stringify(schema));
    const requiredProps = Array.isArray(enhancedSchema.required) ? enhancedSchema.required : [];
    
    for (const [propName, propSchema] of Object.entries<any>(enhancedSchema.properties)) {
        const isRequired = requiredProps.includes(propName);
        const requirementMarker = isRequired ? '[REQUIRED] ' : '[OPTIONAL] ';
        
        // Enhance the description with type information
        if (propSchema.description) {
            propSchema.description = requirementMarker + propSchema.description;
        } else {
            propSchema.description = requirementMarker + 'No description provided';
        }
        
        // Add type information to the description
        const typeInfo = getTypeInfo(propSchema);
        if (typeInfo) {
            propSchema.description += ` (${typeInfo})`;
        }
        
        // Add constraints to the description
        const constraints = getConstraints(propSchema);
        if (constraints) {
            propSchema.description += ` [${constraints}]`;
        }
        
        // Recursively enhance nested objects
        if (propSchema.type === 'object' && propSchema.properties) {
            enhancedSchema.properties[propName] = enhanceSchemaDocumentation(propSchema);
        }
        
        // Enhance array item schemas
        if (propSchema.type === 'array' && propSchema.items) {
            if (propSchema.items.type === 'object' && propSchema.items.properties) {
                propSchema.items = enhanceSchemaDocumentation(propSchema.items);
            }
        }
    }
    
    return enhancedSchema;
}
```

## utils/vaultUtils.ts

```typescript
/**
 * Utility functions for vault-related operations
 * This module provides functions for working with vault names and identifiers
 */

/**
 * Sanitizes a vault name for use in identifiers, filenames, and configuration keys
 * 
 * This function standardizes vault names by:
 * - Converting to lowercase
 * - Removing special characters (keeping only alphanumeric, spaces, and hyphens)
 * - Replacing spaces with hyphens
 * - Normalizing multiple consecutive hyphens to a single hyphen
 * 
 * @param vaultName - The original vault name to sanitize
 * @returns A sanitized version of the vault name suitable for use in identifiers
 * @throws Error if the input is null, undefined, or not a string
 * 
 * @example
 * // Returns "my-vault-name"
 * sanitizeVaultName("My Vault Name!");
 * 
 * @example
 * // Returns "test-vault-123"
 * sanitizeVaultName("Test Vault 123 @#$%");
 */
export function sanitizeVaultName(vaultName: string): string {
    // Input validation
    if (vaultName === null || vaultName === undefined) {
        throw new Error('Vault name cannot be null or undefined');
    }
    
    if (typeof vaultName !== 'string') {
        throw new Error(`Expected vault name to be a string, got ${typeof vaultName}`);
    }
    
    // Sanitize the vault name
    return vaultName
        .toLowerCase()           // Convert to lowercase
        .replace(/[^\w\s-]/g, '') // Remove special characters (keep alphanumeric, spaces, hyphens)
        .replace(/\s+/g, '-')     // Replace spaces with hyphens
        .replace(/-+/g, '-');     // Replace multiple consecutive hyphens with a single one
}
```

## utils/WasmEnsurer.ts

```typescript
import { Plugin, Notice, requestUrl } from 'obsidian';

/**
 * Location: src/utils/WasmEnsurer.ts
 *
 * Ensures sqlite3.wasm exists in the plugin folder.
 *
 * The sqlite3.wasm file is required for SQLite caching functionality.
 * If it's missing (e.g., due to incomplete installation or manual install
 * that only copied main.js/manifest.json), this utility will automatically
 * download it from the npm CDN.
 *
 * Download sources (in order of preference):
 * 1. jsDelivr CDN - fast, reliable
 * 2. unpkg CDN - fallback
 */
export class WasmEnsurer {
    // CDN URLs for the WASM file from @dao-xyz/sqlite3-vec package
    // Version should match package.json dependency
    private static readonly WASM_URLS = [
        'https://cdn.jsdelivr.net/npm/@dao-xyz/sqlite3-vec@0.0.19/sqlite-wasm/jswasm/sqlite3.wasm',
        'https://unpkg.com/@dao-xyz/sqlite3-vec@0.0.19/sqlite-wasm/jswasm/sqlite3.wasm'
    ];

    private static readonly WASM_FILENAME = 'sqlite3.wasm';
    // Expected size ~3.4MB, reject if too small (likely error page)
    private static readonly MIN_WASM_SIZE = 1_000_000;

    constructor(private plugin: Plugin) {}

    /**
     * Check if sqlite3.wasm exists, and download it if missing.
     * Shows a notice during download to inform the user.
     * @returns true if wasm exists (or was downloaded), false on error
     */
    async ensureWasmExists(): Promise<boolean> {
        const pluginDir = this.plugin.manifest.dir;
        if (!pluginDir) {
            console.error('[WasmEnsurer] Plugin directory not available');
            return false;
        }

        const wasmPath = `${pluginDir}/${WasmEnsurer.WASM_FILENAME}`;

        try {
            // Check if file exists
            const exists = await this.plugin.app.vault.adapter.exists(wasmPath);

            if (exists) {
                // Verify it's not corrupted (check file size)
                const stat = await this.plugin.app.vault.adapter.stat(wasmPath);
                if (stat && stat.size >= WasmEnsurer.MIN_WASM_SIZE) {
                    return true;
                }
                console.warn('[WasmEnsurer] sqlite3.wasm exists but is too small, re-downloading...');
            }

            // File doesn't exist or is corrupted - download it
            return await this.downloadWasm(wasmPath);

        } catch (error) {
            console.error('[WasmEnsurer] Failed to ensure sqlite3.wasm:', error);
            return false;
        }
    }

    /**
     * Download sqlite3.wasm from CDN
     */
    private async downloadWasm(wasmPath: string): Promise<boolean> {
        const notice = new Notice('Downloading SQLite WASM file... This only happens once.', 0);

        try {
            for (const url of WasmEnsurer.WASM_URLS) {
                try {
                    console.log(`[WasmEnsurer] Attempting download from: ${url}`);

                    const response = await requestUrl({
                        url,
                        method: 'GET',
                        // Request binary response
                    });

                    if (response.status !== 200) {
                        console.warn(`[WasmEnsurer] HTTP ${response.status} from ${url}`);
                        continue;
                    }

                    const wasmData = response.arrayBuffer;

                    // Validate size
                    if (wasmData.byteLength < WasmEnsurer.MIN_WASM_SIZE) {
                        console.warn(`[WasmEnsurer] Downloaded file too small (${wasmData.byteLength} bytes) from ${url}`);
                        continue;
                    }

                    // Write to plugin directory
                    await this.plugin.app.vault.adapter.writeBinary(wasmPath, wasmData);

                    notice.hide();
                    new Notice('SQLite WASM file downloaded successfully!', 3000);
                    console.log(`[WasmEnsurer] Successfully downloaded sqlite3.wasm (${wasmData.byteLength} bytes)`);
                    return true;

                } catch (error) {
                    console.warn(`[WasmEnsurer] Failed to download from ${url}:`, error);
                    // Try next URL
                }
            }

            // All URLs failed
            notice.hide();
            new Notice('Failed to download SQLite WASM file. Please check your internet connection and restart Obsidian.', 10000);
            return false;

        } catch (error) {
            notice.hide();
            console.error('[WasmEnsurer] Download failed:', error);
            new Notice('Failed to download SQLite WASM file. Some features may not work.', 10000);
            return false;
        }
    }

    /**
     * Force re-download sqlite3.wasm even if it exists.
     * Useful for repairs or updates.
     */
    async redownloadWasm(): Promise<boolean> {
        const pluginDir = this.plugin.manifest.dir;
        if (!pluginDir) {
            console.error('[WasmEnsurer] Plugin directory not available');
            return false;
        }

        const wasmPath = `${pluginDir}/${WasmEnsurer.WASM_FILENAME}`;
        return await this.downloadWasm(wasmPath);
    }
}

```

## utils/WorkspaceDataFormatter.ts

```typescript
/**
 * WorkspaceDataFormatter - Shared utility for formatting workspace data
 *
 * Used by:
 * - SystemPromptBuilder (for chat system prompts)
 * - SubagentExecutor (for subagent system prompts)
 *
 * Extracts relevant fields from comprehensive workspace data and serializes to JSON.
 */

export interface FormattedWorkspaceData {
  context?: unknown;
  workflows?: unknown[];
  workspaceStructure?: unknown[];
  recentFiles?: unknown[];
  keyFiles?: Record<string, unknown>;
  preferences?: string;
  sessions?: unknown[];
  states?: unknown[];
}

export interface FormatOptions {
  /** Maximum number of states to include (default: all) */
  maxStates?: number;
  /** Maximum number of sessions to include (default: all) */
  maxSessions?: number;
  /** Whether to pretty-print JSON (default: true) */
  prettyPrint?: boolean;
}

/**
 * Extract relevant fields from workspace data into a clean object
 * @param workspaceData Raw workspace data from LoadWorkspaceTool or similar
 * @param options Formatting options
 * @returns Formatted workspace data object
 */
export function extractWorkspaceData(
  workspaceData: any,
  options: FormatOptions = {}
): FormattedWorkspaceData {
  if (!workspaceData) return {};

  const { maxStates, maxSessions } = options;
  const formatted: FormattedWorkspaceData = {};

  // Core context (memory, goal, constraints, etc.)
  if (workspaceData.context) {
    formatted.context = workspaceData.context;
  }

  // Workflows
  if (workspaceData.workflows?.length) {
    formatted.workflows = workspaceData.workflows;
  }

  // Workspace structure (folder/file tree)
  if (workspaceData.workspaceStructure?.length) {
    formatted.workspaceStructure = workspaceData.workspaceStructure;
  }

  // Recent files
  if (workspaceData.recentFiles?.length) {
    formatted.recentFiles = workspaceData.recentFiles;
  }

  // Key files
  if (workspaceData.keyFiles && Object.keys(workspaceData.keyFiles).length) {
    formatted.keyFiles = workspaceData.keyFiles;
  }

  // Preferences
  if (workspaceData.preferences) {
    formatted.preferences = workspaceData.preferences;
  }

  // Sessions (with optional limit)
  if (workspaceData.sessions?.length) {
    formatted.sessions = maxSessions
      ? workspaceData.sessions.slice(0, maxSessions)
      : workspaceData.sessions;
  }

  // States (with optional limit for subagents that don't need full history)
  if (workspaceData.states?.length) {
    formatted.states = maxStates
      ? workspaceData.states.slice(0, maxStates)
      : workspaceData.states;
  }

  return formatted;
}

/**
 * Format workspace data as JSON string for inclusion in prompts
 * @param workspaceData Raw workspace data
 * @param options Formatting options
 * @returns JSON string or empty string if no data
 */
export function formatWorkspaceDataForPrompt(
  workspaceData: any,
  options: FormatOptions = {}
): string {
  const formatted = extractWorkspaceData(workspaceData, options);

  if (Object.keys(formatted).length === 0) {
    return '';
  }

  const { prettyPrint = true } = options;
  return prettyPrint
    ? JSON.stringify(formatted, null, 2)
    : JSON.stringify(formatted);
}

/**
 * Check if workspace data has any meaningful content
 * @param workspaceData Raw workspace data
 * @returns true if there's content worth including in a prompt
 */
export function hasWorkspaceContent(workspaceData: any): boolean {
  if (!workspaceData) return false;

  return !!(
    workspaceData.context ||
    workspaceData.workflows?.length ||
    workspaceData.workspaceStructure?.length ||
    workspaceData.recentFiles?.length ||
    (workspaceData.keyFiles && Object.keys(workspaceData.keyFiles).length) ||
    workspaceData.preferences ||
    workspaceData.sessions?.length ||
    workspaceData.states?.length
  );
}

```

## utils/workspaceUtils.ts

```typescript
import { normalizePath } from "obsidian";
import { WorkspaceService } from '../services/WorkspaceService';
import { ProjectWorkspace } from "../database/workspace-types";

/**
 * Utility functions for working with workspaces and files
 */

/**
 * Check if a file is within a workspace
 * @param filePath Path of the file to check
 * @param workspace Workspace to check against
 * @returns True if the file is in the workspace, false otherwise
 */
export function fileIsInWorkspace(filePath: string, workspace: ProjectWorkspace): boolean {
  const normalizedFilePath = normalizePath(filePath);
  const normalizedRootFolder = normalizePath(workspace.rootFolder);
  
  // Check if file is in the root folder
  if (normalizedFilePath.startsWith(normalizedRootFolder + '/') || 
      normalizedFilePath === normalizedRootFolder) {
    return true;
  }
  
  // Check related folders
  for (const folder of (workspace.relatedFolders || [])) {
    const normalizedFolder = normalizePath(folder);
    if (normalizedFilePath.startsWith(normalizedFolder + '/') || 
        normalizedFilePath === normalizedFolder) {
      return true;
    }
  }
  
  // Check individual related files
  if (workspace.relatedFiles) {
    for (const file of workspace.relatedFiles) {
      const normalizedFile = normalizePath(file);
      if (normalizedFilePath === normalizedFile) {
        return true;
      }
    }
  }
  
  return false;
}

/**
 * Get all workspaces that contain a file
 * @param filePath Path of the file to check
 * @param workspaceService WorkspaceService instance
 * @returns Promise resolving to an array of workspace IDs that contain the file
 */
export async function getWorkspacesForFile(
  filePath: string, 
  workspaceService: WorkspaceService
): Promise<string[]> {
  // Get all workspaces
  const workspaces = await workspaceService.listWorkspaces();
  const matchingWorkspaceIds: string[] = [];
  
  // Normalize the file path
  const normalizedFilePath = normalizePath(filePath);
  
  // Check each workspace
  for (const workspace of workspaces) {
    if (fileIsInWorkspace(normalizedFilePath, workspace)) {
      matchingWorkspaceIds.push(workspace.id);
    }
  }
  
  return matchingWorkspaceIds;
}

/**
 * Find the "best" workspace for a file based on folder path specificity
 * @param filePath Path of the file to check
 * @param workspaceService WorkspaceService instance
 * @returns Promise resolving to the best matching workspace ID or undefined if none found
 */
export async function getBestWorkspaceForFile(
  filePath: string, 
  workspaceService: WorkspaceService
): Promise<string | undefined> {
  // Get all workspaces that contain this file
  const workspaceIds = await getWorkspacesForFile(filePath, workspaceService);
  
  if (workspaceIds.length === 0) {
    return undefined;
  }
  
  if (workspaceIds.length === 1) {
    return workspaceIds[0];
  }
  
  // Multiple workspaces match, find the best one based on path specificity
  const workspaces: ProjectWorkspace[] = [];
  for (const id of workspaceIds) {
    const workspace = await workspaceService.getWorkspace(id);
    if (workspace) {
      workspaces.push(workspace);
    }
  }
  
  // Prioritize by folder path length (longer paths are more specific)
  const normalizedFilePath = normalizePath(filePath);
  
  // Sort by the closest folder match
  workspaces.sort((a, b) => {
    const aPath = normalizePath(a.rootFolder);
    const bPath = normalizePath(b.rootFolder);
    
    // If the file is directly in one of the folders, prioritize that one
    const directlyInA = normalizedFilePath.indexOf(aPath) === 0 && 
                      normalizedFilePath.substring(aPath.length).split('/').filter(Boolean).length === 0;
    const directlyInB = normalizedFilePath.indexOf(bPath) === 0 && 
                      normalizedFilePath.substring(bPath.length).split('/').filter(Boolean).length === 0;
    
    if (directlyInA && !directlyInB) return -1;
    if (directlyInB && !directlyInA) return 1;
    
    // Otherwise take the longest matching path (most specific)
    return bPath.length - aPath.length;
  });
      
  return workspaces[0].id;
}

/**
 * Update the activity history for all relevant workspaces when a file is modified
 * @param filePath Path of the file that was modified
 * @param action The action performed ('create', 'edit', 'delete' - will be mapped to valid activity types)
 * @param workspaceService WorkspaceService instance
 * @remarks Activity tracking not supported in split-file storage architecture
 * @deprecated Activity tracking removed - this function is a no-op
 */
export async function updateWorkspaceActivityForFile(
  filePath: string,
  action: 'create' | 'edit' | 'delete',
  workspaceService: WorkspaceService
): Promise<void> {
  // Activity tracking not supported in new storage architecture
  // IndividualWorkspace does not have activityHistory property
  // This function is kept for backward compatibility but does nothing
}
```

